#include "ruby_cocos2dx_auto.hpp"
#include "ruby_cocos2dx_auto_data_types.h"
#include "cocos2d.h"
#include "CCProtectedNode.h"
#include "CCAsyncTaskPool.h"
#include "RubyBasicConversions.h"

mrb_value ruby_cocos2dx_constant_get(mrb_state* mrb, mrb_value self)
{
    RClass *c = mrb_class_ptr(self);
    return mrb_mod_cv_get(mrb, c, mrb->c->ci->mid);
}

mrb_value ruby_cocos2dx_global_constant_get(mrb_state* mrb, mrb_value self)
{
    return mrb_gv_get(mrb, mrb->c->ci->mid);
}

mrb_value ruby_cocos2dx_Ref_release(mrb_state* mrb, mrb_value self)
{
    cocos2d::Ref* cobj = static_cast<cocos2d::Ref*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            cobj->release();
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::Ref#release");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Ref_retain(mrb_state* mrb, mrb_value self)
{
    cocos2d::Ref* cobj = static_cast<cocos2d::Ref*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            cobj->retain();
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::Ref#retain");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Ref_getReferenceCount(mrb_state* mrb, mrb_value self)
{
    cocos2d::Ref* cobj = static_cast<cocos2d::Ref*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            unsigned int retval = cobj->getReferenceCount();
            mrb_value ret;
            ret = mrb_fixnum_value((mrb_int)retval);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::Ref#getReferenceCount");

    return mrb_nil_value();
}

void ruby_register_cocos2dx_Ref(mrb_state* mrb, struct RClass* rmodule)
{
    std::string typeName = typeid(cocos2d::Ref).name();
    g_rubyType[typeName] = "CC::Ref";
    g_rubyDataType[typeName] = &ruby_cocos2dx_Ref_type;

    struct RClass *rclass = mrb_define_class_under(mrb, rmodule, "Ref", mrb->object_class);
    MRB_SET_INSTANCE_TT(rclass, MRB_TT_DATA);

    mrb_define_method(mrb, rclass, "release", ruby_cocos2dx_Ref_release, ARGS_NONE());
    mrb_define_method(mrb, rclass, "retain", ruby_cocos2dx_Ref_retain, ARGS_NONE());
    mrb_define_method(mrb, rclass, "get_reference_count", ruby_cocos2dx_Ref_getReferenceCount, ARGS_NONE());
}
mrb_value ruby_cocos2dx_Console_listenOnTCP(mrb_state* mrb, mrb_value self)
{
    cocos2d::Console* cobj = static_cast<cocos2d::Console*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            int arg0;
            ok = rubyval_to_int32(mrb, argv[0], (int*)&arg0, "CC::Console.listenOnTCP");
            if (!ok) { break; }
            bool retval = cobj->listenOnTCP(arg0);
            mrb_value ret;
            ret = mrb_bool_value((mrb_bool)retval);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::Console#listenOnTCP");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Console_log(mrb_state* mrb, mrb_value self)
{
    cocos2d::Console* cobj = static_cast<cocos2d::Console*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            const char* arg0;
            std::string arg0_tmp; ok = rubyval_to_std_string(mrb, argv[0], &arg0_tmp, "CC::Console:log"); arg0 = arg0_tmp.c_str();
            if (!ok) { break; }
            cobj->log(arg0);
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::Console#log");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Console_setBindAddress(mrb_state* mrb, mrb_value self)
{
    cocos2d::Console* cobj = static_cast<cocos2d::Console*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            std::string arg0;
            ok = rubyval_to_std_string(mrb, argv[0], &arg0, "CC::Console.setBindAddress");
            if (!ok) { break; }
            cobj->setBindAddress(arg0);
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::Console#setBindAddress");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Console_stop(mrb_state* mrb, mrb_value self)
{
    cocos2d::Console* cobj = static_cast<cocos2d::Console*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            cobj->stop();
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::Console#stop");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Console_listenOnFileDescriptor(mrb_state* mrb, mrb_value self)
{
    cocos2d::Console* cobj = static_cast<cocos2d::Console*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            int arg0;
            ok = rubyval_to_int32(mrb, argv[0], (int*)&arg0, "CC::Console.listenOnFileDescriptor");
            if (!ok) { break; }
            bool retval = cobj->listenOnFileDescriptor(arg0);
            mrb_value ret;
            ret = mrb_bool_value((mrb_bool)retval);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::Console#listenOnFileDescriptor");

    return mrb_nil_value();
}

void ruby_register_cocos2dx_Console(mrb_state* mrb, struct RClass* rmodule)
{
    std::string typeName = typeid(cocos2d::Console).name();
    g_rubyType[typeName] = "CC::Console";
    g_rubyDataType[typeName] = &ruby_cocos2dx_Ref_type;

    struct RClass* p_rmodule = mrb->object_class;
    p_rmodule = mrb_module_get_under(mrb, p_rmodule, "CC");
    struct RClass* p_rclass = mrb_class_get_under(mrb, p_rmodule, "Ref");
    struct RClass *rclass = mrb_define_class_under(mrb, rmodule, "Console", p_rclass);
    MRB_SET_INSTANCE_TT(rclass, MRB_TT_DATA);

    mrb_define_method(mrb, rclass, "listen_on_tcp", ruby_cocos2dx_Console_listenOnTCP, ARGS_REQ(1));
    mrb_define_method(mrb, rclass, "log", ruby_cocos2dx_Console_log, ARGS_REQ(1));
    mrb_define_method(mrb, rclass, "set_bind_address", ruby_cocos2dx_Console_setBindAddress, ARGS_REQ(1));
    mrb_define_method(mrb, rclass, "stop", ruby_cocos2dx_Console_stop, ARGS_NONE());
    mrb_define_method(mrb, rclass, "listen_on_file_descriptor", ruby_cocos2dx_Console_listenOnFileDescriptor, ARGS_REQ(1));
}
mrb_value ruby_cocos2dx_Vec2_clamp(mrb_state* mrb, mrb_value self)
{
    cocos2d::Vec2* cobj = static_cast<cocos2d::Vec2*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Vec2_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 2) {
            cocos2d::Vec2* arg0;
            ok = rubyval_to_object<cocos2d::Vec2>(mrb, argv[0], "CC::Vec2", &arg0);
            if (!ok) { break; }
            cocos2d::Vec2* arg1;
            ok = rubyval_to_object<cocos2d::Vec2>(mrb, argv[1], "CC::Vec2", &arg1);
            if (!ok) { break; }
            cobj->clamp(*arg0, *arg1);
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::Vec2#clamp");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Vec2_set(mrb_state* mrb, mrb_value self)
{
    cocos2d::Vec2* cobj = static_cast<cocos2d::Vec2*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Vec2_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            float* arg0;
            ok = rubyval_to_carray_float(mrb, argv[0], &arg0, "CC::Vec2.set");
            if (!ok) { break; }
            cobj->set(arg0);
            return self;
        }
    } while (0);
    do {
        if (argc == 2) {
            double arg0;
            ok = rubyval_to_number(mrb, argv[0], (double*)&arg0, "CC::Vec2.set");
            if (!ok) { break; }
            double arg1;
            ok = rubyval_to_number(mrb, argv[1], (double*)&arg1, "CC::Vec2.set");
            if (!ok) { break; }
            cobj->set(arg0, arg1);
            return self;
        }
    } while (0);
    do {
        if (argc == 1) {
            cocos2d::Vec2* arg0;
            ok = rubyval_to_object<cocos2d::Vec2>(mrb, argv[0], "CC::Vec2", &arg0);
            if (!ok) { break; }
            cobj->set(*arg0);
            return self;
        }
    } while (0);
    do {
        if (argc == 2) {
            cocos2d::Vec2* arg0;
            ok = rubyval_to_object<cocos2d::Vec2>(mrb, argv[0], "CC::Vec2", &arg0);
            if (!ok) { break; }
            cocos2d::Vec2* arg1;
            ok = rubyval_to_object<cocos2d::Vec2>(mrb, argv[1], "CC::Vec2", &arg1);
            if (!ok) { break; }
            cobj->set(*arg0, *arg1);
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::Vec2#set");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Vec2_operator_lt(mrb_state* mrb, mrb_value self)
{
    cocos2d::Vec2* cobj = static_cast<cocos2d::Vec2*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Vec2_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            cocos2d::Vec2* arg0;
            ok = rubyval_to_object<cocos2d::Vec2>(mrb, argv[0], "CC::Vec2", &arg0);
            if (!ok) { break; }
            bool retval = cobj->operator<(*arg0);
            mrb_value ret;
            ret = mrb_bool_value((mrb_bool)retval);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::Vec2#operator<");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Vec2_operator_gt(mrb_state* mrb, mrb_value self)
{
    cocos2d::Vec2* cobj = static_cast<cocos2d::Vec2*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Vec2_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            cocos2d::Vec2* arg0;
            ok = rubyval_to_object<cocos2d::Vec2>(mrb, argv[0], "CC::Vec2", &arg0);
            if (!ok) { break; }
            bool retval = cobj->operator>(*arg0);
            mrb_value ret;
            ret = mrb_bool_value((mrb_bool)retval);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::Vec2#operator>");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Vec2_getDistanceSq(mrb_state* mrb, mrb_value self)
{
    cocos2d::Vec2* cobj = static_cast<cocos2d::Vec2*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Vec2_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            cocos2d::Vec2* arg0;
            ok = rubyval_to_object<cocos2d::Vec2>(mrb, argv[0], "CC::Vec2", &arg0);
            if (!ok) { break; }
            double retval = cobj->getDistanceSq(*arg0);
            mrb_value ret;
            ret = mrb_float_value(mrb, (mrb_float)retval);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::Vec2#getDistanceSq");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Vec2_operator_plus(mrb_state* mrb, mrb_value self)
{
    cocos2d::Vec2* cobj = static_cast<cocos2d::Vec2*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Vec2_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            cocos2d::Vec2* arg0;
            ok = rubyval_to_object<cocos2d::Vec2>(mrb, argv[0], "CC::Vec2", &arg0);
            if (!ok) { break; }
            cocos2d::Vec2 retval = cobj->operator+(*arg0);
            cocos2d::Vec2* retval_ptr = new cocos2d::Vec2(retval);
            mrb_value ret;
            ret = object_to_rubyval<cocos2d::Vec2>(mrb, "CC::Vec2", (cocos2d::Vec2*)retval_ptr, nullptr);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::Vec2#operator+");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Vec2_operator_multiply(mrb_state* mrb, mrb_value self)
{
    cocos2d::Vec2* cobj = static_cast<cocos2d::Vec2*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Vec2_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            double arg0;
            ok = rubyval_to_number(mrb, argv[0], (double*)&arg0, "CC::Vec2.operator*");
            if (!ok) { break; }
            cocos2d::Vec2 retval = cobj->operator*(arg0);
            cocos2d::Vec2* retval_ptr = new cocos2d::Vec2(retval);
            mrb_value ret;
            ret = object_to_rubyval<cocos2d::Vec2>(mrb, "CC::Vec2", (cocos2d::Vec2*)retval_ptr, nullptr);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::Vec2#operator*");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Vec2_operator_minus(mrb_state* mrb, mrb_value self)
{
    cocos2d::Vec2* cobj = static_cast<cocos2d::Vec2*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Vec2_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 0) {
            cocos2d::Vec2 retval = cobj->operator-();
            cocos2d::Vec2* retval_ptr = new cocos2d::Vec2(retval);
            mrb_value ret;
            ret = object_to_rubyval<cocos2d::Vec2>(mrb, "CC::Vec2", (cocos2d::Vec2*)retval_ptr, nullptr);
            return ret;
        }
    } while (0);
    do {
        if (argc == 1) {
            cocos2d::Vec2* arg0;
            ok = rubyval_to_object<cocos2d::Vec2>(mrb, argv[0], "CC::Vec2", &arg0);
            if (!ok) { break; }
            cocos2d::Vec2 retval = cobj->operator-(*arg0);
            cocos2d::Vec2* retval_ptr = new cocos2d::Vec2(retval);
            mrb_value ret;
            ret = object_to_rubyval<cocos2d::Vec2>(mrb, "CC::Vec2", (cocos2d::Vec2*)retval_ptr, nullptr);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::Vec2#operator-");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Vec2_operator_divide(mrb_state* mrb, mrb_value self)
{
    cocos2d::Vec2* cobj = static_cast<cocos2d::Vec2*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Vec2_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            double arg0;
            ok = rubyval_to_number(mrb, argv[0], (double*)&arg0, "CC::Vec2.operator/");
            if (!ok) { break; }
            cocos2d::Vec2 retval = cobj->operator/(arg0);
            cocos2d::Vec2* retval_ptr = new cocos2d::Vec2(retval);
            mrb_value ret;
            ret = object_to_rubyval<cocos2d::Vec2>(mrb, "CC::Vec2", (cocos2d::Vec2*)retval_ptr, nullptr);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::Vec2#operator/");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Vec2_negate(mrb_state* mrb, mrb_value self)
{
    cocos2d::Vec2* cobj = static_cast<cocos2d::Vec2*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Vec2_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            cobj->negate();
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::Vec2#negate");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Vec2_distanceSquared(mrb_state* mrb, mrb_value self)
{
    cocos2d::Vec2* cobj = static_cast<cocos2d::Vec2*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Vec2_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            cocos2d::Vec2* arg0;
            ok = rubyval_to_object<cocos2d::Vec2>(mrb, argv[0], "CC::Vec2", &arg0);
            if (!ok) { break; }
            double retval = cobj->distanceSquared(*arg0);
            mrb_value ret;
            ret = mrb_float_value(mrb, (mrb_float)retval);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::Vec2#distanceSquared");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Vec2_operator_minus_eq(mrb_state* mrb, mrb_value self)
{
    cocos2d::Vec2* cobj = static_cast<cocos2d::Vec2*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Vec2_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            cocos2d::Vec2* arg0;
            ok = rubyval_to_object<cocos2d::Vec2>(mrb, argv[0], "CC::Vec2", &arg0);
            if (!ok) { break; }
            cocos2d::Vec2 retval = cobj->operator-=(*arg0);
            cocos2d::Vec2* retval_ptr = new cocos2d::Vec2(retval);
            mrb_value ret;
            ret = object_to_rubyval<cocos2d::Vec2>(mrb, "CC::Vec2", (cocos2d::Vec2*)retval_ptr, nullptr);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::Vec2#operator-=");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Vec2_isOne(mrb_state* mrb, mrb_value self)
{
    cocos2d::Vec2* cobj = static_cast<cocos2d::Vec2*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Vec2_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            bool retval = cobj->isOne();
            mrb_value ret;
            ret = mrb_bool_value((mrb_bool)retval);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::Vec2#isOne");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Vec2_scale(mrb_state* mrb, mrb_value self)
{
    cocos2d::Vec2* cobj = static_cast<cocos2d::Vec2*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Vec2_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            cocos2d::Vec2* arg0;
            ok = rubyval_to_object<cocos2d::Vec2>(mrb, argv[0], "CC::Vec2", &arg0);
            if (!ok) { break; }
            cobj->scale(*arg0);
            return self;
        }
    } while (0);
    do {
        if (argc == 1) {
            double arg0;
            ok = rubyval_to_number(mrb, argv[0], (double*)&arg0, "CC::Vec2.scale");
            if (!ok) { break; }
            cobj->scale(arg0);
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::Vec2#scale");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Vec2_operator_plus_eq(mrb_state* mrb, mrb_value self)
{
    cocos2d::Vec2* cobj = static_cast<cocos2d::Vec2*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Vec2_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            cocos2d::Vec2* arg0;
            ok = rubyval_to_object<cocos2d::Vec2>(mrb, argv[0], "CC::Vec2", &arg0);
            if (!ok) { break; }
            cocos2d::Vec2 retval = cobj->operator+=(*arg0);
            cocos2d::Vec2* retval_ptr = new cocos2d::Vec2(retval);
            mrb_value ret;
            ret = object_to_rubyval<cocos2d::Vec2>(mrb, "CC::Vec2", (cocos2d::Vec2*)retval_ptr, nullptr);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::Vec2#operator+=");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Vec2_getLength(mrb_state* mrb, mrb_value self)
{
    cocos2d::Vec2* cobj = static_cast<cocos2d::Vec2*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Vec2_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            double retval = cobj->getLength();
            mrb_value ret;
            ret = mrb_float_value(mrb, (mrb_float)retval);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::Vec2#getLength");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Vec2_cross(mrb_state* mrb, mrb_value self)
{
    cocos2d::Vec2* cobj = static_cast<cocos2d::Vec2*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Vec2_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            cocos2d::Vec2* arg0;
            ok = rubyval_to_object<cocos2d::Vec2>(mrb, argv[0], "CC::Vec2", &arg0);
            if (!ok) { break; }
            double retval = cobj->cross(*arg0);
            mrb_value ret;
            ret = mrb_float_value(mrb, (mrb_float)retval);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::Vec2#cross");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Vec2_rotateByAngle(mrb_state* mrb, mrb_value self)
{
    cocos2d::Vec2* cobj = static_cast<cocos2d::Vec2*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Vec2_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 2) {
            cocos2d::Vec2* arg0;
            ok = rubyval_to_object<cocos2d::Vec2>(mrb, argv[0], "CC::Vec2", &arg0);
            if (!ok) { break; }
            double arg1;
            ok = rubyval_to_number(mrb, argv[1], (double*)&arg1, "CC::Vec2.rotateByAngle");
            if (!ok) { break; }
            cocos2d::Vec2 retval = cobj->rotateByAngle(*arg0, arg1);
            cocos2d::Vec2* retval_ptr = new cocos2d::Vec2(retval);
            mrb_value ret;
            ret = object_to_rubyval<cocos2d::Vec2>(mrb, "CC::Vec2", (cocos2d::Vec2*)retval_ptr, nullptr);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::Vec2#rotateByAngle");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Vec2_add(mrb_state* mrb, mrb_value self)
{
    cocos2d::Vec2* cobj = static_cast<cocos2d::Vec2*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Vec2_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            cocos2d::Vec2* arg0;
            ok = rubyval_to_object<cocos2d::Vec2>(mrb, argv[0], "CC::Vec2", &arg0);
            if (!ok) { break; }
            cobj->add(*arg0);
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::Vec2#add");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Vec2_fuzzyEquals(mrb_state* mrb, mrb_value self)
{
    cocos2d::Vec2* cobj = static_cast<cocos2d::Vec2*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Vec2_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 2) {
            cocos2d::Vec2* arg0;
            ok = rubyval_to_object<cocos2d::Vec2>(mrb, argv[0], "CC::Vec2", &arg0);
            if (!ok) { break; }
            double arg1;
            ok = rubyval_to_number(mrb, argv[1], (double*)&arg1, "CC::Vec2.fuzzyEquals");
            if (!ok) { break; }
            bool retval = cobj->fuzzyEquals(*arg0, arg1);
            mrb_value ret;
            ret = mrb_bool_value((mrb_bool)retval);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::Vec2#fuzzyEquals");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Vec2_getDistance(mrb_state* mrb, mrb_value self)
{
    cocos2d::Vec2* cobj = static_cast<cocos2d::Vec2*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Vec2_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            cocos2d::Vec2* arg0;
            ok = rubyval_to_object<cocos2d::Vec2>(mrb, argv[0], "CC::Vec2", &arg0);
            if (!ok) { break; }
            double retval = cobj->getDistance(*arg0);
            mrb_value ret;
            ret = mrb_float_value(mrb, (mrb_float)retval);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::Vec2#getDistance");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Vec2_isZero(mrb_state* mrb, mrb_value self)
{
    cocos2d::Vec2* cobj = static_cast<cocos2d::Vec2*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Vec2_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            bool retval = cobj->isZero();
            mrb_value ret;
            ret = mrb_bool_value((mrb_bool)retval);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::Vec2#isZero");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Vec2_getMidpoint(mrb_state* mrb, mrb_value self)
{
    cocos2d::Vec2* cobj = static_cast<cocos2d::Vec2*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Vec2_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            cocos2d::Vec2* arg0;
            ok = rubyval_to_object<cocos2d::Vec2>(mrb, argv[0], "CC::Vec2", &arg0);
            if (!ok) { break; }
            cocos2d::Vec2 retval = cobj->getMidpoint(*arg0);
            cocos2d::Vec2* retval_ptr = new cocos2d::Vec2(retval);
            mrb_value ret;
            ret = object_to_rubyval<cocos2d::Vec2>(mrb, "CC::Vec2", (cocos2d::Vec2*)retval_ptr, nullptr);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::Vec2#getMidpoint");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Vec2_getNormalized(mrb_state* mrb, mrb_value self)
{
    cocos2d::Vec2* cobj = static_cast<cocos2d::Vec2*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Vec2_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            cocos2d::Vec2 retval = cobj->getNormalized();
            cocos2d::Vec2* retval_ptr = new cocos2d::Vec2(retval);
            mrb_value ret;
            ret = object_to_rubyval<cocos2d::Vec2>(mrb, "CC::Vec2", (cocos2d::Vec2*)retval_ptr, nullptr);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::Vec2#getNormalized");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Vec2_normalize(mrb_state* mrb, mrb_value self)
{
    cocos2d::Vec2* cobj = static_cast<cocos2d::Vec2*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Vec2_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            cobj->normalize();
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::Vec2#normalize");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Vec2_lengthSquared(mrb_state* mrb, mrb_value self)
{
    cocos2d::Vec2* cobj = static_cast<cocos2d::Vec2*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Vec2_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            double retval = cobj->lengthSquared();
            mrb_value ret;
            ret = mrb_float_value(mrb, (mrb_float)retval);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::Vec2#lengthSquared");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Vec2_operator_not_eq(mrb_state* mrb, mrb_value self)
{
    cocos2d::Vec2* cobj = static_cast<cocos2d::Vec2*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Vec2_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            cocos2d::Vec2* arg0;
            ok = rubyval_to_object<cocos2d::Vec2>(mrb, argv[0], "CC::Vec2", &arg0);
            if (!ok) { break; }
            bool retval = cobj->operator!=(*arg0);
            mrb_value ret;
            ret = mrb_bool_value((mrb_bool)retval);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::Vec2#operator!=");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Vec2_lerp(mrb_state* mrb, mrb_value self)
{
    cocos2d::Vec2* cobj = static_cast<cocos2d::Vec2*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Vec2_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 2) {
            cocos2d::Vec2* arg0;
            ok = rubyval_to_object<cocos2d::Vec2>(mrb, argv[0], "CC::Vec2", &arg0);
            if (!ok) { break; }
            double arg1;
            ok = rubyval_to_number(mrb, argv[1], (double*)&arg1, "CC::Vec2.lerp");
            if (!ok) { break; }
            cocos2d::Vec2 retval = cobj->lerp(*arg0, arg1);
            cocos2d::Vec2* retval_ptr = new cocos2d::Vec2(retval);
            mrb_value ret;
            ret = object_to_rubyval<cocos2d::Vec2>(mrb, "CC::Vec2", (cocos2d::Vec2*)retval_ptr, nullptr);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::Vec2#lerp");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Vec2_equals(mrb_state* mrb, mrb_value self)
{
    cocos2d::Vec2* cobj = static_cast<cocos2d::Vec2*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Vec2_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            cocos2d::Vec2* arg0;
            ok = rubyval_to_object<cocos2d::Vec2>(mrb, argv[0], "CC::Vec2", &arg0);
            if (!ok) { break; }
            bool retval = cobj->equals(*arg0);
            mrb_value ret;
            ret = mrb_bool_value((mrb_bool)retval);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::Vec2#equals");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Vec2_compOp(mrb_state* mrb, mrb_value self)
{
    cocos2d::Vec2* cobj = static_cast<cocos2d::Vec2*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Vec2_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            std::function<float (float)> arg0;
            do {
			    // Lambda binding for ruby.
			    unsigned long idx = -1;
			    arg0 = [mrb, self, idx](double larg0) -> double {
			        mrb_value ruby_arg0;
			        ruby_arg0 = mrb_float_value(mrb, (mrb_float)larg0);
			        mrb_value hash = mrb_iv_get(mrb, self, mrb_intern_cstr(mrb, "__callback_hash"));
			        mrb_value func = mrb_hash_get(mrb, hash, mrb_str_new_cstr(mrb, "compOp->arg0"));
			        mrb_value mrb_ret = mrb_funcall(mrb, func, "call", 1, ruby_arg0);
			        if (mrb_exception_p(mrb_ret)) {
			            mrb_exc_raise(mrb, mrb_ret);
			        }
			        bool ok = true;
			        double lret;
			        ok = rubyval_to_number(mrb, mrb_ret, (double*)&lret, ".Proc.call");
			        return lret;
			    };
			    mrb_value hash = mrb_iv_get(mrb, self, mrb_intern_cstr(mrb, "__callback_hash"));
			    if (!mrb_hash_p(hash)) {
			        hash = mrb_hash_new(mrb);
			    }
			    mrb_hash_set(mrb, hash, mrb_str_new_cstr(mrb, "compOp->arg0"), argv[0]);
			    mrb_iv_set(mrb, self, mrb_intern_cstr(mrb, "__callback_hash"), hash);
			    break;
			} while(0);
            cocos2d::Vec2 retval = cobj->compOp(arg0);
            cocos2d::Vec2* retval_ptr = new cocos2d::Vec2(retval);
            mrb_value ret;
            ret = object_to_rubyval<cocos2d::Vec2>(mrb, "CC::Vec2", (cocos2d::Vec2*)retval_ptr, nullptr);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::Vec2#compOp");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Vec2_operator_eq_eq(mrb_state* mrb, mrb_value self)
{
    cocos2d::Vec2* cobj = static_cast<cocos2d::Vec2*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Vec2_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            cocos2d::Vec2* arg0;
            ok = rubyval_to_object<cocos2d::Vec2>(mrb, argv[0], "CC::Vec2", &arg0);
            if (!ok) { break; }
            bool retval = cobj->operator==(*arg0);
            mrb_value ret;
            ret = mrb_bool_value((mrb_bool)retval);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::Vec2#operator==");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Vec2_unrotate(mrb_state* mrb, mrb_value self)
{
    cocos2d::Vec2* cobj = static_cast<cocos2d::Vec2*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Vec2_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            cocos2d::Vec2* arg0;
            ok = rubyval_to_object<cocos2d::Vec2>(mrb, argv[0], "CC::Vec2", &arg0);
            if (!ok) { break; }
            cocos2d::Vec2 retval = cobj->unrotate(*arg0);
            cocos2d::Vec2* retval_ptr = new cocos2d::Vec2(retval);
            mrb_value ret;
            ret = object_to_rubyval<cocos2d::Vec2>(mrb, "CC::Vec2", (cocos2d::Vec2*)retval_ptr, nullptr);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::Vec2#unrotate");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Vec2_getLengthSq(mrb_state* mrb, mrb_value self)
{
    cocos2d::Vec2* cobj = static_cast<cocos2d::Vec2*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Vec2_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            double retval = cobj->getLengthSq();
            mrb_value ret;
            ret = mrb_float_value(mrb, (mrb_float)retval);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::Vec2#getLengthSq");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Vec2_getPerp(mrb_state* mrb, mrb_value self)
{
    cocos2d::Vec2* cobj = static_cast<cocos2d::Vec2*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Vec2_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            cocos2d::Vec2 retval = cobj->getPerp();
            cocos2d::Vec2* retval_ptr = new cocos2d::Vec2(retval);
            mrb_value ret;
            ret = object_to_rubyval<cocos2d::Vec2>(mrb, "CC::Vec2", (cocos2d::Vec2*)retval_ptr, nullptr);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::Vec2#getPerp");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Vec2_subtract(mrb_state* mrb, mrb_value self)
{
    cocos2d::Vec2* cobj = static_cast<cocos2d::Vec2*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Vec2_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            cocos2d::Vec2* arg0;
            ok = rubyval_to_object<cocos2d::Vec2>(mrb, argv[0], "CC::Vec2", &arg0);
            if (!ok) { break; }
            cobj->subtract(*arg0);
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::Vec2#subtract");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Vec2_distance(mrb_state* mrb, mrb_value self)
{
    cocos2d::Vec2* cobj = static_cast<cocos2d::Vec2*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Vec2_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            cocos2d::Vec2* arg0;
            ok = rubyval_to_object<cocos2d::Vec2>(mrb, argv[0], "CC::Vec2", &arg0);
            if (!ok) { break; }
            double retval = cobj->distance(*arg0);
            mrb_value ret;
            ret = mrb_float_value(mrb, (mrb_float)retval);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::Vec2#distance");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Vec2_rotate(mrb_state* mrb, mrb_value self)
{
    cocos2d::Vec2* cobj = static_cast<cocos2d::Vec2*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Vec2_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            cocos2d::Vec2* arg0;
            ok = rubyval_to_object<cocos2d::Vec2>(mrb, argv[0], "CC::Vec2", &arg0);
            if (!ok) { break; }
            cocos2d::Vec2 retval = cobj->rotate(*arg0);
            cocos2d::Vec2* retval_ptr = new cocos2d::Vec2(retval);
            mrb_value ret;
            ret = object_to_rubyval<cocos2d::Vec2>(mrb, "CC::Vec2", (cocos2d::Vec2*)retval_ptr, nullptr);
            return ret;
        }
    } while (0);
    do {
        if (argc == 2) {
            cocos2d::Vec2* arg0;
            ok = rubyval_to_object<cocos2d::Vec2>(mrb, argv[0], "CC::Vec2", &arg0);
            if (!ok) { break; }
            double arg1;
            ok = rubyval_to_number(mrb, argv[1], (double*)&arg1, "CC::Vec2.rotate");
            if (!ok) { break; }
            cobj->rotate(*arg0, arg1);
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::Vec2#rotate");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Vec2_getClampPoint(mrb_state* mrb, mrb_value self)
{
    cocos2d::Vec2* cobj = static_cast<cocos2d::Vec2*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Vec2_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 2) {
            cocos2d::Vec2* arg0;
            ok = rubyval_to_object<cocos2d::Vec2>(mrb, argv[0], "CC::Vec2", &arg0);
            if (!ok) { break; }
            cocos2d::Vec2* arg1;
            ok = rubyval_to_object<cocos2d::Vec2>(mrb, argv[1], "CC::Vec2", &arg1);
            if (!ok) { break; }
            cocos2d::Vec2 retval = cobj->getClampPoint(*arg0, *arg1);
            cocos2d::Vec2* retval_ptr = new cocos2d::Vec2(retval);
            mrb_value ret;
            ret = object_to_rubyval<cocos2d::Vec2>(mrb, "CC::Vec2", (cocos2d::Vec2*)retval_ptr, nullptr);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::Vec2#getClampPoint");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Vec2_getAngle(mrb_state* mrb, mrb_value self)
{
    cocos2d::Vec2* cobj = static_cast<cocos2d::Vec2*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Vec2_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            cocos2d::Vec2* arg0;
            ok = rubyval_to_object<cocos2d::Vec2>(mrb, argv[0], "CC::Vec2", &arg0);
            if (!ok) { break; }
            double retval = cobj->getAngle(*arg0);
            mrb_value ret;
            ret = mrb_float_value(mrb, (mrb_float)retval);
            return ret;
        }
    } while (0);
    do {
        if (argc == 0) {
            double retval = cobj->getAngle();
            mrb_value ret;
            ret = mrb_float_value(mrb, (mrb_float)retval);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::Vec2#getAngle");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Vec2_setPoint(mrb_state* mrb, mrb_value self)
{
    cocos2d::Vec2* cobj = static_cast<cocos2d::Vec2*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Vec2_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 2) {
            double arg0;
            ok = rubyval_to_number(mrb, argv[0], (double*)&arg0, "CC::Vec2.setPoint");
            if (!ok) { break; }
            double arg1;
            ok = rubyval_to_number(mrb, argv[1], (double*)&arg1, "CC::Vec2.setPoint");
            if (!ok) { break; }
            cobj->setPoint(arg0, arg1);
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::Vec2#setPoint");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Vec2_smooth(mrb_state* mrb, mrb_value self)
{
    cocos2d::Vec2* cobj = static_cast<cocos2d::Vec2*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Vec2_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 3) {
            cocos2d::Vec2* arg0;
            ok = rubyval_to_object<cocos2d::Vec2>(mrb, argv[0], "CC::Vec2", &arg0);
            if (!ok) { break; }
            double arg1;
            ok = rubyval_to_number(mrb, argv[1], (double*)&arg1, "CC::Vec2.smooth");
            if (!ok) { break; }
            double arg2;
            ok = rubyval_to_number(mrb, argv[2], (double*)&arg2, "CC::Vec2.smooth");
            if (!ok) { break; }
            cobj->smooth(*arg0, arg1, arg2);
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::Vec2#smooth");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Vec2_project(mrb_state* mrb, mrb_value self)
{
    cocos2d::Vec2* cobj = static_cast<cocos2d::Vec2*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Vec2_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            cocos2d::Vec2* arg0;
            ok = rubyval_to_object<cocos2d::Vec2>(mrb, argv[0], "CC::Vec2", &arg0);
            if (!ok) { break; }
            cocos2d::Vec2 retval = cobj->project(*arg0);
            cocos2d::Vec2* retval_ptr = new cocos2d::Vec2(retval);
            mrb_value ret;
            ret = object_to_rubyval<cocos2d::Vec2>(mrb, "CC::Vec2", (cocos2d::Vec2*)retval_ptr, nullptr);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::Vec2#project");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Vec2_getRPerp(mrb_state* mrb, mrb_value self)
{
    cocos2d::Vec2* cobj = static_cast<cocos2d::Vec2*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Vec2_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            cocos2d::Vec2 retval = cobj->getRPerp();
            cocos2d::Vec2* retval_ptr = new cocos2d::Vec2(retval);
            mrb_value ret;
            ret = object_to_rubyval<cocos2d::Vec2>(mrb, "CC::Vec2", (cocos2d::Vec2*)retval_ptr, nullptr);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::Vec2#getRPerp");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Vec2_length(mrb_state* mrb, mrb_value self)
{
    cocos2d::Vec2* cobj = static_cast<cocos2d::Vec2*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Vec2_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            double retval = cobj->length();
            mrb_value ret;
            ret = mrb_float_value(mrb, (mrb_float)retval);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::Vec2#length");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Vec2_operator_multiply_eq(mrb_state* mrb, mrb_value self)
{
    cocos2d::Vec2* cobj = static_cast<cocos2d::Vec2*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Vec2_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            double arg0;
            ok = rubyval_to_number(mrb, argv[0], (double*)&arg0, "CC::Vec2.operator*=");
            if (!ok) { break; }
            cocos2d::Vec2 retval = cobj->operator*=(arg0);
            cocos2d::Vec2* retval_ptr = new cocos2d::Vec2(retval);
            mrb_value ret;
            ret = object_to_rubyval<cocos2d::Vec2>(mrb, "CC::Vec2", (cocos2d::Vec2*)retval_ptr, nullptr);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::Vec2#operator*=");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Vec2_dot(mrb_state* mrb, mrb_value self)
{
    cocos2d::Vec2* cobj = static_cast<cocos2d::Vec2*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Vec2_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            cocos2d::Vec2* arg0;
            ok = rubyval_to_object<cocos2d::Vec2>(mrb, argv[0], "CC::Vec2", &arg0);
            if (!ok) { break; }
            double retval = cobj->dot(*arg0);
            mrb_value ret;
            ret = mrb_float_value(mrb, (mrb_float)retval);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::Vec2#dot");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Vec2_clamp_static(mrb_state* mrb, mrb_value self)
{
    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 4) {
            cocos2d::Vec2* arg0;
            ok = rubyval_to_object<cocos2d::Vec2>(mrb, argv[0], "CC::Vec2", &arg0);
            if (!ok) { break; }

            cocos2d::Vec2* arg1;
            ok = rubyval_to_object<cocos2d::Vec2>(mrb, argv[1], "CC::Vec2", &arg1);
            if (!ok) { break; }

            cocos2d::Vec2* arg2;
            ok = rubyval_to_object<cocos2d::Vec2>(mrb, argv[2], "CC::Vec2", &arg2);
            if (!ok) { break; }

            cocos2d::Vec2* arg3;
            ok = rubyval_to_object<cocos2d::Vec2>(mrb, argv[3], "CC::Vec2", &arg3);
            if (!ok) { break; }

            cocos2d::Vec2::clamp(*arg0, *arg1, *arg2, arg3);
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined static method : cocos2d::Vec2#clamp");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Vec2_isLineParallel_static(mrb_state* mrb, mrb_value self)
{
    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 4) {
            cocos2d::Vec2* arg0;
            ok = rubyval_to_object<cocos2d::Vec2>(mrb, argv[0], "CC::Vec2", &arg0);
            if (!ok) { break; }

            cocos2d::Vec2* arg1;
            ok = rubyval_to_object<cocos2d::Vec2>(mrb, argv[1], "CC::Vec2", &arg1);
            if (!ok) { break; }

            cocos2d::Vec2* arg2;
            ok = rubyval_to_object<cocos2d::Vec2>(mrb, argv[2], "CC::Vec2", &arg2);
            if (!ok) { break; }

            cocos2d::Vec2* arg3;
            ok = rubyval_to_object<cocos2d::Vec2>(mrb, argv[3], "CC::Vec2", &arg3);
            if (!ok) { break; }

            bool retval = cocos2d::Vec2::isLineParallel(*arg0, *arg1, *arg2, *arg3);
            mrb_value ret;
            ret = mrb_bool_value((mrb_bool)retval);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined static method : cocos2d::Vec2#isLineParallel");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Vec2_isLineOverlap_static(mrb_state* mrb, mrb_value self)
{
    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 4) {
            cocos2d::Vec2* arg0;
            ok = rubyval_to_object<cocos2d::Vec2>(mrb, argv[0], "CC::Vec2", &arg0);
            if (!ok) { break; }

            cocos2d::Vec2* arg1;
            ok = rubyval_to_object<cocos2d::Vec2>(mrb, argv[1], "CC::Vec2", &arg1);
            if (!ok) { break; }

            cocos2d::Vec2* arg2;
            ok = rubyval_to_object<cocos2d::Vec2>(mrb, argv[2], "CC::Vec2", &arg2);
            if (!ok) { break; }

            cocos2d::Vec2* arg3;
            ok = rubyval_to_object<cocos2d::Vec2>(mrb, argv[3], "CC::Vec2", &arg3);
            if (!ok) { break; }

            bool retval = cocos2d::Vec2::isLineOverlap(*arg0, *arg1, *arg2, *arg3);
            mrb_value ret;
            ret = mrb_bool_value((mrb_bool)retval);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined static method : cocos2d::Vec2#isLineOverlap");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Vec2_angle_static(mrb_state* mrb, mrb_value self)
{
    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 2) {
            cocos2d::Vec2* arg0;
            ok = rubyval_to_object<cocos2d::Vec2>(mrb, argv[0], "CC::Vec2", &arg0);
            if (!ok) { break; }

            cocos2d::Vec2* arg1;
            ok = rubyval_to_object<cocos2d::Vec2>(mrb, argv[1], "CC::Vec2", &arg1);
            if (!ok) { break; }

            double retval = cocos2d::Vec2::angle(*arg0, *arg1);
            mrb_value ret;
            ret = mrb_float_value(mrb, (mrb_float)retval);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined static method : cocos2d::Vec2#angle");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Vec2_getIntersectPoint_static(mrb_state* mrb, mrb_value self)
{
    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 4) {
            cocos2d::Vec2* arg0;
            ok = rubyval_to_object<cocos2d::Vec2>(mrb, argv[0], "CC::Vec2", &arg0);
            if (!ok) { break; }

            cocos2d::Vec2* arg1;
            ok = rubyval_to_object<cocos2d::Vec2>(mrb, argv[1], "CC::Vec2", &arg1);
            if (!ok) { break; }

            cocos2d::Vec2* arg2;
            ok = rubyval_to_object<cocos2d::Vec2>(mrb, argv[2], "CC::Vec2", &arg2);
            if (!ok) { break; }

            cocos2d::Vec2* arg3;
            ok = rubyval_to_object<cocos2d::Vec2>(mrb, argv[3], "CC::Vec2", &arg3);
            if (!ok) { break; }

            cocos2d::Vec2 retval = cocos2d::Vec2::getIntersectPoint(*arg0, *arg1, *arg2, *arg3);
            cocos2d::Vec2* retval_ptr = new cocos2d::Vec2(retval);
            mrb_value ret;
            ret = object_to_rubyval<cocos2d::Vec2>(mrb, "CC::Vec2", (cocos2d::Vec2*)retval_ptr, nullptr);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined static method : cocos2d::Vec2#getIntersectPoint");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Vec2_isLineIntersect_static(mrb_state* mrb, mrb_value self)
{
    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 4) {
            cocos2d::Vec2* arg0;
            ok = rubyval_to_object<cocos2d::Vec2>(mrb, argv[0], "CC::Vec2", &arg0);
            if (!ok) { break; }

            cocos2d::Vec2* arg1;
            ok = rubyval_to_object<cocos2d::Vec2>(mrb, argv[1], "CC::Vec2", &arg1);
            if (!ok) { break; }

            cocos2d::Vec2* arg2;
            ok = rubyval_to_object<cocos2d::Vec2>(mrb, argv[2], "CC::Vec2", &arg2);
            if (!ok) { break; }

            cocos2d::Vec2* arg3;
            ok = rubyval_to_object<cocos2d::Vec2>(mrb, argv[3], "CC::Vec2", &arg3);
            if (!ok) { break; }

            bool retval = cocos2d::Vec2::isLineIntersect(*arg0, *arg1, *arg2, *arg3);
            mrb_value ret;
            ret = mrb_bool_value((mrb_bool)retval);
            return ret;
        }
    } while (0);
    do {
        if (argc == 5) {
            cocos2d::Vec2* arg0;
            ok = rubyval_to_object<cocos2d::Vec2>(mrb, argv[0], "CC::Vec2", &arg0);
            if (!ok) { break; }

            cocos2d::Vec2* arg1;
            ok = rubyval_to_object<cocos2d::Vec2>(mrb, argv[1], "CC::Vec2", &arg1);
            if (!ok) { break; }

            cocos2d::Vec2* arg2;
            ok = rubyval_to_object<cocos2d::Vec2>(mrb, argv[2], "CC::Vec2", &arg2);
            if (!ok) { break; }

            cocos2d::Vec2* arg3;
            ok = rubyval_to_object<cocos2d::Vec2>(mrb, argv[3], "CC::Vec2", &arg3);
            if (!ok) { break; }

            float* arg4;
            ok = rubyval_to_carray_float(mrb, argv[4], &arg4, "CC::Vec2.isLineIntersect");
            if (!ok) { break; }

            bool retval = cocos2d::Vec2::isLineIntersect(*arg0, *arg1, *arg2, *arg3, arg4);
            mrb_value ret;
            ret = mrb_bool_value((mrb_bool)retval);
            return ret;
        }
    } while (0);
    do {
        if (argc == 6) {
            cocos2d::Vec2* arg0;
            ok = rubyval_to_object<cocos2d::Vec2>(mrb, argv[0], "CC::Vec2", &arg0);
            if (!ok) { break; }

            cocos2d::Vec2* arg1;
            ok = rubyval_to_object<cocos2d::Vec2>(mrb, argv[1], "CC::Vec2", &arg1);
            if (!ok) { break; }

            cocos2d::Vec2* arg2;
            ok = rubyval_to_object<cocos2d::Vec2>(mrb, argv[2], "CC::Vec2", &arg2);
            if (!ok) { break; }

            cocos2d::Vec2* arg3;
            ok = rubyval_to_object<cocos2d::Vec2>(mrb, argv[3], "CC::Vec2", &arg3);
            if (!ok) { break; }

            float* arg4;
            ok = rubyval_to_carray_float(mrb, argv[4], &arg4, "CC::Vec2.isLineIntersect");
            if (!ok) { break; }

            float* arg5;
            ok = rubyval_to_carray_float(mrb, argv[5], &arg5, "CC::Vec2.isLineIntersect");
            if (!ok) { break; }

            bool retval = cocos2d::Vec2::isLineIntersect(*arg0, *arg1, *arg2, *arg3, arg4, arg5);
            mrb_value ret;
            ret = mrb_bool_value((mrb_bool)retval);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined static method : cocos2d::Vec2#isLineIntersect");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Vec2_isSegmentOverlap_static(mrb_state* mrb, mrb_value self)
{
    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 4) {
            cocos2d::Vec2* arg0;
            ok = rubyval_to_object<cocos2d::Vec2>(mrb, argv[0], "CC::Vec2", &arg0);
            if (!ok) { break; }

            cocos2d::Vec2* arg1;
            ok = rubyval_to_object<cocos2d::Vec2>(mrb, argv[1], "CC::Vec2", &arg1);
            if (!ok) { break; }

            cocos2d::Vec2* arg2;
            ok = rubyval_to_object<cocos2d::Vec2>(mrb, argv[2], "CC::Vec2", &arg2);
            if (!ok) { break; }

            cocos2d::Vec2* arg3;
            ok = rubyval_to_object<cocos2d::Vec2>(mrb, argv[3], "CC::Vec2", &arg3);
            if (!ok) { break; }

            bool retval = cocos2d::Vec2::isSegmentOverlap(*arg0, *arg1, *arg2, *arg3);
            mrb_value ret;
            ret = mrb_bool_value((mrb_bool)retval);
            return ret;
        }
    } while (0);
    do {
        if (argc == 5) {
            cocos2d::Vec2* arg0;
            ok = rubyval_to_object<cocos2d::Vec2>(mrb, argv[0], "CC::Vec2", &arg0);
            if (!ok) { break; }

            cocos2d::Vec2* arg1;
            ok = rubyval_to_object<cocos2d::Vec2>(mrb, argv[1], "CC::Vec2", &arg1);
            if (!ok) { break; }

            cocos2d::Vec2* arg2;
            ok = rubyval_to_object<cocos2d::Vec2>(mrb, argv[2], "CC::Vec2", &arg2);
            if (!ok) { break; }

            cocos2d::Vec2* arg3;
            ok = rubyval_to_object<cocos2d::Vec2>(mrb, argv[3], "CC::Vec2", &arg3);
            if (!ok) { break; }

            cocos2d::Vec2* arg4;
            ok = rubyval_to_object<cocos2d::Vec2>(mrb, argv[4], "CC::Vec2", &arg4);
            if (!ok) { break; }

            bool retval = cocos2d::Vec2::isSegmentOverlap(*arg0, *arg1, *arg2, *arg3, arg4);
            mrb_value ret;
            ret = mrb_bool_value((mrb_bool)retval);
            return ret;
        }
    } while (0);
    do {
        if (argc == 6) {
            cocos2d::Vec2* arg0;
            ok = rubyval_to_object<cocos2d::Vec2>(mrb, argv[0], "CC::Vec2", &arg0);
            if (!ok) { break; }

            cocos2d::Vec2* arg1;
            ok = rubyval_to_object<cocos2d::Vec2>(mrb, argv[1], "CC::Vec2", &arg1);
            if (!ok) { break; }

            cocos2d::Vec2* arg2;
            ok = rubyval_to_object<cocos2d::Vec2>(mrb, argv[2], "CC::Vec2", &arg2);
            if (!ok) { break; }

            cocos2d::Vec2* arg3;
            ok = rubyval_to_object<cocos2d::Vec2>(mrb, argv[3], "CC::Vec2", &arg3);
            if (!ok) { break; }

            cocos2d::Vec2* arg4;
            ok = rubyval_to_object<cocos2d::Vec2>(mrb, argv[4], "CC::Vec2", &arg4);
            if (!ok) { break; }

            cocos2d::Vec2* arg5;
            ok = rubyval_to_object<cocos2d::Vec2>(mrb, argv[5], "CC::Vec2", &arg5);
            if (!ok) { break; }

            bool retval = cocos2d::Vec2::isSegmentOverlap(*arg0, *arg1, *arg2, *arg3, arg4, arg5);
            mrb_value ret;
            ret = mrb_bool_value((mrb_bool)retval);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined static method : cocos2d::Vec2#isSegmentOverlap");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Vec2_forAngle_static(mrb_state* mrb, mrb_value self)
{
    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            float arg0;
            ok = rubyval_to_number(mrb, argv[0], (double*)&arg0, "CC::Vec2.forAngle");
            if (!ok) { break; }

            cocos2d::Vec2 retval = cocos2d::Vec2::forAngle(arg0);
            cocos2d::Vec2* retval_ptr = new cocos2d::Vec2(retval);
            mrb_value ret;
            ret = object_to_rubyval<cocos2d::Vec2>(mrb, "CC::Vec2", (cocos2d::Vec2*)retval_ptr, nullptr);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined static method : cocos2d::Vec2#forAngle");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Vec2_isSegmentIntersect_static(mrb_state* mrb, mrb_value self)
{
    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 4) {
            cocos2d::Vec2* arg0;
            ok = rubyval_to_object<cocos2d::Vec2>(mrb, argv[0], "CC::Vec2", &arg0);
            if (!ok) { break; }

            cocos2d::Vec2* arg1;
            ok = rubyval_to_object<cocos2d::Vec2>(mrb, argv[1], "CC::Vec2", &arg1);
            if (!ok) { break; }

            cocos2d::Vec2* arg2;
            ok = rubyval_to_object<cocos2d::Vec2>(mrb, argv[2], "CC::Vec2", &arg2);
            if (!ok) { break; }

            cocos2d::Vec2* arg3;
            ok = rubyval_to_object<cocos2d::Vec2>(mrb, argv[3], "CC::Vec2", &arg3);
            if (!ok) { break; }

            bool retval = cocos2d::Vec2::isSegmentIntersect(*arg0, *arg1, *arg2, *arg3);
            mrb_value ret;
            ret = mrb_bool_value((mrb_bool)retval);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined static method : cocos2d::Vec2#isSegmentIntersect");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Vec2_add_static(mrb_state* mrb, mrb_value self)
{
    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 3) {
            cocos2d::Vec2* arg0;
            ok = rubyval_to_object<cocos2d::Vec2>(mrb, argv[0], "CC::Vec2", &arg0);
            if (!ok) { break; }

            cocos2d::Vec2* arg1;
            ok = rubyval_to_object<cocos2d::Vec2>(mrb, argv[1], "CC::Vec2", &arg1);
            if (!ok) { break; }

            cocos2d::Vec2* arg2;
            ok = rubyval_to_object<cocos2d::Vec2>(mrb, argv[2], "CC::Vec2", &arg2);
            if (!ok) { break; }

            cocos2d::Vec2::add(*arg0, *arg1, arg2);
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined static method : cocos2d::Vec2#add");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Vec2_subtract_static(mrb_state* mrb, mrb_value self)
{
    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 3) {
            cocos2d::Vec2* arg0;
            ok = rubyval_to_object<cocos2d::Vec2>(mrb, argv[0], "CC::Vec2", &arg0);
            if (!ok) { break; }

            cocos2d::Vec2* arg1;
            ok = rubyval_to_object<cocos2d::Vec2>(mrb, argv[1], "CC::Vec2", &arg1);
            if (!ok) { break; }

            cocos2d::Vec2* arg2;
            ok = rubyval_to_object<cocos2d::Vec2>(mrb, argv[2], "CC::Vec2", &arg2);
            if (!ok) { break; }

            cocos2d::Vec2::subtract(*arg0, *arg1, arg2);
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined static method : cocos2d::Vec2#subtract");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Vec2_dot_static(mrb_state* mrb, mrb_value self)
{
    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 2) {
            cocos2d::Vec2* arg0;
            ok = rubyval_to_object<cocos2d::Vec2>(mrb, argv[0], "CC::Vec2", &arg0);
            if (!ok) { break; }

            cocos2d::Vec2* arg1;
            ok = rubyval_to_object<cocos2d::Vec2>(mrb, argv[1], "CC::Vec2", &arg1);
            if (!ok) { break; }

            double retval = cocos2d::Vec2::dot(*arg0, *arg1);
            mrb_value ret;
            ret = mrb_float_value(mrb, (mrb_float)retval);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined static method : cocos2d::Vec2#dot");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Vec2_property_x_get(mrb_state* mrb, mrb_value self)
{
    cocos2d::Vec2* cobj = static_cast<cocos2d::Vec2*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Vec2_type));

    mrb_value ret;
    ret = mrb_float_value(mrb, (mrb_float)cobj->x);
    return ret;
}

mrb_value ruby_cocos2dx_Vec2_property_x_set(mrb_state* mrb, mrb_value self)
{
    cocos2d::Vec2* cobj = static_cast<cocos2d::Vec2*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Vec2_type));

    mrb_value argv;
    mrb_get_args(mrb, "o", &argv);

    bool ok = true;
    double val;
    ok = rubyval_to_number(mrb, argv, (double*)&val, "CC::Vec2.x");
    if (! ok) {
        mrb_raise(mrb, E_RUNTIME_ERROR, "convert to native failed : Vec2#x");
    }
    cobj->x = val;

    return self;
}

mrb_value ruby_cocos2dx_Vec2_property_y_get(mrb_state* mrb, mrb_value self)
{
    cocos2d::Vec2* cobj = static_cast<cocos2d::Vec2*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Vec2_type));

    mrb_value ret;
    ret = mrb_float_value(mrb, (mrb_float)cobj->y);
    return ret;
}

mrb_value ruby_cocos2dx_Vec2_property_y_set(mrb_state* mrb, mrb_value self)
{
    cocos2d::Vec2* cobj = static_cast<cocos2d::Vec2*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Vec2_type));

    mrb_value argv;
    mrb_get_args(mrb, "o", &argv);

    bool ok = true;
    double val;
    ok = rubyval_to_number(mrb, argv, (double*)&val, "CC::Vec2.y");
    if (! ok) {
        mrb_raise(mrb, E_RUNTIME_ERROR, "convert to native failed : Vec2#y");
    }
    cobj->y = val;

    return self;
}

mrb_value ruby_cocos2dx_Vec2_constructor(mrb_state* mrb, mrb_value self)
{

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 2) {
            double arg0;
            ok = rubyval_to_number(mrb, argv[0], (double*)&arg0, "CC::Vec2.Vec2");
            if (!ok) { break; }
            double arg1;
            ok = rubyval_to_number(mrb, argv[1], (double*)&arg1, "CC::Vec2.Vec2");
            if (!ok) { break; }
            cocos2d::Vec2* cobj = new cocos2d::Vec2(arg0, arg1);
            DATA_TYPE(self) = &ruby_cocos2dx_Vec2_type;
            DATA_PTR(self) = cobj;
            return self;
        }
    } while (0);
    do {
        if (argc == 0) {
            cocos2d::Vec2* cobj = new cocos2d::Vec2();
            DATA_TYPE(self) = &ruby_cocos2dx_Vec2_type;
            DATA_PTR(self) = cobj;
            return self;
        }
    } while (0);
    do {
        if (argc == 1) {
            float* arg0;
            ok = rubyval_to_carray_float(mrb, argv[0], &arg0, "CC::Vec2.Vec2");
            if (!ok) { break; }
            cocos2d::Vec2* cobj = new cocos2d::Vec2(arg0);
            DATA_TYPE(self) = &ruby_cocos2dx_Vec2_type;
            DATA_PTR(self) = cobj;
            return self;
        }
    } while (0);
    do {
        if (argc == 2) {
            cocos2d::Vec2* arg0;
            ok = rubyval_to_object<cocos2d::Vec2>(mrb, argv[0], "CC::Vec2", &arg0);
            if (!ok) { break; }
            cocos2d::Vec2* arg1;
            ok = rubyval_to_object<cocos2d::Vec2>(mrb, argv[1], "CC::Vec2", &arg1);
            if (!ok) { break; }
            cocos2d::Vec2* cobj = new cocos2d::Vec2(*arg0, *arg1);
            DATA_TYPE(self) = &ruby_cocos2dx_Vec2_type;
            DATA_PTR(self) = cobj;
            return self;
        }
    } while (0);
    do {
        if (argc == 1) {
            cocos2d::Vec2* arg0;
            ok = rubyval_to_object<cocos2d::Vec2>(mrb, argv[0], "CC::Vec2", &arg0);
            if (!ok) { break; }
            cocos2d::Vec2* cobj = new cocos2d::Vec2(*arg0);
            DATA_TYPE(self) = &ruby_cocos2dx_Vec2_type;
            DATA_PTR(self) = cobj;
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::Vec2#Vec2");

    return mrb_nil_value();
}


void ruby_cocos2dx_Vec2_constants_init(mrb_state* mrb, struct RClass* rclass)
{
    do {
        cocos2d::Vec2* retval_ptr = new cocos2d::Vec2(cocos2d::Vec2::ZERO);
        mrb_value ret;
        ret = object_to_rubyval<cocos2d::Vec2>(mrb, "CC::Vec2", (cocos2d::Vec2*)retval_ptr, nullptr);
        mrb_mod_cv_set(mrb, rclass, mrb_intern_cstr(mrb, "ZERO"), ret);
    } while (0);

    do {
        cocos2d::Vec2* retval_ptr = new cocos2d::Vec2(cocos2d::Vec2::ONE);
        mrb_value ret;
        ret = object_to_rubyval<cocos2d::Vec2>(mrb, "CC::Vec2", (cocos2d::Vec2*)retval_ptr, nullptr);
        mrb_mod_cv_set(mrb, rclass, mrb_intern_cstr(mrb, "ONE"), ret);
    } while (0);

    do {
        cocos2d::Vec2* retval_ptr = new cocos2d::Vec2(cocos2d::Vec2::UNIT_X);
        mrb_value ret;
        ret = object_to_rubyval<cocos2d::Vec2>(mrb, "CC::Vec2", (cocos2d::Vec2*)retval_ptr, nullptr);
        mrb_mod_cv_set(mrb, rclass, mrb_intern_cstr(mrb, "UNIT_X"), ret);
    } while (0);

    do {
        cocos2d::Vec2* retval_ptr = new cocos2d::Vec2(cocos2d::Vec2::UNIT_Y);
        mrb_value ret;
        ret = object_to_rubyval<cocos2d::Vec2>(mrb, "CC::Vec2", (cocos2d::Vec2*)retval_ptr, nullptr);
        mrb_mod_cv_set(mrb, rclass, mrb_intern_cstr(mrb, "UNIT_Y"), ret);
    } while (0);

    do {
        cocos2d::Vec2* retval_ptr = new cocos2d::Vec2(cocos2d::Vec2::ANCHOR_MIDDLE);
        mrb_value ret;
        ret = object_to_rubyval<cocos2d::Vec2>(mrb, "CC::Vec2", (cocos2d::Vec2*)retval_ptr, nullptr);
        mrb_mod_cv_set(mrb, rclass, mrb_intern_cstr(mrb, "ANCHOR_MIDDLE"), ret);
    } while (0);

    do {
        cocos2d::Vec2* retval_ptr = new cocos2d::Vec2(cocos2d::Vec2::ANCHOR_BOTTOM_LEFT);
        mrb_value ret;
        ret = object_to_rubyval<cocos2d::Vec2>(mrb, "CC::Vec2", (cocos2d::Vec2*)retval_ptr, nullptr);
        mrb_mod_cv_set(mrb, rclass, mrb_intern_cstr(mrb, "ANCHOR_BOTTOM_LEFT"), ret);
    } while (0);

    do {
        cocos2d::Vec2* retval_ptr = new cocos2d::Vec2(cocos2d::Vec2::ANCHOR_TOP_LEFT);
        mrb_value ret;
        ret = object_to_rubyval<cocos2d::Vec2>(mrb, "CC::Vec2", (cocos2d::Vec2*)retval_ptr, nullptr);
        mrb_mod_cv_set(mrb, rclass, mrb_intern_cstr(mrb, "ANCHOR_TOP_LEFT"), ret);
    } while (0);

    do {
        cocos2d::Vec2* retval_ptr = new cocos2d::Vec2(cocos2d::Vec2::ANCHOR_BOTTOM_RIGHT);
        mrb_value ret;
        ret = object_to_rubyval<cocos2d::Vec2>(mrb, "CC::Vec2", (cocos2d::Vec2*)retval_ptr, nullptr);
        mrb_mod_cv_set(mrb, rclass, mrb_intern_cstr(mrb, "ANCHOR_BOTTOM_RIGHT"), ret);
    } while (0);

    do {
        cocos2d::Vec2* retval_ptr = new cocos2d::Vec2(cocos2d::Vec2::ANCHOR_TOP_RIGHT);
        mrb_value ret;
        ret = object_to_rubyval<cocos2d::Vec2>(mrb, "CC::Vec2", (cocos2d::Vec2*)retval_ptr, nullptr);
        mrb_mod_cv_set(mrb, rclass, mrb_intern_cstr(mrb, "ANCHOR_TOP_RIGHT"), ret);
    } while (0);

    do {
        cocos2d::Vec2* retval_ptr = new cocos2d::Vec2(cocos2d::Vec2::ANCHOR_MIDDLE_RIGHT);
        mrb_value ret;
        ret = object_to_rubyval<cocos2d::Vec2>(mrb, "CC::Vec2", (cocos2d::Vec2*)retval_ptr, nullptr);
        mrb_mod_cv_set(mrb, rclass, mrb_intern_cstr(mrb, "ANCHOR_MIDDLE_RIGHT"), ret);
    } while (0);

    do {
        cocos2d::Vec2* retval_ptr = new cocos2d::Vec2(cocos2d::Vec2::ANCHOR_MIDDLE_LEFT);
        mrb_value ret;
        ret = object_to_rubyval<cocos2d::Vec2>(mrb, "CC::Vec2", (cocos2d::Vec2*)retval_ptr, nullptr);
        mrb_mod_cv_set(mrb, rclass, mrb_intern_cstr(mrb, "ANCHOR_MIDDLE_LEFT"), ret);
    } while (0);

    do {
        cocos2d::Vec2* retval_ptr = new cocos2d::Vec2(cocos2d::Vec2::ANCHOR_MIDDLE_TOP);
        mrb_value ret;
        ret = object_to_rubyval<cocos2d::Vec2>(mrb, "CC::Vec2", (cocos2d::Vec2*)retval_ptr, nullptr);
        mrb_mod_cv_set(mrb, rclass, mrb_intern_cstr(mrb, "ANCHOR_MIDDLE_TOP"), ret);
    } while (0);

    do {
        cocos2d::Vec2* retval_ptr = new cocos2d::Vec2(cocos2d::Vec2::ANCHOR_MIDDLE_BOTTOM);
        mrb_value ret;
        ret = object_to_rubyval<cocos2d::Vec2>(mrb, "CC::Vec2", (cocos2d::Vec2*)retval_ptr, nullptr);
        mrb_mod_cv_set(mrb, rclass, mrb_intern_cstr(mrb, "ANCHOR_MIDDLE_BOTTOM"), ret);
    } while (0);

}

void ruby_register_cocos2dx_Vec2(mrb_state* mrb, struct RClass* rmodule)
{
    std::string typeName = typeid(cocos2d::Vec2).name();
    g_rubyType[typeName] = "CC::Vec2";
    g_rubyDataType[typeName] = &ruby_cocos2dx_Vec2_type;

    struct RClass *rclass = mrb_define_class_under(mrb, rmodule, "Vec2", mrb->object_class);
    MRB_SET_INSTANCE_TT(rclass, MRB_TT_DATA);

    mrb_define_method(mrb, rclass, "initialize", ruby_cocos2dx_Vec2_constructor, ARGS_REQ(0)|ARGS_OPT(2));
    mrb_define_method(mrb, rclass, "clamp", ruby_cocos2dx_Vec2_clamp, ARGS_REQ(2));
    mrb_define_method(mrb, rclass, "set", ruby_cocos2dx_Vec2_set, ARGS_REQ(1)|ARGS_OPT(1));
    mrb_define_method(mrb, rclass, "<", ruby_cocos2dx_Vec2_operator_lt, ARGS_REQ(1));
    mrb_define_method(mrb, rclass, ">", ruby_cocos2dx_Vec2_operator_gt, ARGS_REQ(1));
    mrb_define_method(mrb, rclass, "get_distance_sq", ruby_cocos2dx_Vec2_getDistanceSq, ARGS_REQ(1));
    mrb_define_method(mrb, rclass, "+", ruby_cocos2dx_Vec2_operator_plus, ARGS_REQ(1));
    mrb_define_method(mrb, rclass, "*", ruby_cocos2dx_Vec2_operator_multiply, ARGS_REQ(1));
    mrb_define_method(mrb, rclass, "-", ruby_cocos2dx_Vec2_operator_minus, ARGS_REQ(0)|ARGS_OPT(1));
    mrb_define_method(mrb, rclass, "/", ruby_cocos2dx_Vec2_operator_divide, ARGS_REQ(1));
    mrb_define_method(mrb, rclass, "negate", ruby_cocos2dx_Vec2_negate, ARGS_NONE());
    mrb_define_method(mrb, rclass, "distance_squared", ruby_cocos2dx_Vec2_distanceSquared, ARGS_REQ(1));
    mrb_define_method(mrb, rclass, "-=", ruby_cocos2dx_Vec2_operator_minus_eq, ARGS_REQ(1));
    mrb_define_method(mrb, rclass, "one?", ruby_cocos2dx_Vec2_isOne, ARGS_NONE());
    mrb_define_method(mrb, rclass, "scale", ruby_cocos2dx_Vec2_scale, ARGS_REQ(1));
    mrb_define_method(mrb, rclass, "+=", ruby_cocos2dx_Vec2_operator_plus_eq, ARGS_REQ(1));
    mrb_define_method(mrb, rclass, "get_length", ruby_cocos2dx_Vec2_getLength, ARGS_NONE());
    mrb_define_method(mrb, rclass, "cross", ruby_cocos2dx_Vec2_cross, ARGS_REQ(1));
    mrb_define_method(mrb, rclass, "rotate_by_angle", ruby_cocos2dx_Vec2_rotateByAngle, ARGS_REQ(2));
    mrb_define_method(mrb, rclass, "add", ruby_cocos2dx_Vec2_add, ARGS_REQ(1));
    mrb_define_method(mrb, rclass, "fuzzy_equals", ruby_cocos2dx_Vec2_fuzzyEquals, ARGS_REQ(2));
    mrb_define_method(mrb, rclass, "get_distance", ruby_cocos2dx_Vec2_getDistance, ARGS_REQ(1));
    mrb_define_method(mrb, rclass, "zero?", ruby_cocos2dx_Vec2_isZero, ARGS_NONE());
    mrb_define_method(mrb, rclass, "get_midpoint", ruby_cocos2dx_Vec2_getMidpoint, ARGS_REQ(1));
    mrb_define_method(mrb, rclass, "get_normalized", ruby_cocos2dx_Vec2_getNormalized, ARGS_NONE());
    mrb_define_method(mrb, rclass, "normalize", ruby_cocos2dx_Vec2_normalize, ARGS_NONE());
    mrb_define_method(mrb, rclass, "length_squared", ruby_cocos2dx_Vec2_lengthSquared, ARGS_NONE());
    mrb_define_method(mrb, rclass, "!=", ruby_cocos2dx_Vec2_operator_not_eq, ARGS_REQ(1));
    mrb_define_method(mrb, rclass, "lerp", ruby_cocos2dx_Vec2_lerp, ARGS_REQ(2));
    mrb_define_method(mrb, rclass, "equals", ruby_cocos2dx_Vec2_equals, ARGS_REQ(1));
    mrb_define_method(mrb, rclass, "comp_op", ruby_cocos2dx_Vec2_compOp, ARGS_REQ(1));
    mrb_define_method(mrb, rclass, "==", ruby_cocos2dx_Vec2_operator_eq_eq, ARGS_REQ(1));
    mrb_define_method(mrb, rclass, "unrotate", ruby_cocos2dx_Vec2_unrotate, ARGS_REQ(1));
    mrb_define_method(mrb, rclass, "get_length_sq", ruby_cocos2dx_Vec2_getLengthSq, ARGS_NONE());
    mrb_define_method(mrb, rclass, "get_perp", ruby_cocos2dx_Vec2_getPerp, ARGS_NONE());
    mrb_define_method(mrb, rclass, "subtract", ruby_cocos2dx_Vec2_subtract, ARGS_REQ(1));
    mrb_define_method(mrb, rclass, "distance", ruby_cocos2dx_Vec2_distance, ARGS_REQ(1));
    mrb_define_method(mrb, rclass, "rotate", ruby_cocos2dx_Vec2_rotate, ARGS_REQ(1)|ARGS_OPT(1));
    mrb_define_method(mrb, rclass, "get_clamp_point", ruby_cocos2dx_Vec2_getClampPoint, ARGS_REQ(2));
    mrb_define_method(mrb, rclass, "get_angle", ruby_cocos2dx_Vec2_getAngle, ARGS_REQ(0)|ARGS_OPT(1));
    mrb_define_method(mrb, rclass, "set_point", ruby_cocos2dx_Vec2_setPoint, ARGS_REQ(2));
    mrb_define_method(mrb, rclass, "smooth", ruby_cocos2dx_Vec2_smooth, ARGS_REQ(3));
    mrb_define_method(mrb, rclass, "project", ruby_cocos2dx_Vec2_project, ARGS_REQ(1));
    mrb_define_method(mrb, rclass, "get_rperp", ruby_cocos2dx_Vec2_getRPerp, ARGS_NONE());
    mrb_define_method(mrb, rclass, "length", ruby_cocos2dx_Vec2_length, ARGS_NONE());
    mrb_define_method(mrb, rclass, "*=", ruby_cocos2dx_Vec2_operator_multiply_eq, ARGS_REQ(1));
    mrb_define_method(mrb, rclass, "dot", ruby_cocos2dx_Vec2_dot, ARGS_REQ(1));
    mrb_define_class_method(mrb, rclass, "clamp", ruby_cocos2dx_Vec2_clamp_static, ARGS_REQ(4));
    mrb_define_class_method(mrb, rclass, "line_parallel?", ruby_cocos2dx_Vec2_isLineParallel_static, ARGS_REQ(4));
    mrb_define_class_method(mrb, rclass, "line_overlap?", ruby_cocos2dx_Vec2_isLineOverlap_static, ARGS_REQ(4));
    mrb_define_class_method(mrb, rclass, "angle", ruby_cocos2dx_Vec2_angle_static, ARGS_REQ(2));
    mrb_define_class_method(mrb, rclass, "get_intersect_point", ruby_cocos2dx_Vec2_getIntersectPoint_static, ARGS_REQ(4));
    mrb_define_class_method(mrb, rclass, "line_intersect?", ruby_cocos2dx_Vec2_isLineIntersect_static, ARGS_REQ(6));
    mrb_define_class_method(mrb, rclass, "segment_overlap?", ruby_cocos2dx_Vec2_isSegmentOverlap_static, ARGS_REQ(6));
    mrb_define_class_method(mrb, rclass, "for_angle", ruby_cocos2dx_Vec2_forAngle_static, ARGS_REQ(1));
    mrb_define_class_method(mrb, rclass, "segment_intersect?", ruby_cocos2dx_Vec2_isSegmentIntersect_static, ARGS_REQ(4));
    mrb_define_class_method(mrb, rclass, "add", ruby_cocos2dx_Vec2_add_static, ARGS_REQ(3));
    mrb_define_class_method(mrb, rclass, "subtract", ruby_cocos2dx_Vec2_subtract_static, ARGS_REQ(3));
    mrb_define_class_method(mrb, rclass, "dot", ruby_cocos2dx_Vec2_dot_static, ARGS_REQ(2));
    mrb_define_method(mrb, rclass, "x", ruby_cocos2dx_Vec2_property_x_get, ARGS_NONE());
    mrb_define_method(mrb, rclass, "x=", ruby_cocos2dx_Vec2_property_x_set, ARGS_REQ(1));
    mrb_define_method(mrb, rclass, "y", ruby_cocos2dx_Vec2_property_y_get, ARGS_NONE());
    mrb_define_method(mrb, rclass, "y=", ruby_cocos2dx_Vec2_property_y_set, ARGS_REQ(1));
    ruby_cocos2dx_Vec2_constants_init(mrb, rclass);
    mrb_define_class_method(mrb, rclass, "ZERO", ruby_cocos2dx_constant_get, ARGS_NONE());
    mrb_define_class_method(mrb, rclass, "ONE", ruby_cocos2dx_constant_get, ARGS_NONE());
    mrb_define_class_method(mrb, rclass, "UNIT_X", ruby_cocos2dx_constant_get, ARGS_NONE());
    mrb_define_class_method(mrb, rclass, "UNIT_Y", ruby_cocos2dx_constant_get, ARGS_NONE());
    mrb_define_class_method(mrb, rclass, "ANCHOR_MIDDLE", ruby_cocos2dx_constant_get, ARGS_NONE());
    mrb_define_class_method(mrb, rclass, "ANCHOR_BOTTOM_LEFT", ruby_cocos2dx_constant_get, ARGS_NONE());
    mrb_define_class_method(mrb, rclass, "ANCHOR_TOP_LEFT", ruby_cocos2dx_constant_get, ARGS_NONE());
    mrb_define_class_method(mrb, rclass, "ANCHOR_BOTTOM_RIGHT", ruby_cocos2dx_constant_get, ARGS_NONE());
    mrb_define_class_method(mrb, rclass, "ANCHOR_TOP_RIGHT", ruby_cocos2dx_constant_get, ARGS_NONE());
    mrb_define_class_method(mrb, rclass, "ANCHOR_MIDDLE_RIGHT", ruby_cocos2dx_constant_get, ARGS_NONE());
    mrb_define_class_method(mrb, rclass, "ANCHOR_MIDDLE_LEFT", ruby_cocos2dx_constant_get, ARGS_NONE());
    mrb_define_class_method(mrb, rclass, "ANCHOR_MIDDLE_TOP", ruby_cocos2dx_constant_get, ARGS_NONE());
    mrb_define_class_method(mrb, rclass, "ANCHOR_MIDDLE_BOTTOM", ruby_cocos2dx_constant_get, ARGS_NONE());
}
mrb_value ruby_cocos2dx_Vec3_clamp(mrb_state* mrb, mrb_value self)
{
    cocos2d::Vec3* cobj = static_cast<cocos2d::Vec3*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Vec3_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 2) {
            cocos2d::Vec3* arg0;
            ok = rubyval_to_object<cocos2d::Vec3>(mrb, argv[0], "CC::Vec3", &arg0);
            if (!ok) { break; }
            cocos2d::Vec3* arg1;
            ok = rubyval_to_object<cocos2d::Vec3>(mrb, argv[1], "CC::Vec3", &arg1);
            if (!ok) { break; }
            cobj->clamp(*arg0, *arg1);
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::Vec3#clamp");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Vec3_set(mrb_state* mrb, mrb_value self)
{
    cocos2d::Vec3* cobj = static_cast<cocos2d::Vec3*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Vec3_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            float* arg0;
            ok = rubyval_to_carray_float(mrb, argv[0], &arg0, "CC::Vec3.set");
            if (!ok) { break; }
            cobj->set(arg0);
            return self;
        }
    } while (0);
    do {
        if (argc == 3) {
            double arg0;
            ok = rubyval_to_number(mrb, argv[0], (double*)&arg0, "CC::Vec3.set");
            if (!ok) { break; }
            double arg1;
            ok = rubyval_to_number(mrb, argv[1], (double*)&arg1, "CC::Vec3.set");
            if (!ok) { break; }
            double arg2;
            ok = rubyval_to_number(mrb, argv[2], (double*)&arg2, "CC::Vec3.set");
            if (!ok) { break; }
            cobj->set(arg0, arg1, arg2);
            return self;
        }
    } while (0);
    do {
        if (argc == 1) {
            cocos2d::Vec3* arg0;
            ok = rubyval_to_object<cocos2d::Vec3>(mrb, argv[0], "CC::Vec3", &arg0);
            if (!ok) { break; }
            cobj->set(*arg0);
            return self;
        }
    } while (0);
    do {
        if (argc == 2) {
            cocos2d::Vec3* arg0;
            ok = rubyval_to_object<cocos2d::Vec3>(mrb, argv[0], "CC::Vec3", &arg0);
            if (!ok) { break; }
            cocos2d::Vec3* arg1;
            ok = rubyval_to_object<cocos2d::Vec3>(mrb, argv[1], "CC::Vec3", &arg1);
            if (!ok) { break; }
            cobj->set(*arg0, *arg1);
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::Vec3#set");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Vec3_operator_lt(mrb_state* mrb, mrb_value self)
{
    cocos2d::Vec3* cobj = static_cast<cocos2d::Vec3*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Vec3_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            cocos2d::Vec3* arg0;
            ok = rubyval_to_object<cocos2d::Vec3>(mrb, argv[0], "CC::Vec3", &arg0);
            if (!ok) { break; }
            bool retval = cobj->operator<(*arg0);
            mrb_value ret;
            ret = mrb_bool_value((mrb_bool)retval);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::Vec3#operator<");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Vec3_operator_gt(mrb_state* mrb, mrb_value self)
{
    cocos2d::Vec3* cobj = static_cast<cocos2d::Vec3*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Vec3_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            cocos2d::Vec3* arg0;
            ok = rubyval_to_object<cocos2d::Vec3>(mrb, argv[0], "CC::Vec3", &arg0);
            if (!ok) { break; }
            bool retval = cobj->operator>(*arg0);
            mrb_value ret;
            ret = mrb_bool_value((mrb_bool)retval);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::Vec3#operator>");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Vec3_operator_plus(mrb_state* mrb, mrb_value self)
{
    cocos2d::Vec3* cobj = static_cast<cocos2d::Vec3*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Vec3_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            cocos2d::Vec3* arg0;
            ok = rubyval_to_object<cocos2d::Vec3>(mrb, argv[0], "CC::Vec3", &arg0);
            if (!ok) { break; }
            cocos2d::Vec3 retval = cobj->operator+(*arg0);
            cocos2d::Vec3* retval_ptr = new cocos2d::Vec3(retval);
            mrb_value ret;
            ret = object_to_rubyval<cocos2d::Vec3>(mrb, "CC::Vec3", (cocos2d::Vec3*)retval_ptr, nullptr);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::Vec3#operator+");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Vec3_operator_multiply(mrb_state* mrb, mrb_value self)
{
    cocos2d::Vec3* cobj = static_cast<cocos2d::Vec3*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Vec3_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            double arg0;
            ok = rubyval_to_number(mrb, argv[0], (double*)&arg0, "CC::Vec3.operator*");
            if (!ok) { break; }
            cocos2d::Vec3 retval = cobj->operator*(arg0);
            cocos2d::Vec3* retval_ptr = new cocos2d::Vec3(retval);
            mrb_value ret;
            ret = object_to_rubyval<cocos2d::Vec3>(mrb, "CC::Vec3", (cocos2d::Vec3*)retval_ptr, nullptr);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::Vec3#operator*");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Vec3_operator_minus(mrb_state* mrb, mrb_value self)
{
    cocos2d::Vec3* cobj = static_cast<cocos2d::Vec3*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Vec3_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 0) {
            cocos2d::Vec3 retval = cobj->operator-();
            cocos2d::Vec3* retval_ptr = new cocos2d::Vec3(retval);
            mrb_value ret;
            ret = object_to_rubyval<cocos2d::Vec3>(mrb, "CC::Vec3", (cocos2d::Vec3*)retval_ptr, nullptr);
            return ret;
        }
    } while (0);
    do {
        if (argc == 1) {
            cocos2d::Vec3* arg0;
            ok = rubyval_to_object<cocos2d::Vec3>(mrb, argv[0], "CC::Vec3", &arg0);
            if (!ok) { break; }
            cocos2d::Vec3 retval = cobj->operator-(*arg0);
            cocos2d::Vec3* retval_ptr = new cocos2d::Vec3(retval);
            mrb_value ret;
            ret = object_to_rubyval<cocos2d::Vec3>(mrb, "CC::Vec3", (cocos2d::Vec3*)retval_ptr, nullptr);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::Vec3#operator-");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Vec3_operator_divide(mrb_state* mrb, mrb_value self)
{
    cocos2d::Vec3* cobj = static_cast<cocos2d::Vec3*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Vec3_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            double arg0;
            ok = rubyval_to_number(mrb, argv[0], (double*)&arg0, "CC::Vec3.operator/");
            if (!ok) { break; }
            cocos2d::Vec3 retval = cobj->operator/(arg0);
            cocos2d::Vec3* retval_ptr = new cocos2d::Vec3(retval);
            mrb_value ret;
            ret = object_to_rubyval<cocos2d::Vec3>(mrb, "CC::Vec3", (cocos2d::Vec3*)retval_ptr, nullptr);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::Vec3#operator/");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Vec3_negate(mrb_state* mrb, mrb_value self)
{
    cocos2d::Vec3* cobj = static_cast<cocos2d::Vec3*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Vec3_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            cobj->negate();
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::Vec3#negate");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Vec3_distanceSquared(mrb_state* mrb, mrb_value self)
{
    cocos2d::Vec3* cobj = static_cast<cocos2d::Vec3*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Vec3_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            cocos2d::Vec3* arg0;
            ok = rubyval_to_object<cocos2d::Vec3>(mrb, argv[0], "CC::Vec3", &arg0);
            if (!ok) { break; }
            double retval = cobj->distanceSquared(*arg0);
            mrb_value ret;
            ret = mrb_float_value(mrb, (mrb_float)retval);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::Vec3#distanceSquared");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Vec3_operator_minus_eq(mrb_state* mrb, mrb_value self)
{
    cocos2d::Vec3* cobj = static_cast<cocos2d::Vec3*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Vec3_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            cocos2d::Vec3* arg0;
            ok = rubyval_to_object<cocos2d::Vec3>(mrb, argv[0], "CC::Vec3", &arg0);
            if (!ok) { break; }
            cocos2d::Vec3 retval = cobj->operator-=(*arg0);
            cocos2d::Vec3* retval_ptr = new cocos2d::Vec3(retval);
            mrb_value ret;
            ret = object_to_rubyval<cocos2d::Vec3>(mrb, "CC::Vec3", (cocos2d::Vec3*)retval_ptr, nullptr);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::Vec3#operator-=");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Vec3_isOne(mrb_state* mrb, mrb_value self)
{
    cocos2d::Vec3* cobj = static_cast<cocos2d::Vec3*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Vec3_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            bool retval = cobj->isOne();
            mrb_value ret;
            ret = mrb_bool_value((mrb_bool)retval);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::Vec3#isOne");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Vec3_scale(mrb_state* mrb, mrb_value self)
{
    cocos2d::Vec3* cobj = static_cast<cocos2d::Vec3*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Vec3_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            double arg0;
            ok = rubyval_to_number(mrb, argv[0], (double*)&arg0, "CC::Vec3.scale");
            if (!ok) { break; }
            cobj->scale(arg0);
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::Vec3#scale");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Vec3_operator_plus_eq(mrb_state* mrb, mrb_value self)
{
    cocos2d::Vec3* cobj = static_cast<cocos2d::Vec3*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Vec3_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            cocos2d::Vec3* arg0;
            ok = rubyval_to_object<cocos2d::Vec3>(mrb, argv[0], "CC::Vec3", &arg0);
            if (!ok) { break; }
            cocos2d::Vec3 retval = cobj->operator+=(*arg0);
            cocos2d::Vec3* retval_ptr = new cocos2d::Vec3(retval);
            mrb_value ret;
            ret = object_to_rubyval<cocos2d::Vec3>(mrb, "CC::Vec3", (cocos2d::Vec3*)retval_ptr, nullptr);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::Vec3#operator+=");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Vec3_cross(mrb_state* mrb, mrb_value self)
{
    cocos2d::Vec3* cobj = static_cast<cocos2d::Vec3*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Vec3_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            cocos2d::Vec3* arg0;
            ok = rubyval_to_object<cocos2d::Vec3>(mrb, argv[0], "CC::Vec3", &arg0);
            if (!ok) { break; }
            cobj->cross(*arg0);
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::Vec3#cross");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Vec3_add(mrb_state* mrb, mrb_value self)
{
    cocos2d::Vec3* cobj = static_cast<cocos2d::Vec3*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Vec3_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            cocos2d::Vec3* arg0;
            ok = rubyval_to_object<cocos2d::Vec3>(mrb, argv[0], "CC::Vec3", &arg0);
            if (!ok) { break; }
            cobj->add(*arg0);
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::Vec3#add");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Vec3_isZero(mrb_state* mrb, mrb_value self)
{
    cocos2d::Vec3* cobj = static_cast<cocos2d::Vec3*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Vec3_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            bool retval = cobj->isZero();
            mrb_value ret;
            ret = mrb_bool_value((mrb_bool)retval);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::Vec3#isZero");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Vec3_getNormalized(mrb_state* mrb, mrb_value self)
{
    cocos2d::Vec3* cobj = static_cast<cocos2d::Vec3*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Vec3_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            cocos2d::Vec3 retval = cobj->getNormalized();
            cocos2d::Vec3* retval_ptr = new cocos2d::Vec3(retval);
            mrb_value ret;
            ret = object_to_rubyval<cocos2d::Vec3>(mrb, "CC::Vec3", (cocos2d::Vec3*)retval_ptr, nullptr);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::Vec3#getNormalized");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Vec3_normalize(mrb_state* mrb, mrb_value self)
{
    cocos2d::Vec3* cobj = static_cast<cocos2d::Vec3*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Vec3_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            cobj->normalize();
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::Vec3#normalize");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Vec3_lengthSquared(mrb_state* mrb, mrb_value self)
{
    cocos2d::Vec3* cobj = static_cast<cocos2d::Vec3*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Vec3_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            double retval = cobj->lengthSquared();
            mrb_value ret;
            ret = mrb_float_value(mrb, (mrb_float)retval);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::Vec3#lengthSquared");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Vec3_operator_not_eq(mrb_state* mrb, mrb_value self)
{
    cocos2d::Vec3* cobj = static_cast<cocos2d::Vec3*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Vec3_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            cocos2d::Vec3* arg0;
            ok = rubyval_to_object<cocos2d::Vec3>(mrb, argv[0], "CC::Vec3", &arg0);
            if (!ok) { break; }
            bool retval = cobj->operator!=(*arg0);
            mrb_value ret;
            ret = mrb_bool_value((mrb_bool)retval);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::Vec3#operator!=");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Vec3_operator_eq_eq(mrb_state* mrb, mrb_value self)
{
    cocos2d::Vec3* cobj = static_cast<cocos2d::Vec3*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Vec3_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            cocos2d::Vec3* arg0;
            ok = rubyval_to_object<cocos2d::Vec3>(mrb, argv[0], "CC::Vec3", &arg0);
            if (!ok) { break; }
            bool retval = cobj->operator==(*arg0);
            mrb_value ret;
            ret = mrb_bool_value((mrb_bool)retval);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::Vec3#operator==");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Vec3_subtract(mrb_state* mrb, mrb_value self)
{
    cocos2d::Vec3* cobj = static_cast<cocos2d::Vec3*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Vec3_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            cocos2d::Vec3* arg0;
            ok = rubyval_to_object<cocos2d::Vec3>(mrb, argv[0], "CC::Vec3", &arg0);
            if (!ok) { break; }
            cobj->subtract(*arg0);
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::Vec3#subtract");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Vec3_distance(mrb_state* mrb, mrb_value self)
{
    cocos2d::Vec3* cobj = static_cast<cocos2d::Vec3*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Vec3_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            cocos2d::Vec3* arg0;
            ok = rubyval_to_object<cocos2d::Vec3>(mrb, argv[0], "CC::Vec3", &arg0);
            if (!ok) { break; }
            double retval = cobj->distance(*arg0);
            mrb_value ret;
            ret = mrb_float_value(mrb, (mrb_float)retval);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::Vec3#distance");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Vec3_smooth(mrb_state* mrb, mrb_value self)
{
    cocos2d::Vec3* cobj = static_cast<cocos2d::Vec3*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Vec3_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 3) {
            cocos2d::Vec3* arg0;
            ok = rubyval_to_object<cocos2d::Vec3>(mrb, argv[0], "CC::Vec3", &arg0);
            if (!ok) { break; }
            double arg1;
            ok = rubyval_to_number(mrb, argv[1], (double*)&arg1, "CC::Vec3.smooth");
            if (!ok) { break; }
            double arg2;
            ok = rubyval_to_number(mrb, argv[2], (double*)&arg2, "CC::Vec3.smooth");
            if (!ok) { break; }
            cobj->smooth(*arg0, arg1, arg2);
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::Vec3#smooth");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Vec3_length(mrb_state* mrb, mrb_value self)
{
    cocos2d::Vec3* cobj = static_cast<cocos2d::Vec3*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Vec3_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            double retval = cobj->length();
            mrb_value ret;
            ret = mrb_float_value(mrb, (mrb_float)retval);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::Vec3#length");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Vec3_operator_multiply_eq(mrb_state* mrb, mrb_value self)
{
    cocos2d::Vec3* cobj = static_cast<cocos2d::Vec3*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Vec3_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            double arg0;
            ok = rubyval_to_number(mrb, argv[0], (double*)&arg0, "CC::Vec3.operator*=");
            if (!ok) { break; }
            cocos2d::Vec3 retval = cobj->operator*=(arg0);
            cocos2d::Vec3* retval_ptr = new cocos2d::Vec3(retval);
            mrb_value ret;
            ret = object_to_rubyval<cocos2d::Vec3>(mrb, "CC::Vec3", (cocos2d::Vec3*)retval_ptr, nullptr);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::Vec3#operator*=");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Vec3_dot(mrb_state* mrb, mrb_value self)
{
    cocos2d::Vec3* cobj = static_cast<cocos2d::Vec3*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Vec3_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            cocos2d::Vec3* arg0;
            ok = rubyval_to_object<cocos2d::Vec3>(mrb, argv[0], "CC::Vec3", &arg0);
            if (!ok) { break; }
            double retval = cobj->dot(*arg0);
            mrb_value ret;
            ret = mrb_float_value(mrb, (mrb_float)retval);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::Vec3#dot");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Vec3_clamp_static(mrb_state* mrb, mrb_value self)
{
    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 4) {
            cocos2d::Vec3* arg0;
            ok = rubyval_to_object<cocos2d::Vec3>(mrb, argv[0], "CC::Vec3", &arg0);
            if (!ok) { break; }

            cocos2d::Vec3* arg1;
            ok = rubyval_to_object<cocos2d::Vec3>(mrb, argv[1], "CC::Vec3", &arg1);
            if (!ok) { break; }

            cocos2d::Vec3* arg2;
            ok = rubyval_to_object<cocos2d::Vec3>(mrb, argv[2], "CC::Vec3", &arg2);
            if (!ok) { break; }

            cocos2d::Vec3* arg3;
            ok = rubyval_to_object<cocos2d::Vec3>(mrb, argv[3], "CC::Vec3", &arg3);
            if (!ok) { break; }

            cocos2d::Vec3::clamp(*arg0, *arg1, *arg2, arg3);
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined static method : cocos2d::Vec3#clamp");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Vec3_angle_static(mrb_state* mrb, mrb_value self)
{
    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 2) {
            cocos2d::Vec3* arg0;
            ok = rubyval_to_object<cocos2d::Vec3>(mrb, argv[0], "CC::Vec3", &arg0);
            if (!ok) { break; }

            cocos2d::Vec3* arg1;
            ok = rubyval_to_object<cocos2d::Vec3>(mrb, argv[1], "CC::Vec3", &arg1);
            if (!ok) { break; }

            double retval = cocos2d::Vec3::angle(*arg0, *arg1);
            mrb_value ret;
            ret = mrb_float_value(mrb, (mrb_float)retval);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined static method : cocos2d::Vec3#angle");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Vec3_cross_static(mrb_state* mrb, mrb_value self)
{
    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 3) {
            cocos2d::Vec3* arg0;
            ok = rubyval_to_object<cocos2d::Vec3>(mrb, argv[0], "CC::Vec3", &arg0);
            if (!ok) { break; }

            cocos2d::Vec3* arg1;
            ok = rubyval_to_object<cocos2d::Vec3>(mrb, argv[1], "CC::Vec3", &arg1);
            if (!ok) { break; }

            cocos2d::Vec3* arg2;
            ok = rubyval_to_object<cocos2d::Vec3>(mrb, argv[2], "CC::Vec3", &arg2);
            if (!ok) { break; }

            cocos2d::Vec3::cross(*arg0, *arg1, arg2);
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined static method : cocos2d::Vec3#cross");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Vec3_add_static(mrb_state* mrb, mrb_value self)
{
    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 3) {
            cocos2d::Vec3* arg0;
            ok = rubyval_to_object<cocos2d::Vec3>(mrb, argv[0], "CC::Vec3", &arg0);
            if (!ok) { break; }

            cocos2d::Vec3* arg1;
            ok = rubyval_to_object<cocos2d::Vec3>(mrb, argv[1], "CC::Vec3", &arg1);
            if (!ok) { break; }

            cocos2d::Vec3* arg2;
            ok = rubyval_to_object<cocos2d::Vec3>(mrb, argv[2], "CC::Vec3", &arg2);
            if (!ok) { break; }

            cocos2d::Vec3::add(*arg0, *arg1, arg2);
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined static method : cocos2d::Vec3#add");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Vec3_fromColor_static(mrb_state* mrb, mrb_value self)
{
    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            unsigned int arg0;
            ok = rubyval_to_uint32(mrb, argv[0], &arg0, "CC::Vec3.fromColor");
            if (!ok) { break; }

            cocos2d::Vec3 retval = cocos2d::Vec3::fromColor(arg0);
            cocos2d::Vec3* retval_ptr = new cocos2d::Vec3(retval);
            mrb_value ret;
            ret = object_to_rubyval<cocos2d::Vec3>(mrb, "CC::Vec3", (cocos2d::Vec3*)retval_ptr, nullptr);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined static method : cocos2d::Vec3#fromColor");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Vec3_subtract_static(mrb_state* mrb, mrb_value self)
{
    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 3) {
            cocos2d::Vec3* arg0;
            ok = rubyval_to_object<cocos2d::Vec3>(mrb, argv[0], "CC::Vec3", &arg0);
            if (!ok) { break; }

            cocos2d::Vec3* arg1;
            ok = rubyval_to_object<cocos2d::Vec3>(mrb, argv[1], "CC::Vec3", &arg1);
            if (!ok) { break; }

            cocos2d::Vec3* arg2;
            ok = rubyval_to_object<cocos2d::Vec3>(mrb, argv[2], "CC::Vec3", &arg2);
            if (!ok) { break; }

            cocos2d::Vec3::subtract(*arg0, *arg1, arg2);
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined static method : cocos2d::Vec3#subtract");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Vec3_dot_static(mrb_state* mrb, mrb_value self)
{
    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 2) {
            cocos2d::Vec3* arg0;
            ok = rubyval_to_object<cocos2d::Vec3>(mrb, argv[0], "CC::Vec3", &arg0);
            if (!ok) { break; }

            cocos2d::Vec3* arg1;
            ok = rubyval_to_object<cocos2d::Vec3>(mrb, argv[1], "CC::Vec3", &arg1);
            if (!ok) { break; }

            double retval = cocos2d::Vec3::dot(*arg0, *arg1);
            mrb_value ret;
            ret = mrb_float_value(mrb, (mrb_float)retval);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined static method : cocos2d::Vec3#dot");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Vec3_property_x_get(mrb_state* mrb, mrb_value self)
{
    cocos2d::Vec3* cobj = static_cast<cocos2d::Vec3*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Vec3_type));

    mrb_value ret;
    ret = mrb_float_value(mrb, (mrb_float)cobj->x);
    return ret;
}

mrb_value ruby_cocos2dx_Vec3_property_x_set(mrb_state* mrb, mrb_value self)
{
    cocos2d::Vec3* cobj = static_cast<cocos2d::Vec3*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Vec3_type));

    mrb_value argv;
    mrb_get_args(mrb, "o", &argv);

    bool ok = true;
    double val;
    ok = rubyval_to_number(mrb, argv, (double*)&val, "CC::Vec3.x");
    if (! ok) {
        mrb_raise(mrb, E_RUNTIME_ERROR, "convert to native failed : Vec3#x");
    }
    cobj->x = val;

    return self;
}

mrb_value ruby_cocos2dx_Vec3_property_y_get(mrb_state* mrb, mrb_value self)
{
    cocos2d::Vec3* cobj = static_cast<cocos2d::Vec3*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Vec3_type));

    mrb_value ret;
    ret = mrb_float_value(mrb, (mrb_float)cobj->y);
    return ret;
}

mrb_value ruby_cocos2dx_Vec3_property_y_set(mrb_state* mrb, mrb_value self)
{
    cocos2d::Vec3* cobj = static_cast<cocos2d::Vec3*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Vec3_type));

    mrb_value argv;
    mrb_get_args(mrb, "o", &argv);

    bool ok = true;
    double val;
    ok = rubyval_to_number(mrb, argv, (double*)&val, "CC::Vec3.y");
    if (! ok) {
        mrb_raise(mrb, E_RUNTIME_ERROR, "convert to native failed : Vec3#y");
    }
    cobj->y = val;

    return self;
}

mrb_value ruby_cocos2dx_Vec3_property_z_get(mrb_state* mrb, mrb_value self)
{
    cocos2d::Vec3* cobj = static_cast<cocos2d::Vec3*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Vec3_type));

    mrb_value ret;
    ret = mrb_float_value(mrb, (mrb_float)cobj->z);
    return ret;
}

mrb_value ruby_cocos2dx_Vec3_property_z_set(mrb_state* mrb, mrb_value self)
{
    cocos2d::Vec3* cobj = static_cast<cocos2d::Vec3*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Vec3_type));

    mrb_value argv;
    mrb_get_args(mrb, "o", &argv);

    bool ok = true;
    double val;
    ok = rubyval_to_number(mrb, argv, (double*)&val, "CC::Vec3.z");
    if (! ok) {
        mrb_raise(mrb, E_RUNTIME_ERROR, "convert to native failed : Vec3#z");
    }
    cobj->z = val;

    return self;
}

mrb_value ruby_cocos2dx_Vec3_constructor(mrb_state* mrb, mrb_value self)
{

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 3) {
            double arg0;
            ok = rubyval_to_number(mrb, argv[0], (double*)&arg0, "CC::Vec3.Vec3");
            if (!ok) { break; }
            double arg1;
            ok = rubyval_to_number(mrb, argv[1], (double*)&arg1, "CC::Vec3.Vec3");
            if (!ok) { break; }
            double arg2;
            ok = rubyval_to_number(mrb, argv[2], (double*)&arg2, "CC::Vec3.Vec3");
            if (!ok) { break; }
            cocos2d::Vec3* cobj = new cocos2d::Vec3(arg0, arg1, arg2);
            DATA_TYPE(self) = &ruby_cocos2dx_Vec3_type;
            DATA_PTR(self) = cobj;
            return self;
        }
    } while (0);
    do {
        if (argc == 0) {
            cocos2d::Vec3* cobj = new cocos2d::Vec3();
            DATA_TYPE(self) = &ruby_cocos2dx_Vec3_type;
            DATA_PTR(self) = cobj;
            return self;
        }
    } while (0);
    do {
        if (argc == 1) {
            float* arg0;
            ok = rubyval_to_carray_float(mrb, argv[0], &arg0, "CC::Vec3.Vec3");
            if (!ok) { break; }
            cocos2d::Vec3* cobj = new cocos2d::Vec3(arg0);
            DATA_TYPE(self) = &ruby_cocos2dx_Vec3_type;
            DATA_PTR(self) = cobj;
            return self;
        }
    } while (0);
    do {
        if (argc == 2) {
            cocos2d::Vec3* arg0;
            ok = rubyval_to_object<cocos2d::Vec3>(mrb, argv[0], "CC::Vec3", &arg0);
            if (!ok) { break; }
            cocos2d::Vec3* arg1;
            ok = rubyval_to_object<cocos2d::Vec3>(mrb, argv[1], "CC::Vec3", &arg1);
            if (!ok) { break; }
            cocos2d::Vec3* cobj = new cocos2d::Vec3(*arg0, *arg1);
            DATA_TYPE(self) = &ruby_cocos2dx_Vec3_type;
            DATA_PTR(self) = cobj;
            return self;
        }
    } while (0);
    do {
        if (argc == 1) {
            cocos2d::Vec3* arg0;
            ok = rubyval_to_object<cocos2d::Vec3>(mrb, argv[0], "CC::Vec3", &arg0);
            if (!ok) { break; }
            cocos2d::Vec3* cobj = new cocos2d::Vec3(*arg0);
            DATA_TYPE(self) = &ruby_cocos2dx_Vec3_type;
            DATA_PTR(self) = cobj;
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::Vec3#Vec3");

    return mrb_nil_value();
}


void ruby_cocos2dx_Vec3_constants_init(mrb_state* mrb, struct RClass* rclass)
{
    do {
        cocos2d::Vec3* retval_ptr = new cocos2d::Vec3(cocos2d::Vec3::ZERO);
        mrb_value ret;
        ret = object_to_rubyval<cocos2d::Vec3>(mrb, "CC::Vec3", (cocos2d::Vec3*)retval_ptr, nullptr);
        mrb_mod_cv_set(mrb, rclass, mrb_intern_cstr(mrb, "ZERO"), ret);
    } while (0);

    do {
        cocos2d::Vec3* retval_ptr = new cocos2d::Vec3(cocos2d::Vec3::ONE);
        mrb_value ret;
        ret = object_to_rubyval<cocos2d::Vec3>(mrb, "CC::Vec3", (cocos2d::Vec3*)retval_ptr, nullptr);
        mrb_mod_cv_set(mrb, rclass, mrb_intern_cstr(mrb, "ONE"), ret);
    } while (0);

    do {
        cocos2d::Vec3* retval_ptr = new cocos2d::Vec3(cocos2d::Vec3::UNIT_X);
        mrb_value ret;
        ret = object_to_rubyval<cocos2d::Vec3>(mrb, "CC::Vec3", (cocos2d::Vec3*)retval_ptr, nullptr);
        mrb_mod_cv_set(mrb, rclass, mrb_intern_cstr(mrb, "UNIT_X"), ret);
    } while (0);

    do {
        cocos2d::Vec3* retval_ptr = new cocos2d::Vec3(cocos2d::Vec3::UNIT_Y);
        mrb_value ret;
        ret = object_to_rubyval<cocos2d::Vec3>(mrb, "CC::Vec3", (cocos2d::Vec3*)retval_ptr, nullptr);
        mrb_mod_cv_set(mrb, rclass, mrb_intern_cstr(mrb, "UNIT_Y"), ret);
    } while (0);

    do {
        cocos2d::Vec3* retval_ptr = new cocos2d::Vec3(cocos2d::Vec3::UNIT_Z);
        mrb_value ret;
        ret = object_to_rubyval<cocos2d::Vec3>(mrb, "CC::Vec3", (cocos2d::Vec3*)retval_ptr, nullptr);
        mrb_mod_cv_set(mrb, rclass, mrb_intern_cstr(mrb, "UNIT_Z"), ret);
    } while (0);

}

void ruby_register_cocos2dx_Vec3(mrb_state* mrb, struct RClass* rmodule)
{
    std::string typeName = typeid(cocos2d::Vec3).name();
    g_rubyType[typeName] = "CC::Vec3";
    g_rubyDataType[typeName] = &ruby_cocos2dx_Vec3_type;

    struct RClass *rclass = mrb_define_class_under(mrb, rmodule, "Vec3", mrb->object_class);
    MRB_SET_INSTANCE_TT(rclass, MRB_TT_DATA);

    mrb_define_method(mrb, rclass, "initialize", ruby_cocos2dx_Vec3_constructor, ARGS_REQ(0)|ARGS_OPT(3));
    mrb_define_method(mrb, rclass, "clamp", ruby_cocos2dx_Vec3_clamp, ARGS_REQ(2));
    mrb_define_method(mrb, rclass, "set", ruby_cocos2dx_Vec3_set, ARGS_REQ(1)|ARGS_OPT(2));
    mrb_define_method(mrb, rclass, "<", ruby_cocos2dx_Vec3_operator_lt, ARGS_REQ(1));
    mrb_define_method(mrb, rclass, ">", ruby_cocos2dx_Vec3_operator_gt, ARGS_REQ(1));
    mrb_define_method(mrb, rclass, "+", ruby_cocos2dx_Vec3_operator_plus, ARGS_REQ(1));
    mrb_define_method(mrb, rclass, "*", ruby_cocos2dx_Vec3_operator_multiply, ARGS_REQ(1));
    mrb_define_method(mrb, rclass, "-", ruby_cocos2dx_Vec3_operator_minus, ARGS_REQ(0)|ARGS_OPT(1));
    mrb_define_method(mrb, rclass, "/", ruby_cocos2dx_Vec3_operator_divide, ARGS_REQ(1));
    mrb_define_method(mrb, rclass, "negate", ruby_cocos2dx_Vec3_negate, ARGS_NONE());
    mrb_define_method(mrb, rclass, "distance_squared", ruby_cocos2dx_Vec3_distanceSquared, ARGS_REQ(1));
    mrb_define_method(mrb, rclass, "-=", ruby_cocos2dx_Vec3_operator_minus_eq, ARGS_REQ(1));
    mrb_define_method(mrb, rclass, "one?", ruby_cocos2dx_Vec3_isOne, ARGS_NONE());
    mrb_define_method(mrb, rclass, "scale", ruby_cocos2dx_Vec3_scale, ARGS_REQ(1));
    mrb_define_method(mrb, rclass, "+=", ruby_cocos2dx_Vec3_operator_plus_eq, ARGS_REQ(1));
    mrb_define_method(mrb, rclass, "cross", ruby_cocos2dx_Vec3_cross, ARGS_REQ(1));
    mrb_define_method(mrb, rclass, "add", ruby_cocos2dx_Vec3_add, ARGS_REQ(1));
    mrb_define_method(mrb, rclass, "zero?", ruby_cocos2dx_Vec3_isZero, ARGS_NONE());
    mrb_define_method(mrb, rclass, "get_normalized", ruby_cocos2dx_Vec3_getNormalized, ARGS_NONE());
    mrb_define_method(mrb, rclass, "normalize", ruby_cocos2dx_Vec3_normalize, ARGS_NONE());
    mrb_define_method(mrb, rclass, "length_squared", ruby_cocos2dx_Vec3_lengthSquared, ARGS_NONE());
    mrb_define_method(mrb, rclass, "!=", ruby_cocos2dx_Vec3_operator_not_eq, ARGS_REQ(1));
    mrb_define_method(mrb, rclass, "==", ruby_cocos2dx_Vec3_operator_eq_eq, ARGS_REQ(1));
    mrb_define_method(mrb, rclass, "subtract", ruby_cocos2dx_Vec3_subtract, ARGS_REQ(1));
    mrb_define_method(mrb, rclass, "distance", ruby_cocos2dx_Vec3_distance, ARGS_REQ(1));
    mrb_define_method(mrb, rclass, "smooth", ruby_cocos2dx_Vec3_smooth, ARGS_REQ(3));
    mrb_define_method(mrb, rclass, "length", ruby_cocos2dx_Vec3_length, ARGS_NONE());
    mrb_define_method(mrb, rclass, "*=", ruby_cocos2dx_Vec3_operator_multiply_eq, ARGS_REQ(1));
    mrb_define_method(mrb, rclass, "dot", ruby_cocos2dx_Vec3_dot, ARGS_REQ(1));
    mrb_define_class_method(mrb, rclass, "clamp", ruby_cocos2dx_Vec3_clamp_static, ARGS_REQ(4));
    mrb_define_class_method(mrb, rclass, "angle", ruby_cocos2dx_Vec3_angle_static, ARGS_REQ(2));
    mrb_define_class_method(mrb, rclass, "cross", ruby_cocos2dx_Vec3_cross_static, ARGS_REQ(3));
    mrb_define_class_method(mrb, rclass, "add", ruby_cocos2dx_Vec3_add_static, ARGS_REQ(3));
    mrb_define_class_method(mrb, rclass, "from_color", ruby_cocos2dx_Vec3_fromColor_static, ARGS_REQ(1));
    mrb_define_class_method(mrb, rclass, "subtract", ruby_cocos2dx_Vec3_subtract_static, ARGS_REQ(3));
    mrb_define_class_method(mrb, rclass, "dot", ruby_cocos2dx_Vec3_dot_static, ARGS_REQ(2));
    mrb_define_method(mrb, rclass, "x", ruby_cocos2dx_Vec3_property_x_get, ARGS_NONE());
    mrb_define_method(mrb, rclass, "x=", ruby_cocos2dx_Vec3_property_x_set, ARGS_REQ(1));
    mrb_define_method(mrb, rclass, "y", ruby_cocos2dx_Vec3_property_y_get, ARGS_NONE());
    mrb_define_method(mrb, rclass, "y=", ruby_cocos2dx_Vec3_property_y_set, ARGS_REQ(1));
    mrb_define_method(mrb, rclass, "z", ruby_cocos2dx_Vec3_property_z_get, ARGS_NONE());
    mrb_define_method(mrb, rclass, "z=", ruby_cocos2dx_Vec3_property_z_set, ARGS_REQ(1));
    ruby_cocos2dx_Vec3_constants_init(mrb, rclass);
    mrb_define_class_method(mrb, rclass, "ZERO", ruby_cocos2dx_constant_get, ARGS_NONE());
    mrb_define_class_method(mrb, rclass, "ONE", ruby_cocos2dx_constant_get, ARGS_NONE());
    mrb_define_class_method(mrb, rclass, "UNIT_X", ruby_cocos2dx_constant_get, ARGS_NONE());
    mrb_define_class_method(mrb, rclass, "UNIT_Y", ruby_cocos2dx_constant_get, ARGS_NONE());
    mrb_define_class_method(mrb, rclass, "UNIT_Z", ruby_cocos2dx_constant_get, ARGS_NONE());
}
mrb_value ruby_cocos2dx_Vec4_clamp(mrb_state* mrb, mrb_value self)
{
    cocos2d::Vec4* cobj = static_cast<cocos2d::Vec4*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Vec4_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 2) {
            cocos2d::Vec4* arg0;
            ok = rubyval_to_object<cocos2d::Vec4>(mrb, argv[0], "CC::Vec4", &arg0);
            if (!ok) { break; }
            cocos2d::Vec4* arg1;
            ok = rubyval_to_object<cocos2d::Vec4>(mrb, argv[1], "CC::Vec4", &arg1);
            if (!ok) { break; }
            cobj->clamp(*arg0, *arg1);
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::Vec4#clamp");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Vec4_set(mrb_state* mrb, mrb_value self)
{
    cocos2d::Vec4* cobj = static_cast<cocos2d::Vec4*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Vec4_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            float* arg0;
            ok = rubyval_to_carray_float(mrb, argv[0], &arg0, "CC::Vec4.set");
            if (!ok) { break; }
            cobj->set(arg0);
            return self;
        }
    } while (0);
    do {
        if (argc == 4) {
            double arg0;
            ok = rubyval_to_number(mrb, argv[0], (double*)&arg0, "CC::Vec4.set");
            if (!ok) { break; }
            double arg1;
            ok = rubyval_to_number(mrb, argv[1], (double*)&arg1, "CC::Vec4.set");
            if (!ok) { break; }
            double arg2;
            ok = rubyval_to_number(mrb, argv[2], (double*)&arg2, "CC::Vec4.set");
            if (!ok) { break; }
            double arg3;
            ok = rubyval_to_number(mrb, argv[3], (double*)&arg3, "CC::Vec4.set");
            if (!ok) { break; }
            cobj->set(arg0, arg1, arg2, arg3);
            return self;
        }
    } while (0);
    do {
        if (argc == 1) {
            cocos2d::Vec4* arg0;
            ok = rubyval_to_object<cocos2d::Vec4>(mrb, argv[0], "CC::Vec4", &arg0);
            if (!ok) { break; }
            cobj->set(*arg0);
            return self;
        }
    } while (0);
    do {
        if (argc == 2) {
            cocos2d::Vec4* arg0;
            ok = rubyval_to_object<cocos2d::Vec4>(mrb, argv[0], "CC::Vec4", &arg0);
            if (!ok) { break; }
            cocos2d::Vec4* arg1;
            ok = rubyval_to_object<cocos2d::Vec4>(mrb, argv[1], "CC::Vec4", &arg1);
            if (!ok) { break; }
            cobj->set(*arg0, *arg1);
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::Vec4#set");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Vec4_operator_lt(mrb_state* mrb, mrb_value self)
{
    cocos2d::Vec4* cobj = static_cast<cocos2d::Vec4*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Vec4_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            cocos2d::Vec4* arg0;
            ok = rubyval_to_object<cocos2d::Vec4>(mrb, argv[0], "CC::Vec4", &arg0);
            if (!ok) { break; }
            bool retval = cobj->operator<(*arg0);
            mrb_value ret;
            ret = mrb_bool_value((mrb_bool)retval);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::Vec4#operator<");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Vec4_operator_plus(mrb_state* mrb, mrb_value self)
{
    cocos2d::Vec4* cobj = static_cast<cocos2d::Vec4*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Vec4_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            cocos2d::Vec4* arg0;
            ok = rubyval_to_object<cocos2d::Vec4>(mrb, argv[0], "CC::Vec4", &arg0);
            if (!ok) { break; }
            cocos2d::Vec4 retval = cobj->operator+(*arg0);
            cocos2d::Vec4* retval_ptr = new cocos2d::Vec4(retval);
            mrb_value ret;
            ret = object_to_rubyval<cocos2d::Vec4>(mrb, "CC::Vec4", (cocos2d::Vec4*)retval_ptr, nullptr);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::Vec4#operator+");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Vec4_operator_multiply(mrb_state* mrb, mrb_value self)
{
    cocos2d::Vec4* cobj = static_cast<cocos2d::Vec4*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Vec4_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            double arg0;
            ok = rubyval_to_number(mrb, argv[0], (double*)&arg0, "CC::Vec4.operator*");
            if (!ok) { break; }
            cocos2d::Vec4 retval = cobj->operator*(arg0);
            cocos2d::Vec4* retval_ptr = new cocos2d::Vec4(retval);
            mrb_value ret;
            ret = object_to_rubyval<cocos2d::Vec4>(mrb, "CC::Vec4", (cocos2d::Vec4*)retval_ptr, nullptr);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::Vec4#operator*");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Vec4_operator_minus(mrb_state* mrb, mrb_value self)
{
    cocos2d::Vec4* cobj = static_cast<cocos2d::Vec4*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Vec4_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 0) {
            cocos2d::Vec4 retval = cobj->operator-();
            cocos2d::Vec4* retval_ptr = new cocos2d::Vec4(retval);
            mrb_value ret;
            ret = object_to_rubyval<cocos2d::Vec4>(mrb, "CC::Vec4", (cocos2d::Vec4*)retval_ptr, nullptr);
            return ret;
        }
    } while (0);
    do {
        if (argc == 1) {
            cocos2d::Vec4* arg0;
            ok = rubyval_to_object<cocos2d::Vec4>(mrb, argv[0], "CC::Vec4", &arg0);
            if (!ok) { break; }
            cocos2d::Vec4 retval = cobj->operator-(*arg0);
            cocos2d::Vec4* retval_ptr = new cocos2d::Vec4(retval);
            mrb_value ret;
            ret = object_to_rubyval<cocos2d::Vec4>(mrb, "CC::Vec4", (cocos2d::Vec4*)retval_ptr, nullptr);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::Vec4#operator-");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Vec4_operator_divide(mrb_state* mrb, mrb_value self)
{
    cocos2d::Vec4* cobj = static_cast<cocos2d::Vec4*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Vec4_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            double arg0;
            ok = rubyval_to_number(mrb, argv[0], (double*)&arg0, "CC::Vec4.operator/");
            if (!ok) { break; }
            cocos2d::Vec4 retval = cobj->operator/(arg0);
            cocos2d::Vec4* retval_ptr = new cocos2d::Vec4(retval);
            mrb_value ret;
            ret = object_to_rubyval<cocos2d::Vec4>(mrb, "CC::Vec4", (cocos2d::Vec4*)retval_ptr, nullptr);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::Vec4#operator/");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Vec4_negate(mrb_state* mrb, mrb_value self)
{
    cocos2d::Vec4* cobj = static_cast<cocos2d::Vec4*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Vec4_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            cobj->negate();
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::Vec4#negate");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Vec4_distanceSquared(mrb_state* mrb, mrb_value self)
{
    cocos2d::Vec4* cobj = static_cast<cocos2d::Vec4*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Vec4_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            cocos2d::Vec4* arg0;
            ok = rubyval_to_object<cocos2d::Vec4>(mrb, argv[0], "CC::Vec4", &arg0);
            if (!ok) { break; }
            double retval = cobj->distanceSquared(*arg0);
            mrb_value ret;
            ret = mrb_float_value(mrb, (mrb_float)retval);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::Vec4#distanceSquared");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Vec4_operator_minus_eq(mrb_state* mrb, mrb_value self)
{
    cocos2d::Vec4* cobj = static_cast<cocos2d::Vec4*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Vec4_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            cocos2d::Vec4* arg0;
            ok = rubyval_to_object<cocos2d::Vec4>(mrb, argv[0], "CC::Vec4", &arg0);
            if (!ok) { break; }
            cocos2d::Vec4 retval = cobj->operator-=(*arg0);
            cocos2d::Vec4* retval_ptr = new cocos2d::Vec4(retval);
            mrb_value ret;
            ret = object_to_rubyval<cocos2d::Vec4>(mrb, "CC::Vec4", (cocos2d::Vec4*)retval_ptr, nullptr);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::Vec4#operator-=");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Vec4_isOne(mrb_state* mrb, mrb_value self)
{
    cocos2d::Vec4* cobj = static_cast<cocos2d::Vec4*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Vec4_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            bool retval = cobj->isOne();
            mrb_value ret;
            ret = mrb_bool_value((mrb_bool)retval);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::Vec4#isOne");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Vec4_scale(mrb_state* mrb, mrb_value self)
{
    cocos2d::Vec4* cobj = static_cast<cocos2d::Vec4*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Vec4_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            double arg0;
            ok = rubyval_to_number(mrb, argv[0], (double*)&arg0, "CC::Vec4.scale");
            if (!ok) { break; }
            cobj->scale(arg0);
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::Vec4#scale");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Vec4_operator_plus_eq(mrb_state* mrb, mrb_value self)
{
    cocos2d::Vec4* cobj = static_cast<cocos2d::Vec4*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Vec4_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            cocos2d::Vec4* arg0;
            ok = rubyval_to_object<cocos2d::Vec4>(mrb, argv[0], "CC::Vec4", &arg0);
            if (!ok) { break; }
            cocos2d::Vec4 retval = cobj->operator+=(*arg0);
            cocos2d::Vec4* retval_ptr = new cocos2d::Vec4(retval);
            mrb_value ret;
            ret = object_to_rubyval<cocos2d::Vec4>(mrb, "CC::Vec4", (cocos2d::Vec4*)retval_ptr, nullptr);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::Vec4#operator+=");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Vec4_add(mrb_state* mrb, mrb_value self)
{
    cocos2d::Vec4* cobj = static_cast<cocos2d::Vec4*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Vec4_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            cocos2d::Vec4* arg0;
            ok = rubyval_to_object<cocos2d::Vec4>(mrb, argv[0], "CC::Vec4", &arg0);
            if (!ok) { break; }
            cobj->add(*arg0);
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::Vec4#add");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Vec4_isZero(mrb_state* mrb, mrb_value self)
{
    cocos2d::Vec4* cobj = static_cast<cocos2d::Vec4*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Vec4_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            bool retval = cobj->isZero();
            mrb_value ret;
            ret = mrb_bool_value((mrb_bool)retval);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::Vec4#isZero");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Vec4_getNormalized(mrb_state* mrb, mrb_value self)
{
    cocos2d::Vec4* cobj = static_cast<cocos2d::Vec4*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Vec4_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            cocos2d::Vec4 retval = cobj->getNormalized();
            cocos2d::Vec4* retval_ptr = new cocos2d::Vec4(retval);
            mrb_value ret;
            ret = object_to_rubyval<cocos2d::Vec4>(mrb, "CC::Vec4", (cocos2d::Vec4*)retval_ptr, nullptr);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::Vec4#getNormalized");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Vec4_normalize(mrb_state* mrb, mrb_value self)
{
    cocos2d::Vec4* cobj = static_cast<cocos2d::Vec4*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Vec4_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            cobj->normalize();
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::Vec4#normalize");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Vec4_lengthSquared(mrb_state* mrb, mrb_value self)
{
    cocos2d::Vec4* cobj = static_cast<cocos2d::Vec4*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Vec4_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            double retval = cobj->lengthSquared();
            mrb_value ret;
            ret = mrb_float_value(mrb, (mrb_float)retval);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::Vec4#lengthSquared");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Vec4_operator_not_eq(mrb_state* mrb, mrb_value self)
{
    cocos2d::Vec4* cobj = static_cast<cocos2d::Vec4*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Vec4_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            cocos2d::Vec4* arg0;
            ok = rubyval_to_object<cocos2d::Vec4>(mrb, argv[0], "CC::Vec4", &arg0);
            if (!ok) { break; }
            bool retval = cobj->operator!=(*arg0);
            mrb_value ret;
            ret = mrb_bool_value((mrb_bool)retval);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::Vec4#operator!=");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Vec4_operator_eq_eq(mrb_state* mrb, mrb_value self)
{
    cocos2d::Vec4* cobj = static_cast<cocos2d::Vec4*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Vec4_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            cocos2d::Vec4* arg0;
            ok = rubyval_to_object<cocos2d::Vec4>(mrb, argv[0], "CC::Vec4", &arg0);
            if (!ok) { break; }
            bool retval = cobj->operator==(*arg0);
            mrb_value ret;
            ret = mrb_bool_value((mrb_bool)retval);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::Vec4#operator==");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Vec4_subtract(mrb_state* mrb, mrb_value self)
{
    cocos2d::Vec4* cobj = static_cast<cocos2d::Vec4*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Vec4_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            cocos2d::Vec4* arg0;
            ok = rubyval_to_object<cocos2d::Vec4>(mrb, argv[0], "CC::Vec4", &arg0);
            if (!ok) { break; }
            cobj->subtract(*arg0);
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::Vec4#subtract");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Vec4_distance(mrb_state* mrb, mrb_value self)
{
    cocos2d::Vec4* cobj = static_cast<cocos2d::Vec4*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Vec4_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            cocos2d::Vec4* arg0;
            ok = rubyval_to_object<cocos2d::Vec4>(mrb, argv[0], "CC::Vec4", &arg0);
            if (!ok) { break; }
            double retval = cobj->distance(*arg0);
            mrb_value ret;
            ret = mrb_float_value(mrb, (mrb_float)retval);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::Vec4#distance");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Vec4_length(mrb_state* mrb, mrb_value self)
{
    cocos2d::Vec4* cobj = static_cast<cocos2d::Vec4*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Vec4_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            double retval = cobj->length();
            mrb_value ret;
            ret = mrb_float_value(mrb, (mrb_float)retval);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::Vec4#length");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Vec4_operator_multiply_eq(mrb_state* mrb, mrb_value self)
{
    cocos2d::Vec4* cobj = static_cast<cocos2d::Vec4*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Vec4_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            double arg0;
            ok = rubyval_to_number(mrb, argv[0], (double*)&arg0, "CC::Vec4.operator*=");
            if (!ok) { break; }
            cocos2d::Vec4 retval = cobj->operator*=(arg0);
            cocos2d::Vec4* retval_ptr = new cocos2d::Vec4(retval);
            mrb_value ret;
            ret = object_to_rubyval<cocos2d::Vec4>(mrb, "CC::Vec4", (cocos2d::Vec4*)retval_ptr, nullptr);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::Vec4#operator*=");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Vec4_dot(mrb_state* mrb, mrb_value self)
{
    cocos2d::Vec4* cobj = static_cast<cocos2d::Vec4*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Vec4_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            cocos2d::Vec4* arg0;
            ok = rubyval_to_object<cocos2d::Vec4>(mrb, argv[0], "CC::Vec4", &arg0);
            if (!ok) { break; }
            double retval = cobj->dot(*arg0);
            mrb_value ret;
            ret = mrb_float_value(mrb, (mrb_float)retval);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::Vec4#dot");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Vec4_clamp_static(mrb_state* mrb, mrb_value self)
{
    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 4) {
            cocos2d::Vec4* arg0;
            ok = rubyval_to_object<cocos2d::Vec4>(mrb, argv[0], "CC::Vec4", &arg0);
            if (!ok) { break; }

            cocos2d::Vec4* arg1;
            ok = rubyval_to_object<cocos2d::Vec4>(mrb, argv[1], "CC::Vec4", &arg1);
            if (!ok) { break; }

            cocos2d::Vec4* arg2;
            ok = rubyval_to_object<cocos2d::Vec4>(mrb, argv[2], "CC::Vec4", &arg2);
            if (!ok) { break; }

            cocos2d::Vec4* arg3;
            ok = rubyval_to_object<cocos2d::Vec4>(mrb, argv[3], "CC::Vec4", &arg3);
            if (!ok) { break; }

            cocos2d::Vec4::clamp(*arg0, *arg1, *arg2, arg3);
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined static method : cocos2d::Vec4#clamp");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Vec4_angle_static(mrb_state* mrb, mrb_value self)
{
    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 2) {
            cocos2d::Vec4* arg0;
            ok = rubyval_to_object<cocos2d::Vec4>(mrb, argv[0], "CC::Vec4", &arg0);
            if (!ok) { break; }

            cocos2d::Vec4* arg1;
            ok = rubyval_to_object<cocos2d::Vec4>(mrb, argv[1], "CC::Vec4", &arg1);
            if (!ok) { break; }

            double retval = cocos2d::Vec4::angle(*arg0, *arg1);
            mrb_value ret;
            ret = mrb_float_value(mrb, (mrb_float)retval);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined static method : cocos2d::Vec4#angle");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Vec4_add_static(mrb_state* mrb, mrb_value self)
{
    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 3) {
            cocos2d::Vec4* arg0;
            ok = rubyval_to_object<cocos2d::Vec4>(mrb, argv[0], "CC::Vec4", &arg0);
            if (!ok) { break; }

            cocos2d::Vec4* arg1;
            ok = rubyval_to_object<cocos2d::Vec4>(mrb, argv[1], "CC::Vec4", &arg1);
            if (!ok) { break; }

            cocos2d::Vec4* arg2;
            ok = rubyval_to_object<cocos2d::Vec4>(mrb, argv[2], "CC::Vec4", &arg2);
            if (!ok) { break; }

            cocos2d::Vec4::add(*arg0, *arg1, arg2);
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined static method : cocos2d::Vec4#add");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Vec4_fromColor_static(mrb_state* mrb, mrb_value self)
{
    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            unsigned int arg0;
            ok = rubyval_to_uint32(mrb, argv[0], &arg0, "CC::Vec4.fromColor");
            if (!ok) { break; }

            cocos2d::Vec4 retval = cocos2d::Vec4::fromColor(arg0);
            cocos2d::Vec4* retval_ptr = new cocos2d::Vec4(retval);
            mrb_value ret;
            ret = object_to_rubyval<cocos2d::Vec4>(mrb, "CC::Vec4", (cocos2d::Vec4*)retval_ptr, nullptr);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined static method : cocos2d::Vec4#fromColor");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Vec4_subtract_static(mrb_state* mrb, mrb_value self)
{
    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 3) {
            cocos2d::Vec4* arg0;
            ok = rubyval_to_object<cocos2d::Vec4>(mrb, argv[0], "CC::Vec4", &arg0);
            if (!ok) { break; }

            cocos2d::Vec4* arg1;
            ok = rubyval_to_object<cocos2d::Vec4>(mrb, argv[1], "CC::Vec4", &arg1);
            if (!ok) { break; }

            cocos2d::Vec4* arg2;
            ok = rubyval_to_object<cocos2d::Vec4>(mrb, argv[2], "CC::Vec4", &arg2);
            if (!ok) { break; }

            cocos2d::Vec4::subtract(*arg0, *arg1, arg2);
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined static method : cocos2d::Vec4#subtract");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Vec4_dot_static(mrb_state* mrb, mrb_value self)
{
    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 2) {
            cocos2d::Vec4* arg0;
            ok = rubyval_to_object<cocos2d::Vec4>(mrb, argv[0], "CC::Vec4", &arg0);
            if (!ok) { break; }

            cocos2d::Vec4* arg1;
            ok = rubyval_to_object<cocos2d::Vec4>(mrb, argv[1], "CC::Vec4", &arg1);
            if (!ok) { break; }

            double retval = cocos2d::Vec4::dot(*arg0, *arg1);
            mrb_value ret;
            ret = mrb_float_value(mrb, (mrb_float)retval);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined static method : cocos2d::Vec4#dot");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Vec4_property_x_get(mrb_state* mrb, mrb_value self)
{
    cocos2d::Vec4* cobj = static_cast<cocos2d::Vec4*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Vec4_type));

    mrb_value ret;
    ret = mrb_float_value(mrb, (mrb_float)cobj->x);
    return ret;
}

mrb_value ruby_cocos2dx_Vec4_property_x_set(mrb_state* mrb, mrb_value self)
{
    cocos2d::Vec4* cobj = static_cast<cocos2d::Vec4*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Vec4_type));

    mrb_value argv;
    mrb_get_args(mrb, "o", &argv);

    bool ok = true;
    double val;
    ok = rubyval_to_number(mrb, argv, (double*)&val, "CC::Vec4.x");
    if (! ok) {
        mrb_raise(mrb, E_RUNTIME_ERROR, "convert to native failed : Vec4#x");
    }
    cobj->x = val;

    return self;
}

mrb_value ruby_cocos2dx_Vec4_property_y_get(mrb_state* mrb, mrb_value self)
{
    cocos2d::Vec4* cobj = static_cast<cocos2d::Vec4*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Vec4_type));

    mrb_value ret;
    ret = mrb_float_value(mrb, (mrb_float)cobj->y);
    return ret;
}

mrb_value ruby_cocos2dx_Vec4_property_y_set(mrb_state* mrb, mrb_value self)
{
    cocos2d::Vec4* cobj = static_cast<cocos2d::Vec4*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Vec4_type));

    mrb_value argv;
    mrb_get_args(mrb, "o", &argv);

    bool ok = true;
    double val;
    ok = rubyval_to_number(mrb, argv, (double*)&val, "CC::Vec4.y");
    if (! ok) {
        mrb_raise(mrb, E_RUNTIME_ERROR, "convert to native failed : Vec4#y");
    }
    cobj->y = val;

    return self;
}

mrb_value ruby_cocos2dx_Vec4_property_z_get(mrb_state* mrb, mrb_value self)
{
    cocos2d::Vec4* cobj = static_cast<cocos2d::Vec4*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Vec4_type));

    mrb_value ret;
    ret = mrb_float_value(mrb, (mrb_float)cobj->z);
    return ret;
}

mrb_value ruby_cocos2dx_Vec4_property_z_set(mrb_state* mrb, mrb_value self)
{
    cocos2d::Vec4* cobj = static_cast<cocos2d::Vec4*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Vec4_type));

    mrb_value argv;
    mrb_get_args(mrb, "o", &argv);

    bool ok = true;
    double val;
    ok = rubyval_to_number(mrb, argv, (double*)&val, "CC::Vec4.z");
    if (! ok) {
        mrb_raise(mrb, E_RUNTIME_ERROR, "convert to native failed : Vec4#z");
    }
    cobj->z = val;

    return self;
}

mrb_value ruby_cocos2dx_Vec4_property_w_get(mrb_state* mrb, mrb_value self)
{
    cocos2d::Vec4* cobj = static_cast<cocos2d::Vec4*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Vec4_type));

    mrb_value ret;
    ret = mrb_float_value(mrb, (mrb_float)cobj->w);
    return ret;
}

mrb_value ruby_cocos2dx_Vec4_property_w_set(mrb_state* mrb, mrb_value self)
{
    cocos2d::Vec4* cobj = static_cast<cocos2d::Vec4*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Vec4_type));

    mrb_value argv;
    mrb_get_args(mrb, "o", &argv);

    bool ok = true;
    double val;
    ok = rubyval_to_number(mrb, argv, (double*)&val, "CC::Vec4.w");
    if (! ok) {
        mrb_raise(mrb, E_RUNTIME_ERROR, "convert to native failed : Vec4#w");
    }
    cobj->w = val;

    return self;
}

mrb_value ruby_cocos2dx_Vec4_constructor(mrb_state* mrb, mrb_value self)
{

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 4) {
            double arg0;
            ok = rubyval_to_number(mrb, argv[0], (double*)&arg0, "CC::Vec4.Vec4");
            if (!ok) { break; }
            double arg1;
            ok = rubyval_to_number(mrb, argv[1], (double*)&arg1, "CC::Vec4.Vec4");
            if (!ok) { break; }
            double arg2;
            ok = rubyval_to_number(mrb, argv[2], (double*)&arg2, "CC::Vec4.Vec4");
            if (!ok) { break; }
            double arg3;
            ok = rubyval_to_number(mrb, argv[3], (double*)&arg3, "CC::Vec4.Vec4");
            if (!ok) { break; }
            cocos2d::Vec4* cobj = new cocos2d::Vec4(arg0, arg1, arg2, arg3);
            DATA_TYPE(self) = &ruby_cocos2dx_Vec4_type;
            DATA_PTR(self) = cobj;
            return self;
        }
    } while (0);
    do {
        if (argc == 0) {
            cocos2d::Vec4* cobj = new cocos2d::Vec4();
            DATA_TYPE(self) = &ruby_cocos2dx_Vec4_type;
            DATA_PTR(self) = cobj;
            return self;
        }
    } while (0);
    do {
        if (argc == 1) {
            float* arg0;
            ok = rubyval_to_carray_float(mrb, argv[0], &arg0, "CC::Vec4.Vec4");
            if (!ok) { break; }
            cocos2d::Vec4* cobj = new cocos2d::Vec4(arg0);
            DATA_TYPE(self) = &ruby_cocos2dx_Vec4_type;
            DATA_PTR(self) = cobj;
            return self;
        }
    } while (0);
    do {
        if (argc == 2) {
            cocos2d::Vec4* arg0;
            ok = rubyval_to_object<cocos2d::Vec4>(mrb, argv[0], "CC::Vec4", &arg0);
            if (!ok) { break; }
            cocos2d::Vec4* arg1;
            ok = rubyval_to_object<cocos2d::Vec4>(mrb, argv[1], "CC::Vec4", &arg1);
            if (!ok) { break; }
            cocos2d::Vec4* cobj = new cocos2d::Vec4(*arg0, *arg1);
            DATA_TYPE(self) = &ruby_cocos2dx_Vec4_type;
            DATA_PTR(self) = cobj;
            return self;
        }
    } while (0);
    do {
        if (argc == 1) {
            cocos2d::Vec4* arg0;
            ok = rubyval_to_object<cocos2d::Vec4>(mrb, argv[0], "CC::Vec4", &arg0);
            if (!ok) { break; }
            cocos2d::Vec4* cobj = new cocos2d::Vec4(*arg0);
            DATA_TYPE(self) = &ruby_cocos2dx_Vec4_type;
            DATA_PTR(self) = cobj;
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::Vec4#Vec4");

    return mrb_nil_value();
}


void ruby_cocos2dx_Vec4_constants_init(mrb_state* mrb, struct RClass* rclass)
{
    do {
        cocos2d::Vec4* retval_ptr = new cocos2d::Vec4(cocos2d::Vec4::ZERO);
        mrb_value ret;
        ret = object_to_rubyval<cocos2d::Vec4>(mrb, "CC::Vec4", (cocos2d::Vec4*)retval_ptr, nullptr);
        mrb_mod_cv_set(mrb, rclass, mrb_intern_cstr(mrb, "ZERO"), ret);
    } while (0);

    do {
        cocos2d::Vec4* retval_ptr = new cocos2d::Vec4(cocos2d::Vec4::ONE);
        mrb_value ret;
        ret = object_to_rubyval<cocos2d::Vec4>(mrb, "CC::Vec4", (cocos2d::Vec4*)retval_ptr, nullptr);
        mrb_mod_cv_set(mrb, rclass, mrb_intern_cstr(mrb, "ONE"), ret);
    } while (0);

    do {
        cocos2d::Vec4* retval_ptr = new cocos2d::Vec4(cocos2d::Vec4::UNIT_X);
        mrb_value ret;
        ret = object_to_rubyval<cocos2d::Vec4>(mrb, "CC::Vec4", (cocos2d::Vec4*)retval_ptr, nullptr);
        mrb_mod_cv_set(mrb, rclass, mrb_intern_cstr(mrb, "UNIT_X"), ret);
    } while (0);

    do {
        cocos2d::Vec4* retval_ptr = new cocos2d::Vec4(cocos2d::Vec4::UNIT_Y);
        mrb_value ret;
        ret = object_to_rubyval<cocos2d::Vec4>(mrb, "CC::Vec4", (cocos2d::Vec4*)retval_ptr, nullptr);
        mrb_mod_cv_set(mrb, rclass, mrb_intern_cstr(mrb, "UNIT_Y"), ret);
    } while (0);

    do {
        cocos2d::Vec4* retval_ptr = new cocos2d::Vec4(cocos2d::Vec4::UNIT_Z);
        mrb_value ret;
        ret = object_to_rubyval<cocos2d::Vec4>(mrb, "CC::Vec4", (cocos2d::Vec4*)retval_ptr, nullptr);
        mrb_mod_cv_set(mrb, rclass, mrb_intern_cstr(mrb, "UNIT_Z"), ret);
    } while (0);

    do {
        cocos2d::Vec4* retval_ptr = new cocos2d::Vec4(cocos2d::Vec4::UNIT_W);
        mrb_value ret;
        ret = object_to_rubyval<cocos2d::Vec4>(mrb, "CC::Vec4", (cocos2d::Vec4*)retval_ptr, nullptr);
        mrb_mod_cv_set(mrb, rclass, mrb_intern_cstr(mrb, "UNIT_W"), ret);
    } while (0);

}

void ruby_register_cocos2dx_Vec4(mrb_state* mrb, struct RClass* rmodule)
{
    std::string typeName = typeid(cocos2d::Vec4).name();
    g_rubyType[typeName] = "CC::Vec4";
    g_rubyDataType[typeName] = &ruby_cocos2dx_Vec4_type;

    struct RClass *rclass = mrb_define_class_under(mrb, rmodule, "Vec4", mrb->object_class);
    MRB_SET_INSTANCE_TT(rclass, MRB_TT_DATA);

    mrb_define_method(mrb, rclass, "initialize", ruby_cocos2dx_Vec4_constructor, ARGS_REQ(0)|ARGS_OPT(4));
    mrb_define_method(mrb, rclass, "clamp", ruby_cocos2dx_Vec4_clamp, ARGS_REQ(2));
    mrb_define_method(mrb, rclass, "set", ruby_cocos2dx_Vec4_set, ARGS_REQ(1)|ARGS_OPT(3));
    mrb_define_method(mrb, rclass, "<", ruby_cocos2dx_Vec4_operator_lt, ARGS_REQ(1));
    mrb_define_method(mrb, rclass, "+", ruby_cocos2dx_Vec4_operator_plus, ARGS_REQ(1));
    mrb_define_method(mrb, rclass, "*", ruby_cocos2dx_Vec4_operator_multiply, ARGS_REQ(1));
    mrb_define_method(mrb, rclass, "-", ruby_cocos2dx_Vec4_operator_minus, ARGS_REQ(0)|ARGS_OPT(1));
    mrb_define_method(mrb, rclass, "/", ruby_cocos2dx_Vec4_operator_divide, ARGS_REQ(1));
    mrb_define_method(mrb, rclass, "negate", ruby_cocos2dx_Vec4_negate, ARGS_NONE());
    mrb_define_method(mrb, rclass, "distance_squared", ruby_cocos2dx_Vec4_distanceSquared, ARGS_REQ(1));
    mrb_define_method(mrb, rclass, "-=", ruby_cocos2dx_Vec4_operator_minus_eq, ARGS_REQ(1));
    mrb_define_method(mrb, rclass, "one?", ruby_cocos2dx_Vec4_isOne, ARGS_NONE());
    mrb_define_method(mrb, rclass, "scale", ruby_cocos2dx_Vec4_scale, ARGS_REQ(1));
    mrb_define_method(mrb, rclass, "+=", ruby_cocos2dx_Vec4_operator_plus_eq, ARGS_REQ(1));
    mrb_define_method(mrb, rclass, "add", ruby_cocos2dx_Vec4_add, ARGS_REQ(1));
    mrb_define_method(mrb, rclass, "zero?", ruby_cocos2dx_Vec4_isZero, ARGS_NONE());
    mrb_define_method(mrb, rclass, "get_normalized", ruby_cocos2dx_Vec4_getNormalized, ARGS_NONE());
    mrb_define_method(mrb, rclass, "normalize", ruby_cocos2dx_Vec4_normalize, ARGS_NONE());
    mrb_define_method(mrb, rclass, "length_squared", ruby_cocos2dx_Vec4_lengthSquared, ARGS_NONE());
    mrb_define_method(mrb, rclass, "!=", ruby_cocos2dx_Vec4_operator_not_eq, ARGS_REQ(1));
    mrb_define_method(mrb, rclass, "==", ruby_cocos2dx_Vec4_operator_eq_eq, ARGS_REQ(1));
    mrb_define_method(mrb, rclass, "subtract", ruby_cocos2dx_Vec4_subtract, ARGS_REQ(1));
    mrb_define_method(mrb, rclass, "distance", ruby_cocos2dx_Vec4_distance, ARGS_REQ(1));
    mrb_define_method(mrb, rclass, "length", ruby_cocos2dx_Vec4_length, ARGS_NONE());
    mrb_define_method(mrb, rclass, "*=", ruby_cocos2dx_Vec4_operator_multiply_eq, ARGS_REQ(1));
    mrb_define_method(mrb, rclass, "dot", ruby_cocos2dx_Vec4_dot, ARGS_REQ(1));
    mrb_define_class_method(mrb, rclass, "clamp", ruby_cocos2dx_Vec4_clamp_static, ARGS_REQ(4));
    mrb_define_class_method(mrb, rclass, "angle", ruby_cocos2dx_Vec4_angle_static, ARGS_REQ(2));
    mrb_define_class_method(mrb, rclass, "add", ruby_cocos2dx_Vec4_add_static, ARGS_REQ(3));
    mrb_define_class_method(mrb, rclass, "from_color", ruby_cocos2dx_Vec4_fromColor_static, ARGS_REQ(1));
    mrb_define_class_method(mrb, rclass, "subtract", ruby_cocos2dx_Vec4_subtract_static, ARGS_REQ(3));
    mrb_define_class_method(mrb, rclass, "dot", ruby_cocos2dx_Vec4_dot_static, ARGS_REQ(2));
    mrb_define_method(mrb, rclass, "x", ruby_cocos2dx_Vec4_property_x_get, ARGS_NONE());
    mrb_define_method(mrb, rclass, "x=", ruby_cocos2dx_Vec4_property_x_set, ARGS_REQ(1));
    mrb_define_method(mrb, rclass, "y", ruby_cocos2dx_Vec4_property_y_get, ARGS_NONE());
    mrb_define_method(mrb, rclass, "y=", ruby_cocos2dx_Vec4_property_y_set, ARGS_REQ(1));
    mrb_define_method(mrb, rclass, "z", ruby_cocos2dx_Vec4_property_z_get, ARGS_NONE());
    mrb_define_method(mrb, rclass, "z=", ruby_cocos2dx_Vec4_property_z_set, ARGS_REQ(1));
    mrb_define_method(mrb, rclass, "w", ruby_cocos2dx_Vec4_property_w_get, ARGS_NONE());
    mrb_define_method(mrb, rclass, "w=", ruby_cocos2dx_Vec4_property_w_set, ARGS_REQ(1));
    ruby_cocos2dx_Vec4_constants_init(mrb, rclass);
    mrb_define_class_method(mrb, rclass, "ZERO", ruby_cocos2dx_constant_get, ARGS_NONE());
    mrb_define_class_method(mrb, rclass, "ONE", ruby_cocos2dx_constant_get, ARGS_NONE());
    mrb_define_class_method(mrb, rclass, "UNIT_X", ruby_cocos2dx_constant_get, ARGS_NONE());
    mrb_define_class_method(mrb, rclass, "UNIT_Y", ruby_cocos2dx_constant_get, ARGS_NONE());
    mrb_define_class_method(mrb, rclass, "UNIT_Z", ruby_cocos2dx_constant_get, ARGS_NONE());
    mrb_define_class_method(mrb, rclass, "UNIT_W", ruby_cocos2dx_constant_get, ARGS_NONE());
}
mrb_value ruby_cocos2dx_Size_operator_eq(mrb_state* mrb, mrb_value self)
{
    cocos2d::Size* cobj = static_cast<cocos2d::Size*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Size_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            cocos2d::Vec2* arg0;
            ok = rubyval_to_object<cocos2d::Vec2>(mrb, argv[0], "CC::Vec2", &arg0);
            if (!ok) { break; }
            cocos2d::Size retval = cobj->operator=(*arg0);
            cocos2d::Size* retval_ptr = new cocos2d::Size(retval);
            mrb_value ret;
            ret = object_to_rubyval<cocos2d::Size>(mrb, "CC::Size", (cocos2d::Size*)retval_ptr, nullptr);
            return ret;
        }
    } while (0);
    do {
        if (argc == 1) {
            cocos2d::Size* arg0;
            ok = rubyval_to_object<cocos2d::Size>(mrb, argv[0], "CC::Size", &arg0);
            if (!ok) { break; }
            cocos2d::Size retval = cobj->operator=(*arg0);
            cocos2d::Size* retval_ptr = new cocos2d::Size(retval);
            mrb_value ret;
            ret = object_to_rubyval<cocos2d::Size>(mrb, "CC::Size", (cocos2d::Size*)retval_ptr, nullptr);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::Size#operator=");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Size_equals(mrb_state* mrb, mrb_value self)
{
    cocos2d::Size* cobj = static_cast<cocos2d::Size*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Size_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            cocos2d::Size* arg0;
            ok = rubyval_to_object<cocos2d::Size>(mrb, argv[0], "CC::Size", &arg0);
            if (!ok) { break; }
            bool retval = cobj->equals(*arg0);
            mrb_value ret;
            ret = mrb_bool_value((mrb_bool)retval);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::Size#equals");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Size_operator_plus(mrb_state* mrb, mrb_value self)
{
    cocos2d::Size* cobj = static_cast<cocos2d::Size*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Size_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            cocos2d::Size* arg0;
            ok = rubyval_to_object<cocos2d::Size>(mrb, argv[0], "CC::Size", &arg0);
            if (!ok) { break; }
            cocos2d::Size retval = cobj->operator+(*arg0);
            cocos2d::Size* retval_ptr = new cocos2d::Size(retval);
            mrb_value ret;
            ret = object_to_rubyval<cocos2d::Size>(mrb, "CC::Size", (cocos2d::Size*)retval_ptr, nullptr);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::Size#operator+");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Size_operator_multiply(mrb_state* mrb, mrb_value self)
{
    cocos2d::Size* cobj = static_cast<cocos2d::Size*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Size_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            double arg0;
            ok = rubyval_to_number(mrb, argv[0], (double*)&arg0, "CC::Size.operator*");
            if (!ok) { break; }
            cocos2d::Size retval = cobj->operator*(arg0);
            cocos2d::Size* retval_ptr = new cocos2d::Size(retval);
            mrb_value ret;
            ret = object_to_rubyval<cocos2d::Size>(mrb, "CC::Size", (cocos2d::Size*)retval_ptr, nullptr);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::Size#operator*");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Size_operator_minus(mrb_state* mrb, mrb_value self)
{
    cocos2d::Size* cobj = static_cast<cocos2d::Size*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Size_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            cocos2d::Size* arg0;
            ok = rubyval_to_object<cocos2d::Size>(mrb, argv[0], "CC::Size", &arg0);
            if (!ok) { break; }
            cocos2d::Size retval = cobj->operator-(*arg0);
            cocos2d::Size* retval_ptr = new cocos2d::Size(retval);
            mrb_value ret;
            ret = object_to_rubyval<cocos2d::Size>(mrb, "CC::Size", (cocos2d::Size*)retval_ptr, nullptr);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::Size#operator-");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Size_operator_divide(mrb_state* mrb, mrb_value self)
{
    cocos2d::Size* cobj = static_cast<cocos2d::Size*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Size_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            double arg0;
            ok = rubyval_to_number(mrb, argv[0], (double*)&arg0, "CC::Size.operator/");
            if (!ok) { break; }
            cocos2d::Size retval = cobj->operator/(arg0);
            cocos2d::Size* retval_ptr = new cocos2d::Size(retval);
            mrb_value ret;
            ret = object_to_rubyval<cocos2d::Size>(mrb, "CC::Size", (cocos2d::Size*)retval_ptr, nullptr);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::Size#operator/");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Size_setSize(mrb_state* mrb, mrb_value self)
{
    cocos2d::Size* cobj = static_cast<cocos2d::Size*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Size_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 2) {
            double arg0;
            ok = rubyval_to_number(mrb, argv[0], (double*)&arg0, "CC::Size.setSize");
            if (!ok) { break; }
            double arg1;
            ok = rubyval_to_number(mrb, argv[1], (double*)&arg1, "CC::Size.setSize");
            if (!ok) { break; }
            cobj->setSize(arg0, arg1);
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::Size#setSize");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Size_property_width_get(mrb_state* mrb, mrb_value self)
{
    cocos2d::Size* cobj = static_cast<cocos2d::Size*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Size_type));

    mrb_value ret;
    ret = mrb_float_value(mrb, (mrb_float)cobj->width);
    return ret;
}

mrb_value ruby_cocos2dx_Size_property_width_set(mrb_state* mrb, mrb_value self)
{
    cocos2d::Size* cobj = static_cast<cocos2d::Size*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Size_type));

    mrb_value argv;
    mrb_get_args(mrb, "o", &argv);

    bool ok = true;
    double val;
    ok = rubyval_to_number(mrb, argv, (double*)&val, "CC::Size.width");
    if (! ok) {
        mrb_raise(mrb, E_RUNTIME_ERROR, "convert to native failed : Size#width");
    }
    cobj->width = val;

    return self;
}

mrb_value ruby_cocos2dx_Size_property_height_get(mrb_state* mrb, mrb_value self)
{
    cocos2d::Size* cobj = static_cast<cocos2d::Size*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Size_type));

    mrb_value ret;
    ret = mrb_float_value(mrb, (mrb_float)cobj->height);
    return ret;
}

mrb_value ruby_cocos2dx_Size_property_height_set(mrb_state* mrb, mrb_value self)
{
    cocos2d::Size* cobj = static_cast<cocos2d::Size*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Size_type));

    mrb_value argv;
    mrb_get_args(mrb, "o", &argv);

    bool ok = true;
    double val;
    ok = rubyval_to_number(mrb, argv, (double*)&val, "CC::Size.height");
    if (! ok) {
        mrb_raise(mrb, E_RUNTIME_ERROR, "convert to native failed : Size#height");
    }
    cobj->height = val;

    return self;
}

mrb_value ruby_cocos2dx_Size_constructor(mrb_state* mrb, mrb_value self)
{

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 2) {
            double arg0;
            ok = rubyval_to_number(mrb, argv[0], (double*)&arg0, "CC::Size.Size");
            if (!ok) { break; }
            double arg1;
            ok = rubyval_to_number(mrb, argv[1], (double*)&arg1, "CC::Size.Size");
            if (!ok) { break; }
            cocos2d::Size* cobj = new cocos2d::Size(arg0, arg1);
            DATA_TYPE(self) = &ruby_cocos2dx_Size_type;
            DATA_PTR(self) = cobj;
            return self;
        }
    } while (0);
    do {
        if (argc == 0) {
            cocos2d::Size* cobj = new cocos2d::Size();
            DATA_TYPE(self) = &ruby_cocos2dx_Size_type;
            DATA_PTR(self) = cobj;
            return self;
        }
    } while (0);
    do {
        if (argc == 1) {
            cocos2d::Size* arg0;
            ok = rubyval_to_object<cocos2d::Size>(mrb, argv[0], "CC::Size", &arg0);
            if (!ok) { break; }
            cocos2d::Size* cobj = new cocos2d::Size(*arg0);
            DATA_TYPE(self) = &ruby_cocos2dx_Size_type;
            DATA_PTR(self) = cobj;
            return self;
        }
    } while (0);
    do {
        if (argc == 1) {
            cocos2d::Vec2* arg0;
            ok = rubyval_to_object<cocos2d::Vec2>(mrb, argv[0], "CC::Vec2", &arg0);
            if (!ok) { break; }
            cocos2d::Size* cobj = new cocos2d::Size(*arg0);
            DATA_TYPE(self) = &ruby_cocos2dx_Size_type;
            DATA_PTR(self) = cobj;
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::Size#Size");

    return mrb_nil_value();
}


void ruby_cocos2dx_Size_constants_init(mrb_state* mrb, struct RClass* rclass)
{
    do {
        cocos2d::Size* retval_ptr = new cocos2d::Size(cocos2d::Size::ZERO);
        mrb_value ret;
        ret = object_to_rubyval<cocos2d::Size>(mrb, "CC::Size", (cocos2d::Size*)retval_ptr, nullptr);
        mrb_mod_cv_set(mrb, rclass, mrb_intern_cstr(mrb, "ZERO"), ret);
    } while (0);

}

void ruby_register_cocos2dx_Size(mrb_state* mrb, struct RClass* rmodule)
{
    std::string typeName = typeid(cocos2d::Size).name();
    g_rubyType[typeName] = "CC::Size";
    g_rubyDataType[typeName] = &ruby_cocos2dx_Size_type;

    struct RClass *rclass = mrb_define_class_under(mrb, rmodule, "Size", mrb->object_class);
    MRB_SET_INSTANCE_TT(rclass, MRB_TT_DATA);

    mrb_define_method(mrb, rclass, "initialize", ruby_cocos2dx_Size_constructor, ARGS_REQ(0)|ARGS_OPT(2));
    mrb_define_method(mrb, rclass, "=", ruby_cocos2dx_Size_operator_eq, ARGS_REQ(1));
    mrb_define_method(mrb, rclass, "equals", ruby_cocos2dx_Size_equals, ARGS_REQ(1));
    mrb_define_method(mrb, rclass, "+", ruby_cocos2dx_Size_operator_plus, ARGS_REQ(1));
    mrb_define_method(mrb, rclass, "*", ruby_cocos2dx_Size_operator_multiply, ARGS_REQ(1));
    mrb_define_method(mrb, rclass, "-", ruby_cocos2dx_Size_operator_minus, ARGS_REQ(1));
    mrb_define_method(mrb, rclass, "/", ruby_cocos2dx_Size_operator_divide, ARGS_REQ(1));
    mrb_define_method(mrb, rclass, "set_size", ruby_cocos2dx_Size_setSize, ARGS_REQ(2));
    mrb_define_method(mrb, rclass, "width", ruby_cocos2dx_Size_property_width_get, ARGS_NONE());
    mrb_define_method(mrb, rclass, "width=", ruby_cocos2dx_Size_property_width_set, ARGS_REQ(1));
    mrb_define_method(mrb, rclass, "height", ruby_cocos2dx_Size_property_height_get, ARGS_NONE());
    mrb_define_method(mrb, rclass, "height=", ruby_cocos2dx_Size_property_height_set, ARGS_REQ(1));
    ruby_cocos2dx_Size_constants_init(mrb, rclass);
    mrb_define_class_method(mrb, rclass, "ZERO", ruby_cocos2dx_constant_get, ARGS_NONE());
}
mrb_value ruby_cocos2dx_Rect_operator_eq(mrb_state* mrb, mrb_value self)
{
    cocos2d::Rect* cobj = static_cast<cocos2d::Rect*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Rect_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            cocos2d::Rect* arg0;
            ok = rubyval_to_object<cocos2d::Rect>(mrb, argv[0], "CC::Rect", &arg0);
            if (!ok) { break; }
            cocos2d::Rect retval = cobj->operator=(*arg0);
            cocos2d::Rect* retval_ptr = new cocos2d::Rect(retval);
            mrb_value ret;
            ret = object_to_rubyval<cocos2d::Rect>(mrb, "CC::Rect", (cocos2d::Rect*)retval_ptr, nullptr);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::Rect#operator=");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Rect_getMaxX(mrb_state* mrb, mrb_value self)
{
    cocos2d::Rect* cobj = static_cast<cocos2d::Rect*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Rect_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            double retval = cobj->getMaxX();
            mrb_value ret;
            ret = mrb_float_value(mrb, (mrb_float)retval);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::Rect#getMaxX");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Rect_unionWithRect(mrb_state* mrb, mrb_value self)
{
    cocos2d::Rect* cobj = static_cast<cocos2d::Rect*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Rect_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            cocos2d::Rect* arg0;
            ok = rubyval_to_object<cocos2d::Rect>(mrb, argv[0], "CC::Rect", &arg0);
            if (!ok) { break; }
            cocos2d::Rect retval = cobj->unionWithRect(*arg0);
            cocos2d::Rect* retval_ptr = new cocos2d::Rect(retval);
            mrb_value ret;
            ret = object_to_rubyval<cocos2d::Rect>(mrb, "CC::Rect", (cocos2d::Rect*)retval_ptr, nullptr);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::Rect#unionWithRect");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Rect_equals(mrb_state* mrb, mrb_value self)
{
    cocos2d::Rect* cobj = static_cast<cocos2d::Rect*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Rect_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            cocos2d::Rect* arg0;
            ok = rubyval_to_object<cocos2d::Rect>(mrb, argv[0], "CC::Rect", &arg0);
            if (!ok) { break; }
            bool retval = cobj->equals(*arg0);
            mrb_value ret;
            ret = mrb_bool_value((mrb_bool)retval);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::Rect#equals");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Rect_getMinY(mrb_state* mrb, mrb_value self)
{
    cocos2d::Rect* cobj = static_cast<cocos2d::Rect*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Rect_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            double retval = cobj->getMinY();
            mrb_value ret;
            ret = mrb_float_value(mrb, (mrb_float)retval);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::Rect#getMinY");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Rect_getMinX(mrb_state* mrb, mrb_value self)
{
    cocos2d::Rect* cobj = static_cast<cocos2d::Rect*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Rect_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            double retval = cobj->getMinX();
            mrb_value ret;
            ret = mrb_float_value(mrb, (mrb_float)retval);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::Rect#getMinX");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Rect_getMidY(mrb_state* mrb, mrb_value self)
{
    cocos2d::Rect* cobj = static_cast<cocos2d::Rect*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Rect_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            double retval = cobj->getMidY();
            mrb_value ret;
            ret = mrb_float_value(mrb, (mrb_float)retval);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::Rect#getMidY");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Rect_getMidX(mrb_state* mrb, mrb_value self)
{
    cocos2d::Rect* cobj = static_cast<cocos2d::Rect*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Rect_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            double retval = cobj->getMidX();
            mrb_value ret;
            ret = mrb_float_value(mrb, (mrb_float)retval);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::Rect#getMidX");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Rect_merge(mrb_state* mrb, mrb_value self)
{
    cocos2d::Rect* cobj = static_cast<cocos2d::Rect*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Rect_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            cocos2d::Rect* arg0;
            ok = rubyval_to_object<cocos2d::Rect>(mrb, argv[0], "CC::Rect", &arg0);
            if (!ok) { break; }
            cobj->merge(*arg0);
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::Rect#merge");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Rect_intersectsRect(mrb_state* mrb, mrb_value self)
{
    cocos2d::Rect* cobj = static_cast<cocos2d::Rect*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Rect_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            cocos2d::Rect* arg0;
            ok = rubyval_to_object<cocos2d::Rect>(mrb, argv[0], "CC::Rect", &arg0);
            if (!ok) { break; }
            bool retval = cobj->intersectsRect(*arg0);
            mrb_value ret;
            ret = mrb_bool_value((mrb_bool)retval);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::Rect#intersectsRect");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Rect_getMaxY(mrb_state* mrb, mrb_value self)
{
    cocos2d::Rect* cobj = static_cast<cocos2d::Rect*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Rect_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            double retval = cobj->getMaxY();
            mrb_value ret;
            ret = mrb_float_value(mrb, (mrb_float)retval);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::Rect#getMaxY");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Rect_containsPoint(mrb_state* mrb, mrb_value self)
{
    cocos2d::Rect* cobj = static_cast<cocos2d::Rect*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Rect_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            cocos2d::Vec2* arg0;
            ok = rubyval_to_object<cocos2d::Vec2>(mrb, argv[0], "CC::Vec2", &arg0);
            if (!ok) { break; }
            bool retval = cobj->containsPoint(*arg0);
            mrb_value ret;
            ret = mrb_bool_value((mrb_bool)retval);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::Rect#containsPoint");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Rect_setRect(mrb_state* mrb, mrb_value self)
{
    cocos2d::Rect* cobj = static_cast<cocos2d::Rect*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Rect_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 4) {
            double arg0;
            ok = rubyval_to_number(mrb, argv[0], (double*)&arg0, "CC::Rect.setRect");
            if (!ok) { break; }
            double arg1;
            ok = rubyval_to_number(mrb, argv[1], (double*)&arg1, "CC::Rect.setRect");
            if (!ok) { break; }
            double arg2;
            ok = rubyval_to_number(mrb, argv[2], (double*)&arg2, "CC::Rect.setRect");
            if (!ok) { break; }
            double arg3;
            ok = rubyval_to_number(mrb, argv[3], (double*)&arg3, "CC::Rect.setRect");
            if (!ok) { break; }
            cobj->setRect(arg0, arg1, arg2, arg3);
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::Rect#setRect");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Rect_property_origin_get(mrb_state* mrb, mrb_value self)
{
    cocos2d::Rect* cobj = static_cast<cocos2d::Rect*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Rect_type));

    cocos2d::Vec2* retval_ptr = new cocos2d::Vec2(cobj->origin);
    mrb_value ret;
    ret = object_to_rubyval<cocos2d::Vec2>(mrb, "CC::Vec2", (cocos2d::Vec2*)retval_ptr, nullptr);
    return ret;
}

mrb_value ruby_cocos2dx_Rect_property_origin_set(mrb_state* mrb, mrb_value self)
{
    cocos2d::Rect* cobj = static_cast<cocos2d::Rect*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Rect_type));

    mrb_value argv;
    mrb_get_args(mrb, "o", &argv);

    bool ok = true;
    cocos2d::Vec2* val;
    ok = rubyval_to_object<cocos2d::Vec2>(mrb, argv, "CC::Vec2", &val);
    if (! ok) {
        mrb_raise(mrb, E_RUNTIME_ERROR, "convert to native failed : Rect#origin");
    }
    cobj->origin = *val;

    return self;
}

mrb_value ruby_cocos2dx_Rect_property_size_get(mrb_state* mrb, mrb_value self)
{
    cocos2d::Rect* cobj = static_cast<cocos2d::Rect*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Rect_type));

    cocos2d::Size* retval_ptr = new cocos2d::Size(cobj->size);
    mrb_value ret;
    ret = object_to_rubyval<cocos2d::Size>(mrb, "CC::Size", (cocos2d::Size*)retval_ptr, nullptr);
    return ret;
}

mrb_value ruby_cocos2dx_Rect_property_size_set(mrb_state* mrb, mrb_value self)
{
    cocos2d::Rect* cobj = static_cast<cocos2d::Rect*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Rect_type));

    mrb_value argv;
    mrb_get_args(mrb, "o", &argv);

    bool ok = true;
    cocos2d::Size* val;
    ok = rubyval_to_object<cocos2d::Size>(mrb, argv, "CC::Size", &val);
    if (! ok) {
        mrb_raise(mrb, E_RUNTIME_ERROR, "convert to native failed : Rect#size");
    }
    cobj->size = *val;

    return self;
}

mrb_value ruby_cocos2dx_Rect_constructor(mrb_state* mrb, mrb_value self)
{

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 4) {
            double arg0;
            ok = rubyval_to_number(mrb, argv[0], (double*)&arg0, "CC::Rect.Rect");
            if (!ok) { break; }
            double arg1;
            ok = rubyval_to_number(mrb, argv[1], (double*)&arg1, "CC::Rect.Rect");
            if (!ok) { break; }
            double arg2;
            ok = rubyval_to_number(mrb, argv[2], (double*)&arg2, "CC::Rect.Rect");
            if (!ok) { break; }
            double arg3;
            ok = rubyval_to_number(mrb, argv[3], (double*)&arg3, "CC::Rect.Rect");
            if (!ok) { break; }
            cocos2d::Rect* cobj = new cocos2d::Rect(arg0, arg1, arg2, arg3);
            DATA_TYPE(self) = &ruby_cocos2dx_Rect_type;
            DATA_PTR(self) = cobj;
            return self;
        }
    } while (0);
    do {
        if (argc == 0) {
            cocos2d::Rect* cobj = new cocos2d::Rect();
            DATA_TYPE(self) = &ruby_cocos2dx_Rect_type;
            DATA_PTR(self) = cobj;
            return self;
        }
    } while (0);
    do {
        if (argc == 1) {
            cocos2d::Rect* arg0;
            ok = rubyval_to_object<cocos2d::Rect>(mrb, argv[0], "CC::Rect", &arg0);
            if (!ok) { break; }
            cocos2d::Rect* cobj = new cocos2d::Rect(*arg0);
            DATA_TYPE(self) = &ruby_cocos2dx_Rect_type;
            DATA_PTR(self) = cobj;
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::Rect#Rect");

    return mrb_nil_value();
}


void ruby_cocos2dx_Rect_constants_init(mrb_state* mrb, struct RClass* rclass)
{
    do {
        cocos2d::Rect* retval_ptr = new cocos2d::Rect(cocos2d::Rect::ZERO);
        mrb_value ret;
        ret = object_to_rubyval<cocos2d::Rect>(mrb, "CC::Rect", (cocos2d::Rect*)retval_ptr, nullptr);
        mrb_mod_cv_set(mrb, rclass, mrb_intern_cstr(mrb, "ZERO"), ret);
    } while (0);

}

void ruby_register_cocos2dx_Rect(mrb_state* mrb, struct RClass* rmodule)
{
    std::string typeName = typeid(cocos2d::Rect).name();
    g_rubyType[typeName] = "CC::Rect";
    g_rubyDataType[typeName] = &ruby_cocos2dx_Rect_type;

    struct RClass *rclass = mrb_define_class_under(mrb, rmodule, "Rect", mrb->object_class);
    MRB_SET_INSTANCE_TT(rclass, MRB_TT_DATA);

    mrb_define_method(mrb, rclass, "initialize", ruby_cocos2dx_Rect_constructor, ARGS_REQ(0)|ARGS_OPT(4));
    mrb_define_method(mrb, rclass, "=", ruby_cocos2dx_Rect_operator_eq, ARGS_REQ(1));
    mrb_define_method(mrb, rclass, "get_max_x", ruby_cocos2dx_Rect_getMaxX, ARGS_NONE());
    mrb_define_method(mrb, rclass, "union_with_rect", ruby_cocos2dx_Rect_unionWithRect, ARGS_REQ(1));
    mrb_define_method(mrb, rclass, "equals", ruby_cocos2dx_Rect_equals, ARGS_REQ(1));
    mrb_define_method(mrb, rclass, "get_min_y", ruby_cocos2dx_Rect_getMinY, ARGS_NONE());
    mrb_define_method(mrb, rclass, "get_min_x", ruby_cocos2dx_Rect_getMinX, ARGS_NONE());
    mrb_define_method(mrb, rclass, "get_mid_y", ruby_cocos2dx_Rect_getMidY, ARGS_NONE());
    mrb_define_method(mrb, rclass, "get_mid_x", ruby_cocos2dx_Rect_getMidX, ARGS_NONE());
    mrb_define_method(mrb, rclass, "merge", ruby_cocos2dx_Rect_merge, ARGS_REQ(1));
    mrb_define_method(mrb, rclass, "intersects_rect", ruby_cocos2dx_Rect_intersectsRect, ARGS_REQ(1));
    mrb_define_method(mrb, rclass, "get_max_y", ruby_cocos2dx_Rect_getMaxY, ARGS_NONE());
    mrb_define_method(mrb, rclass, "contains_point", ruby_cocos2dx_Rect_containsPoint, ARGS_REQ(1));
    mrb_define_method(mrb, rclass, "set_rect", ruby_cocos2dx_Rect_setRect, ARGS_REQ(4));
    mrb_define_method(mrb, rclass, "origin", ruby_cocos2dx_Rect_property_origin_get, ARGS_NONE());
    mrb_define_method(mrb, rclass, "origin=", ruby_cocos2dx_Rect_property_origin_set, ARGS_REQ(1));
    mrb_define_method(mrb, rclass, "size", ruby_cocos2dx_Rect_property_size_get, ARGS_NONE());
    mrb_define_method(mrb, rclass, "size=", ruby_cocos2dx_Rect_property_size_set, ARGS_REQ(1));
    ruby_cocos2dx_Rect_constants_init(mrb, rclass);
    mrb_define_class_method(mrb, rclass, "ZERO", ruby_cocos2dx_constant_get, ARGS_NONE());
}
mrb_value ruby_cocos2dx_Color3B_operator_eq_eq(mrb_state* mrb, mrb_value self)
{
    cocos2d::Color3B* cobj = static_cast<cocos2d::Color3B*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Color3B_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            cocos2d::Color4B* arg0;
            ok = rubyval_to_object<cocos2d::Color4B>(mrb, argv[0], "CC::Color4B", &arg0);
            if (!ok) { break; }
            bool retval = cobj->operator==(*arg0);
            mrb_value ret;
            ret = mrb_bool_value((mrb_bool)retval);
            return ret;
        }
    } while (0);
    do {
        if (argc == 1) {
            cocos2d::Color3B* arg0;
            ok = rubyval_to_object<cocos2d::Color3B>(mrb, argv[0], "CC::Color3B", &arg0);
            if (!ok) { break; }
            bool retval = cobj->operator==(*arg0);
            mrb_value ret;
            ret = mrb_bool_value((mrb_bool)retval);
            return ret;
        }
    } while (0);
    do {
        if (argc == 1) {
            cocos2d::Color4F* arg0;
            ok = rubyval_to_object<cocos2d::Color4F>(mrb, argv[0], "CC::Color4F", &arg0);
            if (!ok) { break; }
            bool retval = cobj->operator==(*arg0);
            mrb_value ret;
            ret = mrb_bool_value((mrb_bool)retval);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::Color3B#operator==");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Color3B_operator_not_eq(mrb_state* mrb, mrb_value self)
{
    cocos2d::Color3B* cobj = static_cast<cocos2d::Color3B*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Color3B_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            cocos2d::Color4B* arg0;
            ok = rubyval_to_object<cocos2d::Color4B>(mrb, argv[0], "CC::Color4B", &arg0);
            if (!ok) { break; }
            bool retval = cobj->operator!=(*arg0);
            mrb_value ret;
            ret = mrb_bool_value((mrb_bool)retval);
            return ret;
        }
    } while (0);
    do {
        if (argc == 1) {
            cocos2d::Color3B* arg0;
            ok = rubyval_to_object<cocos2d::Color3B>(mrb, argv[0], "CC::Color3B", &arg0);
            if (!ok) { break; }
            bool retval = cobj->operator!=(*arg0);
            mrb_value ret;
            ret = mrb_bool_value((mrb_bool)retval);
            return ret;
        }
    } while (0);
    do {
        if (argc == 1) {
            cocos2d::Color4F* arg0;
            ok = rubyval_to_object<cocos2d::Color4F>(mrb, argv[0], "CC::Color4F", &arg0);
            if (!ok) { break; }
            bool retval = cobj->operator!=(*arg0);
            mrb_value ret;
            ret = mrb_bool_value((mrb_bool)retval);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::Color3B#operator!=");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Color3B_equals(mrb_state* mrb, mrb_value self)
{
    cocos2d::Color3B* cobj = static_cast<cocos2d::Color3B*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Color3B_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            cocos2d::Color3B* arg0;
            ok = rubyval_to_object<cocos2d::Color3B>(mrb, argv[0], "CC::Color3B", &arg0);
            if (!ok) { break; }
            bool retval = cobj->equals(*arg0);
            mrb_value ret;
            ret = mrb_bool_value((mrb_bool)retval);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::Color3B#equals");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Color3B_property_r_get(mrb_state* mrb, mrb_value self)
{
    cocos2d::Color3B* cobj = static_cast<cocos2d::Color3B*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Color3B_type));

    mrb_value ret;
    ret = mrb_fixnum_value((mrb_int)cobj->r);
    return ret;
}

mrb_value ruby_cocos2dx_Color3B_property_r_set(mrb_state* mrb, mrb_value self)
{
    cocos2d::Color3B* cobj = static_cast<cocos2d::Color3B*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Color3B_type));

    mrb_value argv;
    mrb_get_args(mrb, "o", &argv);

    bool ok = true;
    uint16_t val;
    ok = rubyval_to_uint16(mrb, argv, &val, "CC::Color3B.r");
    if (! ok) {
        mrb_raise(mrb, E_RUNTIME_ERROR, "convert to native failed : Color3B#r");
    }
    cobj->r = val;

    return self;
}

mrb_value ruby_cocos2dx_Color3B_property_g_get(mrb_state* mrb, mrb_value self)
{
    cocos2d::Color3B* cobj = static_cast<cocos2d::Color3B*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Color3B_type));

    mrb_value ret;
    ret = mrb_fixnum_value((mrb_int)cobj->g);
    return ret;
}

mrb_value ruby_cocos2dx_Color3B_property_g_set(mrb_state* mrb, mrb_value self)
{
    cocos2d::Color3B* cobj = static_cast<cocos2d::Color3B*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Color3B_type));

    mrb_value argv;
    mrb_get_args(mrb, "o", &argv);

    bool ok = true;
    uint16_t val;
    ok = rubyval_to_uint16(mrb, argv, &val, "CC::Color3B.g");
    if (! ok) {
        mrb_raise(mrb, E_RUNTIME_ERROR, "convert to native failed : Color3B#g");
    }
    cobj->g = val;

    return self;
}

mrb_value ruby_cocos2dx_Color3B_property_b_get(mrb_state* mrb, mrb_value self)
{
    cocos2d::Color3B* cobj = static_cast<cocos2d::Color3B*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Color3B_type));

    mrb_value ret;
    ret = mrb_fixnum_value((mrb_int)cobj->b);
    return ret;
}

mrb_value ruby_cocos2dx_Color3B_property_b_set(mrb_state* mrb, mrb_value self)
{
    cocos2d::Color3B* cobj = static_cast<cocos2d::Color3B*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Color3B_type));

    mrb_value argv;
    mrb_get_args(mrb, "o", &argv);

    bool ok = true;
    uint16_t val;
    ok = rubyval_to_uint16(mrb, argv, &val, "CC::Color3B.b");
    if (! ok) {
        mrb_raise(mrb, E_RUNTIME_ERROR, "convert to native failed : Color3B#b");
    }
    cobj->b = val;

    return self;
}

mrb_value ruby_cocos2dx_Color3B_constructor(mrb_state* mrb, mrb_value self)
{

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 3) {
            uint16_t arg0;
            ok = rubyval_to_uint16(mrb, argv[0], &arg0, "CC::Color3B.Color3B");
            if (!ok) { break; }
            uint16_t arg1;
            ok = rubyval_to_uint16(mrb, argv[1], &arg1, "CC::Color3B.Color3B");
            if (!ok) { break; }
            uint16_t arg2;
            ok = rubyval_to_uint16(mrb, argv[2], &arg2, "CC::Color3B.Color3B");
            if (!ok) { break; }
            cocos2d::Color3B* cobj = new cocos2d::Color3B(arg0, arg1, arg2);
            DATA_TYPE(self) = &ruby_cocos2dx_Color3B_type;
            DATA_PTR(self) = cobj;
            return self;
        }
    } while (0);
    do {
        if (argc == 0) {
            cocos2d::Color3B* cobj = new cocos2d::Color3B();
            DATA_TYPE(self) = &ruby_cocos2dx_Color3B_type;
            DATA_PTR(self) = cobj;
            return self;
        }
    } while (0);
    do {
        if (argc == 1) {
            cocos2d::Color4B* arg0;
            ok = rubyval_to_object<cocos2d::Color4B>(mrb, argv[0], "CC::Color4B", &arg0);
            if (!ok) { break; }
            cocos2d::Color3B* cobj = new cocos2d::Color3B(*arg0);
            DATA_TYPE(self) = &ruby_cocos2dx_Color3B_type;
            DATA_PTR(self) = cobj;
            return self;
        }
    } while (0);
    do {
        if (argc == 1) {
            cocos2d::Color4F* arg0;
            ok = rubyval_to_object<cocos2d::Color4F>(mrb, argv[0], "CC::Color4F", &arg0);
            if (!ok) { break; }
            cocos2d::Color3B* cobj = new cocos2d::Color3B(*arg0);
            DATA_TYPE(self) = &ruby_cocos2dx_Color3B_type;
            DATA_PTR(self) = cobj;
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::Color3B#Color3B");

    return mrb_nil_value();
}


void ruby_cocos2dx_Color3B_constants_init(mrb_state* mrb, struct RClass* rclass)
{
    do {
        cocos2d::Color3B* retval_ptr = new cocos2d::Color3B(cocos2d::Color3B::WHITE);
        mrb_value ret;
        ret = object_to_rubyval<cocos2d::Color3B>(mrb, "CC::Color3B", (cocos2d::Color3B*)retval_ptr, nullptr);
        mrb_mod_cv_set(mrb, rclass, mrb_intern_cstr(mrb, "WHITE"), ret);
    } while (0);

    do {
        cocos2d::Color3B* retval_ptr = new cocos2d::Color3B(cocos2d::Color3B::YELLOW);
        mrb_value ret;
        ret = object_to_rubyval<cocos2d::Color3B>(mrb, "CC::Color3B", (cocos2d::Color3B*)retval_ptr, nullptr);
        mrb_mod_cv_set(mrb, rclass, mrb_intern_cstr(mrb, "YELLOW"), ret);
    } while (0);

    do {
        cocos2d::Color3B* retval_ptr = new cocos2d::Color3B(cocos2d::Color3B::BLUE);
        mrb_value ret;
        ret = object_to_rubyval<cocos2d::Color3B>(mrb, "CC::Color3B", (cocos2d::Color3B*)retval_ptr, nullptr);
        mrb_mod_cv_set(mrb, rclass, mrb_intern_cstr(mrb, "BLUE"), ret);
    } while (0);

    do {
        cocos2d::Color3B* retval_ptr = new cocos2d::Color3B(cocos2d::Color3B::GREEN);
        mrb_value ret;
        ret = object_to_rubyval<cocos2d::Color3B>(mrb, "CC::Color3B", (cocos2d::Color3B*)retval_ptr, nullptr);
        mrb_mod_cv_set(mrb, rclass, mrb_intern_cstr(mrb, "GREEN"), ret);
    } while (0);

    do {
        cocos2d::Color3B* retval_ptr = new cocos2d::Color3B(cocos2d::Color3B::RED);
        mrb_value ret;
        ret = object_to_rubyval<cocos2d::Color3B>(mrb, "CC::Color3B", (cocos2d::Color3B*)retval_ptr, nullptr);
        mrb_mod_cv_set(mrb, rclass, mrb_intern_cstr(mrb, "RED"), ret);
    } while (0);

    do {
        cocos2d::Color3B* retval_ptr = new cocos2d::Color3B(cocos2d::Color3B::MAGENTA);
        mrb_value ret;
        ret = object_to_rubyval<cocos2d::Color3B>(mrb, "CC::Color3B", (cocos2d::Color3B*)retval_ptr, nullptr);
        mrb_mod_cv_set(mrb, rclass, mrb_intern_cstr(mrb, "MAGENTA"), ret);
    } while (0);

    do {
        cocos2d::Color3B* retval_ptr = new cocos2d::Color3B(cocos2d::Color3B::BLACK);
        mrb_value ret;
        ret = object_to_rubyval<cocos2d::Color3B>(mrb, "CC::Color3B", (cocos2d::Color3B*)retval_ptr, nullptr);
        mrb_mod_cv_set(mrb, rclass, mrb_intern_cstr(mrb, "BLACK"), ret);
    } while (0);

    do {
        cocos2d::Color3B* retval_ptr = new cocos2d::Color3B(cocos2d::Color3B::ORANGE);
        mrb_value ret;
        ret = object_to_rubyval<cocos2d::Color3B>(mrb, "CC::Color3B", (cocos2d::Color3B*)retval_ptr, nullptr);
        mrb_mod_cv_set(mrb, rclass, mrb_intern_cstr(mrb, "ORANGE"), ret);
    } while (0);

    do {
        cocos2d::Color3B* retval_ptr = new cocos2d::Color3B(cocos2d::Color3B::GRAY);
        mrb_value ret;
        ret = object_to_rubyval<cocos2d::Color3B>(mrb, "CC::Color3B", (cocos2d::Color3B*)retval_ptr, nullptr);
        mrb_mod_cv_set(mrb, rclass, mrb_intern_cstr(mrb, "GRAY"), ret);
    } while (0);

}

void ruby_register_cocos2dx_Color3B(mrb_state* mrb, struct RClass* rmodule)
{
    std::string typeName = typeid(cocos2d::Color3B).name();
    g_rubyType[typeName] = "CC::Color3B";
    g_rubyDataType[typeName] = &ruby_cocos2dx_Color3B_type;

    struct RClass *rclass = mrb_define_class_under(mrb, rmodule, "Color3B", mrb->object_class);
    MRB_SET_INSTANCE_TT(rclass, MRB_TT_DATA);

    mrb_define_method(mrb, rclass, "initialize", ruby_cocos2dx_Color3B_constructor, ARGS_REQ(0)|ARGS_OPT(3));
    mrb_define_method(mrb, rclass, "==", ruby_cocos2dx_Color3B_operator_eq_eq, ARGS_REQ(1));
    mrb_define_method(mrb, rclass, "!=", ruby_cocos2dx_Color3B_operator_not_eq, ARGS_REQ(1));
    mrb_define_method(mrb, rclass, "equals", ruby_cocos2dx_Color3B_equals, ARGS_REQ(1));
    mrb_define_method(mrb, rclass, "r", ruby_cocos2dx_Color3B_property_r_get, ARGS_NONE());
    mrb_define_method(mrb, rclass, "r=", ruby_cocos2dx_Color3B_property_r_set, ARGS_REQ(1));
    mrb_define_method(mrb, rclass, "g", ruby_cocos2dx_Color3B_property_g_get, ARGS_NONE());
    mrb_define_method(mrb, rclass, "g=", ruby_cocos2dx_Color3B_property_g_set, ARGS_REQ(1));
    mrb_define_method(mrb, rclass, "b", ruby_cocos2dx_Color3B_property_b_get, ARGS_NONE());
    mrb_define_method(mrb, rclass, "b=", ruby_cocos2dx_Color3B_property_b_set, ARGS_REQ(1));
    ruby_cocos2dx_Color3B_constants_init(mrb, rclass);
    mrb_define_class_method(mrb, rclass, "WHITE", ruby_cocos2dx_constant_get, ARGS_NONE());
    mrb_define_class_method(mrb, rclass, "YELLOW", ruby_cocos2dx_constant_get, ARGS_NONE());
    mrb_define_class_method(mrb, rclass, "BLUE", ruby_cocos2dx_constant_get, ARGS_NONE());
    mrb_define_class_method(mrb, rclass, "GREEN", ruby_cocos2dx_constant_get, ARGS_NONE());
    mrb_define_class_method(mrb, rclass, "RED", ruby_cocos2dx_constant_get, ARGS_NONE());
    mrb_define_class_method(mrb, rclass, "MAGENTA", ruby_cocos2dx_constant_get, ARGS_NONE());
    mrb_define_class_method(mrb, rclass, "BLACK", ruby_cocos2dx_constant_get, ARGS_NONE());
    mrb_define_class_method(mrb, rclass, "ORANGE", ruby_cocos2dx_constant_get, ARGS_NONE());
    mrb_define_class_method(mrb, rclass, "GRAY", ruby_cocos2dx_constant_get, ARGS_NONE());
}
mrb_value ruby_cocos2dx_Color4B_operator_eq_eq(mrb_state* mrb, mrb_value self)
{
    cocos2d::Color4B* cobj = static_cast<cocos2d::Color4B*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Color4B_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            cocos2d::Color3B* arg0;
            ok = rubyval_to_object<cocos2d::Color3B>(mrb, argv[0], "CC::Color3B", &arg0);
            if (!ok) { break; }
            bool retval = cobj->operator==(*arg0);
            mrb_value ret;
            ret = mrb_bool_value((mrb_bool)retval);
            return ret;
        }
    } while (0);
    do {
        if (argc == 1) {
            cocos2d::Color4B* arg0;
            ok = rubyval_to_object<cocos2d::Color4B>(mrb, argv[0], "CC::Color4B", &arg0);
            if (!ok) { break; }
            bool retval = cobj->operator==(*arg0);
            mrb_value ret;
            ret = mrb_bool_value((mrb_bool)retval);
            return ret;
        }
    } while (0);
    do {
        if (argc == 1) {
            cocos2d::Color4F* arg0;
            ok = rubyval_to_object<cocos2d::Color4F>(mrb, argv[0], "CC::Color4F", &arg0);
            if (!ok) { break; }
            bool retval = cobj->operator==(*arg0);
            mrb_value ret;
            ret = mrb_bool_value((mrb_bool)retval);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::Color4B#operator==");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Color4B_operator_not_eq(mrb_state* mrb, mrb_value self)
{
    cocos2d::Color4B* cobj = static_cast<cocos2d::Color4B*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Color4B_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            cocos2d::Color3B* arg0;
            ok = rubyval_to_object<cocos2d::Color3B>(mrb, argv[0], "CC::Color3B", &arg0);
            if (!ok) { break; }
            bool retval = cobj->operator!=(*arg0);
            mrb_value ret;
            ret = mrb_bool_value((mrb_bool)retval);
            return ret;
        }
    } while (0);
    do {
        if (argc == 1) {
            cocos2d::Color4B* arg0;
            ok = rubyval_to_object<cocos2d::Color4B>(mrb, argv[0], "CC::Color4B", &arg0);
            if (!ok) { break; }
            bool retval = cobj->operator!=(*arg0);
            mrb_value ret;
            ret = mrb_bool_value((mrb_bool)retval);
            return ret;
        }
    } while (0);
    do {
        if (argc == 1) {
            cocos2d::Color4F* arg0;
            ok = rubyval_to_object<cocos2d::Color4F>(mrb, argv[0], "CC::Color4F", &arg0);
            if (!ok) { break; }
            bool retval = cobj->operator!=(*arg0);
            mrb_value ret;
            ret = mrb_bool_value((mrb_bool)retval);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::Color4B#operator!=");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Color4B_property_r_get(mrb_state* mrb, mrb_value self)
{
    cocos2d::Color4B* cobj = static_cast<cocos2d::Color4B*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Color4B_type));

    mrb_value ret;
    ret = mrb_fixnum_value((mrb_int)cobj->r);
    return ret;
}

mrb_value ruby_cocos2dx_Color4B_property_r_set(mrb_state* mrb, mrb_value self)
{
    cocos2d::Color4B* cobj = static_cast<cocos2d::Color4B*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Color4B_type));

    mrb_value argv;
    mrb_get_args(mrb, "o", &argv);

    bool ok = true;
    uint16_t val;
    ok = rubyval_to_uint16(mrb, argv, &val, "CC::Color4B.r");
    if (! ok) {
        mrb_raise(mrb, E_RUNTIME_ERROR, "convert to native failed : Color4B#r");
    }
    cobj->r = val;

    return self;
}

mrb_value ruby_cocos2dx_Color4B_property_g_get(mrb_state* mrb, mrb_value self)
{
    cocos2d::Color4B* cobj = static_cast<cocos2d::Color4B*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Color4B_type));

    mrb_value ret;
    ret = mrb_fixnum_value((mrb_int)cobj->g);
    return ret;
}

mrb_value ruby_cocos2dx_Color4B_property_g_set(mrb_state* mrb, mrb_value self)
{
    cocos2d::Color4B* cobj = static_cast<cocos2d::Color4B*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Color4B_type));

    mrb_value argv;
    mrb_get_args(mrb, "o", &argv);

    bool ok = true;
    uint16_t val;
    ok = rubyval_to_uint16(mrb, argv, &val, "CC::Color4B.g");
    if (! ok) {
        mrb_raise(mrb, E_RUNTIME_ERROR, "convert to native failed : Color4B#g");
    }
    cobj->g = val;

    return self;
}

mrb_value ruby_cocos2dx_Color4B_property_b_get(mrb_state* mrb, mrb_value self)
{
    cocos2d::Color4B* cobj = static_cast<cocos2d::Color4B*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Color4B_type));

    mrb_value ret;
    ret = mrb_fixnum_value((mrb_int)cobj->b);
    return ret;
}

mrb_value ruby_cocos2dx_Color4B_property_b_set(mrb_state* mrb, mrb_value self)
{
    cocos2d::Color4B* cobj = static_cast<cocos2d::Color4B*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Color4B_type));

    mrb_value argv;
    mrb_get_args(mrb, "o", &argv);

    bool ok = true;
    uint16_t val;
    ok = rubyval_to_uint16(mrb, argv, &val, "CC::Color4B.b");
    if (! ok) {
        mrb_raise(mrb, E_RUNTIME_ERROR, "convert to native failed : Color4B#b");
    }
    cobj->b = val;

    return self;
}

mrb_value ruby_cocos2dx_Color4B_property_a_get(mrb_state* mrb, mrb_value self)
{
    cocos2d::Color4B* cobj = static_cast<cocos2d::Color4B*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Color4B_type));

    mrb_value ret;
    ret = mrb_fixnum_value((mrb_int)cobj->a);
    return ret;
}

mrb_value ruby_cocos2dx_Color4B_property_a_set(mrb_state* mrb, mrb_value self)
{
    cocos2d::Color4B* cobj = static_cast<cocos2d::Color4B*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Color4B_type));

    mrb_value argv;
    mrb_get_args(mrb, "o", &argv);

    bool ok = true;
    uint16_t val;
    ok = rubyval_to_uint16(mrb, argv, &val, "CC::Color4B.a");
    if (! ok) {
        mrb_raise(mrb, E_RUNTIME_ERROR, "convert to native failed : Color4B#a");
    }
    cobj->a = val;

    return self;
}

mrb_value ruby_cocos2dx_Color4B_constructor(mrb_state* mrb, mrb_value self)
{

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 4) {
            uint16_t arg0;
            ok = rubyval_to_uint16(mrb, argv[0], &arg0, "CC::Color4B.Color4B");
            if (!ok) { break; }
            uint16_t arg1;
            ok = rubyval_to_uint16(mrb, argv[1], &arg1, "CC::Color4B.Color4B");
            if (!ok) { break; }
            uint16_t arg2;
            ok = rubyval_to_uint16(mrb, argv[2], &arg2, "CC::Color4B.Color4B");
            if (!ok) { break; }
            uint16_t arg3;
            ok = rubyval_to_uint16(mrb, argv[3], &arg3, "CC::Color4B.Color4B");
            if (!ok) { break; }
            cocos2d::Color4B* cobj = new cocos2d::Color4B(arg0, arg1, arg2, arg3);
            DATA_TYPE(self) = &ruby_cocos2dx_Color4B_type;
            DATA_PTR(self) = cobj;
            return self;
        }
    } while (0);
    do {
        if (argc == 0) {
            cocos2d::Color4B* cobj = new cocos2d::Color4B();
            DATA_TYPE(self) = &ruby_cocos2dx_Color4B_type;
            DATA_PTR(self) = cobj;
            return self;
        }
    } while (0);
    do {
        if (argc == 1) {
            cocos2d::Color3B* arg0;
            ok = rubyval_to_object<cocos2d::Color3B>(mrb, argv[0], "CC::Color3B", &arg0);
            if (!ok) { break; }
            cocos2d::Color4B* cobj = new cocos2d::Color4B(*arg0);
            DATA_TYPE(self) = &ruby_cocos2dx_Color4B_type;
            DATA_PTR(self) = cobj;
            return self;
        }
    } while (0);
    do {
        if (argc == 1) {
            cocos2d::Color4F* arg0;
            ok = rubyval_to_object<cocos2d::Color4F>(mrb, argv[0], "CC::Color4F", &arg0);
            if (!ok) { break; }
            cocos2d::Color4B* cobj = new cocos2d::Color4B(*arg0);
            DATA_TYPE(self) = &ruby_cocos2dx_Color4B_type;
            DATA_PTR(self) = cobj;
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::Color4B#Color4B");

    return mrb_nil_value();
}


void ruby_cocos2dx_Color4B_constants_init(mrb_state* mrb, struct RClass* rclass)
{
    do {
        cocos2d::Color4B* retval_ptr = new cocos2d::Color4B(cocos2d::Color4B::WHITE);
        mrb_value ret;
        ret = object_to_rubyval<cocos2d::Color4B>(mrb, "CC::Color4B", (cocos2d::Color4B*)retval_ptr, nullptr);
        mrb_mod_cv_set(mrb, rclass, mrb_intern_cstr(mrb, "WHITE"), ret);
    } while (0);

    do {
        cocos2d::Color4B* retval_ptr = new cocos2d::Color4B(cocos2d::Color4B::YELLOW);
        mrb_value ret;
        ret = object_to_rubyval<cocos2d::Color4B>(mrb, "CC::Color4B", (cocos2d::Color4B*)retval_ptr, nullptr);
        mrb_mod_cv_set(mrb, rclass, mrb_intern_cstr(mrb, "YELLOW"), ret);
    } while (0);

    do {
        cocos2d::Color4B* retval_ptr = new cocos2d::Color4B(cocos2d::Color4B::BLUE);
        mrb_value ret;
        ret = object_to_rubyval<cocos2d::Color4B>(mrb, "CC::Color4B", (cocos2d::Color4B*)retval_ptr, nullptr);
        mrb_mod_cv_set(mrb, rclass, mrb_intern_cstr(mrb, "BLUE"), ret);
    } while (0);

    do {
        cocos2d::Color4B* retval_ptr = new cocos2d::Color4B(cocos2d::Color4B::GREEN);
        mrb_value ret;
        ret = object_to_rubyval<cocos2d::Color4B>(mrb, "CC::Color4B", (cocos2d::Color4B*)retval_ptr, nullptr);
        mrb_mod_cv_set(mrb, rclass, mrb_intern_cstr(mrb, "GREEN"), ret);
    } while (0);

    do {
        cocos2d::Color4B* retval_ptr = new cocos2d::Color4B(cocos2d::Color4B::RED);
        mrb_value ret;
        ret = object_to_rubyval<cocos2d::Color4B>(mrb, "CC::Color4B", (cocos2d::Color4B*)retval_ptr, nullptr);
        mrb_mod_cv_set(mrb, rclass, mrb_intern_cstr(mrb, "RED"), ret);
    } while (0);

    do {
        cocos2d::Color4B* retval_ptr = new cocos2d::Color4B(cocos2d::Color4B::MAGENTA);
        mrb_value ret;
        ret = object_to_rubyval<cocos2d::Color4B>(mrb, "CC::Color4B", (cocos2d::Color4B*)retval_ptr, nullptr);
        mrb_mod_cv_set(mrb, rclass, mrb_intern_cstr(mrb, "MAGENTA"), ret);
    } while (0);

    do {
        cocos2d::Color4B* retval_ptr = new cocos2d::Color4B(cocos2d::Color4B::BLACK);
        mrb_value ret;
        ret = object_to_rubyval<cocos2d::Color4B>(mrb, "CC::Color4B", (cocos2d::Color4B*)retval_ptr, nullptr);
        mrb_mod_cv_set(mrb, rclass, mrb_intern_cstr(mrb, "BLACK"), ret);
    } while (0);

    do {
        cocos2d::Color4B* retval_ptr = new cocos2d::Color4B(cocos2d::Color4B::ORANGE);
        mrb_value ret;
        ret = object_to_rubyval<cocos2d::Color4B>(mrb, "CC::Color4B", (cocos2d::Color4B*)retval_ptr, nullptr);
        mrb_mod_cv_set(mrb, rclass, mrb_intern_cstr(mrb, "ORANGE"), ret);
    } while (0);

    do {
        cocos2d::Color4B* retval_ptr = new cocos2d::Color4B(cocos2d::Color4B::GRAY);
        mrb_value ret;
        ret = object_to_rubyval<cocos2d::Color4B>(mrb, "CC::Color4B", (cocos2d::Color4B*)retval_ptr, nullptr);
        mrb_mod_cv_set(mrb, rclass, mrb_intern_cstr(mrb, "GRAY"), ret);
    } while (0);

}

void ruby_register_cocos2dx_Color4B(mrb_state* mrb, struct RClass* rmodule)
{
    std::string typeName = typeid(cocos2d::Color4B).name();
    g_rubyType[typeName] = "CC::Color4B";
    g_rubyDataType[typeName] = &ruby_cocos2dx_Color4B_type;

    struct RClass *rclass = mrb_define_class_under(mrb, rmodule, "Color4B", mrb->object_class);
    MRB_SET_INSTANCE_TT(rclass, MRB_TT_DATA);

    mrb_define_method(mrb, rclass, "initialize", ruby_cocos2dx_Color4B_constructor, ARGS_REQ(0)|ARGS_OPT(4));
    mrb_define_method(mrb, rclass, "==", ruby_cocos2dx_Color4B_operator_eq_eq, ARGS_REQ(1));
    mrb_define_method(mrb, rclass, "!=", ruby_cocos2dx_Color4B_operator_not_eq, ARGS_REQ(1));
    mrb_define_method(mrb, rclass, "r", ruby_cocos2dx_Color4B_property_r_get, ARGS_NONE());
    mrb_define_method(mrb, rclass, "r=", ruby_cocos2dx_Color4B_property_r_set, ARGS_REQ(1));
    mrb_define_method(mrb, rclass, "g", ruby_cocos2dx_Color4B_property_g_get, ARGS_NONE());
    mrb_define_method(mrb, rclass, "g=", ruby_cocos2dx_Color4B_property_g_set, ARGS_REQ(1));
    mrb_define_method(mrb, rclass, "b", ruby_cocos2dx_Color4B_property_b_get, ARGS_NONE());
    mrb_define_method(mrb, rclass, "b=", ruby_cocos2dx_Color4B_property_b_set, ARGS_REQ(1));
    mrb_define_method(mrb, rclass, "a", ruby_cocos2dx_Color4B_property_a_get, ARGS_NONE());
    mrb_define_method(mrb, rclass, "a=", ruby_cocos2dx_Color4B_property_a_set, ARGS_REQ(1));
    ruby_cocos2dx_Color4B_constants_init(mrb, rclass);
    mrb_define_class_method(mrb, rclass, "WHITE", ruby_cocos2dx_constant_get, ARGS_NONE());
    mrb_define_class_method(mrb, rclass, "YELLOW", ruby_cocos2dx_constant_get, ARGS_NONE());
    mrb_define_class_method(mrb, rclass, "BLUE", ruby_cocos2dx_constant_get, ARGS_NONE());
    mrb_define_class_method(mrb, rclass, "GREEN", ruby_cocos2dx_constant_get, ARGS_NONE());
    mrb_define_class_method(mrb, rclass, "RED", ruby_cocos2dx_constant_get, ARGS_NONE());
    mrb_define_class_method(mrb, rclass, "MAGENTA", ruby_cocos2dx_constant_get, ARGS_NONE());
    mrb_define_class_method(mrb, rclass, "BLACK", ruby_cocos2dx_constant_get, ARGS_NONE());
    mrb_define_class_method(mrb, rclass, "ORANGE", ruby_cocos2dx_constant_get, ARGS_NONE());
    mrb_define_class_method(mrb, rclass, "GRAY", ruby_cocos2dx_constant_get, ARGS_NONE());
}
mrb_value ruby_cocos2dx_Color4F_operator_eq_eq(mrb_state* mrb, mrb_value self)
{
    cocos2d::Color4F* cobj = static_cast<cocos2d::Color4F*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Color4F_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            cocos2d::Color3B* arg0;
            ok = rubyval_to_object<cocos2d::Color3B>(mrb, argv[0], "CC::Color3B", &arg0);
            if (!ok) { break; }
            bool retval = cobj->operator==(*arg0);
            mrb_value ret;
            ret = mrb_bool_value((mrb_bool)retval);
            return ret;
        }
    } while (0);
    do {
        if (argc == 1) {
            cocos2d::Color4F* arg0;
            ok = rubyval_to_object<cocos2d::Color4F>(mrb, argv[0], "CC::Color4F", &arg0);
            if (!ok) { break; }
            bool retval = cobj->operator==(*arg0);
            mrb_value ret;
            ret = mrb_bool_value((mrb_bool)retval);
            return ret;
        }
    } while (0);
    do {
        if (argc == 1) {
            cocos2d::Color4B* arg0;
            ok = rubyval_to_object<cocos2d::Color4B>(mrb, argv[0], "CC::Color4B", &arg0);
            if (!ok) { break; }
            bool retval = cobj->operator==(*arg0);
            mrb_value ret;
            ret = mrb_bool_value((mrb_bool)retval);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::Color4F#operator==");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Color4F_operator_not_eq(mrb_state* mrb, mrb_value self)
{
    cocos2d::Color4F* cobj = static_cast<cocos2d::Color4F*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Color4F_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            cocos2d::Color3B* arg0;
            ok = rubyval_to_object<cocos2d::Color3B>(mrb, argv[0], "CC::Color3B", &arg0);
            if (!ok) { break; }
            bool retval = cobj->operator!=(*arg0);
            mrb_value ret;
            ret = mrb_bool_value((mrb_bool)retval);
            return ret;
        }
    } while (0);
    do {
        if (argc == 1) {
            cocos2d::Color4F* arg0;
            ok = rubyval_to_object<cocos2d::Color4F>(mrb, argv[0], "CC::Color4F", &arg0);
            if (!ok) { break; }
            bool retval = cobj->operator!=(*arg0);
            mrb_value ret;
            ret = mrb_bool_value((mrb_bool)retval);
            return ret;
        }
    } while (0);
    do {
        if (argc == 1) {
            cocos2d::Color4B* arg0;
            ok = rubyval_to_object<cocos2d::Color4B>(mrb, argv[0], "CC::Color4B", &arg0);
            if (!ok) { break; }
            bool retval = cobj->operator!=(*arg0);
            mrb_value ret;
            ret = mrb_bool_value((mrb_bool)retval);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::Color4F#operator!=");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Color4F_equals(mrb_state* mrb, mrb_value self)
{
    cocos2d::Color4F* cobj = static_cast<cocos2d::Color4F*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Color4F_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            cocos2d::Color4F* arg0;
            ok = rubyval_to_object<cocos2d::Color4F>(mrb, argv[0], "CC::Color4F", &arg0);
            if (!ok) { break; }
            bool retval = cobj->equals(*arg0);
            mrb_value ret;
            ret = mrb_bool_value((mrb_bool)retval);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::Color4F#equals");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Color4F_property_r_get(mrb_state* mrb, mrb_value self)
{
    cocos2d::Color4F* cobj = static_cast<cocos2d::Color4F*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Color4F_type));

    mrb_value ret;
    ret = mrb_float_value(mrb, (mrb_float)cobj->r);
    return ret;
}

mrb_value ruby_cocos2dx_Color4F_property_r_set(mrb_state* mrb, mrb_value self)
{
    cocos2d::Color4F* cobj = static_cast<cocos2d::Color4F*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Color4F_type));

    mrb_value argv;
    mrb_get_args(mrb, "o", &argv);

    bool ok = true;
    double val;
    ok = rubyval_to_number(mrb, argv, (double*)&val, "CC::Color4F.r");
    if (! ok) {
        mrb_raise(mrb, E_RUNTIME_ERROR, "convert to native failed : Color4F#r");
    }
    cobj->r = val;

    return self;
}

mrb_value ruby_cocos2dx_Color4F_property_g_get(mrb_state* mrb, mrb_value self)
{
    cocos2d::Color4F* cobj = static_cast<cocos2d::Color4F*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Color4F_type));

    mrb_value ret;
    ret = mrb_float_value(mrb, (mrb_float)cobj->g);
    return ret;
}

mrb_value ruby_cocos2dx_Color4F_property_g_set(mrb_state* mrb, mrb_value self)
{
    cocos2d::Color4F* cobj = static_cast<cocos2d::Color4F*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Color4F_type));

    mrb_value argv;
    mrb_get_args(mrb, "o", &argv);

    bool ok = true;
    double val;
    ok = rubyval_to_number(mrb, argv, (double*)&val, "CC::Color4F.g");
    if (! ok) {
        mrb_raise(mrb, E_RUNTIME_ERROR, "convert to native failed : Color4F#g");
    }
    cobj->g = val;

    return self;
}

mrb_value ruby_cocos2dx_Color4F_property_b_get(mrb_state* mrb, mrb_value self)
{
    cocos2d::Color4F* cobj = static_cast<cocos2d::Color4F*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Color4F_type));

    mrb_value ret;
    ret = mrb_float_value(mrb, (mrb_float)cobj->b);
    return ret;
}

mrb_value ruby_cocos2dx_Color4F_property_b_set(mrb_state* mrb, mrb_value self)
{
    cocos2d::Color4F* cobj = static_cast<cocos2d::Color4F*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Color4F_type));

    mrb_value argv;
    mrb_get_args(mrb, "o", &argv);

    bool ok = true;
    double val;
    ok = rubyval_to_number(mrb, argv, (double*)&val, "CC::Color4F.b");
    if (! ok) {
        mrb_raise(mrb, E_RUNTIME_ERROR, "convert to native failed : Color4F#b");
    }
    cobj->b = val;

    return self;
}

mrb_value ruby_cocos2dx_Color4F_property_a_get(mrb_state* mrb, mrb_value self)
{
    cocos2d::Color4F* cobj = static_cast<cocos2d::Color4F*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Color4F_type));

    mrb_value ret;
    ret = mrb_float_value(mrb, (mrb_float)cobj->a);
    return ret;
}

mrb_value ruby_cocos2dx_Color4F_property_a_set(mrb_state* mrb, mrb_value self)
{
    cocos2d::Color4F* cobj = static_cast<cocos2d::Color4F*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Color4F_type));

    mrb_value argv;
    mrb_get_args(mrb, "o", &argv);

    bool ok = true;
    double val;
    ok = rubyval_to_number(mrb, argv, (double*)&val, "CC::Color4F.a");
    if (! ok) {
        mrb_raise(mrb, E_RUNTIME_ERROR, "convert to native failed : Color4F#a");
    }
    cobj->a = val;

    return self;
}

mrb_value ruby_cocos2dx_Color4F_constructor(mrb_state* mrb, mrb_value self)
{

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 4) {
            double arg0;
            ok = rubyval_to_number(mrb, argv[0], (double*)&arg0, "CC::Color4F.Color4F");
            if (!ok) { break; }
            double arg1;
            ok = rubyval_to_number(mrb, argv[1], (double*)&arg1, "CC::Color4F.Color4F");
            if (!ok) { break; }
            double arg2;
            ok = rubyval_to_number(mrb, argv[2], (double*)&arg2, "CC::Color4F.Color4F");
            if (!ok) { break; }
            double arg3;
            ok = rubyval_to_number(mrb, argv[3], (double*)&arg3, "CC::Color4F.Color4F");
            if (!ok) { break; }
            cocos2d::Color4F* cobj = new cocos2d::Color4F(arg0, arg1, arg2, arg3);
            DATA_TYPE(self) = &ruby_cocos2dx_Color4F_type;
            DATA_PTR(self) = cobj;
            return self;
        }
    } while (0);
    do {
        if (argc == 0) {
            cocos2d::Color4F* cobj = new cocos2d::Color4F();
            DATA_TYPE(self) = &ruby_cocos2dx_Color4F_type;
            DATA_PTR(self) = cobj;
            return self;
        }
    } while (0);
    do {
        if (argc == 1) {
            cocos2d::Color3B* arg0;
            ok = rubyval_to_object<cocos2d::Color3B>(mrb, argv[0], "CC::Color3B", &arg0);
            if (!ok) { break; }
            cocos2d::Color4F* cobj = new cocos2d::Color4F(*arg0);
            DATA_TYPE(self) = &ruby_cocos2dx_Color4F_type;
            DATA_PTR(self) = cobj;
            return self;
        }
    } while (0);
    do {
        if (argc == 1) {
            cocos2d::Color4B* arg0;
            ok = rubyval_to_object<cocos2d::Color4B>(mrb, argv[0], "CC::Color4B", &arg0);
            if (!ok) { break; }
            cocos2d::Color4F* cobj = new cocos2d::Color4F(*arg0);
            DATA_TYPE(self) = &ruby_cocos2dx_Color4F_type;
            DATA_PTR(self) = cobj;
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::Color4F#Color4F");

    return mrb_nil_value();
}


void ruby_cocos2dx_Color4F_constants_init(mrb_state* mrb, struct RClass* rclass)
{
    do {
        cocos2d::Color4F* retval_ptr = new cocos2d::Color4F(cocos2d::Color4F::WHITE);
        mrb_value ret;
        ret = object_to_rubyval<cocos2d::Color4F>(mrb, "CC::Color4F", (cocos2d::Color4F*)retval_ptr, nullptr);
        mrb_mod_cv_set(mrb, rclass, mrb_intern_cstr(mrb, "WHITE"), ret);
    } while (0);

    do {
        cocos2d::Color4F* retval_ptr = new cocos2d::Color4F(cocos2d::Color4F::YELLOW);
        mrb_value ret;
        ret = object_to_rubyval<cocos2d::Color4F>(mrb, "CC::Color4F", (cocos2d::Color4F*)retval_ptr, nullptr);
        mrb_mod_cv_set(mrb, rclass, mrb_intern_cstr(mrb, "YELLOW"), ret);
    } while (0);

    do {
        cocos2d::Color4F* retval_ptr = new cocos2d::Color4F(cocos2d::Color4F::BLUE);
        mrb_value ret;
        ret = object_to_rubyval<cocos2d::Color4F>(mrb, "CC::Color4F", (cocos2d::Color4F*)retval_ptr, nullptr);
        mrb_mod_cv_set(mrb, rclass, mrb_intern_cstr(mrb, "BLUE"), ret);
    } while (0);

    do {
        cocos2d::Color4F* retval_ptr = new cocos2d::Color4F(cocos2d::Color4F::GREEN);
        mrb_value ret;
        ret = object_to_rubyval<cocos2d::Color4F>(mrb, "CC::Color4F", (cocos2d::Color4F*)retval_ptr, nullptr);
        mrb_mod_cv_set(mrb, rclass, mrb_intern_cstr(mrb, "GREEN"), ret);
    } while (0);

    do {
        cocos2d::Color4F* retval_ptr = new cocos2d::Color4F(cocos2d::Color4F::RED);
        mrb_value ret;
        ret = object_to_rubyval<cocos2d::Color4F>(mrb, "CC::Color4F", (cocos2d::Color4F*)retval_ptr, nullptr);
        mrb_mod_cv_set(mrb, rclass, mrb_intern_cstr(mrb, "RED"), ret);
    } while (0);

    do {
        cocos2d::Color4F* retval_ptr = new cocos2d::Color4F(cocos2d::Color4F::MAGENTA);
        mrb_value ret;
        ret = object_to_rubyval<cocos2d::Color4F>(mrb, "CC::Color4F", (cocos2d::Color4F*)retval_ptr, nullptr);
        mrb_mod_cv_set(mrb, rclass, mrb_intern_cstr(mrb, "MAGENTA"), ret);
    } while (0);

    do {
        cocos2d::Color4F* retval_ptr = new cocos2d::Color4F(cocos2d::Color4F::BLACK);
        mrb_value ret;
        ret = object_to_rubyval<cocos2d::Color4F>(mrb, "CC::Color4F", (cocos2d::Color4F*)retval_ptr, nullptr);
        mrb_mod_cv_set(mrb, rclass, mrb_intern_cstr(mrb, "BLACK"), ret);
    } while (0);

    do {
        cocos2d::Color4F* retval_ptr = new cocos2d::Color4F(cocos2d::Color4F::ORANGE);
        mrb_value ret;
        ret = object_to_rubyval<cocos2d::Color4F>(mrb, "CC::Color4F", (cocos2d::Color4F*)retval_ptr, nullptr);
        mrb_mod_cv_set(mrb, rclass, mrb_intern_cstr(mrb, "ORANGE"), ret);
    } while (0);

    do {
        cocos2d::Color4F* retval_ptr = new cocos2d::Color4F(cocos2d::Color4F::GRAY);
        mrb_value ret;
        ret = object_to_rubyval<cocos2d::Color4F>(mrb, "CC::Color4F", (cocos2d::Color4F*)retval_ptr, nullptr);
        mrb_mod_cv_set(mrb, rclass, mrb_intern_cstr(mrb, "GRAY"), ret);
    } while (0);

}

void ruby_register_cocos2dx_Color4F(mrb_state* mrb, struct RClass* rmodule)
{
    std::string typeName = typeid(cocos2d::Color4F).name();
    g_rubyType[typeName] = "CC::Color4F";
    g_rubyDataType[typeName] = &ruby_cocos2dx_Color4F_type;

    struct RClass *rclass = mrb_define_class_under(mrb, rmodule, "Color4F", mrb->object_class);
    MRB_SET_INSTANCE_TT(rclass, MRB_TT_DATA);

    mrb_define_method(mrb, rclass, "initialize", ruby_cocos2dx_Color4F_constructor, ARGS_REQ(0)|ARGS_OPT(4));
    mrb_define_method(mrb, rclass, "==", ruby_cocos2dx_Color4F_operator_eq_eq, ARGS_REQ(1));
    mrb_define_method(mrb, rclass, "!=", ruby_cocos2dx_Color4F_operator_not_eq, ARGS_REQ(1));
    mrb_define_method(mrb, rclass, "equals", ruby_cocos2dx_Color4F_equals, ARGS_REQ(1));
    mrb_define_method(mrb, rclass, "r", ruby_cocos2dx_Color4F_property_r_get, ARGS_NONE());
    mrb_define_method(mrb, rclass, "r=", ruby_cocos2dx_Color4F_property_r_set, ARGS_REQ(1));
    mrb_define_method(mrb, rclass, "g", ruby_cocos2dx_Color4F_property_g_get, ARGS_NONE());
    mrb_define_method(mrb, rclass, "g=", ruby_cocos2dx_Color4F_property_g_set, ARGS_REQ(1));
    mrb_define_method(mrb, rclass, "b", ruby_cocos2dx_Color4F_property_b_get, ARGS_NONE());
    mrb_define_method(mrb, rclass, "b=", ruby_cocos2dx_Color4F_property_b_set, ARGS_REQ(1));
    mrb_define_method(mrb, rclass, "a", ruby_cocos2dx_Color4F_property_a_get, ARGS_NONE());
    mrb_define_method(mrb, rclass, "a=", ruby_cocos2dx_Color4F_property_a_set, ARGS_REQ(1));
    ruby_cocos2dx_Color4F_constants_init(mrb, rclass);
    mrb_define_class_method(mrb, rclass, "WHITE", ruby_cocos2dx_constant_get, ARGS_NONE());
    mrb_define_class_method(mrb, rclass, "YELLOW", ruby_cocos2dx_constant_get, ARGS_NONE());
    mrb_define_class_method(mrb, rclass, "BLUE", ruby_cocos2dx_constant_get, ARGS_NONE());
    mrb_define_class_method(mrb, rclass, "GREEN", ruby_cocos2dx_constant_get, ARGS_NONE());
    mrb_define_class_method(mrb, rclass, "RED", ruby_cocos2dx_constant_get, ARGS_NONE());
    mrb_define_class_method(mrb, rclass, "MAGENTA", ruby_cocos2dx_constant_get, ARGS_NONE());
    mrb_define_class_method(mrb, rclass, "BLACK", ruby_cocos2dx_constant_get, ARGS_NONE());
    mrb_define_class_method(mrb, rclass, "ORANGE", ruby_cocos2dx_constant_get, ARGS_NONE());
    mrb_define_class_method(mrb, rclass, "GRAY", ruby_cocos2dx_constant_get, ARGS_NONE());
}
void ruby_cocos2dx_global_TextVAlignment_enum_init(mrb_state* mrb)
{
    do {
        mrb_value ev = mrb_fixnum_value((mrb_int)TextVAlignment::TOP);
        mrb_gv_set(mrb, mrb_intern_cstr(mrb, "TOP"), ev);
    } while (0);

    do {
        mrb_value ev = mrb_fixnum_value((mrb_int)TextVAlignment::CENTER);
        mrb_gv_set(mrb, mrb_intern_cstr(mrb, "CENTER"), ev);
    } while (0);

    do {
        mrb_value ev = mrb_fixnum_value((mrb_int)TextVAlignment::BOTTOM);
        mrb_gv_set(mrb, mrb_intern_cstr(mrb, "BOTTOM"), ev);
    } while (0);

}
void ruby_cocos2dx_global_TextHAlignment_enum_init(mrb_state* mrb)
{
    do {
        mrb_value ev = mrb_fixnum_value((mrb_int)TextHAlignment::LEFT);
        mrb_gv_set(mrb, mrb_intern_cstr(mrb, "LEFT"), ev);
    } while (0);

    do {
        mrb_value ev = mrb_fixnum_value((mrb_int)TextHAlignment::CENTER);
        mrb_gv_set(mrb, mrb_intern_cstr(mrb, "CENTER"), ev);
    } while (0);

    do {
        mrb_value ev = mrb_fixnum_value((mrb_int)TextHAlignment::RIGHT);
        mrb_gv_set(mrb, mrb_intern_cstr(mrb, "RIGHT"), ev);
    } while (0);

}
mrb_value ruby_cocos2dx_AnimationFrameData_property_texCoords_get(mrb_state* mrb, mrb_value self)
{
    cocos2d::AnimationFrameData* cobj = static_cast<cocos2d::AnimationFrameData*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_AnimationFrameData_type));

    cocos2d::T2F_Quad* retval_ptr = new cocos2d::T2F_Quad(cobj->texCoords);
    mrb_value ret;
    ret = object_to_rubyval<cocos2d::T2F_Quad>(mrb, "CC::T2F_Quad", (cocos2d::T2F_Quad*)retval_ptr, nullptr);
    return ret;
}

mrb_value ruby_cocos2dx_AnimationFrameData_property_texCoords_set(mrb_state* mrb, mrb_value self)
{
    cocos2d::AnimationFrameData* cobj = static_cast<cocos2d::AnimationFrameData*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_AnimationFrameData_type));

    mrb_value argv;
    mrb_get_args(mrb, "o", &argv);

    bool ok = true;
    cocos2d::T2F_Quad* val;
    ok = rubyval_to_object<cocos2d::T2F_Quad>(mrb, argv, "CC::T2F_Quad", &val);
    if (! ok) {
        mrb_raise(mrb, E_RUNTIME_ERROR, "convert to native failed : AnimationFrameData#texCoords");
    }
    cobj->texCoords = *val;

    return self;
}

mrb_value ruby_cocos2dx_AnimationFrameData_property_delay_get(mrb_state* mrb, mrb_value self)
{
    cocos2d::AnimationFrameData* cobj = static_cast<cocos2d::AnimationFrameData*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_AnimationFrameData_type));

    mrb_value ret;
    ret = mrb_float_value(mrb, (mrb_float)cobj->delay);
    return ret;
}

mrb_value ruby_cocos2dx_AnimationFrameData_property_delay_set(mrb_state* mrb, mrb_value self)
{
    cocos2d::AnimationFrameData* cobj = static_cast<cocos2d::AnimationFrameData*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_AnimationFrameData_type));

    mrb_value argv;
    mrb_get_args(mrb, "o", &argv);

    bool ok = true;
    double val;
    ok = rubyval_to_number(mrb, argv, (double*)&val, "CC::AnimationFrameData.delay");
    if (! ok) {
        mrb_raise(mrb, E_RUNTIME_ERROR, "convert to native failed : AnimationFrameData#delay");
    }
    cobj->delay = val;

    return self;
}

mrb_value ruby_cocos2dx_AnimationFrameData_property_size_get(mrb_state* mrb, mrb_value self)
{
    cocos2d::AnimationFrameData* cobj = static_cast<cocos2d::AnimationFrameData*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_AnimationFrameData_type));

    cocos2d::Size* retval_ptr = new cocos2d::Size(cobj->size);
    mrb_value ret;
    ret = object_to_rubyval<cocos2d::Size>(mrb, "CC::Size", (cocos2d::Size*)retval_ptr, nullptr);
    return ret;
}

mrb_value ruby_cocos2dx_AnimationFrameData_property_size_set(mrb_state* mrb, mrb_value self)
{
    cocos2d::AnimationFrameData* cobj = static_cast<cocos2d::AnimationFrameData*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_AnimationFrameData_type));

    mrb_value argv;
    mrb_get_args(mrb, "o", &argv);

    bool ok = true;
    cocos2d::Size* val;
    ok = rubyval_to_object<cocos2d::Size>(mrb, argv, "CC::Size", &val);
    if (! ok) {
        mrb_raise(mrb, E_RUNTIME_ERROR, "convert to native failed : AnimationFrameData#size");
    }
    cobj->size = *val;

    return self;
}

mrb_value ruby_cocos2dx_AnimationFrameData_constructor(mrb_state* mrb, mrb_value self)
{
    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    cocos2d::AnimationFrameData* cobj = new cocos2d::AnimationFrameData();
    DATA_TYPE(self) = &ruby_cocos2dx_AnimationFrameData_type;
    DATA_PTR(self) = cobj;

    if (argc == 1) {
        if (mrb_hash_p(argv[0])) {
            mrb_value keys = mrb_hash_keys(mrb, argv[0]);
            mrb_int len = mrb_ary_len(mrb, keys);
            for (mrb_int i = 0; i < len; i++) {
                mrb_value hk = mrb_ary_ref(mrb, keys, i);
                mrb_value kv = mrb_hash_get(mrb, argv[0], hk);
                const char* str = nullptr;
                if (mrb_symbol_p(hk)) {
                    str = mrb_sym2name(mrb, mrb_symbol(hk));
                } else if (mrb_string_p(hk)) {
                    str = mrb_string_value_ptr(mrb, hk);
                }
                if (strcmp(str, "texCoords") == 0) {
                    bool ok = true;
                    cocos2d::T2F_Quad* val;
                    ok = rubyval_to_object<cocos2d::T2F_Quad>(mrb, kv, "CC::T2F_Quad", &val);
                    if (ok) {
                        cobj->texCoords = *val;
                    }
                }
                if (strcmp(str, "delay") == 0) {
                    bool ok = true;
                    double val;
                    ok = rubyval_to_number(mrb, kv, (double*)&val, "CC::AnimationFrameData.delay");
                    if (ok) {
                        cobj->delay = val;
                    }
                }
                if (strcmp(str, "size") == 0) {
                    bool ok = true;
                    cocos2d::Size* val;
                    ok = rubyval_to_object<cocos2d::Size>(mrb, kv, "CC::Size", &val);
                    if (ok) {
                        cobj->size = *val;
                    }
                }
            }
        }
    }

    if (argc > 1) {
        mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::AnimationFrameData#constructor");
    }

    return self;
}

void ruby_register_cocos2dx_AnimationFrameData(mrb_state* mrb, struct RClass* rmodule)
{
    std::string typeName = typeid(cocos2d::AnimationFrameData).name();
    g_rubyType[typeName] = "CC::AnimationFrameData";
    g_rubyDataType[typeName] = &ruby_cocos2dx_AnimationFrameData_type;

    struct RClass *rclass = mrb_define_class_under(mrb, rmodule, "AnimationFrameData", mrb->object_class);
    MRB_SET_INSTANCE_TT(rclass, MRB_TT_DATA);

    mrb_define_method(mrb, rclass, "initialize", ruby_cocos2dx_AnimationFrameData_constructor, ARGS_NONE());
    mrb_define_method(mrb, rclass, "tex_coords", ruby_cocos2dx_AnimationFrameData_property_texCoords_get, ARGS_NONE());
    mrb_define_method(mrb, rclass, "tex_coords=", ruby_cocos2dx_AnimationFrameData_property_texCoords_set, ARGS_REQ(1));
    mrb_define_method(mrb, rclass, "delay", ruby_cocos2dx_AnimationFrameData_property_delay_get, ARGS_NONE());
    mrb_define_method(mrb, rclass, "delay=", ruby_cocos2dx_AnimationFrameData_property_delay_set, ARGS_REQ(1));
    mrb_define_method(mrb, rclass, "size", ruby_cocos2dx_AnimationFrameData_property_size_get, ARGS_NONE());
    mrb_define_method(mrb, rclass, "size=", ruby_cocos2dx_AnimationFrameData_property_size_set, ARGS_REQ(1));
}
mrb_value ruby_cocos2dx_Texture2D_getMaxT(mrb_state* mrb, mrb_value self)
{
    cocos2d::Texture2D* cobj = static_cast<cocos2d::Texture2D*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            double retval = cobj->getMaxT();
            mrb_value ret;
            ret = mrb_float_value(mrb, (mrb_float)retval);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::Texture2D#getMaxT");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Texture2D_getStringForFormat(mrb_state* mrb, mrb_value self)
{
    cocos2d::Texture2D* cobj = static_cast<cocos2d::Texture2D*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            const char* retval = cobj->getStringForFormat();
            mrb_value ret;
            ret = mrb_str_new_cstr(mrb, (const char*)retval);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::Texture2D#getStringForFormat");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Texture2D_initWithImage(mrb_state* mrb, mrb_value self)
{
    cocos2d::Texture2D* cobj = static_cast<cocos2d::Texture2D*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 2) {
            cocos2d::Image* arg0;
            ok = rubyval_to_object<cocos2d::Image>(mrb, argv[0], "CC::Image", &arg0);
            if (!ok) { break; }
            cocos2d::Texture2D::PixelFormat arg1;
            ok = rubyval_to_int32(mrb, argv[1], (int*)&arg1, "CC::Texture2D.initWithImage");
            if (!ok) { break; }
            bool retval = cobj->initWithImage(arg0, arg1);
            mrb_value ret;
            ret = mrb_bool_value((mrb_bool)retval);
            return ret;
        }
    } while (0);
    do {
        if (argc == 1) {
            cocos2d::Image* arg0;
            ok = rubyval_to_object<cocos2d::Image>(mrb, argv[0], "CC::Image", &arg0);
            if (!ok) { break; }
            bool retval = cobj->initWithImage(arg0);
            mrb_value ret;
            ret = mrb_bool_value((mrb_bool)retval);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::Texture2D#initWithImage");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Texture2D_getMaxS(mrb_state* mrb, mrb_value self)
{
    cocos2d::Texture2D* cobj = static_cast<cocos2d::Texture2D*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            double retval = cobj->getMaxS();
            mrb_value ret;
            ret = mrb_float_value(mrb, (mrb_float)retval);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::Texture2D#getMaxS");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Texture2D_releaseGLTexture(mrb_state* mrb, mrb_value self)
{
    cocos2d::Texture2D* cobj = static_cast<cocos2d::Texture2D*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            cobj->releaseGLTexture();
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::Texture2D#releaseGLTexture");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Texture2D_hasPremultipliedAlpha(mrb_state* mrb, mrb_value self)
{
    cocos2d::Texture2D* cobj = static_cast<cocos2d::Texture2D*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            bool retval = cobj->hasPremultipliedAlpha();
            mrb_value ret;
            ret = mrb_bool_value((mrb_bool)retval);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::Texture2D#hasPremultipliedAlpha");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Texture2D_getPixelsHigh(mrb_state* mrb, mrb_value self)
{
    cocos2d::Texture2D* cobj = static_cast<cocos2d::Texture2D*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            int retval = cobj->getPixelsHigh();
            mrb_value ret;
            ret = mrb_fixnum_value((mrb_int)retval);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::Texture2D#getPixelsHigh");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Texture2D_getBitsPerPixelForFormat(mrb_state* mrb, mrb_value self)
{
    cocos2d::Texture2D* cobj = static_cast<cocos2d::Texture2D*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            cocos2d::Texture2D::PixelFormat arg0;
            ok = rubyval_to_int32(mrb, argv[0], (int*)&arg0, "CC::Texture2D.getBitsPerPixelForFormat");
            if (!ok) { break; }
            unsigned int retval = cobj->getBitsPerPixelForFormat(arg0);
            mrb_value ret;
            ret = mrb_fixnum_value((mrb_int)retval);
            return ret;
        }
    } while (0);
    do {
        if (argc == 0) {
            unsigned int retval = cobj->getBitsPerPixelForFormat();
            mrb_value ret;
            ret = mrb_fixnum_value((mrb_int)retval);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::Texture2D#getBitsPerPixelForFormat");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Texture2D_getName(mrb_state* mrb, mrb_value self)
{
    cocos2d::Texture2D* cobj = static_cast<cocos2d::Texture2D*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            unsigned int retval = cobj->getName();
            mrb_value ret;
            ret = mrb_fixnum_value((mrb_int)retval);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::Texture2D#getName");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Texture2D_initWithString(mrb_state* mrb, mrb_value self)
{
    cocos2d::Texture2D* cobj = static_cast<cocos2d::Texture2D*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 2) {
            const char* arg0;
            std::string arg0_tmp; ok = rubyval_to_std_string(mrb, argv[0], &arg0_tmp, "CC::Texture2D:initWithString"); arg0 = arg0_tmp.c_str();
            if (!ok) { break; }
            cocos2d::FontDefinition* arg1;
            ok = rubyval_to_object<cocos2d::FontDefinition>(mrb, argv[1], "CC::FontDefinition", &arg1);
            if (!ok) { break; }
            bool retval = cobj->initWithString(arg0, *arg1);
            mrb_value ret;
            ret = mrb_bool_value((mrb_bool)retval);
            return ret;
        }
    } while (0);
    do {
        if (argc == 3) {
            const char* arg0;
            std::string arg0_tmp; ok = rubyval_to_std_string(mrb, argv[0], &arg0_tmp, "CC::Texture2D:initWithString"); arg0 = arg0_tmp.c_str();
            if (!ok) { break; }
            std::string arg1;
            ok = rubyval_to_std_string(mrb, argv[1], &arg1, "CC::Texture2D.initWithString");
            if (!ok) { break; }
            double arg2;
            ok = rubyval_to_number(mrb, argv[2], (double*)&arg2, "CC::Texture2D.initWithString");
            if (!ok) { break; }
            bool retval = cobj->initWithString(arg0, arg1, arg2);
            mrb_value ret;
            ret = mrb_bool_value((mrb_bool)retval);
            return ret;
        }
    } while (0);
    do {
        if (argc == 4) {
            const char* arg0;
            std::string arg0_tmp; ok = rubyval_to_std_string(mrb, argv[0], &arg0_tmp, "CC::Texture2D:initWithString"); arg0 = arg0_tmp.c_str();
            if (!ok) { break; }
            std::string arg1;
            ok = rubyval_to_std_string(mrb, argv[1], &arg1, "CC::Texture2D.initWithString");
            if (!ok) { break; }
            double arg2;
            ok = rubyval_to_number(mrb, argv[2], (double*)&arg2, "CC::Texture2D.initWithString");
            if (!ok) { break; }
            cocos2d::Size* arg3;
            ok = rubyval_to_object<cocos2d::Size>(mrb, argv[3], "CC::Size", &arg3);
            if (!ok) { break; }
            bool retval = cobj->initWithString(arg0, arg1, arg2, *arg3);
            mrb_value ret;
            ret = mrb_bool_value((mrb_bool)retval);
            return ret;
        }
    } while (0);
    do {
        if (argc == 5) {
            const char* arg0;
            std::string arg0_tmp; ok = rubyval_to_std_string(mrb, argv[0], &arg0_tmp, "CC::Texture2D:initWithString"); arg0 = arg0_tmp.c_str();
            if (!ok) { break; }
            std::string arg1;
            ok = rubyval_to_std_string(mrb, argv[1], &arg1, "CC::Texture2D.initWithString");
            if (!ok) { break; }
            double arg2;
            ok = rubyval_to_number(mrb, argv[2], (double*)&arg2, "CC::Texture2D.initWithString");
            if (!ok) { break; }
            cocos2d::Size* arg3;
            ok = rubyval_to_object<cocos2d::Size>(mrb, argv[3], "CC::Size", &arg3);
            if (!ok) { break; }
            cocos2d::TextHAlignment arg4;
            ok = rubyval_to_int32(mrb, argv[4], (int*)&arg4, "CC::Texture2D.initWithString");
            if (!ok) { break; }
            bool retval = cobj->initWithString(arg0, arg1, arg2, *arg3, arg4);
            mrb_value ret;
            ret = mrb_bool_value((mrb_bool)retval);
            return ret;
        }
    } while (0);
    do {
        if (argc == 6) {
            const char* arg0;
            std::string arg0_tmp; ok = rubyval_to_std_string(mrb, argv[0], &arg0_tmp, "CC::Texture2D:initWithString"); arg0 = arg0_tmp.c_str();
            if (!ok) { break; }
            std::string arg1;
            ok = rubyval_to_std_string(mrb, argv[1], &arg1, "CC::Texture2D.initWithString");
            if (!ok) { break; }
            double arg2;
            ok = rubyval_to_number(mrb, argv[2], (double*)&arg2, "CC::Texture2D.initWithString");
            if (!ok) { break; }
            cocos2d::Size* arg3;
            ok = rubyval_to_object<cocos2d::Size>(mrb, argv[3], "CC::Size", &arg3);
            if (!ok) { break; }
            cocos2d::TextHAlignment arg4;
            ok = rubyval_to_int32(mrb, argv[4], (int*)&arg4, "CC::Texture2D.initWithString");
            if (!ok) { break; }
            cocos2d::TextVAlignment arg5;
            ok = rubyval_to_int32(mrb, argv[5], (int*)&arg5, "CC::Texture2D.initWithString");
            if (!ok) { break; }
            bool retval = cobj->initWithString(arg0, arg1, arg2, *arg3, arg4, arg5);
            mrb_value ret;
            ret = mrb_bool_value((mrb_bool)retval);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::Texture2D#initWithString");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Texture2D_setMaxT(mrb_state* mrb, mrb_value self)
{
    cocos2d::Texture2D* cobj = static_cast<cocos2d::Texture2D*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            double arg0;
            ok = rubyval_to_number(mrb, argv[0], (double*)&arg0, "CC::Texture2D.setMaxT");
            if (!ok) { break; }
            cobj->setMaxT(arg0);
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::Texture2D#setMaxT");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Texture2D_drawInRect(mrb_state* mrb, mrb_value self)
{
    cocos2d::Texture2D* cobj = static_cast<cocos2d::Texture2D*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            cocos2d::Rect* arg0;
            ok = rubyval_to_object<cocos2d::Rect>(mrb, argv[0], "CC::Rect", &arg0);
            if (!ok) { break; }
            cobj->drawInRect(*arg0);
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::Texture2D#drawInRect");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Texture2D_getContentSize(mrb_state* mrb, mrb_value self)
{
    cocos2d::Texture2D* cobj = static_cast<cocos2d::Texture2D*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            cocos2d::Size retval = cobj->getContentSize();
            cocos2d::Size* retval_ptr = new cocos2d::Size(retval);
            mrb_value ret;
            ret = object_to_rubyval<cocos2d::Size>(mrb, "CC::Size", (cocos2d::Size*)retval_ptr, nullptr);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::Texture2D#getContentSize");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Texture2D_setAliasTexParameters(mrb_state* mrb, mrb_value self)
{
    cocos2d::Texture2D* cobj = static_cast<cocos2d::Texture2D*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            cobj->setAliasTexParameters();
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::Texture2D#setAliasTexParameters");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Texture2D_setAntiAliasTexParameters(mrb_state* mrb, mrb_value self)
{
    cocos2d::Texture2D* cobj = static_cast<cocos2d::Texture2D*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            cobj->setAntiAliasTexParameters();
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::Texture2D#setAntiAliasTexParameters");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Texture2D_generateMipmap(mrb_state* mrb, mrb_value self)
{
    cocos2d::Texture2D* cobj = static_cast<cocos2d::Texture2D*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            cobj->generateMipmap();
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::Texture2D#generateMipmap");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Texture2D_getDescription(mrb_state* mrb, mrb_value self)
{
    cocos2d::Texture2D* cobj = static_cast<cocos2d::Texture2D*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            std::string retval = cobj->getDescription();
            mrb_value ret;
            ret = mrb_str_new_cstr(mrb, retval.c_str());
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::Texture2D#getDescription");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Texture2D_getPixelFormat(mrb_state* mrb, mrb_value self)
{
    cocos2d::Texture2D* cobj = static_cast<cocos2d::Texture2D*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            int retval = (int)cobj->getPixelFormat();
            mrb_value ret;
            ret = mrb_fixnum_value((mrb_int)retval);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::Texture2D#getPixelFormat");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Texture2D_setGLProgram(mrb_state* mrb, mrb_value self)
{
    cocos2d::Texture2D* cobj = static_cast<cocos2d::Texture2D*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            cocos2d::GLProgram* arg0;
            ok = rubyval_to_object<cocos2d::GLProgram>(mrb, argv[0], "CC::GLProgram", &arg0);
            if (!ok) { break; }
            cobj->setGLProgram(arg0);
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::Texture2D#setGLProgram");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Texture2D_getContentSizeInPixels(mrb_state* mrb, mrb_value self)
{
    cocos2d::Texture2D* cobj = static_cast<cocos2d::Texture2D*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            cocos2d::Size retval = cobj->getContentSizeInPixels();
            cocos2d::Size* retval_ptr = new cocos2d::Size(retval);
            mrb_value ret;
            ret = object_to_rubyval<cocos2d::Size>(mrb, "CC::Size", (cocos2d::Size*)retval_ptr, nullptr);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::Texture2D#getContentSizeInPixels");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Texture2D_getPixelsWide(mrb_state* mrb, mrb_value self)
{
    cocos2d::Texture2D* cobj = static_cast<cocos2d::Texture2D*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            int retval = cobj->getPixelsWide();
            mrb_value ret;
            ret = mrb_fixnum_value((mrb_int)retval);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::Texture2D#getPixelsWide");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Texture2D_drawAtPoint(mrb_state* mrb, mrb_value self)
{
    cocos2d::Texture2D* cobj = static_cast<cocos2d::Texture2D*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            cocos2d::Vec2* arg0;
            ok = rubyval_to_object<cocos2d::Vec2>(mrb, argv[0], "CC::Vec2", &arg0);
            if (!ok) { break; }
            cobj->drawAtPoint(*arg0);
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::Texture2D#drawAtPoint");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Texture2D_getGLProgram(mrb_state* mrb, mrb_value self)
{
    cocos2d::Texture2D* cobj = static_cast<cocos2d::Texture2D*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            cocos2d::GLProgram* retval = cobj->getGLProgram();
            mrb_value ret;
            ret = object_to_rubyval<cocos2d::GLProgram>(mrb, "CC::GLProgram", (cocos2d::GLProgram*)retval, nullptr);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::Texture2D#getGLProgram");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Texture2D_hasMipmaps(mrb_state* mrb, mrb_value self)
{
    cocos2d::Texture2D* cobj = static_cast<cocos2d::Texture2D*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            bool retval = cobj->hasMipmaps();
            mrb_value ret;
            ret = mrb_bool_value((mrb_bool)retval);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::Texture2D#hasMipmaps");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Texture2D_setMaxS(mrb_state* mrb, mrb_value self)
{
    cocos2d::Texture2D* cobj = static_cast<cocos2d::Texture2D*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            double arg0;
            ok = rubyval_to_number(mrb, argv[0], (double*)&arg0, "CC::Texture2D.setMaxS");
            if (!ok) { break; }
            cobj->setMaxS(arg0);
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::Texture2D#setMaxS");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Texture2D_setDefaultAlphaPixelFormat_static(mrb_state* mrb, mrb_value self)
{
    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            cocos2d::Texture2D::PixelFormat arg0;
            ok = rubyval_to_int32(mrb, argv[0], (int*)&arg0, "CC::Texture2D.setDefaultAlphaPixelFormat");
            if (!ok) { break; }

            cocos2d::Texture2D::setDefaultAlphaPixelFormat(arg0);
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined static method : cocos2d::Texture2D#setDefaultAlphaPixelFormat");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Texture2D_getDefaultAlphaPixelFormat_static(mrb_state* mrb, mrb_value self)
{
    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            int retval = (int)cocos2d::Texture2D::getDefaultAlphaPixelFormat();
            mrb_value ret;
            ret = mrb_fixnum_value((mrb_int)retval);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined static method : cocos2d::Texture2D#getDefaultAlphaPixelFormat");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Texture2D_constructor(mrb_state* mrb, mrb_value self)
{

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            cocos2d::Texture2D* cobj = new cocos2d::Texture2D();
            DATA_TYPE(self) = &ruby_cocos2dx_Ref_type;
            DATA_PTR(self) = cobj;
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::Texture2D#Texture2D");

    return mrb_nil_value();
}


void ruby_cocos2dx_Texture2D_PixelFormat_enum_init(mrb_state* mrb, struct RClass* renum)
{
    do {
        mrb_value ev = mrb_fixnum_value((mrb_int)cocos2d::Texture2D::PixelFormat::AUTO);
        mrb_mod_cv_set(mrb, renum, mrb_intern_cstr(mrb, "AUTO"), ev);
    } while (0);

    do {
        mrb_value ev = mrb_fixnum_value((mrb_int)cocos2d::Texture2D::PixelFormat::BGRA8888);
        mrb_mod_cv_set(mrb, renum, mrb_intern_cstr(mrb, "BGRA8888"), ev);
    } while (0);

    do {
        mrb_value ev = mrb_fixnum_value((mrb_int)cocos2d::Texture2D::PixelFormat::RGBA8888);
        mrb_mod_cv_set(mrb, renum, mrb_intern_cstr(mrb, "RGBA8888"), ev);
    } while (0);

    do {
        mrb_value ev = mrb_fixnum_value((mrb_int)cocos2d::Texture2D::PixelFormat::RGB888);
        mrb_mod_cv_set(mrb, renum, mrb_intern_cstr(mrb, "RGB888"), ev);
    } while (0);

    do {
        mrb_value ev = mrb_fixnum_value((mrb_int)cocos2d::Texture2D::PixelFormat::RGB565);
        mrb_mod_cv_set(mrb, renum, mrb_intern_cstr(mrb, "RGB565"), ev);
    } while (0);

    do {
        mrb_value ev = mrb_fixnum_value((mrb_int)cocos2d::Texture2D::PixelFormat::A8);
        mrb_mod_cv_set(mrb, renum, mrb_intern_cstr(mrb, "A8"), ev);
    } while (0);

    do {
        mrb_value ev = mrb_fixnum_value((mrb_int)cocos2d::Texture2D::PixelFormat::I8);
        mrb_mod_cv_set(mrb, renum, mrb_intern_cstr(mrb, "I8"), ev);
    } while (0);

    do {
        mrb_value ev = mrb_fixnum_value((mrb_int)cocos2d::Texture2D::PixelFormat::AI88);
        mrb_mod_cv_set(mrb, renum, mrb_intern_cstr(mrb, "AI88"), ev);
    } while (0);

    do {
        mrb_value ev = mrb_fixnum_value((mrb_int)cocos2d::Texture2D::PixelFormat::RGBA4444);
        mrb_mod_cv_set(mrb, renum, mrb_intern_cstr(mrb, "RGBA4444"), ev);
    } while (0);

    do {
        mrb_value ev = mrb_fixnum_value((mrb_int)cocos2d::Texture2D::PixelFormat::RGB5A1);
        mrb_mod_cv_set(mrb, renum, mrb_intern_cstr(mrb, "RGB5A1"), ev);
    } while (0);

    do {
        mrb_value ev = mrb_fixnum_value((mrb_int)cocos2d::Texture2D::PixelFormat::PVRTC4);
        mrb_mod_cv_set(mrb, renum, mrb_intern_cstr(mrb, "PVRTC4"), ev);
    } while (0);

    do {
        mrb_value ev = mrb_fixnum_value((mrb_int)cocos2d::Texture2D::PixelFormat::PVRTC4A);
        mrb_mod_cv_set(mrb, renum, mrb_intern_cstr(mrb, "PVRTC4A"), ev);
    } while (0);

    do {
        mrb_value ev = mrb_fixnum_value((mrb_int)cocos2d::Texture2D::PixelFormat::PVRTC2);
        mrb_mod_cv_set(mrb, renum, mrb_intern_cstr(mrb, "PVRTC2"), ev);
    } while (0);

    do {
        mrb_value ev = mrb_fixnum_value((mrb_int)cocos2d::Texture2D::PixelFormat::PVRTC2A);
        mrb_mod_cv_set(mrb, renum, mrb_intern_cstr(mrb, "PVRTC2A"), ev);
    } while (0);

    do {
        mrb_value ev = mrb_fixnum_value((mrb_int)cocos2d::Texture2D::PixelFormat::ETC);
        mrb_mod_cv_set(mrb, renum, mrb_intern_cstr(mrb, "ETC"), ev);
    } while (0);

    do {
        mrb_value ev = mrb_fixnum_value((mrb_int)cocos2d::Texture2D::PixelFormat::S3TC_DXT1);
        mrb_mod_cv_set(mrb, renum, mrb_intern_cstr(mrb, "S3TC_DXT1"), ev);
    } while (0);

    do {
        mrb_value ev = mrb_fixnum_value((mrb_int)cocos2d::Texture2D::PixelFormat::S3TC_DXT3);
        mrb_mod_cv_set(mrb, renum, mrb_intern_cstr(mrb, "S3TC_DXT3"), ev);
    } while (0);

    do {
        mrb_value ev = mrb_fixnum_value((mrb_int)cocos2d::Texture2D::PixelFormat::S3TC_DXT5);
        mrb_mod_cv_set(mrb, renum, mrb_intern_cstr(mrb, "S3TC_DXT5"), ev);
    } while (0);

    do {
        mrb_value ev = mrb_fixnum_value((mrb_int)cocos2d::Texture2D::PixelFormat::ATC_RGB);
        mrb_mod_cv_set(mrb, renum, mrb_intern_cstr(mrb, "ATC_RGB"), ev);
    } while (0);

    do {
        mrb_value ev = mrb_fixnum_value((mrb_int)cocos2d::Texture2D::PixelFormat::ATC_EXPLICIT_ALPHA);
        mrb_mod_cv_set(mrb, renum, mrb_intern_cstr(mrb, "ATC_EXPLICIT_ALPHA"), ev);
    } while (0);

    do {
        mrb_value ev = mrb_fixnum_value((mrb_int)cocos2d::Texture2D::PixelFormat::ATC_INTERPOLATED_ALPHA);
        mrb_mod_cv_set(mrb, renum, mrb_intern_cstr(mrb, "ATC_INTERPOLATED_ALPHA"), ev);
    } while (0);

    do {
        mrb_value ev = mrb_fixnum_value((mrb_int)cocos2d::Texture2D::PixelFormat::DEFAULT);
        mrb_mod_cv_set(mrb, renum, mrb_intern_cstr(mrb, "DEFAULT"), ev);
    } while (0);

    do {
        mrb_value ev = mrb_fixnum_value((mrb_int)cocos2d::Texture2D::PixelFormat::NONE);
        mrb_mod_cv_set(mrb, renum, mrb_intern_cstr(mrb, "NONE"), ev);
    } while (0);

}

void ruby_register_cocos2dx_Texture2D(mrb_state* mrb, struct RClass* rmodule)
{
    std::string typeName = typeid(cocos2d::Texture2D).name();
    g_rubyType[typeName] = "CC::Texture2D";
    g_rubyDataType[typeName] = &ruby_cocos2dx_Ref_type;

    struct RClass* p_rmodule = mrb->object_class;
    p_rmodule = mrb_module_get_under(mrb, p_rmodule, "CC");
    struct RClass* p_rclass = mrb_class_get_under(mrb, p_rmodule, "Ref");
    struct RClass *rclass = mrb_define_class_under(mrb, rmodule, "Texture2D", p_rclass);
    MRB_SET_INSTANCE_TT(rclass, MRB_TT_DATA);

    mrb_define_method(mrb, rclass, "initialize", ruby_cocos2dx_Texture2D_constructor, ARGS_NONE());
    mrb_define_method(mrb, rclass, "get_max_t", ruby_cocos2dx_Texture2D_getMaxT, ARGS_NONE());
    mrb_define_method(mrb, rclass, "get_string_for_format", ruby_cocos2dx_Texture2D_getStringForFormat, ARGS_NONE());
    mrb_define_method(mrb, rclass, "init_with_image", ruby_cocos2dx_Texture2D_initWithImage, ARGS_REQ(1)|ARGS_OPT(1));
    mrb_define_method(mrb, rclass, "get_max_s", ruby_cocos2dx_Texture2D_getMaxS, ARGS_NONE());
    mrb_define_method(mrb, rclass, "release_gltexture", ruby_cocos2dx_Texture2D_releaseGLTexture, ARGS_NONE());
    mrb_define_method(mrb, rclass, "has_premultiplied_alpha", ruby_cocos2dx_Texture2D_hasPremultipliedAlpha, ARGS_NONE());
    mrb_define_method(mrb, rclass, "get_pixels_high", ruby_cocos2dx_Texture2D_getPixelsHigh, ARGS_NONE());
    mrb_define_method(mrb, rclass, "get_bits_per_pixel_for_format", ruby_cocos2dx_Texture2D_getBitsPerPixelForFormat, ARGS_REQ(0)|ARGS_OPT(1));
    mrb_define_method(mrb, rclass, "get_name", ruby_cocos2dx_Texture2D_getName, ARGS_NONE());
    mrb_define_method(mrb, rclass, "init_with_string", ruby_cocos2dx_Texture2D_initWithString, ARGS_REQ(2)|ARGS_OPT(4));
    mrb_define_method(mrb, rclass, "set_max_t", ruby_cocos2dx_Texture2D_setMaxT, ARGS_REQ(1));
    mrb_define_method(mrb, rclass, "draw_in_rect", ruby_cocos2dx_Texture2D_drawInRect, ARGS_REQ(1));
    mrb_define_method(mrb, rclass, "get_content_size", ruby_cocos2dx_Texture2D_getContentSize, ARGS_NONE());
    mrb_define_method(mrb, rclass, "set_alias_tex_parameters", ruby_cocos2dx_Texture2D_setAliasTexParameters, ARGS_NONE());
    mrb_define_method(mrb, rclass, "set_anti_alias_tex_parameters", ruby_cocos2dx_Texture2D_setAntiAliasTexParameters, ARGS_NONE());
    mrb_define_method(mrb, rclass, "generate_mipmap", ruby_cocos2dx_Texture2D_generateMipmap, ARGS_NONE());
    mrb_define_method(mrb, rclass, "get_description", ruby_cocos2dx_Texture2D_getDescription, ARGS_NONE());
    mrb_define_method(mrb, rclass, "get_pixel_format", ruby_cocos2dx_Texture2D_getPixelFormat, ARGS_NONE());
    mrb_define_method(mrb, rclass, "set_glprogram", ruby_cocos2dx_Texture2D_setGLProgram, ARGS_REQ(1));
    mrb_define_method(mrb, rclass, "get_content_size_in_pixels", ruby_cocos2dx_Texture2D_getContentSizeInPixels, ARGS_NONE());
    mrb_define_method(mrb, rclass, "get_pixels_wide", ruby_cocos2dx_Texture2D_getPixelsWide, ARGS_NONE());
    mrb_define_method(mrb, rclass, "draw_at_point", ruby_cocos2dx_Texture2D_drawAtPoint, ARGS_REQ(1));
    mrb_define_method(mrb, rclass, "get_glprogram", ruby_cocos2dx_Texture2D_getGLProgram, ARGS_NONE());
    mrb_define_method(mrb, rclass, "has_mipmaps", ruby_cocos2dx_Texture2D_hasMipmaps, ARGS_NONE());
    mrb_define_method(mrb, rclass, "set_max_s", ruby_cocos2dx_Texture2D_setMaxS, ARGS_REQ(1));
    mrb_define_class_method(mrb, rclass, "set_default_alpha_pixel_format", ruby_cocos2dx_Texture2D_setDefaultAlphaPixelFormat_static, ARGS_REQ(1));
    mrb_define_class_method(mrb, rclass, "get_default_alpha_pixel_format", ruby_cocos2dx_Texture2D_getDefaultAlphaPixelFormat_static, ARGS_NONE());
    struct RClass* renum_PixelFormat = mrb_define_module_under(mrb, rclass, "PixelFormat");
    ruby_cocos2dx_Texture2D_PixelFormat_enum_init(mrb, renum_PixelFormat);
    mrb_define_class_method(mrb, renum_PixelFormat, "AUTO", ruby_cocos2dx_constant_get, ARGS_NONE());
    mrb_define_class_method(mrb, renum_PixelFormat, "BGRA8888", ruby_cocos2dx_constant_get, ARGS_NONE());
    mrb_define_class_method(mrb, renum_PixelFormat, "RGBA8888", ruby_cocos2dx_constant_get, ARGS_NONE());
    mrb_define_class_method(mrb, renum_PixelFormat, "RGB888", ruby_cocos2dx_constant_get, ARGS_NONE());
    mrb_define_class_method(mrb, renum_PixelFormat, "RGB565", ruby_cocos2dx_constant_get, ARGS_NONE());
    mrb_define_class_method(mrb, renum_PixelFormat, "A8", ruby_cocos2dx_constant_get, ARGS_NONE());
    mrb_define_class_method(mrb, renum_PixelFormat, "I8", ruby_cocos2dx_constant_get, ARGS_NONE());
    mrb_define_class_method(mrb, renum_PixelFormat, "AI88", ruby_cocos2dx_constant_get, ARGS_NONE());
    mrb_define_class_method(mrb, renum_PixelFormat, "RGBA4444", ruby_cocos2dx_constant_get, ARGS_NONE());
    mrb_define_class_method(mrb, renum_PixelFormat, "RGB5A1", ruby_cocos2dx_constant_get, ARGS_NONE());
    mrb_define_class_method(mrb, renum_PixelFormat, "PVRTC4", ruby_cocos2dx_constant_get, ARGS_NONE());
    mrb_define_class_method(mrb, renum_PixelFormat, "PVRTC4A", ruby_cocos2dx_constant_get, ARGS_NONE());
    mrb_define_class_method(mrb, renum_PixelFormat, "PVRTC2", ruby_cocos2dx_constant_get, ARGS_NONE());
    mrb_define_class_method(mrb, renum_PixelFormat, "PVRTC2A", ruby_cocos2dx_constant_get, ARGS_NONE());
    mrb_define_class_method(mrb, renum_PixelFormat, "ETC", ruby_cocos2dx_constant_get, ARGS_NONE());
    mrb_define_class_method(mrb, renum_PixelFormat, "S3TC_DXT1", ruby_cocos2dx_constant_get, ARGS_NONE());
    mrb_define_class_method(mrb, renum_PixelFormat, "S3TC_DXT3", ruby_cocos2dx_constant_get, ARGS_NONE());
    mrb_define_class_method(mrb, renum_PixelFormat, "S3TC_DXT5", ruby_cocos2dx_constant_get, ARGS_NONE());
    mrb_define_class_method(mrb, renum_PixelFormat, "ATC_RGB", ruby_cocos2dx_constant_get, ARGS_NONE());
    mrb_define_class_method(mrb, renum_PixelFormat, "ATC_EXPLICIT_ALPHA", ruby_cocos2dx_constant_get, ARGS_NONE());
    mrb_define_class_method(mrb, renum_PixelFormat, "ATC_INTERPOLATED_ALPHA", ruby_cocos2dx_constant_get, ARGS_NONE());
    mrb_define_class_method(mrb, renum_PixelFormat, "DEFAULT", ruby_cocos2dx_constant_get, ARGS_NONE());
    mrb_define_class_method(mrb, renum_PixelFormat, "NONE", ruby_cocos2dx_constant_get, ARGS_NONE());
}
void ruby_cocos2dx_global_LanguageType_enum_init(mrb_state* mrb)
{
    do {
        mrb_value ev = mrb_fixnum_value((mrb_int)LanguageType::ENGLISH);
        mrb_gv_set(mrb, mrb_intern_cstr(mrb, "ENGLISH"), ev);
    } while (0);

    do {
        mrb_value ev = mrb_fixnum_value((mrb_int)LanguageType::CHINESE);
        mrb_gv_set(mrb, mrb_intern_cstr(mrb, "CHINESE"), ev);
    } while (0);

    do {
        mrb_value ev = mrb_fixnum_value((mrb_int)LanguageType::FRENCH);
        mrb_gv_set(mrb, mrb_intern_cstr(mrb, "FRENCH"), ev);
    } while (0);

    do {
        mrb_value ev = mrb_fixnum_value((mrb_int)LanguageType::ITALIAN);
        mrb_gv_set(mrb, mrb_intern_cstr(mrb, "ITALIAN"), ev);
    } while (0);

    do {
        mrb_value ev = mrb_fixnum_value((mrb_int)LanguageType::GERMAN);
        mrb_gv_set(mrb, mrb_intern_cstr(mrb, "GERMAN"), ev);
    } while (0);

    do {
        mrb_value ev = mrb_fixnum_value((mrb_int)LanguageType::SPANISH);
        mrb_gv_set(mrb, mrb_intern_cstr(mrb, "SPANISH"), ev);
    } while (0);

    do {
        mrb_value ev = mrb_fixnum_value((mrb_int)LanguageType::DUTCH);
        mrb_gv_set(mrb, mrb_intern_cstr(mrb, "DUTCH"), ev);
    } while (0);

    do {
        mrb_value ev = mrb_fixnum_value((mrb_int)LanguageType::RUSSIAN);
        mrb_gv_set(mrb, mrb_intern_cstr(mrb, "RUSSIAN"), ev);
    } while (0);

    do {
        mrb_value ev = mrb_fixnum_value((mrb_int)LanguageType::KOREAN);
        mrb_gv_set(mrb, mrb_intern_cstr(mrb, "KOREAN"), ev);
    } while (0);

    do {
        mrb_value ev = mrb_fixnum_value((mrb_int)LanguageType::JAPANESE);
        mrb_gv_set(mrb, mrb_intern_cstr(mrb, "JAPANESE"), ev);
    } while (0);

    do {
        mrb_value ev = mrb_fixnum_value((mrb_int)LanguageType::HUNGARIAN);
        mrb_gv_set(mrb, mrb_intern_cstr(mrb, "HUNGARIAN"), ev);
    } while (0);

    do {
        mrb_value ev = mrb_fixnum_value((mrb_int)LanguageType::PORTUGUESE);
        mrb_gv_set(mrb, mrb_intern_cstr(mrb, "PORTUGUESE"), ev);
    } while (0);

    do {
        mrb_value ev = mrb_fixnum_value((mrb_int)LanguageType::ARABIC);
        mrb_gv_set(mrb, mrb_intern_cstr(mrb, "ARABIC"), ev);
    } while (0);

    do {
        mrb_value ev = mrb_fixnum_value((mrb_int)LanguageType::NORWEGIAN);
        mrb_gv_set(mrb, mrb_intern_cstr(mrb, "NORWEGIAN"), ev);
    } while (0);

    do {
        mrb_value ev = mrb_fixnum_value((mrb_int)LanguageType::POLISH);
        mrb_gv_set(mrb, mrb_intern_cstr(mrb, "POLISH"), ev);
    } while (0);

    do {
        mrb_value ev = mrb_fixnum_value((mrb_int)LanguageType::TURKISH);
        mrb_gv_set(mrb, mrb_intern_cstr(mrb, "TURKISH"), ev);
    } while (0);

    do {
        mrb_value ev = mrb_fixnum_value((mrb_int)LanguageType::UKRAINIAN);
        mrb_gv_set(mrb, mrb_intern_cstr(mrb, "UKRAINIAN"), ev);
    } while (0);

}
mrb_value ruby_cocos2dx_Touch_getPreviousLocationInView(mrb_state* mrb, mrb_value self)
{
    cocos2d::Touch* cobj = static_cast<cocos2d::Touch*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            cocos2d::Vec2 retval = cobj->getPreviousLocationInView();
            cocos2d::Vec2* retval_ptr = new cocos2d::Vec2(retval);
            mrb_value ret;
            ret = object_to_rubyval<cocos2d::Vec2>(mrb, "CC::Vec2", (cocos2d::Vec2*)retval_ptr, nullptr);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::Touch#getPreviousLocationInView");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Touch_getLocation(mrb_state* mrb, mrb_value self)
{
    cocos2d::Touch* cobj = static_cast<cocos2d::Touch*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            cocos2d::Vec2 retval = cobj->getLocation();
            cocos2d::Vec2* retval_ptr = new cocos2d::Vec2(retval);
            mrb_value ret;
            ret = object_to_rubyval<cocos2d::Vec2>(mrb, "CC::Vec2", (cocos2d::Vec2*)retval_ptr, nullptr);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::Touch#getLocation");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Touch_getDelta(mrb_state* mrb, mrb_value self)
{
    cocos2d::Touch* cobj = static_cast<cocos2d::Touch*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            cocos2d::Vec2 retval = cobj->getDelta();
            cocos2d::Vec2* retval_ptr = new cocos2d::Vec2(retval);
            mrb_value ret;
            ret = object_to_rubyval<cocos2d::Vec2>(mrb, "CC::Vec2", (cocos2d::Vec2*)retval_ptr, nullptr);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::Touch#getDelta");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Touch_getStartLocationInView(mrb_state* mrb, mrb_value self)
{
    cocos2d::Touch* cobj = static_cast<cocos2d::Touch*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            cocos2d::Vec2 retval = cobj->getStartLocationInView();
            cocos2d::Vec2* retval_ptr = new cocos2d::Vec2(retval);
            mrb_value ret;
            ret = object_to_rubyval<cocos2d::Vec2>(mrb, "CC::Vec2", (cocos2d::Vec2*)retval_ptr, nullptr);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::Touch#getStartLocationInView");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Touch_getStartLocation(mrb_state* mrb, mrb_value self)
{
    cocos2d::Touch* cobj = static_cast<cocos2d::Touch*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            cocos2d::Vec2 retval = cobj->getStartLocation();
            cocos2d::Vec2* retval_ptr = new cocos2d::Vec2(retval);
            mrb_value ret;
            ret = object_to_rubyval<cocos2d::Vec2>(mrb, "CC::Vec2", (cocos2d::Vec2*)retval_ptr, nullptr);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::Touch#getStartLocation");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Touch_getID(mrb_state* mrb, mrb_value self)
{
    cocos2d::Touch* cobj = static_cast<cocos2d::Touch*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            int retval = cobj->getID();
            mrb_value ret;
            ret = mrb_fixnum_value((mrb_int)retval);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::Touch#getID");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Touch_setTouchInfo(mrb_state* mrb, mrb_value self)
{
    cocos2d::Touch* cobj = static_cast<cocos2d::Touch*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 3) {
            int arg0;
            ok = rubyval_to_int32(mrb, argv[0], (int*)&arg0, "CC::Touch.setTouchInfo");
            if (!ok) { break; }
            double arg1;
            ok = rubyval_to_number(mrb, argv[1], (double*)&arg1, "CC::Touch.setTouchInfo");
            if (!ok) { break; }
            double arg2;
            ok = rubyval_to_number(mrb, argv[2], (double*)&arg2, "CC::Touch.setTouchInfo");
            if (!ok) { break; }
            cobj->setTouchInfo(arg0, arg1, arg2);
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::Touch#setTouchInfo");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Touch_getLocationInView(mrb_state* mrb, mrb_value self)
{
    cocos2d::Touch* cobj = static_cast<cocos2d::Touch*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            cocos2d::Vec2 retval = cobj->getLocationInView();
            cocos2d::Vec2* retval_ptr = new cocos2d::Vec2(retval);
            mrb_value ret;
            ret = object_to_rubyval<cocos2d::Vec2>(mrb, "CC::Vec2", (cocos2d::Vec2*)retval_ptr, nullptr);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::Touch#getLocationInView");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Touch_getPreviousLocation(mrb_state* mrb, mrb_value self)
{
    cocos2d::Touch* cobj = static_cast<cocos2d::Touch*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            cocos2d::Vec2 retval = cobj->getPreviousLocation();
            cocos2d::Vec2* retval_ptr = new cocos2d::Vec2(retval);
            mrb_value ret;
            ret = object_to_rubyval<cocos2d::Vec2>(mrb, "CC::Vec2", (cocos2d::Vec2*)retval_ptr, nullptr);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::Touch#getPreviousLocation");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Touch_constructor(mrb_state* mrb, mrb_value self)
{

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            cocos2d::Touch* cobj = new cocos2d::Touch();
            DATA_TYPE(self) = &ruby_cocos2dx_Ref_type;
            DATA_PTR(self) = cobj;
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::Touch#Touch");

    return mrb_nil_value();
}


void ruby_cocos2dx_Touch_DispatchMode_enum_init(mrb_state* mrb, struct RClass* renum)
{
    do {
        mrb_value ev = mrb_fixnum_value((mrb_int)cocos2d::Touch::DispatchMode::ALL_AT_ONCE);
        mrb_mod_cv_set(mrb, renum, mrb_intern_cstr(mrb, "ALL_AT_ONCE"), ev);
    } while (0);

    do {
        mrb_value ev = mrb_fixnum_value((mrb_int)cocos2d::Touch::DispatchMode::ONE_BY_ONE);
        mrb_mod_cv_set(mrb, renum, mrb_intern_cstr(mrb, "ONE_BY_ONE"), ev);
    } while (0);

}

void ruby_register_cocos2dx_Touch(mrb_state* mrb, struct RClass* rmodule)
{
    std::string typeName = typeid(cocos2d::Touch).name();
    g_rubyType[typeName] = "CC::Touch";
    g_rubyDataType[typeName] = &ruby_cocos2dx_Ref_type;

    struct RClass* p_rmodule = mrb->object_class;
    p_rmodule = mrb_module_get_under(mrb, p_rmodule, "CC");
    struct RClass* p_rclass = mrb_class_get_under(mrb, p_rmodule, "Ref");
    struct RClass *rclass = mrb_define_class_under(mrb, rmodule, "Touch", p_rclass);
    MRB_SET_INSTANCE_TT(rclass, MRB_TT_DATA);

    mrb_define_method(mrb, rclass, "initialize", ruby_cocos2dx_Touch_constructor, ARGS_NONE());
    mrb_define_method(mrb, rclass, "get_previous_location_in_view", ruby_cocos2dx_Touch_getPreviousLocationInView, ARGS_NONE());
    mrb_define_method(mrb, rclass, "get_location", ruby_cocos2dx_Touch_getLocation, ARGS_NONE());
    mrb_define_method(mrb, rclass, "get_delta", ruby_cocos2dx_Touch_getDelta, ARGS_NONE());
    mrb_define_method(mrb, rclass, "get_start_location_in_view", ruby_cocos2dx_Touch_getStartLocationInView, ARGS_NONE());
    mrb_define_method(mrb, rclass, "get_start_location", ruby_cocos2dx_Touch_getStartLocation, ARGS_NONE());
    mrb_define_method(mrb, rclass, "get_id", ruby_cocos2dx_Touch_getID, ARGS_NONE());
    mrb_define_method(mrb, rclass, "set_touch_info", ruby_cocos2dx_Touch_setTouchInfo, ARGS_REQ(3));
    mrb_define_method(mrb, rclass, "get_location_in_view", ruby_cocos2dx_Touch_getLocationInView, ARGS_NONE());
    mrb_define_method(mrb, rclass, "get_previous_location", ruby_cocos2dx_Touch_getPreviousLocation, ARGS_NONE());
    struct RClass* renum_DispatchMode = mrb_define_module_under(mrb, rclass, "DispatchMode");
    ruby_cocos2dx_Touch_DispatchMode_enum_init(mrb, renum_DispatchMode);
    mrb_define_class_method(mrb, renum_DispatchMode, "ALL_AT_ONCE", ruby_cocos2dx_constant_get, ARGS_NONE());
    mrb_define_class_method(mrb, renum_DispatchMode, "ONE_BY_ONE", ruby_cocos2dx_constant_get, ARGS_NONE());
}
mrb_value ruby_cocos2dx_Event_isStopped(mrb_state* mrb, mrb_value self)
{
    cocos2d::Event* cobj = static_cast<cocos2d::Event*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            bool retval = cobj->isStopped();
            mrb_value ret;
            ret = mrb_bool_value((mrb_bool)retval);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::Event#isStopped");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Event_getType(mrb_state* mrb, mrb_value self)
{
    cocos2d::Event* cobj = static_cast<cocos2d::Event*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            int retval = (int)cobj->getType();
            mrb_value ret;
            ret = mrb_fixnum_value((mrb_int)retval);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::Event#getType");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Event_getCurrentTarget(mrb_state* mrb, mrb_value self)
{
    cocos2d::Event* cobj = static_cast<cocos2d::Event*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            cocos2d::Node* retval = cobj->getCurrentTarget();
            mrb_value ret;
            ret = object_to_rubyval<cocos2d::Node>(mrb, "CC::Node", (cocos2d::Node*)retval, nullptr);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::Event#getCurrentTarget");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Event_stopPropagation(mrb_state* mrb, mrb_value self)
{
    cocos2d::Event* cobj = static_cast<cocos2d::Event*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            cobj->stopPropagation();
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::Event#stopPropagation");

    return mrb_nil_value();
}

void ruby_cocos2dx_Event_Type_enum_init(mrb_state* mrb, struct RClass* renum)
{
    do {
        mrb_value ev = mrb_fixnum_value((mrb_int)cocos2d::Event::Type::TOUCH);
        mrb_mod_cv_set(mrb, renum, mrb_intern_cstr(mrb, "TOUCH"), ev);
    } while (0);

    do {
        mrb_value ev = mrb_fixnum_value((mrb_int)cocos2d::Event::Type::KEYBOARD);
        mrb_mod_cv_set(mrb, renum, mrb_intern_cstr(mrb, "KEYBOARD"), ev);
    } while (0);

    do {
        mrb_value ev = mrb_fixnum_value((mrb_int)cocos2d::Event::Type::ACCELERATION);
        mrb_mod_cv_set(mrb, renum, mrb_intern_cstr(mrb, "ACCELERATION"), ev);
    } while (0);

    do {
        mrb_value ev = mrb_fixnum_value((mrb_int)cocos2d::Event::Type::MOUSE);
        mrb_mod_cv_set(mrb, renum, mrb_intern_cstr(mrb, "MOUSE"), ev);
    } while (0);

    do {
        mrb_value ev = mrb_fixnum_value((mrb_int)cocos2d::Event::Type::FOCUS);
        mrb_mod_cv_set(mrb, renum, mrb_intern_cstr(mrb, "FOCUS"), ev);
    } while (0);

    do {
        mrb_value ev = mrb_fixnum_value((mrb_int)cocos2d::Event::Type::GAME_CONTROLLER);
        mrb_mod_cv_set(mrb, renum, mrb_intern_cstr(mrb, "GAME_CONTROLLER"), ev);
    } while (0);

    do {
        mrb_value ev = mrb_fixnum_value((mrb_int)cocos2d::Event::Type::CUSTOM);
        mrb_mod_cv_set(mrb, renum, mrb_intern_cstr(mrb, "CUSTOM"), ev);
    } while (0);

}

void ruby_register_cocos2dx_Event(mrb_state* mrb, struct RClass* rmodule)
{
    std::string typeName = typeid(cocos2d::Event).name();
    g_rubyType[typeName] = "CC::Event";
    g_rubyDataType[typeName] = &ruby_cocos2dx_Ref_type;

    struct RClass* p_rmodule = mrb->object_class;
    p_rmodule = mrb_module_get_under(mrb, p_rmodule, "CC");
    struct RClass* p_rclass = mrb_class_get_under(mrb, p_rmodule, "Ref");
    struct RClass *rclass = mrb_define_class_under(mrb, rmodule, "Event", p_rclass);
    MRB_SET_INSTANCE_TT(rclass, MRB_TT_DATA);

    mrb_define_method(mrb, rclass, "stopped?", ruby_cocos2dx_Event_isStopped, ARGS_NONE());
    mrb_define_method(mrb, rclass, "get_type", ruby_cocos2dx_Event_getType, ARGS_NONE());
    mrb_define_method(mrb, rclass, "get_current_target", ruby_cocos2dx_Event_getCurrentTarget, ARGS_NONE());
    mrb_define_method(mrb, rclass, "stop_propagation", ruby_cocos2dx_Event_stopPropagation, ARGS_NONE());
    struct RClass* renum_Type = mrb_define_module_under(mrb, rclass, "Type");
    ruby_cocos2dx_Event_Type_enum_init(mrb, renum_Type);
    mrb_define_class_method(mrb, renum_Type, "TOUCH", ruby_cocos2dx_constant_get, ARGS_NONE());
    mrb_define_class_method(mrb, renum_Type, "KEYBOARD", ruby_cocos2dx_constant_get, ARGS_NONE());
    mrb_define_class_method(mrb, renum_Type, "ACCELERATION", ruby_cocos2dx_constant_get, ARGS_NONE());
    mrb_define_class_method(mrb, renum_Type, "MOUSE", ruby_cocos2dx_constant_get, ARGS_NONE());
    mrb_define_class_method(mrb, renum_Type, "FOCUS", ruby_cocos2dx_constant_get, ARGS_NONE());
    mrb_define_class_method(mrb, renum_Type, "GAME_CONTROLLER", ruby_cocos2dx_constant_get, ARGS_NONE());
    mrb_define_class_method(mrb, renum_Type, "CUSTOM", ruby_cocos2dx_constant_get, ARGS_NONE());
}
mrb_value ruby_cocos2dx_EventTouch_getEventCode(mrb_state* mrb, mrb_value self)
{
    cocos2d::EventTouch* cobj = static_cast<cocos2d::EventTouch*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            int retval = (int)cobj->getEventCode();
            mrb_value ret;
            ret = mrb_fixnum_value((mrb_int)retval);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::EventTouch#getEventCode");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_EventTouch_setTouches(mrb_state* mrb, mrb_value self)
{
    cocos2d::EventTouch* cobj = static_cast<cocos2d::EventTouch*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            std::vector<cocos2d::Touch *> arg0;
            ok = rubyval_to_std_vector_object(mrb, argv[0], &arg0, "CC::Touch", "CC::EventTouch.setTouches");
            if (!ok) { break; }
            cobj->setTouches(arg0);
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::EventTouch#setTouches");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_EventTouch_setEventCode(mrb_state* mrb, mrb_value self)
{
    cocos2d::EventTouch* cobj = static_cast<cocos2d::EventTouch*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            cocos2d::EventTouch::EventCode arg0;
            ok = rubyval_to_int32(mrb, argv[0], (int*)&arg0, "CC::EventTouch.setEventCode");
            if (!ok) { break; }
            cobj->setEventCode(arg0);
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::EventTouch#setEventCode");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_EventTouch_getTouches(mrb_state* mrb, mrb_value self)
{
    cocos2d::EventTouch* cobj = static_cast<cocos2d::EventTouch*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            std::vector<cocos2d::Touch *> retval = cobj->getTouches();
            mrb_value ret;
            ret = std_vector_object_to_rubyval(mrb, retval, "CC::Touch");
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::EventTouch#getTouches");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_EventTouch_constructor(mrb_state* mrb, mrb_value self)
{

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            cocos2d::EventTouch* cobj = new cocos2d::EventTouch();
            DATA_TYPE(self) = &ruby_cocos2dx_Ref_type;
            DATA_PTR(self) = cobj;
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::EventTouch#EventTouch");

    return mrb_nil_value();
}


void ruby_cocos2dx_EventTouch_constants_init(mrb_state* mrb, struct RClass* rclass)
{
    do {
        mrb_value ret;
        ret = mrb_fixnum_value((mrb_int)cocos2d::EventTouch::MAX_TOUCHES);
        mrb_mod_cv_set(mrb, rclass, mrb_intern_cstr(mrb, "MAX_TOUCHES"), ret);
    } while (0);

}

void ruby_cocos2dx_EventTouch_EventCode_enum_init(mrb_state* mrb, struct RClass* renum)
{
    do {
        mrb_value ev = mrb_fixnum_value((mrb_int)cocos2d::EventTouch::EventCode::BEGAN);
        mrb_mod_cv_set(mrb, renum, mrb_intern_cstr(mrb, "BEGAN"), ev);
    } while (0);

    do {
        mrb_value ev = mrb_fixnum_value((mrb_int)cocos2d::EventTouch::EventCode::MOVED);
        mrb_mod_cv_set(mrb, renum, mrb_intern_cstr(mrb, "MOVED"), ev);
    } while (0);

    do {
        mrb_value ev = mrb_fixnum_value((mrb_int)cocos2d::EventTouch::EventCode::ENDED);
        mrb_mod_cv_set(mrb, renum, mrb_intern_cstr(mrb, "ENDED"), ev);
    } while (0);

    do {
        mrb_value ev = mrb_fixnum_value((mrb_int)cocos2d::EventTouch::EventCode::CANCELLED);
        mrb_mod_cv_set(mrb, renum, mrb_intern_cstr(mrb, "CANCELLED"), ev);
    } while (0);

}

void ruby_register_cocos2dx_EventTouch(mrb_state* mrb, struct RClass* rmodule)
{
    std::string typeName = typeid(cocos2d::EventTouch).name();
    g_rubyType[typeName] = "CC::EventTouch";
    g_rubyDataType[typeName] = &ruby_cocos2dx_Ref_type;

    struct RClass* p_rmodule = mrb->object_class;
    p_rmodule = mrb_module_get_under(mrb, p_rmodule, "CC");
    struct RClass* p_rclass = mrb_class_get_under(mrb, p_rmodule, "Event");
    struct RClass *rclass = mrb_define_class_under(mrb, rmodule, "EventTouch", p_rclass);
    MRB_SET_INSTANCE_TT(rclass, MRB_TT_DATA);

    mrb_define_method(mrb, rclass, "initialize", ruby_cocos2dx_EventTouch_constructor, ARGS_NONE());
    mrb_define_method(mrb, rclass, "get_event_code", ruby_cocos2dx_EventTouch_getEventCode, ARGS_NONE());
    mrb_define_method(mrb, rclass, "set_touches", ruby_cocos2dx_EventTouch_setTouches, ARGS_REQ(1));
    mrb_define_method(mrb, rclass, "set_event_code", ruby_cocos2dx_EventTouch_setEventCode, ARGS_REQ(1));
    mrb_define_method(mrb, rclass, "get_touches", ruby_cocos2dx_EventTouch_getTouches, ARGS_NONE());
    ruby_cocos2dx_EventTouch_constants_init(mrb, rclass);
    mrb_define_class_method(mrb, rclass, "MAX_TOUCHES", ruby_cocos2dx_constant_get, ARGS_NONE());
    struct RClass* renum_EventCode = mrb_define_module_under(mrb, rclass, "EventCode");
    ruby_cocos2dx_EventTouch_EventCode_enum_init(mrb, renum_EventCode);
    mrb_define_class_method(mrb, renum_EventCode, "BEGAN", ruby_cocos2dx_constant_get, ARGS_NONE());
    mrb_define_class_method(mrb, renum_EventCode, "MOVED", ruby_cocos2dx_constant_get, ARGS_NONE());
    mrb_define_class_method(mrb, renum_EventCode, "ENDED", ruby_cocos2dx_constant_get, ARGS_NONE());
    mrb_define_class_method(mrb, renum_EventCode, "CANCELLED", ruby_cocos2dx_constant_get, ARGS_NONE());
}
mrb_value ruby_cocos2dx_EventKeyboard_constructor(mrb_state* mrb, mrb_value self)
{

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 2) {
            cocos2d::EventKeyboard::KeyCode arg0;
            ok = rubyval_to_int32(mrb, argv[0], (int*)&arg0, "CC::EventKeyboard.EventKeyboard");
            if (!ok) { break; }
            bool arg1;
            ok = rubyval_to_boolean(mrb, argv[1], &arg1, "CC::EventKeyboard.EventKeyboard");
            if (!ok) { break; }
            cocos2d::EventKeyboard* cobj = new cocos2d::EventKeyboard(arg0, arg1);
            DATA_TYPE(self) = &ruby_cocos2dx_Ref_type;
            DATA_PTR(self) = cobj;
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::EventKeyboard#EventKeyboard");

    return mrb_nil_value();
}


void ruby_cocos2dx_EventKeyboard_KeyCode_enum_init(mrb_state* mrb, struct RClass* renum)
{
    do {
        mrb_value ev = mrb_fixnum_value((mrb_int)cocos2d::EventKeyboard::KeyCode::KEY_NONE);
        mrb_mod_cv_set(mrb, renum, mrb_intern_cstr(mrb, "KEY_NONE"), ev);
    } while (0);

    do {
        mrb_value ev = mrb_fixnum_value((mrb_int)cocos2d::EventKeyboard::KeyCode::KEY_PAUSE);
        mrb_mod_cv_set(mrb, renum, mrb_intern_cstr(mrb, "KEY_PAUSE"), ev);
    } while (0);

    do {
        mrb_value ev = mrb_fixnum_value((mrb_int)cocos2d::EventKeyboard::KeyCode::KEY_SCROLL_LOCK);
        mrb_mod_cv_set(mrb, renum, mrb_intern_cstr(mrb, "KEY_SCROLL_LOCK"), ev);
    } while (0);

    do {
        mrb_value ev = mrb_fixnum_value((mrb_int)cocos2d::EventKeyboard::KeyCode::KEY_PRINT);
        mrb_mod_cv_set(mrb, renum, mrb_intern_cstr(mrb, "KEY_PRINT"), ev);
    } while (0);

    do {
        mrb_value ev = mrb_fixnum_value((mrb_int)cocos2d::EventKeyboard::KeyCode::KEY_SYSREQ);
        mrb_mod_cv_set(mrb, renum, mrb_intern_cstr(mrb, "KEY_SYSREQ"), ev);
    } while (0);

    do {
        mrb_value ev = mrb_fixnum_value((mrb_int)cocos2d::EventKeyboard::KeyCode::KEY_BREAK);
        mrb_mod_cv_set(mrb, renum, mrb_intern_cstr(mrb, "KEY_BREAK"), ev);
    } while (0);

    do {
        mrb_value ev = mrb_fixnum_value((mrb_int)cocos2d::EventKeyboard::KeyCode::KEY_ESCAPE);
        mrb_mod_cv_set(mrb, renum, mrb_intern_cstr(mrb, "KEY_ESCAPE"), ev);
    } while (0);

    do {
        mrb_value ev = mrb_fixnum_value((mrb_int)cocos2d::EventKeyboard::KeyCode::KEY_BACK);
        mrb_mod_cv_set(mrb, renum, mrb_intern_cstr(mrb, "KEY_BACK"), ev);
    } while (0);

    do {
        mrb_value ev = mrb_fixnum_value((mrb_int)cocos2d::EventKeyboard::KeyCode::KEY_BACKSPACE);
        mrb_mod_cv_set(mrb, renum, mrb_intern_cstr(mrb, "KEY_BACKSPACE"), ev);
    } while (0);

    do {
        mrb_value ev = mrb_fixnum_value((mrb_int)cocos2d::EventKeyboard::KeyCode::KEY_TAB);
        mrb_mod_cv_set(mrb, renum, mrb_intern_cstr(mrb, "KEY_TAB"), ev);
    } while (0);

    do {
        mrb_value ev = mrb_fixnum_value((mrb_int)cocos2d::EventKeyboard::KeyCode::KEY_BACK_TAB);
        mrb_mod_cv_set(mrb, renum, mrb_intern_cstr(mrb, "KEY_BACK_TAB"), ev);
    } while (0);

    do {
        mrb_value ev = mrb_fixnum_value((mrb_int)cocos2d::EventKeyboard::KeyCode::KEY_RETURN);
        mrb_mod_cv_set(mrb, renum, mrb_intern_cstr(mrb, "KEY_RETURN"), ev);
    } while (0);

    do {
        mrb_value ev = mrb_fixnum_value((mrb_int)cocos2d::EventKeyboard::KeyCode::KEY_CAPS_LOCK);
        mrb_mod_cv_set(mrb, renum, mrb_intern_cstr(mrb, "KEY_CAPS_LOCK"), ev);
    } while (0);

    do {
        mrb_value ev = mrb_fixnum_value((mrb_int)cocos2d::EventKeyboard::KeyCode::KEY_SHIFT);
        mrb_mod_cv_set(mrb, renum, mrb_intern_cstr(mrb, "KEY_SHIFT"), ev);
    } while (0);

    do {
        mrb_value ev = mrb_fixnum_value((mrb_int)cocos2d::EventKeyboard::KeyCode::KEY_LEFT_SHIFT);
        mrb_mod_cv_set(mrb, renum, mrb_intern_cstr(mrb, "KEY_LEFT_SHIFT"), ev);
    } while (0);

    do {
        mrb_value ev = mrb_fixnum_value((mrb_int)cocos2d::EventKeyboard::KeyCode::KEY_RIGHT_SHIFT);
        mrb_mod_cv_set(mrb, renum, mrb_intern_cstr(mrb, "KEY_RIGHT_SHIFT"), ev);
    } while (0);

    do {
        mrb_value ev = mrb_fixnum_value((mrb_int)cocos2d::EventKeyboard::KeyCode::KEY_CTRL);
        mrb_mod_cv_set(mrb, renum, mrb_intern_cstr(mrb, "KEY_CTRL"), ev);
    } while (0);

    do {
        mrb_value ev = mrb_fixnum_value((mrb_int)cocos2d::EventKeyboard::KeyCode::KEY_LEFT_CTRL);
        mrb_mod_cv_set(mrb, renum, mrb_intern_cstr(mrb, "KEY_LEFT_CTRL"), ev);
    } while (0);

    do {
        mrb_value ev = mrb_fixnum_value((mrb_int)cocos2d::EventKeyboard::KeyCode::KEY_RIGHT_CTRL);
        mrb_mod_cv_set(mrb, renum, mrb_intern_cstr(mrb, "KEY_RIGHT_CTRL"), ev);
    } while (0);

    do {
        mrb_value ev = mrb_fixnum_value((mrb_int)cocos2d::EventKeyboard::KeyCode::KEY_ALT);
        mrb_mod_cv_set(mrb, renum, mrb_intern_cstr(mrb, "KEY_ALT"), ev);
    } while (0);

    do {
        mrb_value ev = mrb_fixnum_value((mrb_int)cocos2d::EventKeyboard::KeyCode::KEY_LEFT_ALT);
        mrb_mod_cv_set(mrb, renum, mrb_intern_cstr(mrb, "KEY_LEFT_ALT"), ev);
    } while (0);

    do {
        mrb_value ev = mrb_fixnum_value((mrb_int)cocos2d::EventKeyboard::KeyCode::KEY_RIGHT_ALT);
        mrb_mod_cv_set(mrb, renum, mrb_intern_cstr(mrb, "KEY_RIGHT_ALT"), ev);
    } while (0);

    do {
        mrb_value ev = mrb_fixnum_value((mrb_int)cocos2d::EventKeyboard::KeyCode::KEY_MENU);
        mrb_mod_cv_set(mrb, renum, mrb_intern_cstr(mrb, "KEY_MENU"), ev);
    } while (0);

    do {
        mrb_value ev = mrb_fixnum_value((mrb_int)cocos2d::EventKeyboard::KeyCode::KEY_HYPER);
        mrb_mod_cv_set(mrb, renum, mrb_intern_cstr(mrb, "KEY_HYPER"), ev);
    } while (0);

    do {
        mrb_value ev = mrb_fixnum_value((mrb_int)cocos2d::EventKeyboard::KeyCode::KEY_INSERT);
        mrb_mod_cv_set(mrb, renum, mrb_intern_cstr(mrb, "KEY_INSERT"), ev);
    } while (0);

    do {
        mrb_value ev = mrb_fixnum_value((mrb_int)cocos2d::EventKeyboard::KeyCode::KEY_HOME);
        mrb_mod_cv_set(mrb, renum, mrb_intern_cstr(mrb, "KEY_HOME"), ev);
    } while (0);

    do {
        mrb_value ev = mrb_fixnum_value((mrb_int)cocos2d::EventKeyboard::KeyCode::KEY_PG_UP);
        mrb_mod_cv_set(mrb, renum, mrb_intern_cstr(mrb, "KEY_PG_UP"), ev);
    } while (0);

    do {
        mrb_value ev = mrb_fixnum_value((mrb_int)cocos2d::EventKeyboard::KeyCode::KEY_DELETE);
        mrb_mod_cv_set(mrb, renum, mrb_intern_cstr(mrb, "KEY_DELETE"), ev);
    } while (0);

    do {
        mrb_value ev = mrb_fixnum_value((mrb_int)cocos2d::EventKeyboard::KeyCode::KEY_END);
        mrb_mod_cv_set(mrb, renum, mrb_intern_cstr(mrb, "KEY_END"), ev);
    } while (0);

    do {
        mrb_value ev = mrb_fixnum_value((mrb_int)cocos2d::EventKeyboard::KeyCode::KEY_PG_DOWN);
        mrb_mod_cv_set(mrb, renum, mrb_intern_cstr(mrb, "KEY_PG_DOWN"), ev);
    } while (0);

    do {
        mrb_value ev = mrb_fixnum_value((mrb_int)cocos2d::EventKeyboard::KeyCode::KEY_LEFT_ARROW);
        mrb_mod_cv_set(mrb, renum, mrb_intern_cstr(mrb, "KEY_LEFT_ARROW"), ev);
    } while (0);

    do {
        mrb_value ev = mrb_fixnum_value((mrb_int)cocos2d::EventKeyboard::KeyCode::KEY_RIGHT_ARROW);
        mrb_mod_cv_set(mrb, renum, mrb_intern_cstr(mrb, "KEY_RIGHT_ARROW"), ev);
    } while (0);

    do {
        mrb_value ev = mrb_fixnum_value((mrb_int)cocos2d::EventKeyboard::KeyCode::KEY_UP_ARROW);
        mrb_mod_cv_set(mrb, renum, mrb_intern_cstr(mrb, "KEY_UP_ARROW"), ev);
    } while (0);

    do {
        mrb_value ev = mrb_fixnum_value((mrb_int)cocos2d::EventKeyboard::KeyCode::KEY_DOWN_ARROW);
        mrb_mod_cv_set(mrb, renum, mrb_intern_cstr(mrb, "KEY_DOWN_ARROW"), ev);
    } while (0);

    do {
        mrb_value ev = mrb_fixnum_value((mrb_int)cocos2d::EventKeyboard::KeyCode::KEY_NUM_LOCK);
        mrb_mod_cv_set(mrb, renum, mrb_intern_cstr(mrb, "KEY_NUM_LOCK"), ev);
    } while (0);

    do {
        mrb_value ev = mrb_fixnum_value((mrb_int)cocos2d::EventKeyboard::KeyCode::KEY_KP_PLUS);
        mrb_mod_cv_set(mrb, renum, mrb_intern_cstr(mrb, "KEY_KP_PLUS"), ev);
    } while (0);

    do {
        mrb_value ev = mrb_fixnum_value((mrb_int)cocos2d::EventKeyboard::KeyCode::KEY_KP_MINUS);
        mrb_mod_cv_set(mrb, renum, mrb_intern_cstr(mrb, "KEY_KP_MINUS"), ev);
    } while (0);

    do {
        mrb_value ev = mrb_fixnum_value((mrb_int)cocos2d::EventKeyboard::KeyCode::KEY_KP_MULTIPLY);
        mrb_mod_cv_set(mrb, renum, mrb_intern_cstr(mrb, "KEY_KP_MULTIPLY"), ev);
    } while (0);

    do {
        mrb_value ev = mrb_fixnum_value((mrb_int)cocos2d::EventKeyboard::KeyCode::KEY_KP_DIVIDE);
        mrb_mod_cv_set(mrb, renum, mrb_intern_cstr(mrb, "KEY_KP_DIVIDE"), ev);
    } while (0);

    do {
        mrb_value ev = mrb_fixnum_value((mrb_int)cocos2d::EventKeyboard::KeyCode::KEY_KP_ENTER);
        mrb_mod_cv_set(mrb, renum, mrb_intern_cstr(mrb, "KEY_KP_ENTER"), ev);
    } while (0);

    do {
        mrb_value ev = mrb_fixnum_value((mrb_int)cocos2d::EventKeyboard::KeyCode::KEY_KP_HOME);
        mrb_mod_cv_set(mrb, renum, mrb_intern_cstr(mrb, "KEY_KP_HOME"), ev);
    } while (0);

    do {
        mrb_value ev = mrb_fixnum_value((mrb_int)cocos2d::EventKeyboard::KeyCode::KEY_KP_UP);
        mrb_mod_cv_set(mrb, renum, mrb_intern_cstr(mrb, "KEY_KP_UP"), ev);
    } while (0);

    do {
        mrb_value ev = mrb_fixnum_value((mrb_int)cocos2d::EventKeyboard::KeyCode::KEY_KP_PG_UP);
        mrb_mod_cv_set(mrb, renum, mrb_intern_cstr(mrb, "KEY_KP_PG_UP"), ev);
    } while (0);

    do {
        mrb_value ev = mrb_fixnum_value((mrb_int)cocos2d::EventKeyboard::KeyCode::KEY_KP_LEFT);
        mrb_mod_cv_set(mrb, renum, mrb_intern_cstr(mrb, "KEY_KP_LEFT"), ev);
    } while (0);

    do {
        mrb_value ev = mrb_fixnum_value((mrb_int)cocos2d::EventKeyboard::KeyCode::KEY_KP_FIVE);
        mrb_mod_cv_set(mrb, renum, mrb_intern_cstr(mrb, "KEY_KP_FIVE"), ev);
    } while (0);

    do {
        mrb_value ev = mrb_fixnum_value((mrb_int)cocos2d::EventKeyboard::KeyCode::KEY_KP_RIGHT);
        mrb_mod_cv_set(mrb, renum, mrb_intern_cstr(mrb, "KEY_KP_RIGHT"), ev);
    } while (0);

    do {
        mrb_value ev = mrb_fixnum_value((mrb_int)cocos2d::EventKeyboard::KeyCode::KEY_KP_END);
        mrb_mod_cv_set(mrb, renum, mrb_intern_cstr(mrb, "KEY_KP_END"), ev);
    } while (0);

    do {
        mrb_value ev = mrb_fixnum_value((mrb_int)cocos2d::EventKeyboard::KeyCode::KEY_KP_DOWN);
        mrb_mod_cv_set(mrb, renum, mrb_intern_cstr(mrb, "KEY_KP_DOWN"), ev);
    } while (0);

    do {
        mrb_value ev = mrb_fixnum_value((mrb_int)cocos2d::EventKeyboard::KeyCode::KEY_KP_PG_DOWN);
        mrb_mod_cv_set(mrb, renum, mrb_intern_cstr(mrb, "KEY_KP_PG_DOWN"), ev);
    } while (0);

    do {
        mrb_value ev = mrb_fixnum_value((mrb_int)cocos2d::EventKeyboard::KeyCode::KEY_KP_INSERT);
        mrb_mod_cv_set(mrb, renum, mrb_intern_cstr(mrb, "KEY_KP_INSERT"), ev);
    } while (0);

    do {
        mrb_value ev = mrb_fixnum_value((mrb_int)cocos2d::EventKeyboard::KeyCode::KEY_KP_DELETE);
        mrb_mod_cv_set(mrb, renum, mrb_intern_cstr(mrb, "KEY_KP_DELETE"), ev);
    } while (0);

    do {
        mrb_value ev = mrb_fixnum_value((mrb_int)cocos2d::EventKeyboard::KeyCode::KEY_F1);
        mrb_mod_cv_set(mrb, renum, mrb_intern_cstr(mrb, "KEY_F1"), ev);
    } while (0);

    do {
        mrb_value ev = mrb_fixnum_value((mrb_int)cocos2d::EventKeyboard::KeyCode::KEY_F2);
        mrb_mod_cv_set(mrb, renum, mrb_intern_cstr(mrb, "KEY_F2"), ev);
    } while (0);

    do {
        mrb_value ev = mrb_fixnum_value((mrb_int)cocos2d::EventKeyboard::KeyCode::KEY_F3);
        mrb_mod_cv_set(mrb, renum, mrb_intern_cstr(mrb, "KEY_F3"), ev);
    } while (0);

    do {
        mrb_value ev = mrb_fixnum_value((mrb_int)cocos2d::EventKeyboard::KeyCode::KEY_F4);
        mrb_mod_cv_set(mrb, renum, mrb_intern_cstr(mrb, "KEY_F4"), ev);
    } while (0);

    do {
        mrb_value ev = mrb_fixnum_value((mrb_int)cocos2d::EventKeyboard::KeyCode::KEY_F5);
        mrb_mod_cv_set(mrb, renum, mrb_intern_cstr(mrb, "KEY_F5"), ev);
    } while (0);

    do {
        mrb_value ev = mrb_fixnum_value((mrb_int)cocos2d::EventKeyboard::KeyCode::KEY_F6);
        mrb_mod_cv_set(mrb, renum, mrb_intern_cstr(mrb, "KEY_F6"), ev);
    } while (0);

    do {
        mrb_value ev = mrb_fixnum_value((mrb_int)cocos2d::EventKeyboard::KeyCode::KEY_F7);
        mrb_mod_cv_set(mrb, renum, mrb_intern_cstr(mrb, "KEY_F7"), ev);
    } while (0);

    do {
        mrb_value ev = mrb_fixnum_value((mrb_int)cocos2d::EventKeyboard::KeyCode::KEY_F8);
        mrb_mod_cv_set(mrb, renum, mrb_intern_cstr(mrb, "KEY_F8"), ev);
    } while (0);

    do {
        mrb_value ev = mrb_fixnum_value((mrb_int)cocos2d::EventKeyboard::KeyCode::KEY_F9);
        mrb_mod_cv_set(mrb, renum, mrb_intern_cstr(mrb, "KEY_F9"), ev);
    } while (0);

    do {
        mrb_value ev = mrb_fixnum_value((mrb_int)cocos2d::EventKeyboard::KeyCode::KEY_F10);
        mrb_mod_cv_set(mrb, renum, mrb_intern_cstr(mrb, "KEY_F10"), ev);
    } while (0);

    do {
        mrb_value ev = mrb_fixnum_value((mrb_int)cocos2d::EventKeyboard::KeyCode::KEY_F11);
        mrb_mod_cv_set(mrb, renum, mrb_intern_cstr(mrb, "KEY_F11"), ev);
    } while (0);

    do {
        mrb_value ev = mrb_fixnum_value((mrb_int)cocos2d::EventKeyboard::KeyCode::KEY_F12);
        mrb_mod_cv_set(mrb, renum, mrb_intern_cstr(mrb, "KEY_F12"), ev);
    } while (0);

    do {
        mrb_value ev = mrb_fixnum_value((mrb_int)cocos2d::EventKeyboard::KeyCode::KEY_SPACE);
        mrb_mod_cv_set(mrb, renum, mrb_intern_cstr(mrb, "KEY_SPACE"), ev);
    } while (0);

    do {
        mrb_value ev = mrb_fixnum_value((mrb_int)cocos2d::EventKeyboard::KeyCode::KEY_EXCLAM);
        mrb_mod_cv_set(mrb, renum, mrb_intern_cstr(mrb, "KEY_EXCLAM"), ev);
    } while (0);

    do {
        mrb_value ev = mrb_fixnum_value((mrb_int)cocos2d::EventKeyboard::KeyCode::KEY_QUOTE);
        mrb_mod_cv_set(mrb, renum, mrb_intern_cstr(mrb, "KEY_QUOTE"), ev);
    } while (0);

    do {
        mrb_value ev = mrb_fixnum_value((mrb_int)cocos2d::EventKeyboard::KeyCode::KEY_NUMBER);
        mrb_mod_cv_set(mrb, renum, mrb_intern_cstr(mrb, "KEY_NUMBER"), ev);
    } while (0);

    do {
        mrb_value ev = mrb_fixnum_value((mrb_int)cocos2d::EventKeyboard::KeyCode::KEY_DOLLAR);
        mrb_mod_cv_set(mrb, renum, mrb_intern_cstr(mrb, "KEY_DOLLAR"), ev);
    } while (0);

    do {
        mrb_value ev = mrb_fixnum_value((mrb_int)cocos2d::EventKeyboard::KeyCode::KEY_PERCENT);
        mrb_mod_cv_set(mrb, renum, mrb_intern_cstr(mrb, "KEY_PERCENT"), ev);
    } while (0);

    do {
        mrb_value ev = mrb_fixnum_value((mrb_int)cocos2d::EventKeyboard::KeyCode::KEY_CIRCUMFLEX);
        mrb_mod_cv_set(mrb, renum, mrb_intern_cstr(mrb, "KEY_CIRCUMFLEX"), ev);
    } while (0);

    do {
        mrb_value ev = mrb_fixnum_value((mrb_int)cocos2d::EventKeyboard::KeyCode::KEY_AMPERSAND);
        mrb_mod_cv_set(mrb, renum, mrb_intern_cstr(mrb, "KEY_AMPERSAND"), ev);
    } while (0);

    do {
        mrb_value ev = mrb_fixnum_value((mrb_int)cocos2d::EventKeyboard::KeyCode::KEY_APOSTROPHE);
        mrb_mod_cv_set(mrb, renum, mrb_intern_cstr(mrb, "KEY_APOSTROPHE"), ev);
    } while (0);

    do {
        mrb_value ev = mrb_fixnum_value((mrb_int)cocos2d::EventKeyboard::KeyCode::KEY_LEFT_PARENTHESIS);
        mrb_mod_cv_set(mrb, renum, mrb_intern_cstr(mrb, "KEY_LEFT_PARENTHESIS"), ev);
    } while (0);

    do {
        mrb_value ev = mrb_fixnum_value((mrb_int)cocos2d::EventKeyboard::KeyCode::KEY_RIGHT_PARENTHESIS);
        mrb_mod_cv_set(mrb, renum, mrb_intern_cstr(mrb, "KEY_RIGHT_PARENTHESIS"), ev);
    } while (0);

    do {
        mrb_value ev = mrb_fixnum_value((mrb_int)cocos2d::EventKeyboard::KeyCode::KEY_ASTERISK);
        mrb_mod_cv_set(mrb, renum, mrb_intern_cstr(mrb, "KEY_ASTERISK"), ev);
    } while (0);

    do {
        mrb_value ev = mrb_fixnum_value((mrb_int)cocos2d::EventKeyboard::KeyCode::KEY_PLUS);
        mrb_mod_cv_set(mrb, renum, mrb_intern_cstr(mrb, "KEY_PLUS"), ev);
    } while (0);

    do {
        mrb_value ev = mrb_fixnum_value((mrb_int)cocos2d::EventKeyboard::KeyCode::KEY_COMMA);
        mrb_mod_cv_set(mrb, renum, mrb_intern_cstr(mrb, "KEY_COMMA"), ev);
    } while (0);

    do {
        mrb_value ev = mrb_fixnum_value((mrb_int)cocos2d::EventKeyboard::KeyCode::KEY_MINUS);
        mrb_mod_cv_set(mrb, renum, mrb_intern_cstr(mrb, "KEY_MINUS"), ev);
    } while (0);

    do {
        mrb_value ev = mrb_fixnum_value((mrb_int)cocos2d::EventKeyboard::KeyCode::KEY_PERIOD);
        mrb_mod_cv_set(mrb, renum, mrb_intern_cstr(mrb, "KEY_PERIOD"), ev);
    } while (0);

    do {
        mrb_value ev = mrb_fixnum_value((mrb_int)cocos2d::EventKeyboard::KeyCode::KEY_SLASH);
        mrb_mod_cv_set(mrb, renum, mrb_intern_cstr(mrb, "KEY_SLASH"), ev);
    } while (0);

    do {
        mrb_value ev = mrb_fixnum_value((mrb_int)cocos2d::EventKeyboard::KeyCode::KEY_0);
        mrb_mod_cv_set(mrb, renum, mrb_intern_cstr(mrb, "KEY_0"), ev);
    } while (0);

    do {
        mrb_value ev = mrb_fixnum_value((mrb_int)cocos2d::EventKeyboard::KeyCode::KEY_1);
        mrb_mod_cv_set(mrb, renum, mrb_intern_cstr(mrb, "KEY_1"), ev);
    } while (0);

    do {
        mrb_value ev = mrb_fixnum_value((mrb_int)cocos2d::EventKeyboard::KeyCode::KEY_2);
        mrb_mod_cv_set(mrb, renum, mrb_intern_cstr(mrb, "KEY_2"), ev);
    } while (0);

    do {
        mrb_value ev = mrb_fixnum_value((mrb_int)cocos2d::EventKeyboard::KeyCode::KEY_3);
        mrb_mod_cv_set(mrb, renum, mrb_intern_cstr(mrb, "KEY_3"), ev);
    } while (0);

    do {
        mrb_value ev = mrb_fixnum_value((mrb_int)cocos2d::EventKeyboard::KeyCode::KEY_4);
        mrb_mod_cv_set(mrb, renum, mrb_intern_cstr(mrb, "KEY_4"), ev);
    } while (0);

    do {
        mrb_value ev = mrb_fixnum_value((mrb_int)cocos2d::EventKeyboard::KeyCode::KEY_5);
        mrb_mod_cv_set(mrb, renum, mrb_intern_cstr(mrb, "KEY_5"), ev);
    } while (0);

    do {
        mrb_value ev = mrb_fixnum_value((mrb_int)cocos2d::EventKeyboard::KeyCode::KEY_6);
        mrb_mod_cv_set(mrb, renum, mrb_intern_cstr(mrb, "KEY_6"), ev);
    } while (0);

    do {
        mrb_value ev = mrb_fixnum_value((mrb_int)cocos2d::EventKeyboard::KeyCode::KEY_7);
        mrb_mod_cv_set(mrb, renum, mrb_intern_cstr(mrb, "KEY_7"), ev);
    } while (0);

    do {
        mrb_value ev = mrb_fixnum_value((mrb_int)cocos2d::EventKeyboard::KeyCode::KEY_8);
        mrb_mod_cv_set(mrb, renum, mrb_intern_cstr(mrb, "KEY_8"), ev);
    } while (0);

    do {
        mrb_value ev = mrb_fixnum_value((mrb_int)cocos2d::EventKeyboard::KeyCode::KEY_9);
        mrb_mod_cv_set(mrb, renum, mrb_intern_cstr(mrb, "KEY_9"), ev);
    } while (0);

    do {
        mrb_value ev = mrb_fixnum_value((mrb_int)cocos2d::EventKeyboard::KeyCode::KEY_COLON);
        mrb_mod_cv_set(mrb, renum, mrb_intern_cstr(mrb, "KEY_COLON"), ev);
    } while (0);

    do {
        mrb_value ev = mrb_fixnum_value((mrb_int)cocos2d::EventKeyboard::KeyCode::KEY_SEMICOLON);
        mrb_mod_cv_set(mrb, renum, mrb_intern_cstr(mrb, "KEY_SEMICOLON"), ev);
    } while (0);

    do {
        mrb_value ev = mrb_fixnum_value((mrb_int)cocos2d::EventKeyboard::KeyCode::KEY_LESS_THAN);
        mrb_mod_cv_set(mrb, renum, mrb_intern_cstr(mrb, "KEY_LESS_THAN"), ev);
    } while (0);

    do {
        mrb_value ev = mrb_fixnum_value((mrb_int)cocos2d::EventKeyboard::KeyCode::KEY_EQUAL);
        mrb_mod_cv_set(mrb, renum, mrb_intern_cstr(mrb, "KEY_EQUAL"), ev);
    } while (0);

    do {
        mrb_value ev = mrb_fixnum_value((mrb_int)cocos2d::EventKeyboard::KeyCode::KEY_GREATER_THAN);
        mrb_mod_cv_set(mrb, renum, mrb_intern_cstr(mrb, "KEY_GREATER_THAN"), ev);
    } while (0);

    do {
        mrb_value ev = mrb_fixnum_value((mrb_int)cocos2d::EventKeyboard::KeyCode::KEY_QUESTION);
        mrb_mod_cv_set(mrb, renum, mrb_intern_cstr(mrb, "KEY_QUESTION"), ev);
    } while (0);

    do {
        mrb_value ev = mrb_fixnum_value((mrb_int)cocos2d::EventKeyboard::KeyCode::KEY_AT);
        mrb_mod_cv_set(mrb, renum, mrb_intern_cstr(mrb, "KEY_AT"), ev);
    } while (0);

    do {
        mrb_value ev = mrb_fixnum_value((mrb_int)cocos2d::EventKeyboard::KeyCode::KEY_CAPITAL_A);
        mrb_mod_cv_set(mrb, renum, mrb_intern_cstr(mrb, "KEY_CAPITAL_A"), ev);
    } while (0);

    do {
        mrb_value ev = mrb_fixnum_value((mrb_int)cocos2d::EventKeyboard::KeyCode::KEY_CAPITAL_B);
        mrb_mod_cv_set(mrb, renum, mrb_intern_cstr(mrb, "KEY_CAPITAL_B"), ev);
    } while (0);

    do {
        mrb_value ev = mrb_fixnum_value((mrb_int)cocos2d::EventKeyboard::KeyCode::KEY_CAPITAL_C);
        mrb_mod_cv_set(mrb, renum, mrb_intern_cstr(mrb, "KEY_CAPITAL_C"), ev);
    } while (0);

    do {
        mrb_value ev = mrb_fixnum_value((mrb_int)cocos2d::EventKeyboard::KeyCode::KEY_CAPITAL_D);
        mrb_mod_cv_set(mrb, renum, mrb_intern_cstr(mrb, "KEY_CAPITAL_D"), ev);
    } while (0);

    do {
        mrb_value ev = mrb_fixnum_value((mrb_int)cocos2d::EventKeyboard::KeyCode::KEY_CAPITAL_E);
        mrb_mod_cv_set(mrb, renum, mrb_intern_cstr(mrb, "KEY_CAPITAL_E"), ev);
    } while (0);

    do {
        mrb_value ev = mrb_fixnum_value((mrb_int)cocos2d::EventKeyboard::KeyCode::KEY_CAPITAL_F);
        mrb_mod_cv_set(mrb, renum, mrb_intern_cstr(mrb, "KEY_CAPITAL_F"), ev);
    } while (0);

    do {
        mrb_value ev = mrb_fixnum_value((mrb_int)cocos2d::EventKeyboard::KeyCode::KEY_CAPITAL_G);
        mrb_mod_cv_set(mrb, renum, mrb_intern_cstr(mrb, "KEY_CAPITAL_G"), ev);
    } while (0);

    do {
        mrb_value ev = mrb_fixnum_value((mrb_int)cocos2d::EventKeyboard::KeyCode::KEY_CAPITAL_H);
        mrb_mod_cv_set(mrb, renum, mrb_intern_cstr(mrb, "KEY_CAPITAL_H"), ev);
    } while (0);

    do {
        mrb_value ev = mrb_fixnum_value((mrb_int)cocos2d::EventKeyboard::KeyCode::KEY_CAPITAL_I);
        mrb_mod_cv_set(mrb, renum, mrb_intern_cstr(mrb, "KEY_CAPITAL_I"), ev);
    } while (0);

    do {
        mrb_value ev = mrb_fixnum_value((mrb_int)cocos2d::EventKeyboard::KeyCode::KEY_CAPITAL_J);
        mrb_mod_cv_set(mrb, renum, mrb_intern_cstr(mrb, "KEY_CAPITAL_J"), ev);
    } while (0);

    do {
        mrb_value ev = mrb_fixnum_value((mrb_int)cocos2d::EventKeyboard::KeyCode::KEY_CAPITAL_K);
        mrb_mod_cv_set(mrb, renum, mrb_intern_cstr(mrb, "KEY_CAPITAL_K"), ev);
    } while (0);

    do {
        mrb_value ev = mrb_fixnum_value((mrb_int)cocos2d::EventKeyboard::KeyCode::KEY_CAPITAL_L);
        mrb_mod_cv_set(mrb, renum, mrb_intern_cstr(mrb, "KEY_CAPITAL_L"), ev);
    } while (0);

    do {
        mrb_value ev = mrb_fixnum_value((mrb_int)cocos2d::EventKeyboard::KeyCode::KEY_CAPITAL_M);
        mrb_mod_cv_set(mrb, renum, mrb_intern_cstr(mrb, "KEY_CAPITAL_M"), ev);
    } while (0);

    do {
        mrb_value ev = mrb_fixnum_value((mrb_int)cocos2d::EventKeyboard::KeyCode::KEY_CAPITAL_N);
        mrb_mod_cv_set(mrb, renum, mrb_intern_cstr(mrb, "KEY_CAPITAL_N"), ev);
    } while (0);

    do {
        mrb_value ev = mrb_fixnum_value((mrb_int)cocos2d::EventKeyboard::KeyCode::KEY_CAPITAL_O);
        mrb_mod_cv_set(mrb, renum, mrb_intern_cstr(mrb, "KEY_CAPITAL_O"), ev);
    } while (0);

    do {
        mrb_value ev = mrb_fixnum_value((mrb_int)cocos2d::EventKeyboard::KeyCode::KEY_CAPITAL_P);
        mrb_mod_cv_set(mrb, renum, mrb_intern_cstr(mrb, "KEY_CAPITAL_P"), ev);
    } while (0);

    do {
        mrb_value ev = mrb_fixnum_value((mrb_int)cocos2d::EventKeyboard::KeyCode::KEY_CAPITAL_Q);
        mrb_mod_cv_set(mrb, renum, mrb_intern_cstr(mrb, "KEY_CAPITAL_Q"), ev);
    } while (0);

    do {
        mrb_value ev = mrb_fixnum_value((mrb_int)cocos2d::EventKeyboard::KeyCode::KEY_CAPITAL_R);
        mrb_mod_cv_set(mrb, renum, mrb_intern_cstr(mrb, "KEY_CAPITAL_R"), ev);
    } while (0);

    do {
        mrb_value ev = mrb_fixnum_value((mrb_int)cocos2d::EventKeyboard::KeyCode::KEY_CAPITAL_S);
        mrb_mod_cv_set(mrb, renum, mrb_intern_cstr(mrb, "KEY_CAPITAL_S"), ev);
    } while (0);

    do {
        mrb_value ev = mrb_fixnum_value((mrb_int)cocos2d::EventKeyboard::KeyCode::KEY_CAPITAL_T);
        mrb_mod_cv_set(mrb, renum, mrb_intern_cstr(mrb, "KEY_CAPITAL_T"), ev);
    } while (0);

    do {
        mrb_value ev = mrb_fixnum_value((mrb_int)cocos2d::EventKeyboard::KeyCode::KEY_CAPITAL_U);
        mrb_mod_cv_set(mrb, renum, mrb_intern_cstr(mrb, "KEY_CAPITAL_U"), ev);
    } while (0);

    do {
        mrb_value ev = mrb_fixnum_value((mrb_int)cocos2d::EventKeyboard::KeyCode::KEY_CAPITAL_V);
        mrb_mod_cv_set(mrb, renum, mrb_intern_cstr(mrb, "KEY_CAPITAL_V"), ev);
    } while (0);

    do {
        mrb_value ev = mrb_fixnum_value((mrb_int)cocos2d::EventKeyboard::KeyCode::KEY_CAPITAL_W);
        mrb_mod_cv_set(mrb, renum, mrb_intern_cstr(mrb, "KEY_CAPITAL_W"), ev);
    } while (0);

    do {
        mrb_value ev = mrb_fixnum_value((mrb_int)cocos2d::EventKeyboard::KeyCode::KEY_CAPITAL_X);
        mrb_mod_cv_set(mrb, renum, mrb_intern_cstr(mrb, "KEY_CAPITAL_X"), ev);
    } while (0);

    do {
        mrb_value ev = mrb_fixnum_value((mrb_int)cocos2d::EventKeyboard::KeyCode::KEY_CAPITAL_Y);
        mrb_mod_cv_set(mrb, renum, mrb_intern_cstr(mrb, "KEY_CAPITAL_Y"), ev);
    } while (0);

    do {
        mrb_value ev = mrb_fixnum_value((mrb_int)cocos2d::EventKeyboard::KeyCode::KEY_CAPITAL_Z);
        mrb_mod_cv_set(mrb, renum, mrb_intern_cstr(mrb, "KEY_CAPITAL_Z"), ev);
    } while (0);

    do {
        mrb_value ev = mrb_fixnum_value((mrb_int)cocos2d::EventKeyboard::KeyCode::KEY_LEFT_BRACKET);
        mrb_mod_cv_set(mrb, renum, mrb_intern_cstr(mrb, "KEY_LEFT_BRACKET"), ev);
    } while (0);

    do {
        mrb_value ev = mrb_fixnum_value((mrb_int)cocos2d::EventKeyboard::KeyCode::KEY_BACK_SLASH);
        mrb_mod_cv_set(mrb, renum, mrb_intern_cstr(mrb, "KEY_BACK_SLASH"), ev);
    } while (0);

    do {
        mrb_value ev = mrb_fixnum_value((mrb_int)cocos2d::EventKeyboard::KeyCode::KEY_RIGHT_BRACKET);
        mrb_mod_cv_set(mrb, renum, mrb_intern_cstr(mrb, "KEY_RIGHT_BRACKET"), ev);
    } while (0);

    do {
        mrb_value ev = mrb_fixnum_value((mrb_int)cocos2d::EventKeyboard::KeyCode::KEY_UNDERSCORE);
        mrb_mod_cv_set(mrb, renum, mrb_intern_cstr(mrb, "KEY_UNDERSCORE"), ev);
    } while (0);

    do {
        mrb_value ev = mrb_fixnum_value((mrb_int)cocos2d::EventKeyboard::KeyCode::KEY_GRAVE);
        mrb_mod_cv_set(mrb, renum, mrb_intern_cstr(mrb, "KEY_GRAVE"), ev);
    } while (0);

    do {
        mrb_value ev = mrb_fixnum_value((mrb_int)cocos2d::EventKeyboard::KeyCode::KEY_A);
        mrb_mod_cv_set(mrb, renum, mrb_intern_cstr(mrb, "KEY_A"), ev);
    } while (0);

    do {
        mrb_value ev = mrb_fixnum_value((mrb_int)cocos2d::EventKeyboard::KeyCode::KEY_B);
        mrb_mod_cv_set(mrb, renum, mrb_intern_cstr(mrb, "KEY_B"), ev);
    } while (0);

    do {
        mrb_value ev = mrb_fixnum_value((mrb_int)cocos2d::EventKeyboard::KeyCode::KEY_C);
        mrb_mod_cv_set(mrb, renum, mrb_intern_cstr(mrb, "KEY_C"), ev);
    } while (0);

    do {
        mrb_value ev = mrb_fixnum_value((mrb_int)cocos2d::EventKeyboard::KeyCode::KEY_D);
        mrb_mod_cv_set(mrb, renum, mrb_intern_cstr(mrb, "KEY_D"), ev);
    } while (0);

    do {
        mrb_value ev = mrb_fixnum_value((mrb_int)cocos2d::EventKeyboard::KeyCode::KEY_E);
        mrb_mod_cv_set(mrb, renum, mrb_intern_cstr(mrb, "KEY_E"), ev);
    } while (0);

    do {
        mrb_value ev = mrb_fixnum_value((mrb_int)cocos2d::EventKeyboard::KeyCode::KEY_F);
        mrb_mod_cv_set(mrb, renum, mrb_intern_cstr(mrb, "KEY_F"), ev);
    } while (0);

    do {
        mrb_value ev = mrb_fixnum_value((mrb_int)cocos2d::EventKeyboard::KeyCode::KEY_G);
        mrb_mod_cv_set(mrb, renum, mrb_intern_cstr(mrb, "KEY_G"), ev);
    } while (0);

    do {
        mrb_value ev = mrb_fixnum_value((mrb_int)cocos2d::EventKeyboard::KeyCode::KEY_H);
        mrb_mod_cv_set(mrb, renum, mrb_intern_cstr(mrb, "KEY_H"), ev);
    } while (0);

    do {
        mrb_value ev = mrb_fixnum_value((mrb_int)cocos2d::EventKeyboard::KeyCode::KEY_I);
        mrb_mod_cv_set(mrb, renum, mrb_intern_cstr(mrb, "KEY_I"), ev);
    } while (0);

    do {
        mrb_value ev = mrb_fixnum_value((mrb_int)cocos2d::EventKeyboard::KeyCode::KEY_J);
        mrb_mod_cv_set(mrb, renum, mrb_intern_cstr(mrb, "KEY_J"), ev);
    } while (0);

    do {
        mrb_value ev = mrb_fixnum_value((mrb_int)cocos2d::EventKeyboard::KeyCode::KEY_K);
        mrb_mod_cv_set(mrb, renum, mrb_intern_cstr(mrb, "KEY_K"), ev);
    } while (0);

    do {
        mrb_value ev = mrb_fixnum_value((mrb_int)cocos2d::EventKeyboard::KeyCode::KEY_L);
        mrb_mod_cv_set(mrb, renum, mrb_intern_cstr(mrb, "KEY_L"), ev);
    } while (0);

    do {
        mrb_value ev = mrb_fixnum_value((mrb_int)cocos2d::EventKeyboard::KeyCode::KEY_M);
        mrb_mod_cv_set(mrb, renum, mrb_intern_cstr(mrb, "KEY_M"), ev);
    } while (0);

    do {
        mrb_value ev = mrb_fixnum_value((mrb_int)cocos2d::EventKeyboard::KeyCode::KEY_N);
        mrb_mod_cv_set(mrb, renum, mrb_intern_cstr(mrb, "KEY_N"), ev);
    } while (0);

    do {
        mrb_value ev = mrb_fixnum_value((mrb_int)cocos2d::EventKeyboard::KeyCode::KEY_O);
        mrb_mod_cv_set(mrb, renum, mrb_intern_cstr(mrb, "KEY_O"), ev);
    } while (0);

    do {
        mrb_value ev = mrb_fixnum_value((mrb_int)cocos2d::EventKeyboard::KeyCode::KEY_P);
        mrb_mod_cv_set(mrb, renum, mrb_intern_cstr(mrb, "KEY_P"), ev);
    } while (0);

    do {
        mrb_value ev = mrb_fixnum_value((mrb_int)cocos2d::EventKeyboard::KeyCode::KEY_Q);
        mrb_mod_cv_set(mrb, renum, mrb_intern_cstr(mrb, "KEY_Q"), ev);
    } while (0);

    do {
        mrb_value ev = mrb_fixnum_value((mrb_int)cocos2d::EventKeyboard::KeyCode::KEY_R);
        mrb_mod_cv_set(mrb, renum, mrb_intern_cstr(mrb, "KEY_R"), ev);
    } while (0);

    do {
        mrb_value ev = mrb_fixnum_value((mrb_int)cocos2d::EventKeyboard::KeyCode::KEY_S);
        mrb_mod_cv_set(mrb, renum, mrb_intern_cstr(mrb, "KEY_S"), ev);
    } while (0);

    do {
        mrb_value ev = mrb_fixnum_value((mrb_int)cocos2d::EventKeyboard::KeyCode::KEY_T);
        mrb_mod_cv_set(mrb, renum, mrb_intern_cstr(mrb, "KEY_T"), ev);
    } while (0);

    do {
        mrb_value ev = mrb_fixnum_value((mrb_int)cocos2d::EventKeyboard::KeyCode::KEY_U);
        mrb_mod_cv_set(mrb, renum, mrb_intern_cstr(mrb, "KEY_U"), ev);
    } while (0);

    do {
        mrb_value ev = mrb_fixnum_value((mrb_int)cocos2d::EventKeyboard::KeyCode::KEY_V);
        mrb_mod_cv_set(mrb, renum, mrb_intern_cstr(mrb, "KEY_V"), ev);
    } while (0);

    do {
        mrb_value ev = mrb_fixnum_value((mrb_int)cocos2d::EventKeyboard::KeyCode::KEY_W);
        mrb_mod_cv_set(mrb, renum, mrb_intern_cstr(mrb, "KEY_W"), ev);
    } while (0);

    do {
        mrb_value ev = mrb_fixnum_value((mrb_int)cocos2d::EventKeyboard::KeyCode::KEY_X);
        mrb_mod_cv_set(mrb, renum, mrb_intern_cstr(mrb, "KEY_X"), ev);
    } while (0);

    do {
        mrb_value ev = mrb_fixnum_value((mrb_int)cocos2d::EventKeyboard::KeyCode::KEY_Y);
        mrb_mod_cv_set(mrb, renum, mrb_intern_cstr(mrb, "KEY_Y"), ev);
    } while (0);

    do {
        mrb_value ev = mrb_fixnum_value((mrb_int)cocos2d::EventKeyboard::KeyCode::KEY_Z);
        mrb_mod_cv_set(mrb, renum, mrb_intern_cstr(mrb, "KEY_Z"), ev);
    } while (0);

    do {
        mrb_value ev = mrb_fixnum_value((mrb_int)cocos2d::EventKeyboard::KeyCode::KEY_LEFT_BRACE);
        mrb_mod_cv_set(mrb, renum, mrb_intern_cstr(mrb, "KEY_LEFT_BRACE"), ev);
    } while (0);

    do {
        mrb_value ev = mrb_fixnum_value((mrb_int)cocos2d::EventKeyboard::KeyCode::KEY_BAR);
        mrb_mod_cv_set(mrb, renum, mrb_intern_cstr(mrb, "KEY_BAR"), ev);
    } while (0);

    do {
        mrb_value ev = mrb_fixnum_value((mrb_int)cocos2d::EventKeyboard::KeyCode::KEY_RIGHT_BRACE);
        mrb_mod_cv_set(mrb, renum, mrb_intern_cstr(mrb, "KEY_RIGHT_BRACE"), ev);
    } while (0);

    do {
        mrb_value ev = mrb_fixnum_value((mrb_int)cocos2d::EventKeyboard::KeyCode::KEY_TILDE);
        mrb_mod_cv_set(mrb, renum, mrb_intern_cstr(mrb, "KEY_TILDE"), ev);
    } while (0);

    do {
        mrb_value ev = mrb_fixnum_value((mrb_int)cocos2d::EventKeyboard::KeyCode::KEY_EURO);
        mrb_mod_cv_set(mrb, renum, mrb_intern_cstr(mrb, "KEY_EURO"), ev);
    } while (0);

    do {
        mrb_value ev = mrb_fixnum_value((mrb_int)cocos2d::EventKeyboard::KeyCode::KEY_POUND);
        mrb_mod_cv_set(mrb, renum, mrb_intern_cstr(mrb, "KEY_POUND"), ev);
    } while (0);

    do {
        mrb_value ev = mrb_fixnum_value((mrb_int)cocos2d::EventKeyboard::KeyCode::KEY_YEN);
        mrb_mod_cv_set(mrb, renum, mrb_intern_cstr(mrb, "KEY_YEN"), ev);
    } while (0);

    do {
        mrb_value ev = mrb_fixnum_value((mrb_int)cocos2d::EventKeyboard::KeyCode::KEY_MIDDLE_DOT);
        mrb_mod_cv_set(mrb, renum, mrb_intern_cstr(mrb, "KEY_MIDDLE_DOT"), ev);
    } while (0);

    do {
        mrb_value ev = mrb_fixnum_value((mrb_int)cocos2d::EventKeyboard::KeyCode::KEY_SEARCH);
        mrb_mod_cv_set(mrb, renum, mrb_intern_cstr(mrb, "KEY_SEARCH"), ev);
    } while (0);

    do {
        mrb_value ev = mrb_fixnum_value((mrb_int)cocos2d::EventKeyboard::KeyCode::KEY_DPAD_LEFT);
        mrb_mod_cv_set(mrb, renum, mrb_intern_cstr(mrb, "KEY_DPAD_LEFT"), ev);
    } while (0);

    do {
        mrb_value ev = mrb_fixnum_value((mrb_int)cocos2d::EventKeyboard::KeyCode::KEY_DPAD_RIGHT);
        mrb_mod_cv_set(mrb, renum, mrb_intern_cstr(mrb, "KEY_DPAD_RIGHT"), ev);
    } while (0);

    do {
        mrb_value ev = mrb_fixnum_value((mrb_int)cocos2d::EventKeyboard::KeyCode::KEY_DPAD_UP);
        mrb_mod_cv_set(mrb, renum, mrb_intern_cstr(mrb, "KEY_DPAD_UP"), ev);
    } while (0);

    do {
        mrb_value ev = mrb_fixnum_value((mrb_int)cocos2d::EventKeyboard::KeyCode::KEY_DPAD_DOWN);
        mrb_mod_cv_set(mrb, renum, mrb_intern_cstr(mrb, "KEY_DPAD_DOWN"), ev);
    } while (0);

    do {
        mrb_value ev = mrb_fixnum_value((mrb_int)cocos2d::EventKeyboard::KeyCode::KEY_DPAD_CENTER);
        mrb_mod_cv_set(mrb, renum, mrb_intern_cstr(mrb, "KEY_DPAD_CENTER"), ev);
    } while (0);

    do {
        mrb_value ev = mrb_fixnum_value((mrb_int)cocos2d::EventKeyboard::KeyCode::KEY_ENTER);
        mrb_mod_cv_set(mrb, renum, mrb_intern_cstr(mrb, "KEY_ENTER"), ev);
    } while (0);

    do {
        mrb_value ev = mrb_fixnum_value((mrb_int)cocos2d::EventKeyboard::KeyCode::KEY_PLAY);
        mrb_mod_cv_set(mrb, renum, mrb_intern_cstr(mrb, "KEY_PLAY"), ev);
    } while (0);

}

void ruby_register_cocos2dx_EventKeyboard(mrb_state* mrb, struct RClass* rmodule)
{
    std::string typeName = typeid(cocos2d::EventKeyboard).name();
    g_rubyType[typeName] = "CC::EventKeyboard";
    g_rubyDataType[typeName] = &ruby_cocos2dx_Ref_type;

    struct RClass* p_rmodule = mrb->object_class;
    p_rmodule = mrb_module_get_under(mrb, p_rmodule, "CC");
    struct RClass* p_rclass = mrb_class_get_under(mrb, p_rmodule, "Event");
    struct RClass *rclass = mrb_define_class_under(mrb, rmodule, "EventKeyboard", p_rclass);
    MRB_SET_INSTANCE_TT(rclass, MRB_TT_DATA);

    mrb_define_method(mrb, rclass, "initialize", ruby_cocos2dx_EventKeyboard_constructor, ARGS_REQ(2));
    struct RClass* renum_KeyCode = mrb_define_module_under(mrb, rclass, "KeyCode");
    ruby_cocos2dx_EventKeyboard_KeyCode_enum_init(mrb, renum_KeyCode);
    mrb_define_class_method(mrb, renum_KeyCode, "KEY_NONE", ruby_cocos2dx_constant_get, ARGS_NONE());
    mrb_define_class_method(mrb, renum_KeyCode, "KEY_PAUSE", ruby_cocos2dx_constant_get, ARGS_NONE());
    mrb_define_class_method(mrb, renum_KeyCode, "KEY_SCROLL_LOCK", ruby_cocos2dx_constant_get, ARGS_NONE());
    mrb_define_class_method(mrb, renum_KeyCode, "KEY_PRINT", ruby_cocos2dx_constant_get, ARGS_NONE());
    mrb_define_class_method(mrb, renum_KeyCode, "KEY_SYSREQ", ruby_cocos2dx_constant_get, ARGS_NONE());
    mrb_define_class_method(mrb, renum_KeyCode, "KEY_BREAK", ruby_cocos2dx_constant_get, ARGS_NONE());
    mrb_define_class_method(mrb, renum_KeyCode, "KEY_ESCAPE", ruby_cocos2dx_constant_get, ARGS_NONE());
    mrb_define_class_method(mrb, renum_KeyCode, "KEY_BACK", ruby_cocos2dx_constant_get, ARGS_NONE());
    mrb_define_class_method(mrb, renum_KeyCode, "KEY_BACKSPACE", ruby_cocos2dx_constant_get, ARGS_NONE());
    mrb_define_class_method(mrb, renum_KeyCode, "KEY_TAB", ruby_cocos2dx_constant_get, ARGS_NONE());
    mrb_define_class_method(mrb, renum_KeyCode, "KEY_BACK_TAB", ruby_cocos2dx_constant_get, ARGS_NONE());
    mrb_define_class_method(mrb, renum_KeyCode, "KEY_RETURN", ruby_cocos2dx_constant_get, ARGS_NONE());
    mrb_define_class_method(mrb, renum_KeyCode, "KEY_CAPS_LOCK", ruby_cocos2dx_constant_get, ARGS_NONE());
    mrb_define_class_method(mrb, renum_KeyCode, "KEY_SHIFT", ruby_cocos2dx_constant_get, ARGS_NONE());
    mrb_define_class_method(mrb, renum_KeyCode, "KEY_LEFT_SHIFT", ruby_cocos2dx_constant_get, ARGS_NONE());
    mrb_define_class_method(mrb, renum_KeyCode, "KEY_RIGHT_SHIFT", ruby_cocos2dx_constant_get, ARGS_NONE());
    mrb_define_class_method(mrb, renum_KeyCode, "KEY_CTRL", ruby_cocos2dx_constant_get, ARGS_NONE());
    mrb_define_class_method(mrb, renum_KeyCode, "KEY_LEFT_CTRL", ruby_cocos2dx_constant_get, ARGS_NONE());
    mrb_define_class_method(mrb, renum_KeyCode, "KEY_RIGHT_CTRL", ruby_cocos2dx_constant_get, ARGS_NONE());
    mrb_define_class_method(mrb, renum_KeyCode, "KEY_ALT", ruby_cocos2dx_constant_get, ARGS_NONE());
    mrb_define_class_method(mrb, renum_KeyCode, "KEY_LEFT_ALT", ruby_cocos2dx_constant_get, ARGS_NONE());
    mrb_define_class_method(mrb, renum_KeyCode, "KEY_RIGHT_ALT", ruby_cocos2dx_constant_get, ARGS_NONE());
    mrb_define_class_method(mrb, renum_KeyCode, "KEY_MENU", ruby_cocos2dx_constant_get, ARGS_NONE());
    mrb_define_class_method(mrb, renum_KeyCode, "KEY_HYPER", ruby_cocos2dx_constant_get, ARGS_NONE());
    mrb_define_class_method(mrb, renum_KeyCode, "KEY_INSERT", ruby_cocos2dx_constant_get, ARGS_NONE());
    mrb_define_class_method(mrb, renum_KeyCode, "KEY_HOME", ruby_cocos2dx_constant_get, ARGS_NONE());
    mrb_define_class_method(mrb, renum_KeyCode, "KEY_PG_UP", ruby_cocos2dx_constant_get, ARGS_NONE());
    mrb_define_class_method(mrb, renum_KeyCode, "KEY_DELETE", ruby_cocos2dx_constant_get, ARGS_NONE());
    mrb_define_class_method(mrb, renum_KeyCode, "KEY_END", ruby_cocos2dx_constant_get, ARGS_NONE());
    mrb_define_class_method(mrb, renum_KeyCode, "KEY_PG_DOWN", ruby_cocos2dx_constant_get, ARGS_NONE());
    mrb_define_class_method(mrb, renum_KeyCode, "KEY_LEFT_ARROW", ruby_cocos2dx_constant_get, ARGS_NONE());
    mrb_define_class_method(mrb, renum_KeyCode, "KEY_RIGHT_ARROW", ruby_cocos2dx_constant_get, ARGS_NONE());
    mrb_define_class_method(mrb, renum_KeyCode, "KEY_UP_ARROW", ruby_cocos2dx_constant_get, ARGS_NONE());
    mrb_define_class_method(mrb, renum_KeyCode, "KEY_DOWN_ARROW", ruby_cocos2dx_constant_get, ARGS_NONE());
    mrb_define_class_method(mrb, renum_KeyCode, "KEY_NUM_LOCK", ruby_cocos2dx_constant_get, ARGS_NONE());
    mrb_define_class_method(mrb, renum_KeyCode, "KEY_KP_PLUS", ruby_cocos2dx_constant_get, ARGS_NONE());
    mrb_define_class_method(mrb, renum_KeyCode, "KEY_KP_MINUS", ruby_cocos2dx_constant_get, ARGS_NONE());
    mrb_define_class_method(mrb, renum_KeyCode, "KEY_KP_MULTIPLY", ruby_cocos2dx_constant_get, ARGS_NONE());
    mrb_define_class_method(mrb, renum_KeyCode, "KEY_KP_DIVIDE", ruby_cocos2dx_constant_get, ARGS_NONE());
    mrb_define_class_method(mrb, renum_KeyCode, "KEY_KP_ENTER", ruby_cocos2dx_constant_get, ARGS_NONE());
    mrb_define_class_method(mrb, renum_KeyCode, "KEY_KP_HOME", ruby_cocos2dx_constant_get, ARGS_NONE());
    mrb_define_class_method(mrb, renum_KeyCode, "KEY_KP_UP", ruby_cocos2dx_constant_get, ARGS_NONE());
    mrb_define_class_method(mrb, renum_KeyCode, "KEY_KP_PG_UP", ruby_cocos2dx_constant_get, ARGS_NONE());
    mrb_define_class_method(mrb, renum_KeyCode, "KEY_KP_LEFT", ruby_cocos2dx_constant_get, ARGS_NONE());
    mrb_define_class_method(mrb, renum_KeyCode, "KEY_KP_FIVE", ruby_cocos2dx_constant_get, ARGS_NONE());
    mrb_define_class_method(mrb, renum_KeyCode, "KEY_KP_RIGHT", ruby_cocos2dx_constant_get, ARGS_NONE());
    mrb_define_class_method(mrb, renum_KeyCode, "KEY_KP_END", ruby_cocos2dx_constant_get, ARGS_NONE());
    mrb_define_class_method(mrb, renum_KeyCode, "KEY_KP_DOWN", ruby_cocos2dx_constant_get, ARGS_NONE());
    mrb_define_class_method(mrb, renum_KeyCode, "KEY_KP_PG_DOWN", ruby_cocos2dx_constant_get, ARGS_NONE());
    mrb_define_class_method(mrb, renum_KeyCode, "KEY_KP_INSERT", ruby_cocos2dx_constant_get, ARGS_NONE());
    mrb_define_class_method(mrb, renum_KeyCode, "KEY_KP_DELETE", ruby_cocos2dx_constant_get, ARGS_NONE());
    mrb_define_class_method(mrb, renum_KeyCode, "KEY_F1", ruby_cocos2dx_constant_get, ARGS_NONE());
    mrb_define_class_method(mrb, renum_KeyCode, "KEY_F2", ruby_cocos2dx_constant_get, ARGS_NONE());
    mrb_define_class_method(mrb, renum_KeyCode, "KEY_F3", ruby_cocos2dx_constant_get, ARGS_NONE());
    mrb_define_class_method(mrb, renum_KeyCode, "KEY_F4", ruby_cocos2dx_constant_get, ARGS_NONE());
    mrb_define_class_method(mrb, renum_KeyCode, "KEY_F5", ruby_cocos2dx_constant_get, ARGS_NONE());
    mrb_define_class_method(mrb, renum_KeyCode, "KEY_F6", ruby_cocos2dx_constant_get, ARGS_NONE());
    mrb_define_class_method(mrb, renum_KeyCode, "KEY_F7", ruby_cocos2dx_constant_get, ARGS_NONE());
    mrb_define_class_method(mrb, renum_KeyCode, "KEY_F8", ruby_cocos2dx_constant_get, ARGS_NONE());
    mrb_define_class_method(mrb, renum_KeyCode, "KEY_F9", ruby_cocos2dx_constant_get, ARGS_NONE());
    mrb_define_class_method(mrb, renum_KeyCode, "KEY_F10", ruby_cocos2dx_constant_get, ARGS_NONE());
    mrb_define_class_method(mrb, renum_KeyCode, "KEY_F11", ruby_cocos2dx_constant_get, ARGS_NONE());
    mrb_define_class_method(mrb, renum_KeyCode, "KEY_F12", ruby_cocos2dx_constant_get, ARGS_NONE());
    mrb_define_class_method(mrb, renum_KeyCode, "KEY_SPACE", ruby_cocos2dx_constant_get, ARGS_NONE());
    mrb_define_class_method(mrb, renum_KeyCode, "KEY_EXCLAM", ruby_cocos2dx_constant_get, ARGS_NONE());
    mrb_define_class_method(mrb, renum_KeyCode, "KEY_QUOTE", ruby_cocos2dx_constant_get, ARGS_NONE());
    mrb_define_class_method(mrb, renum_KeyCode, "KEY_NUMBER", ruby_cocos2dx_constant_get, ARGS_NONE());
    mrb_define_class_method(mrb, renum_KeyCode, "KEY_DOLLAR", ruby_cocos2dx_constant_get, ARGS_NONE());
    mrb_define_class_method(mrb, renum_KeyCode, "KEY_PERCENT", ruby_cocos2dx_constant_get, ARGS_NONE());
    mrb_define_class_method(mrb, renum_KeyCode, "KEY_CIRCUMFLEX", ruby_cocos2dx_constant_get, ARGS_NONE());
    mrb_define_class_method(mrb, renum_KeyCode, "KEY_AMPERSAND", ruby_cocos2dx_constant_get, ARGS_NONE());
    mrb_define_class_method(mrb, renum_KeyCode, "KEY_APOSTROPHE", ruby_cocos2dx_constant_get, ARGS_NONE());
    mrb_define_class_method(mrb, renum_KeyCode, "KEY_LEFT_PARENTHESIS", ruby_cocos2dx_constant_get, ARGS_NONE());
    mrb_define_class_method(mrb, renum_KeyCode, "KEY_RIGHT_PARENTHESIS", ruby_cocos2dx_constant_get, ARGS_NONE());
    mrb_define_class_method(mrb, renum_KeyCode, "KEY_ASTERISK", ruby_cocos2dx_constant_get, ARGS_NONE());
    mrb_define_class_method(mrb, renum_KeyCode, "KEY_PLUS", ruby_cocos2dx_constant_get, ARGS_NONE());
    mrb_define_class_method(mrb, renum_KeyCode, "KEY_COMMA", ruby_cocos2dx_constant_get, ARGS_NONE());
    mrb_define_class_method(mrb, renum_KeyCode, "KEY_MINUS", ruby_cocos2dx_constant_get, ARGS_NONE());
    mrb_define_class_method(mrb, renum_KeyCode, "KEY_PERIOD", ruby_cocos2dx_constant_get, ARGS_NONE());
    mrb_define_class_method(mrb, renum_KeyCode, "KEY_SLASH", ruby_cocos2dx_constant_get, ARGS_NONE());
    mrb_define_class_method(mrb, renum_KeyCode, "KEY_0", ruby_cocos2dx_constant_get, ARGS_NONE());
    mrb_define_class_method(mrb, renum_KeyCode, "KEY_1", ruby_cocos2dx_constant_get, ARGS_NONE());
    mrb_define_class_method(mrb, renum_KeyCode, "KEY_2", ruby_cocos2dx_constant_get, ARGS_NONE());
    mrb_define_class_method(mrb, renum_KeyCode, "KEY_3", ruby_cocos2dx_constant_get, ARGS_NONE());
    mrb_define_class_method(mrb, renum_KeyCode, "KEY_4", ruby_cocos2dx_constant_get, ARGS_NONE());
    mrb_define_class_method(mrb, renum_KeyCode, "KEY_5", ruby_cocos2dx_constant_get, ARGS_NONE());
    mrb_define_class_method(mrb, renum_KeyCode, "KEY_6", ruby_cocos2dx_constant_get, ARGS_NONE());
    mrb_define_class_method(mrb, renum_KeyCode, "KEY_7", ruby_cocos2dx_constant_get, ARGS_NONE());
    mrb_define_class_method(mrb, renum_KeyCode, "KEY_8", ruby_cocos2dx_constant_get, ARGS_NONE());
    mrb_define_class_method(mrb, renum_KeyCode, "KEY_9", ruby_cocos2dx_constant_get, ARGS_NONE());
    mrb_define_class_method(mrb, renum_KeyCode, "KEY_COLON", ruby_cocos2dx_constant_get, ARGS_NONE());
    mrb_define_class_method(mrb, renum_KeyCode, "KEY_SEMICOLON", ruby_cocos2dx_constant_get, ARGS_NONE());
    mrb_define_class_method(mrb, renum_KeyCode, "KEY_LESS_THAN", ruby_cocos2dx_constant_get, ARGS_NONE());
    mrb_define_class_method(mrb, renum_KeyCode, "KEY_EQUAL", ruby_cocos2dx_constant_get, ARGS_NONE());
    mrb_define_class_method(mrb, renum_KeyCode, "KEY_GREATER_THAN", ruby_cocos2dx_constant_get, ARGS_NONE());
    mrb_define_class_method(mrb, renum_KeyCode, "KEY_QUESTION", ruby_cocos2dx_constant_get, ARGS_NONE());
    mrb_define_class_method(mrb, renum_KeyCode, "KEY_AT", ruby_cocos2dx_constant_get, ARGS_NONE());
    mrb_define_class_method(mrb, renum_KeyCode, "KEY_CAPITAL_A", ruby_cocos2dx_constant_get, ARGS_NONE());
    mrb_define_class_method(mrb, renum_KeyCode, "KEY_CAPITAL_B", ruby_cocos2dx_constant_get, ARGS_NONE());
    mrb_define_class_method(mrb, renum_KeyCode, "KEY_CAPITAL_C", ruby_cocos2dx_constant_get, ARGS_NONE());
    mrb_define_class_method(mrb, renum_KeyCode, "KEY_CAPITAL_D", ruby_cocos2dx_constant_get, ARGS_NONE());
    mrb_define_class_method(mrb, renum_KeyCode, "KEY_CAPITAL_E", ruby_cocos2dx_constant_get, ARGS_NONE());
    mrb_define_class_method(mrb, renum_KeyCode, "KEY_CAPITAL_F", ruby_cocos2dx_constant_get, ARGS_NONE());
    mrb_define_class_method(mrb, renum_KeyCode, "KEY_CAPITAL_G", ruby_cocos2dx_constant_get, ARGS_NONE());
    mrb_define_class_method(mrb, renum_KeyCode, "KEY_CAPITAL_H", ruby_cocos2dx_constant_get, ARGS_NONE());
    mrb_define_class_method(mrb, renum_KeyCode, "KEY_CAPITAL_I", ruby_cocos2dx_constant_get, ARGS_NONE());
    mrb_define_class_method(mrb, renum_KeyCode, "KEY_CAPITAL_J", ruby_cocos2dx_constant_get, ARGS_NONE());
    mrb_define_class_method(mrb, renum_KeyCode, "KEY_CAPITAL_K", ruby_cocos2dx_constant_get, ARGS_NONE());
    mrb_define_class_method(mrb, renum_KeyCode, "KEY_CAPITAL_L", ruby_cocos2dx_constant_get, ARGS_NONE());
    mrb_define_class_method(mrb, renum_KeyCode, "KEY_CAPITAL_M", ruby_cocos2dx_constant_get, ARGS_NONE());
    mrb_define_class_method(mrb, renum_KeyCode, "KEY_CAPITAL_N", ruby_cocos2dx_constant_get, ARGS_NONE());
    mrb_define_class_method(mrb, renum_KeyCode, "KEY_CAPITAL_O", ruby_cocos2dx_constant_get, ARGS_NONE());
    mrb_define_class_method(mrb, renum_KeyCode, "KEY_CAPITAL_P", ruby_cocos2dx_constant_get, ARGS_NONE());
    mrb_define_class_method(mrb, renum_KeyCode, "KEY_CAPITAL_Q", ruby_cocos2dx_constant_get, ARGS_NONE());
    mrb_define_class_method(mrb, renum_KeyCode, "KEY_CAPITAL_R", ruby_cocos2dx_constant_get, ARGS_NONE());
    mrb_define_class_method(mrb, renum_KeyCode, "KEY_CAPITAL_S", ruby_cocos2dx_constant_get, ARGS_NONE());
    mrb_define_class_method(mrb, renum_KeyCode, "KEY_CAPITAL_T", ruby_cocos2dx_constant_get, ARGS_NONE());
    mrb_define_class_method(mrb, renum_KeyCode, "KEY_CAPITAL_U", ruby_cocos2dx_constant_get, ARGS_NONE());
    mrb_define_class_method(mrb, renum_KeyCode, "KEY_CAPITAL_V", ruby_cocos2dx_constant_get, ARGS_NONE());
    mrb_define_class_method(mrb, renum_KeyCode, "KEY_CAPITAL_W", ruby_cocos2dx_constant_get, ARGS_NONE());
    mrb_define_class_method(mrb, renum_KeyCode, "KEY_CAPITAL_X", ruby_cocos2dx_constant_get, ARGS_NONE());
    mrb_define_class_method(mrb, renum_KeyCode, "KEY_CAPITAL_Y", ruby_cocos2dx_constant_get, ARGS_NONE());
    mrb_define_class_method(mrb, renum_KeyCode, "KEY_CAPITAL_Z", ruby_cocos2dx_constant_get, ARGS_NONE());
    mrb_define_class_method(mrb, renum_KeyCode, "KEY_LEFT_BRACKET", ruby_cocos2dx_constant_get, ARGS_NONE());
    mrb_define_class_method(mrb, renum_KeyCode, "KEY_BACK_SLASH", ruby_cocos2dx_constant_get, ARGS_NONE());
    mrb_define_class_method(mrb, renum_KeyCode, "KEY_RIGHT_BRACKET", ruby_cocos2dx_constant_get, ARGS_NONE());
    mrb_define_class_method(mrb, renum_KeyCode, "KEY_UNDERSCORE", ruby_cocos2dx_constant_get, ARGS_NONE());
    mrb_define_class_method(mrb, renum_KeyCode, "KEY_GRAVE", ruby_cocos2dx_constant_get, ARGS_NONE());
    mrb_define_class_method(mrb, renum_KeyCode, "KEY_A", ruby_cocos2dx_constant_get, ARGS_NONE());
    mrb_define_class_method(mrb, renum_KeyCode, "KEY_B", ruby_cocos2dx_constant_get, ARGS_NONE());
    mrb_define_class_method(mrb, renum_KeyCode, "KEY_C", ruby_cocos2dx_constant_get, ARGS_NONE());
    mrb_define_class_method(mrb, renum_KeyCode, "KEY_D", ruby_cocos2dx_constant_get, ARGS_NONE());
    mrb_define_class_method(mrb, renum_KeyCode, "KEY_E", ruby_cocos2dx_constant_get, ARGS_NONE());
    mrb_define_class_method(mrb, renum_KeyCode, "KEY_F", ruby_cocos2dx_constant_get, ARGS_NONE());
    mrb_define_class_method(mrb, renum_KeyCode, "KEY_G", ruby_cocos2dx_constant_get, ARGS_NONE());
    mrb_define_class_method(mrb, renum_KeyCode, "KEY_H", ruby_cocos2dx_constant_get, ARGS_NONE());
    mrb_define_class_method(mrb, renum_KeyCode, "KEY_I", ruby_cocos2dx_constant_get, ARGS_NONE());
    mrb_define_class_method(mrb, renum_KeyCode, "KEY_J", ruby_cocos2dx_constant_get, ARGS_NONE());
    mrb_define_class_method(mrb, renum_KeyCode, "KEY_K", ruby_cocos2dx_constant_get, ARGS_NONE());
    mrb_define_class_method(mrb, renum_KeyCode, "KEY_L", ruby_cocos2dx_constant_get, ARGS_NONE());
    mrb_define_class_method(mrb, renum_KeyCode, "KEY_M", ruby_cocos2dx_constant_get, ARGS_NONE());
    mrb_define_class_method(mrb, renum_KeyCode, "KEY_N", ruby_cocos2dx_constant_get, ARGS_NONE());
    mrb_define_class_method(mrb, renum_KeyCode, "KEY_O", ruby_cocos2dx_constant_get, ARGS_NONE());
    mrb_define_class_method(mrb, renum_KeyCode, "KEY_P", ruby_cocos2dx_constant_get, ARGS_NONE());
    mrb_define_class_method(mrb, renum_KeyCode, "KEY_Q", ruby_cocos2dx_constant_get, ARGS_NONE());
    mrb_define_class_method(mrb, renum_KeyCode, "KEY_R", ruby_cocos2dx_constant_get, ARGS_NONE());
    mrb_define_class_method(mrb, renum_KeyCode, "KEY_S", ruby_cocos2dx_constant_get, ARGS_NONE());
    mrb_define_class_method(mrb, renum_KeyCode, "KEY_T", ruby_cocos2dx_constant_get, ARGS_NONE());
    mrb_define_class_method(mrb, renum_KeyCode, "KEY_U", ruby_cocos2dx_constant_get, ARGS_NONE());
    mrb_define_class_method(mrb, renum_KeyCode, "KEY_V", ruby_cocos2dx_constant_get, ARGS_NONE());
    mrb_define_class_method(mrb, renum_KeyCode, "KEY_W", ruby_cocos2dx_constant_get, ARGS_NONE());
    mrb_define_class_method(mrb, renum_KeyCode, "KEY_X", ruby_cocos2dx_constant_get, ARGS_NONE());
    mrb_define_class_method(mrb, renum_KeyCode, "KEY_Y", ruby_cocos2dx_constant_get, ARGS_NONE());
    mrb_define_class_method(mrb, renum_KeyCode, "KEY_Z", ruby_cocos2dx_constant_get, ARGS_NONE());
    mrb_define_class_method(mrb, renum_KeyCode, "KEY_LEFT_BRACE", ruby_cocos2dx_constant_get, ARGS_NONE());
    mrb_define_class_method(mrb, renum_KeyCode, "KEY_BAR", ruby_cocos2dx_constant_get, ARGS_NONE());
    mrb_define_class_method(mrb, renum_KeyCode, "KEY_RIGHT_BRACE", ruby_cocos2dx_constant_get, ARGS_NONE());
    mrb_define_class_method(mrb, renum_KeyCode, "KEY_TILDE", ruby_cocos2dx_constant_get, ARGS_NONE());
    mrb_define_class_method(mrb, renum_KeyCode, "KEY_EURO", ruby_cocos2dx_constant_get, ARGS_NONE());
    mrb_define_class_method(mrb, renum_KeyCode, "KEY_POUND", ruby_cocos2dx_constant_get, ARGS_NONE());
    mrb_define_class_method(mrb, renum_KeyCode, "KEY_YEN", ruby_cocos2dx_constant_get, ARGS_NONE());
    mrb_define_class_method(mrb, renum_KeyCode, "KEY_MIDDLE_DOT", ruby_cocos2dx_constant_get, ARGS_NONE());
    mrb_define_class_method(mrb, renum_KeyCode, "KEY_SEARCH", ruby_cocos2dx_constant_get, ARGS_NONE());
    mrb_define_class_method(mrb, renum_KeyCode, "KEY_DPAD_LEFT", ruby_cocos2dx_constant_get, ARGS_NONE());
    mrb_define_class_method(mrb, renum_KeyCode, "KEY_DPAD_RIGHT", ruby_cocos2dx_constant_get, ARGS_NONE());
    mrb_define_class_method(mrb, renum_KeyCode, "KEY_DPAD_UP", ruby_cocos2dx_constant_get, ARGS_NONE());
    mrb_define_class_method(mrb, renum_KeyCode, "KEY_DPAD_DOWN", ruby_cocos2dx_constant_get, ARGS_NONE());
    mrb_define_class_method(mrb, renum_KeyCode, "KEY_DPAD_CENTER", ruby_cocos2dx_constant_get, ARGS_NONE());
    mrb_define_class_method(mrb, renum_KeyCode, "KEY_ENTER", ruby_cocos2dx_constant_get, ARGS_NONE());
    mrb_define_class_method(mrb, renum_KeyCode, "KEY_PLAY", ruby_cocos2dx_constant_get, ARGS_NONE());
}
mrb_value ruby_cocos2dx_Node_addChild(mrb_state* mrb, mrb_value self)
{
    cocos2d::Node* cobj = static_cast<cocos2d::Node*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 2) {
            cocos2d::Node* arg0;
            ok = rubyval_to_object<cocos2d::Node>(mrb, argv[0], "CC::Node", &arg0);
            if (!ok) { break; }
            int arg1;
            ok = rubyval_to_int32(mrb, argv[1], (int*)&arg1, "CC::Node.addChild");
            if (!ok) { break; }
            cobj->addChild(arg0, arg1);
            return self;
        }
    } while (0);
    do {
        if (argc == 1) {
            cocos2d::Node* arg0;
            ok = rubyval_to_object<cocos2d::Node>(mrb, argv[0], "CC::Node", &arg0);
            if (!ok) { break; }
            cobj->addChild(arg0);
            return self;
        }
    } while (0);
    do {
        if (argc == 3) {
            cocos2d::Node* arg0;
            ok = rubyval_to_object<cocos2d::Node>(mrb, argv[0], "CC::Node", &arg0);
            if (!ok) { break; }
            int arg1;
            ok = rubyval_to_int32(mrb, argv[1], (int*)&arg1, "CC::Node.addChild");
            if (!ok) { break; }
            int arg2;
            ok = rubyval_to_int32(mrb, argv[2], (int*)&arg2, "CC::Node.addChild");
            if (!ok) { break; }
            cobj->addChild(arg0, arg1, arg2);
            return self;
        }
    } while (0);
    do {
        if (argc == 3) {
            cocos2d::Node* arg0;
            ok = rubyval_to_object<cocos2d::Node>(mrb, argv[0], "CC::Node", &arg0);
            if (!ok) { break; }
            int arg1;
            ok = rubyval_to_int32(mrb, argv[1], (int*)&arg1, "CC::Node.addChild");
            if (!ok) { break; }
            std::string arg2;
            ok = rubyval_to_std_string(mrb, argv[2], &arg2, "CC::Node.addChild");
            if (!ok) { break; }
            cobj->addChild(arg0, arg1, arg2);
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::Node#addChild");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Node_removeComponent(mrb_state* mrb, mrb_value self)
{
    cocos2d::Node* cobj = static_cast<cocos2d::Node*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            cocos2d::Component* arg0;
            ok = rubyval_to_object<cocos2d::Component>(mrb, argv[0], "CC::Component", &arg0);
            if (!ok) { break; }
            bool retval = cobj->removeComponent(arg0);
            mrb_value ret;
            ret = mrb_bool_value((mrb_bool)retval);
            return ret;
        }
    } while (0);
    do {
        if (argc == 1) {
            std::string arg0;
            ok = rubyval_to_std_string(mrb, argv[0], &arg0, "CC::Node.removeComponent");
            if (!ok) { break; }
            bool retval = cobj->removeComponent(arg0);
            mrb_value ret;
            ret = mrb_bool_value((mrb_bool)retval);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::Node#removeComponent");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Node_getUserObject(mrb_state* mrb, mrb_value self)
{
    cocos2d::Node* cobj = static_cast<cocos2d::Node*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            const cocos2d::Ref* retval = cobj->getUserObject();
            mrb_value ret;
            ret = object_to_rubyval<cocos2d::Ref>(mrb, "CC::Ref", (cocos2d::Ref*)retval, nullptr);
            return ret;
        }
    } while (0);
    do {
        if (argc == 0) {
            cocos2d::Ref* retval = cobj->getUserObject();
            mrb_value ret;
            ret = object_to_rubyval<cocos2d::Ref>(mrb, "CC::Ref", (cocos2d::Ref*)retval, nullptr);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::Node#getUserObject");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Node_getDescription(mrb_state* mrb, mrb_value self)
{
    cocos2d::Node* cobj = static_cast<cocos2d::Node*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            std::string retval = cobj->getDescription();
            mrb_value ret;
            ret = mrb_str_new_cstr(mrb, retval.c_str());
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::Node#getDescription");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Node_setRotationSkewY(mrb_state* mrb, mrb_value self)
{
    cocos2d::Node* cobj = static_cast<cocos2d::Node*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            double arg0;
            ok = rubyval_to_number(mrb, argv[0], (double*)&arg0, "CC::Node.setRotationSkewY");
            if (!ok) { break; }
            cobj->setRotationSkewY(arg0);
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::Node#setRotationSkewY");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Node_setOpacityModifyRGB(mrb_state* mrb, mrb_value self)
{
    cocos2d::Node* cobj = static_cast<cocos2d::Node*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            bool arg0;
            ok = rubyval_to_boolean(mrb, argv[0], &arg0, "CC::Node.setOpacityModifyRGB");
            if (!ok) { break; }
            cobj->setOpacityModifyRGB(arg0);
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::Node#setOpacityModifyRGB");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Node_setCascadeOpacityEnabled(mrb_state* mrb, mrb_value self)
{
    cocos2d::Node* cobj = static_cast<cocos2d::Node*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            bool arg0;
            ok = rubyval_to_boolean(mrb, argv[0], &arg0, "CC::Node.setCascadeOpacityEnabled");
            if (!ok) { break; }
            cobj->setCascadeOpacityEnabled(arg0);
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::Node#setCascadeOpacityEnabled");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Node_getChildren(mrb_state* mrb, mrb_value self)
{
    cocos2d::Node* cobj = static_cast<cocos2d::Node*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            cocos2d::Vector<cocos2d::Node *> retval = cobj->getChildren();
            mrb_value ret;
            ret = ccvector_to_rubyval(mrb, retval);
            return ret;
        }
    } while (0);
    do {
        if (argc == 0) {
            cocos2d::Vector<cocos2d::Node *> retval = cobj->getChildren();
            mrb_value ret;
            ret = ccvector_to_rubyval(mrb, retval);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::Node#getChildren");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Node_unschedule(mrb_state* mrb, mrb_value self)
{
    cocos2d::Node* cobj = static_cast<cocos2d::Node*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            std::string arg0;
            ok = rubyval_to_std_string(mrb, argv[0], &arg0, "CC::Node.unschedule");
            if (!ok) { break; }
            cobj->unschedule(arg0);
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::Node#unschedule");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Node_scheduleOnce(mrb_state* mrb, mrb_value self)
{
    cocos2d::Node* cobj = static_cast<cocos2d::Node*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 3) {
            std::function<void (float)> arg0;
            double arg1;
            ok = rubyval_to_number(mrb, argv[1], (double*)&arg1, "CC::Node.scheduleOnce");
            if (!ok) { break; }
            std::string arg2;
            ok = rubyval_to_std_string(mrb, argv[2], &arg2, "CC::Node.scheduleOnce");
            if (!ok) { break; }
            do {
			    // Lambda binding for ruby.
			    unsigned long idx = -1;
			    arg0 = [mrb, self, idx, arg2](double larg0) -> void {
			        mrb_value ruby_arg0;
			        ruby_arg0 = mrb_float_value(mrb, (mrb_float)larg0);
			        mrb_value hash = mrb_iv_get(mrb, self, mrb_intern_cstr(mrb, "__callback_hash"));
			        mrb_value func = mrb_hash_get(mrb, hash, mrb_str_new_cstr(mrb, arg2.c_str()));
			        mrb_value mrb_ret = mrb_funcall(mrb, func, "call", 1, ruby_arg0);
			        if (mrb_exception_p(mrb_ret)) {
			            mrb_exc_raise(mrb, mrb_ret);
			        }
			    };
			    mrb_value hash = mrb_iv_get(mrb, self, mrb_intern_cstr(mrb, "__callback_hash"));
			    if (!mrb_hash_p(hash)) {
			        hash = mrb_hash_new(mrb);
			    }
			    mrb_hash_set(mrb, hash, mrb_str_new_cstr(mrb, arg2.c_str()), argv[0]);
			    mrb_iv_set(mrb, self, mrb_intern_cstr(mrb, "__callback_hash"), hash);
			    break;
			} while(0);
            cobj->scheduleOnce(arg0, arg1, arg2);
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::Node#scheduleOnce");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Node_setOnExitCallback(mrb_state* mrb, mrb_value self)
{
    cocos2d::Node* cobj = static_cast<cocos2d::Node*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            std::function<void ()> arg0;
            do {
			    // Lambda binding for ruby.
			    unsigned long idx = -1;
			    arg0 = [mrb, self, idx]() -> void {
			        mrb_value hash = mrb_iv_get(mrb, self, mrb_intern_cstr(mrb, "__callback_hash"));
			        mrb_value func = mrb_hash_get(mrb, hash, mrb_str_new_cstr(mrb, "setOnExitCallback->arg0"));
			        mrb_value mrb_ret = mrb_funcall(mrb, func, "call", 0);
			        if (mrb_exception_p(mrb_ret)) {
			            mrb_exc_raise(mrb, mrb_ret);
			        }
			    };
			    mrb_value hash = mrb_iv_get(mrb, self, mrb_intern_cstr(mrb, "__callback_hash"));
			    if (!mrb_hash_p(hash)) {
			        hash = mrb_hash_new(mrb);
			    }
			    mrb_hash_set(mrb, hash, mrb_str_new_cstr(mrb, "setOnExitCallback->arg0"), argv[0]);
			    mrb_iv_set(mrb, self, mrb_intern_cstr(mrb, "__callback_hash"), hash);
			    break;
			} while(0);
            cobj->setOnExitCallback(arg0);
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::Node#setOnExitCallback");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Node_pause(mrb_state* mrb, mrb_value self)
{
    cocos2d::Node* cobj = static_cast<cocos2d::Node*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            cobj->pause();
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::Node#pause");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Node_convertToWorldSpaceAR(mrb_state* mrb, mrb_value self)
{
    cocos2d::Node* cobj = static_cast<cocos2d::Node*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            cocos2d::Vec2* arg0;
            ok = rubyval_to_object<cocos2d::Vec2>(mrb, argv[0], "CC::Vec2", &arg0);
            if (!ok) { break; }
            cocos2d::Vec2 retval = cobj->convertToWorldSpaceAR(*arg0);
            cocos2d::Vec2* retval_ptr = new cocos2d::Vec2(retval);
            mrb_value ret;
            ret = object_to_rubyval<cocos2d::Vec2>(mrb, "CC::Vec2", (cocos2d::Vec2*)retval_ptr, nullptr);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::Node#convertToWorldSpaceAR");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Node_isIgnoreAnchorPointForPosition(mrb_state* mrb, mrb_value self)
{
    cocos2d::Node* cobj = static_cast<cocos2d::Node*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            bool retval = cobj->isIgnoreAnchorPointForPosition();
            mrb_value ret;
            ret = mrb_bool_value((mrb_bool)retval);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::Node#isIgnoreAnchorPointForPosition");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Node_getChildByName(mrb_state* mrb, mrb_value self)
{
    cocos2d::Node* cobj = static_cast<cocos2d::Node*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            std::string arg0;
            ok = rubyval_to_std_string(mrb, argv[0], &arg0, "CC::Node.getChildByName");
            if (!ok) { break; }
            cocos2d::Node* retval = cobj->getChildByName(arg0);
            mrb_value ret;
            ret = object_to_rubyval<cocos2d::Node>(mrb, "CC::Node", (cocos2d::Node*)retval, nullptr);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::Node#getChildByName");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Node_updateDisplayedOpacity(mrb_state* mrb, mrb_value self)
{
    cocos2d::Node* cobj = static_cast<cocos2d::Node*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            uint16_t arg0;
            ok = rubyval_to_uint16(mrb, argv[0], &arg0, "CC::Node.updateDisplayedOpacity");
            if (!ok) { break; }
            cobj->updateDisplayedOpacity(arg0);
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::Node#updateDisplayedOpacity");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Node_getCameraMask(mrb_state* mrb, mrb_value self)
{
    cocos2d::Node* cobj = static_cast<cocos2d::Node*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            unsigned short retval = cobj->getCameraMask();
            mrb_value ret;
            ret = mrb_fixnum_value((mrb_int)retval);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::Node#getCameraMask");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Node_setRotation(mrb_state* mrb, mrb_value self)
{
    cocos2d::Node* cobj = static_cast<cocos2d::Node*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            double arg0;
            ok = rubyval_to_number(mrb, argv[0], (double*)&arg0, "CC::Node.setRotation");
            if (!ok) { break; }
            cobj->setRotation(arg0);
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::Node#setRotation");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Node_setScaleZ(mrb_state* mrb, mrb_value self)
{
    cocos2d::Node* cobj = static_cast<cocos2d::Node*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            double arg0;
            ok = rubyval_to_number(mrb, argv[0], (double*)&arg0, "CC::Node.setScaleZ");
            if (!ok) { break; }
            cobj->setScaleZ(arg0);
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::Node#setScaleZ");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Node_setScaleY(mrb_state* mrb, mrb_value self)
{
    cocos2d::Node* cobj = static_cast<cocos2d::Node*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            double arg0;
            ok = rubyval_to_number(mrb, argv[0], (double*)&arg0, "CC::Node.setScaleY");
            if (!ok) { break; }
            cobj->setScaleY(arg0);
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::Node#setScaleY");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Node_setScaleX(mrb_state* mrb, mrb_value self)
{
    cocos2d::Node* cobj = static_cast<cocos2d::Node*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            double arg0;
            ok = rubyval_to_number(mrb, argv[0], (double*)&arg0, "CC::Node.setScaleX");
            if (!ok) { break; }
            cobj->setScaleX(arg0);
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::Node#setScaleX");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Node_setRotationSkewX(mrb_state* mrb, mrb_value self)
{
    cocos2d::Node* cobj = static_cast<cocos2d::Node*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            double arg0;
            ok = rubyval_to_number(mrb, argv[0], (double*)&arg0, "CC::Node.setRotationSkewX");
            if (!ok) { break; }
            cobj->setRotationSkewX(arg0);
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::Node#setRotationSkewX");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Node_scheduleUpdateWithPriority(mrb_state* mrb, mrb_value self)
{
    cocos2d::Node* cobj = static_cast<cocos2d::Node*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            int arg0;
            ok = rubyval_to_int32(mrb, argv[0], (int*)&arg0, "CC::Node.scheduleUpdateWithPriority");
            if (!ok) { break; }
            cobj->scheduleUpdateWithPriority(arg0);
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::Node#scheduleUpdateWithPriority");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Node_setonEnterTransitionDidFinishCallback(mrb_state* mrb, mrb_value self)
{
    cocos2d::Node* cobj = static_cast<cocos2d::Node*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            std::function<void ()> arg0;
            do {
			    // Lambda binding for ruby.
			    unsigned long idx = -1;
			    arg0 = [mrb, self, idx]() -> void {
			        mrb_value hash = mrb_iv_get(mrb, self, mrb_intern_cstr(mrb, "__callback_hash"));
			        mrb_value func = mrb_hash_get(mrb, hash, mrb_str_new_cstr(mrb, "setonEnterTransitionDidFinishCallback->arg0"));
			        mrb_value mrb_ret = mrb_funcall(mrb, func, "call", 0);
			        if (mrb_exception_p(mrb_ret)) {
			            mrb_exc_raise(mrb, mrb_ret);
			        }
			    };
			    mrb_value hash = mrb_iv_get(mrb, self, mrb_intern_cstr(mrb, "__callback_hash"));
			    if (!mrb_hash_p(hash)) {
			        hash = mrb_hash_new(mrb);
			    }
			    mrb_hash_set(mrb, hash, mrb_str_new_cstr(mrb, "setonEnterTransitionDidFinishCallback->arg0"), argv[0]);
			    mrb_iv_set(mrb, self, mrb_intern_cstr(mrb, "__callback_hash"), hash);
			    break;
			} while(0);
            cobj->setonEnterTransitionDidFinishCallback(arg0);
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::Node#setonEnterTransitionDidFinishCallback");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Node_removeAllComponents(mrb_state* mrb, mrb_value self)
{
    cocos2d::Node* cobj = static_cast<cocos2d::Node*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            cobj->removeAllComponents();
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::Node#removeAllComponents");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Node_getOpacity(mrb_state* mrb, mrb_value self)
{
    cocos2d::Node* cobj = static_cast<cocos2d::Node*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            uint16_t retval = cobj->getOpacity();
            mrb_value ret;
            ret = mrb_fixnum_value((mrb_int)retval);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::Node#getOpacity");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Node_setCameraMask(mrb_state* mrb, mrb_value self)
{
    cocos2d::Node* cobj = static_cast<cocos2d::Node*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            unsigned short arg0;
            ok = rubyval_to_ushort(mrb, argv[0], &arg0, "CC::Node.setCameraMask");
            if (!ok) { break; }
            cobj->setCameraMask(arg0);
            return self;
        }
    } while (0);
    do {
        if (argc == 2) {
            unsigned short arg0;
            ok = rubyval_to_ushort(mrb, argv[0], &arg0, "CC::Node.setCameraMask");
            if (!ok) { break; }
            bool arg1;
            ok = rubyval_to_boolean(mrb, argv[1], &arg1, "CC::Node.setCameraMask");
            if (!ok) { break; }
            cobj->setCameraMask(arg0, arg1);
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::Node#setCameraMask");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Node_getTag(mrb_state* mrb, mrb_value self)
{
    cocos2d::Node* cobj = static_cast<cocos2d::Node*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            int retval = cobj->getTag();
            mrb_value ret;
            ret = mrb_fixnum_value((mrb_int)retval);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::Node#getTag");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Node_getonEnterTransitionDidFinishCallback(mrb_state* mrb, mrb_value self)
{
    cocos2d::Node* cobj = static_cast<cocos2d::Node*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            std::function<void ()> retval = cobj->getonEnterTransitionDidFinishCallback();
            mrb_value ret;
            #pragma warning NO CONVERSION FROM NATIVE FOR std::function;
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::Node#getonEnterTransitionDidFinishCallback");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Node_getGLProgram(mrb_state* mrb, mrb_value self)
{
    cocos2d::Node* cobj = static_cast<cocos2d::Node*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            cocos2d::GLProgram* retval = cobj->getGLProgram();
            mrb_value ret;
            ret = object_to_rubyval<cocos2d::GLProgram>(mrb, "CC::GLProgram", (cocos2d::GLProgram*)retval, nullptr);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::Node#getGLProgram");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Node_getNodeToWorldTransform(mrb_state* mrb, mrb_value self)
{
    cocos2d::Node* cobj = static_cast<cocos2d::Node*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            cocos2d::Mat4 retval = cobj->getNodeToWorldTransform();
            cocos2d::Mat4* retval_ptr = new cocos2d::Mat4(retval);
            mrb_value ret;
            ret = object_to_rubyval<cocos2d::Mat4>(mrb, "CC::Mat4", (cocos2d::Mat4*)retval_ptr, nullptr);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::Node#getNodeToWorldTransform");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Node_getPosition3D(mrb_state* mrb, mrb_value self)
{
    cocos2d::Node* cobj = static_cast<cocos2d::Node*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            cocos2d::Vec3 retval = cobj->getPosition3D();
            cocos2d::Vec3* retval_ptr = new cocos2d::Vec3(retval);
            mrb_value ret;
            ret = object_to_rubyval<cocos2d::Vec3>(mrb, "CC::Vec3", (cocos2d::Vec3*)retval_ptr, nullptr);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::Node#getPosition3D");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Node_removeChild(mrb_state* mrb, mrb_value self)
{
    cocos2d::Node* cobj = static_cast<cocos2d::Node*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            cocos2d::Node* arg0;
            ok = rubyval_to_object<cocos2d::Node>(mrb, argv[0], "CC::Node", &arg0);
            if (!ok) { break; }
            cobj->removeChild(arg0);
            return self;
        }
    } while (0);
    do {
        if (argc == 2) {
            cocos2d::Node* arg0;
            ok = rubyval_to_object<cocos2d::Node>(mrb, argv[0], "CC::Node", &arg0);
            if (!ok) { break; }
            bool arg1;
            ok = rubyval_to_boolean(mrb, argv[1], &arg1, "CC::Node.removeChild");
            if (!ok) { break; }
            cobj->removeChild(arg0, arg1);
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::Node#removeChild");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Node_convertToWorldSpace(mrb_state* mrb, mrb_value self)
{
    cocos2d::Node* cobj = static_cast<cocos2d::Node*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            cocos2d::Vec2* arg0;
            ok = rubyval_to_object<cocos2d::Vec2>(mrb, argv[0], "CC::Vec2", &arg0);
            if (!ok) { break; }
            cocos2d::Vec2 retval = cobj->convertToWorldSpace(*arg0);
            cocos2d::Vec2* retval_ptr = new cocos2d::Vec2(retval);
            mrb_value ret;
            ret = object_to_rubyval<cocos2d::Vec2>(mrb, "CC::Vec2", (cocos2d::Vec2*)retval_ptr, nullptr);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::Node#convertToWorldSpace");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Node_getScene(mrb_state* mrb, mrb_value self)
{
    cocos2d::Node* cobj = static_cast<cocos2d::Node*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            cocos2d::Scene* retval = cobj->getScene();
            mrb_value ret;
            ret = object_to_rubyval<cocos2d::Scene>(mrb, "CC::Scene", (cocos2d::Scene*)retval, nullptr);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::Node#getScene");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Node_getEventDispatcher(mrb_state* mrb, mrb_value self)
{
    cocos2d::Node* cobj = static_cast<cocos2d::Node*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            cocos2d::EventDispatcher* retval = cobj->getEventDispatcher();
            mrb_value ret;
            ret = object_to_rubyval<cocos2d::EventDispatcher>(mrb, "CC::EventDispatcher", (cocos2d::EventDispatcher*)retval, nullptr);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::Node#getEventDispatcher");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Node_setSkewX(mrb_state* mrb, mrb_value self)
{
    cocos2d::Node* cobj = static_cast<cocos2d::Node*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            double arg0;
            ok = rubyval_to_number(mrb, argv[0], (double*)&arg0, "CC::Node.setSkewX");
            if (!ok) { break; }
            cobj->setSkewX(arg0);
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::Node#setSkewX");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Node_setGLProgramState(mrb_state* mrb, mrb_value self)
{
    cocos2d::Node* cobj = static_cast<cocos2d::Node*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            cocos2d::GLProgramState* arg0;
            ok = rubyval_to_object<cocos2d::GLProgramState>(mrb, argv[0], "CC::GLProgramState", &arg0);
            if (!ok) { break; }
            cobj->setGLProgramState(arg0);
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::Node#setGLProgramState");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Node_setOnEnterCallback(mrb_state* mrb, mrb_value self)
{
    cocos2d::Node* cobj = static_cast<cocos2d::Node*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            std::function<void ()> arg0;
            do {
			    // Lambda binding for ruby.
			    unsigned long idx = -1;
			    arg0 = [mrb, self, idx]() -> void {
			        mrb_value hash = mrb_iv_get(mrb, self, mrb_intern_cstr(mrb, "__callback_hash"));
			        mrb_value func = mrb_hash_get(mrb, hash, mrb_str_new_cstr(mrb, "setOnEnterCallback->arg0"));
			        mrb_value mrb_ret = mrb_funcall(mrb, func, "call", 0);
			        if (mrb_exception_p(mrb_ret)) {
			            mrb_exc_raise(mrb, mrb_ret);
			        }
			    };
			    mrb_value hash = mrb_iv_get(mrb, self, mrb_intern_cstr(mrb, "__callback_hash"));
			    if (!mrb_hash_p(hash)) {
			        hash = mrb_hash_new(mrb);
			    }
			    mrb_hash_set(mrb, hash, mrb_str_new_cstr(mrb, "setOnEnterCallback->arg0"), argv[0]);
			    mrb_iv_set(mrb, self, mrb_intern_cstr(mrb, "__callback_hash"), hash);
			    break;
			} while(0);
            cobj->setOnEnterCallback(arg0);
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::Node#setOnEnterCallback");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Node_setNormalizedPosition(mrb_state* mrb, mrb_value self)
{
    cocos2d::Node* cobj = static_cast<cocos2d::Node*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            cocos2d::Vec2* arg0;
            ok = rubyval_to_object<cocos2d::Vec2>(mrb, argv[0], "CC::Vec2", &arg0);
            if (!ok) { break; }
            cobj->setNormalizedPosition(*arg0);
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::Node#setNormalizedPosition");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Node_setonExitTransitionDidStartCallback(mrb_state* mrb, mrb_value self)
{
    cocos2d::Node* cobj = static_cast<cocos2d::Node*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            std::function<void ()> arg0;
            do {
			    // Lambda binding for ruby.
			    unsigned long idx = -1;
			    arg0 = [mrb, self, idx]() -> void {
			        mrb_value hash = mrb_iv_get(mrb, self, mrb_intern_cstr(mrb, "__callback_hash"));
			        mrb_value func = mrb_hash_get(mrb, hash, mrb_str_new_cstr(mrb, "setonExitTransitionDidStartCallback->arg0"));
			        mrb_value mrb_ret = mrb_funcall(mrb, func, "call", 0);
			        if (mrb_exception_p(mrb_ret)) {
			            mrb_exc_raise(mrb, mrb_ret);
			        }
			    };
			    mrb_value hash = mrb_iv_get(mrb, self, mrb_intern_cstr(mrb, "__callback_hash"));
			    if (!mrb_hash_p(hash)) {
			        hash = mrb_hash_new(mrb);
			    }
			    mrb_hash_set(mrb, hash, mrb_str_new_cstr(mrb, "setonExitTransitionDidStartCallback->arg0"), argv[0]);
			    mrb_iv_set(mrb, self, mrb_intern_cstr(mrb, "__callback_hash"), hash);
			    break;
			} while(0);
            cobj->setonExitTransitionDidStartCallback(arg0);
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::Node#setonExitTransitionDidStartCallback");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Node_unscheduleAllCallbacks(mrb_state* mrb, mrb_value self)
{
    cocos2d::Node* cobj = static_cast<cocos2d::Node*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            cobj->unscheduleAllCallbacks();
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::Node#unscheduleAllCallbacks");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Node_convertTouchToNodeSpace(mrb_state* mrb, mrb_value self)
{
    cocos2d::Node* cobj = static_cast<cocos2d::Node*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            cocos2d::Touch* arg0;
            ok = rubyval_to_object<cocos2d::Touch>(mrb, argv[0], "CC::Touch", &arg0);
            if (!ok) { break; }
            cocos2d::Vec2 retval = cobj->convertTouchToNodeSpace(arg0);
            cocos2d::Vec2* retval_ptr = new cocos2d::Vec2(retval);
            mrb_value ret;
            ret = object_to_rubyval<cocos2d::Vec2>(mrb, "CC::Vec2", (cocos2d::Vec2*)retval_ptr, nullptr);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::Node#convertTouchToNodeSpace");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Node_removeAllChildrenWithCleanup(mrb_state* mrb, mrb_value self)
{
    cocos2d::Node* cobj = static_cast<cocos2d::Node*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            bool arg0;
            ok = rubyval_to_boolean(mrb, argv[0], &arg0, "CC::Node.removeAllChildrenWithCleanup");
            if (!ok) { break; }
            cobj->removeAllChildrenWithCleanup(arg0);
            return self;
        }
    } while (0);
    do {
        if (argc == 0) {
            cobj->removeAllChildren();
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::Node#removeAllChildrenWithCleanup");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Node_getNodeToParentAffineTransform(mrb_state* mrb, mrb_value self)
{
    cocos2d::Node* cobj = static_cast<cocos2d::Node*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            cocos2d::AffineTransform retval = cobj->getNodeToParentAffineTransform();
            cocos2d::AffineTransform* retval_ptr = new cocos2d::AffineTransform(retval);
            mrb_value ret;
            ret = object_to_rubyval<cocos2d::AffineTransform>(mrb, "CC::AffineTransform", (cocos2d::AffineTransform*)retval_ptr, nullptr);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::Node#getNodeToParentAffineTransform");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Node_unscheduleUpdate(mrb_state* mrb, mrb_value self)
{
    cocos2d::Node* cobj = static_cast<cocos2d::Node*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            cobj->unscheduleUpdate();
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::Node#unscheduleUpdate");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Node_getUserData(mrb_state* mrb, mrb_value self)
{
    cocos2d::Node* cobj = static_cast<cocos2d::Node*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            const void* retval = cobj->getUserData();
            mrb_value ret;
            #pragma warning NO CONVERSION FROM NATIVE FOR void*;
            return ret;
        }
    } while (0);
    do {
        if (argc == 0) {
            void* retval = cobj->getUserData();
            mrb_value ret;
            #pragma warning NO CONVERSION FROM NATIVE FOR void*;
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::Node#getUserData");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Node_isCascadeOpacityEnabled(mrb_state* mrb, mrb_value self)
{
    cocos2d::Node* cobj = static_cast<cocos2d::Node*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            bool retval = cobj->isCascadeOpacityEnabled();
            mrb_value ret;
            ret = mrb_bool_value((mrb_bool)retval);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::Node#isCascadeOpacityEnabled");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Node_setParent(mrb_state* mrb, mrb_value self)
{
    cocos2d::Node* cobj = static_cast<cocos2d::Node*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            cocos2d::Node* arg0;
            ok = rubyval_to_object<cocos2d::Node>(mrb, argv[0], "CC::Node", &arg0);
            if (!ok) { break; }
            cobj->setParent(arg0);
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::Node#setParent");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Node_getName(mrb_state* mrb, mrb_value self)
{
    cocos2d::Node* cobj = static_cast<cocos2d::Node*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            std::string retval = cobj->getName();
            mrb_value ret;
            ret = mrb_str_new_cstr(mrb, retval.c_str());
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::Node#getName");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Node_resume(mrb_state* mrb, mrb_value self)
{
    cocos2d::Node* cobj = static_cast<cocos2d::Node*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            cobj->resume();
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::Node#resume");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Node_getRotation3D(mrb_state* mrb, mrb_value self)
{
    cocos2d::Node* cobj = static_cast<cocos2d::Node*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            cocos2d::Vec3 retval = cobj->getRotation3D();
            cocos2d::Vec3* retval_ptr = new cocos2d::Vec3(retval);
            mrb_value ret;
            ret = object_to_rubyval<cocos2d::Vec3>(mrb, "CC::Vec3", (cocos2d::Vec3*)retval_ptr, nullptr);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::Node#getRotation3D");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Node_getNodeToParentTransform(mrb_state* mrb, mrb_value self)
{
    cocos2d::Node* cobj = static_cast<cocos2d::Node*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            cocos2d::Mat4 retval = cobj->getNodeToParentTransform();
            cocos2d::Mat4* retval_ptr = new cocos2d::Mat4(retval);
            mrb_value ret;
            ret = object_to_rubyval<cocos2d::Mat4>(mrb, "CC::Mat4", (cocos2d::Mat4*)retval_ptr, nullptr);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::Node#getNodeToParentTransform");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Node_convertTouchToNodeSpaceAR(mrb_state* mrb, mrb_value self)
{
    cocos2d::Node* cobj = static_cast<cocos2d::Node*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            cocos2d::Touch* arg0;
            ok = rubyval_to_object<cocos2d::Touch>(mrb, argv[0], "CC::Touch", &arg0);
            if (!ok) { break; }
            cocos2d::Vec2 retval = cobj->convertTouchToNodeSpaceAR(arg0);
            cocos2d::Vec2* retval_ptr = new cocos2d::Vec2(retval);
            mrb_value ret;
            ret = object_to_rubyval<cocos2d::Vec2>(mrb, "CC::Vec2", (cocos2d::Vec2*)retval_ptr, nullptr);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::Node#convertTouchToNodeSpaceAR");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Node_getOnEnterCallback(mrb_state* mrb, mrb_value self)
{
    cocos2d::Node* cobj = static_cast<cocos2d::Node*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            std::function<void ()> retval = cobj->getOnEnterCallback();
            mrb_value ret;
            #pragma warning NO CONVERSION FROM NATIVE FOR std::function;
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::Node#getOnEnterCallback");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Node_convertToNodeSpace(mrb_state* mrb, mrb_value self)
{
    cocos2d::Node* cobj = static_cast<cocos2d::Node*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            cocos2d::Vec2* arg0;
            ok = rubyval_to_object<cocos2d::Vec2>(mrb, argv[0], "CC::Vec2", &arg0);
            if (!ok) { break; }
            cocos2d::Vec2 retval = cobj->convertToNodeSpace(*arg0);
            cocos2d::Vec2* retval_ptr = new cocos2d::Vec2(retval);
            mrb_value ret;
            ret = object_to_rubyval<cocos2d::Vec2>(mrb, "CC::Vec2", (cocos2d::Vec2*)retval_ptr, nullptr);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::Node#convertToNodeSpace");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Node_schedule(mrb_state* mrb, mrb_value self)
{
    cocos2d::Node* cobj = static_cast<cocos2d::Node*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 3) {
            std::function<void (float)> arg0;
            double arg1;
            ok = rubyval_to_number(mrb, argv[1], (double*)&arg1, "CC::Node.schedule");
            if (!ok) { break; }
            std::string arg2;
            ok = rubyval_to_std_string(mrb, argv[2], &arg2, "CC::Node.schedule");
            if (!ok) { break; }
            do {
			    // Lambda binding for ruby.
			    unsigned long idx = -1;
			    arg0 = [mrb, self, idx, arg2](double larg0) -> void {
			        mrb_value ruby_arg0;
			        ruby_arg0 = mrb_float_value(mrb, (mrb_float)larg0);
			        mrb_value hash = mrb_iv_get(mrb, self, mrb_intern_cstr(mrb, "__callback_hash"));
			        mrb_value func = mrb_hash_get(mrb, hash, mrb_str_new_cstr(mrb, arg2.c_str()));
			        mrb_value mrb_ret = mrb_funcall(mrb, func, "call", 1, ruby_arg0);
			        if (mrb_exception_p(mrb_ret)) {
			            mrb_exc_raise(mrb, mrb_ret);
			        }
			    };
			    mrb_value hash = mrb_iv_get(mrb, self, mrb_intern_cstr(mrb, "__callback_hash"));
			    if (!mrb_hash_p(hash)) {
			        hash = mrb_hash_new(mrb);
			    }
			    mrb_hash_set(mrb, hash, mrb_str_new_cstr(mrb, arg2.c_str()), argv[0]);
			    mrb_iv_set(mrb, self, mrb_intern_cstr(mrb, "__callback_hash"), hash);
			    break;
			} while(0);
            cobj->schedule(arg0, arg1, arg2);
            return self;
        }
    } while (0);
    do {
        if (argc == 2) {
            std::function<void (float)> arg0;
            std::string arg1;
            ok = rubyval_to_std_string(mrb, argv[1], &arg1, "CC::Node.schedule");
            if (!ok) { break; }
            do {
			    // Lambda binding for ruby.
			    unsigned long idx = -1;
			    arg0 = [mrb, self, idx, arg1](double larg0) -> void {
			        mrb_value ruby_arg0;
			        ruby_arg0 = mrb_float_value(mrb, (mrb_float)larg0);
			        mrb_value hash = mrb_iv_get(mrb, self, mrb_intern_cstr(mrb, "__callback_hash"));
			        mrb_value func = mrb_hash_get(mrb, hash, mrb_str_new_cstr(mrb, arg1.c_str()));
			        mrb_value mrb_ret = mrb_funcall(mrb, func, "call", 1, ruby_arg0);
			        if (mrb_exception_p(mrb_ret)) {
			            mrb_exc_raise(mrb, mrb_ret);
			        }
			    };
			    mrb_value hash = mrb_iv_get(mrb, self, mrb_intern_cstr(mrb, "__callback_hash"));
			    if (!mrb_hash_p(hash)) {
			        hash = mrb_hash_new(mrb);
			    }
			    mrb_hash_set(mrb, hash, mrb_str_new_cstr(mrb, arg1.c_str()), argv[0]);
			    mrb_iv_set(mrb, self, mrb_intern_cstr(mrb, "__callback_hash"), hash);
			    break;
			} while(0);
            cobj->schedule(arg0, arg1);
            return self;
        }
    } while (0);
    do {
        if (argc == 5) {
            std::function<void (float)> arg0;
            double arg1;
            ok = rubyval_to_number(mrb, argv[1], (double*)&arg1, "CC::Node.schedule");
            if (!ok) { break; }
            unsigned int arg2;
            ok = rubyval_to_uint32(mrb, argv[2], &arg2, "CC::Node.schedule");
            if (!ok) { break; }
            double arg3;
            ok = rubyval_to_number(mrb, argv[3], (double*)&arg3, "CC::Node.schedule");
            if (!ok) { break; }
            std::string arg4;
            ok = rubyval_to_std_string(mrb, argv[4], &arg4, "CC::Node.schedule");
            if (!ok) { break; }
            do {
			    // Lambda binding for ruby.
			    unsigned long idx = -1;
			    arg0 = [mrb, self, idx, arg4](double larg0) -> void {
			        mrb_value ruby_arg0;
			        ruby_arg0 = mrb_float_value(mrb, (mrb_float)larg0);
			        mrb_value hash = mrb_iv_get(mrb, self, mrb_intern_cstr(mrb, "__callback_hash"));
			        mrb_value func = mrb_hash_get(mrb, hash, mrb_str_new_cstr(mrb, arg4.c_str()));
			        mrb_value mrb_ret = mrb_funcall(mrb, func, "call", 1, ruby_arg0);
			        if (mrb_exception_p(mrb_ret)) {
			            mrb_exc_raise(mrb, mrb_ret);
			        }
			    };
			    mrb_value hash = mrb_iv_get(mrb, self, mrb_intern_cstr(mrb, "__callback_hash"));
			    if (!mrb_hash_p(hash)) {
			        hash = mrb_hash_new(mrb);
			    }
			    mrb_hash_set(mrb, hash, mrb_str_new_cstr(mrb, arg4.c_str()), argv[0]);
			    mrb_iv_set(mrb, self, mrb_intern_cstr(mrb, "__callback_hash"), hash);
			    break;
			} while(0);
            cobj->schedule(arg0, arg1, arg2, arg3, arg4);
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::Node#schedule");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Node_setPosition(mrb_state* mrb, mrb_value self)
{
    cocos2d::Node* cobj = static_cast<cocos2d::Node*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 2) {
            double arg0;
            ok = rubyval_to_number(mrb, argv[0], (double*)&arg0, "CC::Node.setPosition");
            if (!ok) { break; }
            double arg1;
            ok = rubyval_to_number(mrb, argv[1], (double*)&arg1, "CC::Node.setPosition");
            if (!ok) { break; }
            cobj->setPosition(arg0, arg1);
            return self;
        }
    } while (0);
    do {
        if (argc == 1) {
            cocos2d::Vec2* arg0;
            ok = rubyval_to_object<cocos2d::Vec2>(mrb, argv[0], "CC::Vec2", &arg0);
            if (!ok) { break; }
            cobj->setPosition(*arg0);
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::Node#setPosition");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Node_stopActionByTag(mrb_state* mrb, mrb_value self)
{
    cocos2d::Node* cobj = static_cast<cocos2d::Node*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            int arg0;
            ok = rubyval_to_int32(mrb, argv[0], (int*)&arg0, "CC::Node.stopActionByTag");
            if (!ok) { break; }
            cobj->stopActionByTag(arg0);
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::Node#stopActionByTag");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Node_reorderChild(mrb_state* mrb, mrb_value self)
{
    cocos2d::Node* cobj = static_cast<cocos2d::Node*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 2) {
            cocos2d::Node* arg0;
            ok = rubyval_to_object<cocos2d::Node>(mrb, argv[0], "CC::Node", &arg0);
            if (!ok) { break; }
            int arg1;
            ok = rubyval_to_int32(mrb, argv[1], (int*)&arg1, "CC::Node.reorderChild");
            if (!ok) { break; }
            cobj->reorderChild(arg0, arg1);
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::Node#reorderChild");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Node_ignoreAnchorPointForPosition(mrb_state* mrb, mrb_value self)
{
    cocos2d::Node* cobj = static_cast<cocos2d::Node*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            bool arg0;
            ok = rubyval_to_boolean(mrb, argv[0], &arg0, "CC::Node.ignoreAnchorPointForPosition");
            if (!ok) { break; }
            cobj->ignoreAnchorPointForPosition(arg0);
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::Node#ignoreAnchorPointForPosition");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Node_setSkewY(mrb_state* mrb, mrb_value self)
{
    cocos2d::Node* cobj = static_cast<cocos2d::Node*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            double arg0;
            ok = rubyval_to_number(mrb, argv[0], (double*)&arg0, "CC::Node.setSkewY");
            if (!ok) { break; }
            cobj->setSkewY(arg0);
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::Node#setSkewY");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Node_setPositionZ(mrb_state* mrb, mrb_value self)
{
    cocos2d::Node* cobj = static_cast<cocos2d::Node*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            double arg0;
            ok = rubyval_to_number(mrb, argv[0], (double*)&arg0, "CC::Node.setPositionZ");
            if (!ok) { break; }
            cobj->setPositionZ(arg0);
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::Node#setPositionZ");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Node_setRotation3D(mrb_state* mrb, mrb_value self)
{
    cocos2d::Node* cobj = static_cast<cocos2d::Node*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            cocos2d::Vec3* arg0;
            ok = rubyval_to_object<cocos2d::Vec3>(mrb, argv[0], "CC::Vec3", &arg0);
            if (!ok) { break; }
            cobj->setRotation3D(*arg0);
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::Node#setRotation3D");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Node_setPositionX(mrb_state* mrb, mrb_value self)
{
    cocos2d::Node* cobj = static_cast<cocos2d::Node*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            double arg0;
            ok = rubyval_to_number(mrb, argv[0], (double*)&arg0, "CC::Node.setPositionX");
            if (!ok) { break; }
            cobj->setPositionX(arg0);
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::Node#setPositionX");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Node_setNodeToParentTransform(mrb_state* mrb, mrb_value self)
{
    cocos2d::Node* cobj = static_cast<cocos2d::Node*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            cocos2d::Mat4* arg0;
            ok = rubyval_to_object<cocos2d::Mat4>(mrb, argv[0], "CC::Mat4", &arg0);
            if (!ok) { break; }
            cobj->setNodeToParentTransform(*arg0);
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::Node#setNodeToParentTransform");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Node_getAnchorPoint(mrb_state* mrb, mrb_value self)
{
    cocos2d::Node* cobj = static_cast<cocos2d::Node*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            cocos2d::Vec2 retval = cobj->getAnchorPoint();
            cocos2d::Vec2* retval_ptr = new cocos2d::Vec2(retval);
            mrb_value ret;
            ret = object_to_rubyval<cocos2d::Vec2>(mrb, "CC::Vec2", (cocos2d::Vec2*)retval_ptr, nullptr);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::Node#getAnchorPoint");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Node_getNumberOfRunningActions(mrb_state* mrb, mrb_value self)
{
    cocos2d::Node* cobj = static_cast<cocos2d::Node*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            ssize_t retval = cobj->getNumberOfRunningActions();
            mrb_value ret;
            ret = mrb_fixnum_value((mrb_int)retval);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::Node#getNumberOfRunningActions");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Node_updateTransform(mrb_state* mrb, mrb_value self)
{
    cocos2d::Node* cobj = static_cast<cocos2d::Node*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            cobj->updateTransform();
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::Node#updateTransform");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Node_isVisible(mrb_state* mrb, mrb_value self)
{
    cocos2d::Node* cobj = static_cast<cocos2d::Node*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            bool retval = cobj->isVisible();
            mrb_value ret;
            ret = mrb_bool_value((mrb_bool)retval);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::Node#isVisible");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Node_getChildrenCount(mrb_state* mrb, mrb_value self)
{
    cocos2d::Node* cobj = static_cast<cocos2d::Node*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            ssize_t retval = cobj->getChildrenCount();
            mrb_value ret;
            ret = mrb_fixnum_value((mrb_int)retval);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::Node#getChildrenCount");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Node_setAnchorPoint(mrb_state* mrb, mrb_value self)
{
    cocos2d::Node* cobj = static_cast<cocos2d::Node*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            cocos2d::Vec2* arg0;
            ok = rubyval_to_object<cocos2d::Vec2>(mrb, argv[0], "CC::Vec2", &arg0);
            if (!ok) { break; }
            cobj->setAnchorPoint(*arg0);
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::Node#setAnchorPoint");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Node_convertToNodeSpaceAR(mrb_state* mrb, mrb_value self)
{
    cocos2d::Node* cobj = static_cast<cocos2d::Node*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            cocos2d::Vec2* arg0;
            ok = rubyval_to_object<cocos2d::Vec2>(mrb, argv[0], "CC::Vec2", &arg0);
            if (!ok) { break; }
            cocos2d::Vec2 retval = cobj->convertToNodeSpaceAR(*arg0);
            cocos2d::Vec2* retval_ptr = new cocos2d::Vec2(retval);
            mrb_value ret;
            ret = object_to_rubyval<cocos2d::Vec2>(mrb, "CC::Vec2", (cocos2d::Vec2*)retval_ptr, nullptr);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::Node#convertToNodeSpaceAR");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Node_addComponent(mrb_state* mrb, mrb_value self)
{
    cocos2d::Node* cobj = static_cast<cocos2d::Node*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            cocos2d::Component* arg0;
            ok = rubyval_to_object<cocos2d::Component>(mrb, argv[0], "CC::Component", &arg0);
            if (!ok) { break; }
            bool retval = cobj->addComponent(arg0);
            mrb_value ret;
            ret = mrb_bool_value((mrb_bool)retval);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::Node#addComponent");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Node_runAction(mrb_state* mrb, mrb_value self)
{
    cocos2d::Node* cobj = static_cast<cocos2d::Node*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            cocos2d::Action* arg0;
            ok = rubyval_to_object<cocos2d::Action>(mrb, argv[0], "CC::Action", &arg0);
            if (!ok) { break; }
            cocos2d::Action* retval = cobj->runAction(arg0);
            mrb_value ret;
            ret = object_to_rubyval<cocos2d::Action>(mrb, "CC::Action", (cocos2d::Action*)retval, nullptr);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::Node#runAction");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Node_visit(mrb_state* mrb, mrb_value self)
{
    cocos2d::Node* cobj = static_cast<cocos2d::Node*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 0) {
            cobj->visit();
            return self;
        }
    } while (0);
    do {
        if (argc == 3) {
            cocos2d::Renderer* arg0;
            ok = rubyval_to_object<cocos2d::Renderer>(mrb, argv[0], "CC::Renderer", &arg0);
            if (!ok) { break; }
            cocos2d::Mat4* arg1;
            ok = rubyval_to_object<cocos2d::Mat4>(mrb, argv[1], "CC::Mat4", &arg1);
            if (!ok) { break; }
            unsigned int arg2;
            ok = rubyval_to_uint32(mrb, argv[2], &arg2, "CC::Node.visit");
            if (!ok) { break; }
            cobj->visit(arg0, *arg1, arg2);
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::Node#visit");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Node_isOpacityModifyRGB(mrb_state* mrb, mrb_value self)
{
    cocos2d::Node* cobj = static_cast<cocos2d::Node*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            bool retval = cobj->isOpacityModifyRGB();
            mrb_value ret;
            ret = mrb_bool_value((mrb_bool)retval);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::Node#isOpacityModifyRGB");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Node_scheduleUpdateWithPriorityLua(mrb_state* mrb, mrb_value self)
{
    cocos2d::Node* cobj = static_cast<cocos2d::Node*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 2) {
            int arg0;
            ok = rubyval_to_int32(mrb, argv[0], (int*)&arg0, "CC::Node.scheduleUpdateWithPriorityLua");
            if (!ok) { break; }
            int arg1;
            ok = rubyval_to_int32(mrb, argv[1], (int*)&arg1, "CC::Node.scheduleUpdateWithPriorityLua");
            if (!ok) { break; }
            cobj->scheduleUpdateWithPriorityLua(arg0, arg1);
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::Node#scheduleUpdateWithPriorityLua");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Node_getRotation(mrb_state* mrb, mrb_value self)
{
    cocos2d::Node* cobj = static_cast<cocos2d::Node*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            double retval = cobj->getRotation();
            mrb_value ret;
            ret = mrb_float_value(mrb, (mrb_float)retval);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::Node#getRotation");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Node_getAnchorPointInPoints(mrb_state* mrb, mrb_value self)
{
    cocos2d::Node* cobj = static_cast<cocos2d::Node*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            cocos2d::Vec2 retval = cobj->getAnchorPointInPoints();
            cocos2d::Vec2* retval_ptr = new cocos2d::Vec2(retval);
            mrb_value ret;
            ret = object_to_rubyval<cocos2d::Vec2>(mrb, "CC::Vec2", (cocos2d::Vec2*)retval_ptr, nullptr);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::Node#getAnchorPointInPoints");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Node_removeChildByName(mrb_state* mrb, mrb_value self)
{
    cocos2d::Node* cobj = static_cast<cocos2d::Node*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            std::string arg0;
            ok = rubyval_to_std_string(mrb, argv[0], &arg0, "CC::Node.removeChildByName");
            if (!ok) { break; }
            cobj->removeChildByName(arg0);
            return self;
        }
    } while (0);
    do {
        if (argc == 2) {
            std::string arg0;
            ok = rubyval_to_std_string(mrb, argv[0], &arg0, "CC::Node.removeChildByName");
            if (!ok) { break; }
            bool arg1;
            ok = rubyval_to_boolean(mrb, argv[1], &arg1, "CC::Node.removeChildByName");
            if (!ok) { break; }
            cobj->removeChildByName(arg0, arg1);
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::Node#removeChildByName");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Node_getGLProgramState(mrb_state* mrb, mrb_value self)
{
    cocos2d::Node* cobj = static_cast<cocos2d::Node*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            cocos2d::GLProgramState* retval = cobj->getGLProgramState();
            mrb_value ret;
            ret = object_to_rubyval<cocos2d::GLProgramState>(mrb, "CC::GLProgramState", (cocos2d::GLProgramState*)retval, nullptr);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::Node#getGLProgramState");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Node_setScheduler(mrb_state* mrb, mrb_value self)
{
    cocos2d::Node* cobj = static_cast<cocos2d::Node*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            cocos2d::Scheduler* arg0;
            ok = rubyval_to_object<cocos2d::Scheduler>(mrb, argv[0], "CC::Scheduler", &arg0);
            if (!ok) { break; }
            cobj->setScheduler(arg0);
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::Node#setScheduler");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Node_stopAllActions(mrb_state* mrb, mrb_value self)
{
    cocos2d::Node* cobj = static_cast<cocos2d::Node*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            cobj->stopAllActions();
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::Node#stopAllActions");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Node_getSkewX(mrb_state* mrb, mrb_value self)
{
    cocos2d::Node* cobj = static_cast<cocos2d::Node*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            double retval = cobj->getSkewX();
            mrb_value ret;
            ret = mrb_float_value(mrb, (mrb_float)retval);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::Node#getSkewX");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Node_getSkewY(mrb_state* mrb, mrb_value self)
{
    cocos2d::Node* cobj = static_cast<cocos2d::Node*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            double retval = cobj->getSkewY();
            mrb_value ret;
            ret = mrb_float_value(mrb, (mrb_float)retval);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::Node#getSkewY");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Node_getDisplayedColor(mrb_state* mrb, mrb_value self)
{
    cocos2d::Node* cobj = static_cast<cocos2d::Node*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            cocos2d::Color3B retval = cobj->getDisplayedColor();
            cocos2d::Color3B* retval_ptr = new cocos2d::Color3B(retval);
            mrb_value ret;
            ret = object_to_rubyval<cocos2d::Color3B>(mrb, "CC::Color3B", (cocos2d::Color3B*)retval_ptr, nullptr);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::Node#getDisplayedColor");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Node_getActionByTag(mrb_state* mrb, mrb_value self)
{
    cocos2d::Node* cobj = static_cast<cocos2d::Node*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            int arg0;
            ok = rubyval_to_int32(mrb, argv[0], (int*)&arg0, "CC::Node.getActionByTag");
            if (!ok) { break; }
            cocos2d::Action* retval = cobj->getActionByTag(arg0);
            mrb_value ret;
            ret = object_to_rubyval<cocos2d::Action>(mrb, "CC::Action", (cocos2d::Action*)retval, nullptr);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::Node#getActionByTag");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Node_setName(mrb_state* mrb, mrb_value self)
{
    cocos2d::Node* cobj = static_cast<cocos2d::Node*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            std::string arg0;
            ok = rubyval_to_std_string(mrb, argv[0], &arg0, "CC::Node.setName");
            if (!ok) { break; }
            cobj->setName(arg0);
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::Node#setName");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Node_getDisplayedOpacity(mrb_state* mrb, mrb_value self)
{
    cocos2d::Node* cobj = static_cast<cocos2d::Node*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            uint16_t retval = cobj->getDisplayedOpacity();
            mrb_value ret;
            ret = mrb_fixnum_value((mrb_int)retval);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::Node#getDisplayedOpacity");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Node_getLocalZOrder(mrb_state* mrb, mrb_value self)
{
    cocos2d::Node* cobj = static_cast<cocos2d::Node*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            int retval = cobj->getLocalZOrder();
            mrb_value ret;
            ret = mrb_fixnum_value((mrb_int)retval);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::Node#getLocalZOrder");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Node_getScheduler(mrb_state* mrb, mrb_value self)
{
    cocos2d::Node* cobj = static_cast<cocos2d::Node*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            const cocos2d::Scheduler* retval = cobj->getScheduler();
            mrb_value ret;
            ret = object_to_rubyval<cocos2d::Scheduler>(mrb, "CC::Scheduler", (cocos2d::Scheduler*)retval, nullptr);
            return ret;
        }
    } while (0);
    do {
        if (argc == 0) {
            cocos2d::Scheduler* retval = cobj->getScheduler();
            mrb_value ret;
            ret = object_to_rubyval<cocos2d::Scheduler>(mrb, "CC::Scheduler", (cocos2d::Scheduler*)retval, nullptr);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::Node#getScheduler");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Node_getParentToNodeAffineTransform(mrb_state* mrb, mrb_value self)
{
    cocos2d::Node* cobj = static_cast<cocos2d::Node*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            cocos2d::AffineTransform retval = cobj->getParentToNodeAffineTransform();
            cocos2d::AffineTransform* retval_ptr = new cocos2d::AffineTransform(retval);
            mrb_value ret;
            ret = object_to_rubyval<cocos2d::AffineTransform>(mrb, "CC::AffineTransform", (cocos2d::AffineTransform*)retval_ptr, nullptr);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::Node#getParentToNodeAffineTransform");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Node_getOrderOfArrival(mrb_state* mrb, mrb_value self)
{
    cocos2d::Node* cobj = static_cast<cocos2d::Node*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            int retval = cobj->getOrderOfArrival();
            mrb_value ret;
            ret = mrb_fixnum_value((mrb_int)retval);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::Node#getOrderOfArrival");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Node_setContentSize(mrb_state* mrb, mrb_value self)
{
    cocos2d::Node* cobj = static_cast<cocos2d::Node*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            cocos2d::Size* arg0;
            ok = rubyval_to_object<cocos2d::Size>(mrb, argv[0], "CC::Size", &arg0);
            if (!ok) { break; }
            cobj->setContentSize(*arg0);
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::Node#setContentSize");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Node_setActionManager(mrb_state* mrb, mrb_value self)
{
    cocos2d::Node* cobj = static_cast<cocos2d::Node*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            cocos2d::ActionManager* arg0;
            ok = rubyval_to_object<cocos2d::ActionManager>(mrb, argv[0], "CC::ActionManager", &arg0);
            if (!ok) { break; }
            cobj->setActionManager(arg0);
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::Node#setActionManager");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Node_getPosition(mrb_state* mrb, mrb_value self)
{
    cocos2d::Node* cobj = static_cast<cocos2d::Node*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 2) {
            float* arg0;
            ok = rubyval_to_carray_float(mrb, argv[0], &arg0, "CC::Node.getPosition");
            if (!ok) { break; }
            float* arg1;
            ok = rubyval_to_carray_float(mrb, argv[1], &arg1, "CC::Node.getPosition");
            if (!ok) { break; }
            cobj->getPosition(arg0, arg1);
            return self;
        }
    } while (0);
    do {
        if (argc == 0) {
            cocos2d::Vec2 retval = cobj->getPosition();
            cocos2d::Vec2* retval_ptr = new cocos2d::Vec2(retval);
            mrb_value ret;
            ret = object_to_rubyval<cocos2d::Vec2>(mrb, "CC::Vec2", (cocos2d::Vec2*)retval_ptr, nullptr);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::Node#getPosition");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Node_setColor(mrb_state* mrb, mrb_value self)
{
    cocos2d::Node* cobj = static_cast<cocos2d::Node*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            cocos2d::Color3B* arg0;
            ok = rubyval_to_object<cocos2d::Color3B>(mrb, argv[0], "CC::Color3B", &arg0);
            if (!ok) { break; }
            cobj->setColor(*arg0);
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::Node#setColor");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Node_isRunning(mrb_state* mrb, mrb_value self)
{
    cocos2d::Node* cobj = static_cast<cocos2d::Node*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            bool retval = cobj->isRunning();
            mrb_value ret;
            ret = mrb_bool_value((mrb_bool)retval);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::Node#isRunning");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Node_getParent(mrb_state* mrb, mrb_value self)
{
    cocos2d::Node* cobj = static_cast<cocos2d::Node*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            const cocos2d::Node* retval = cobj->getParent();
            mrb_value ret;
            ret = object_to_rubyval<cocos2d::Node>(mrb, "CC::Node", (cocos2d::Node*)retval, nullptr);
            return ret;
        }
    } while (0);
    do {
        if (argc == 0) {
            cocos2d::Node* retval = cobj->getParent();
            mrb_value ret;
            ret = object_to_rubyval<cocos2d::Node>(mrb, "CC::Node", (cocos2d::Node*)retval, nullptr);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::Node#getParent");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Node_getPositionZ(mrb_state* mrb, mrb_value self)
{
    cocos2d::Node* cobj = static_cast<cocos2d::Node*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            double retval = cobj->getPositionZ();
            mrb_value ret;
            ret = mrb_float_value(mrb, (mrb_float)retval);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::Node#getPositionZ");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Node_getPositionY(mrb_state* mrb, mrb_value self)
{
    cocos2d::Node* cobj = static_cast<cocos2d::Node*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            double retval = cobj->getPositionY();
            mrb_value ret;
            ret = mrb_float_value(mrb, (mrb_float)retval);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::Node#getPositionY");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Node_getPositionX(mrb_state* mrb, mrb_value self)
{
    cocos2d::Node* cobj = static_cast<cocos2d::Node*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            double retval = cobj->getPositionX();
            mrb_value ret;
            ret = mrb_float_value(mrb, (mrb_float)retval);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::Node#getPositionX");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Node_removeChildByTag(mrb_state* mrb, mrb_value self)
{
    cocos2d::Node* cobj = static_cast<cocos2d::Node*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            int arg0;
            ok = rubyval_to_int32(mrb, argv[0], (int*)&arg0, "CC::Node.removeChildByTag");
            if (!ok) { break; }
            cobj->removeChildByTag(arg0);
            return self;
        }
    } while (0);
    do {
        if (argc == 2) {
            int arg0;
            ok = rubyval_to_int32(mrb, argv[0], (int*)&arg0, "CC::Node.removeChildByTag");
            if (!ok) { break; }
            bool arg1;
            ok = rubyval_to_boolean(mrb, argv[1], &arg1, "CC::Node.removeChildByTag");
            if (!ok) { break; }
            cobj->removeChildByTag(arg0, arg1);
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::Node#removeChildByTag");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Node_setPositionY(mrb_state* mrb, mrb_value self)
{
    cocos2d::Node* cobj = static_cast<cocos2d::Node*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            double arg0;
            ok = rubyval_to_number(mrb, argv[0], (double*)&arg0, "CC::Node.setPositionY");
            if (!ok) { break; }
            cobj->setPositionY(arg0);
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::Node#setPositionY");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Node_getNodeToWorldAffineTransform(mrb_state* mrb, mrb_value self)
{
    cocos2d::Node* cobj = static_cast<cocos2d::Node*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            cocos2d::AffineTransform retval = cobj->getNodeToWorldAffineTransform();
            cocos2d::AffineTransform* retval_ptr = new cocos2d::AffineTransform(retval);
            mrb_value ret;
            ret = object_to_rubyval<cocos2d::AffineTransform>(mrb, "CC::AffineTransform", (cocos2d::AffineTransform*)retval_ptr, nullptr);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::Node#getNodeToWorldAffineTransform");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Node_updateDisplayedColor(mrb_state* mrb, mrb_value self)
{
    cocos2d::Node* cobj = static_cast<cocos2d::Node*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            cocos2d::Color3B* arg0;
            ok = rubyval_to_object<cocos2d::Color3B>(mrb, argv[0], "CC::Color3B", &arg0);
            if (!ok) { break; }
            cobj->updateDisplayedColor(*arg0);
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::Node#updateDisplayedColor");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Node_setVisible(mrb_state* mrb, mrb_value self)
{
    cocos2d::Node* cobj = static_cast<cocos2d::Node*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            bool arg0;
            ok = rubyval_to_boolean(mrb, argv[0], &arg0, "CC::Node.setVisible");
            if (!ok) { break; }
            cobj->setVisible(arg0);
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::Node#setVisible");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Node_getParentToNodeTransform(mrb_state* mrb, mrb_value self)
{
    cocos2d::Node* cobj = static_cast<cocos2d::Node*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            cocos2d::Mat4 retval = cobj->getParentToNodeTransform();
            cocos2d::Mat4* retval_ptr = new cocos2d::Mat4(retval);
            mrb_value ret;
            ret = object_to_rubyval<cocos2d::Mat4>(mrb, "CC::Mat4", (cocos2d::Mat4*)retval_ptr, nullptr);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::Node#getParentToNodeTransform");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Node_isScheduled(mrb_state* mrb, mrb_value self)
{
    cocos2d::Node* cobj = static_cast<cocos2d::Node*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            std::string arg0;
            ok = rubyval_to_std_string(mrb, argv[0], &arg0, "CC::Node.isScheduled");
            if (!ok) { break; }
            bool retval = cobj->isScheduled(arg0);
            mrb_value ret;
            ret = mrb_bool_value((mrb_bool)retval);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::Node#isScheduled");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Node_setGlobalZOrder(mrb_state* mrb, mrb_value self)
{
    cocos2d::Node* cobj = static_cast<cocos2d::Node*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            double arg0;
            ok = rubyval_to_number(mrb, argv[0], (double*)&arg0, "CC::Node.setGlobalZOrder");
            if (!ok) { break; }
            cobj->setGlobalZOrder(arg0);
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::Node#setGlobalZOrder");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Node_setScale(mrb_state* mrb, mrb_value self)
{
    cocos2d::Node* cobj = static_cast<cocos2d::Node*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 2) {
            double arg0;
            ok = rubyval_to_number(mrb, argv[0], (double*)&arg0, "CC::Node.setScale");
            if (!ok) { break; }
            double arg1;
            ok = rubyval_to_number(mrb, argv[1], (double*)&arg1, "CC::Node.setScale");
            if (!ok) { break; }
            cobj->setScale(arg0, arg1);
            return self;
        }
    } while (0);
    do {
        if (argc == 1) {
            double arg0;
            ok = rubyval_to_number(mrb, argv[0], (double*)&arg0, "CC::Node.setScale");
            if (!ok) { break; }
            cobj->setScale(arg0);
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::Node#setScale");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Node_getOnExitCallback(mrb_state* mrb, mrb_value self)
{
    cocos2d::Node* cobj = static_cast<cocos2d::Node*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            std::function<void ()> retval = cobj->getOnExitCallback();
            mrb_value ret;
            #pragma warning NO CONVERSION FROM NATIVE FOR std::function;
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::Node#getOnExitCallback");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Node_getChildByTag(mrb_state* mrb, mrb_value self)
{
    cocos2d::Node* cobj = static_cast<cocos2d::Node*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            int arg0;
            ok = rubyval_to_int32(mrb, argv[0], (int*)&arg0, "CC::Node.getChildByTag");
            if (!ok) { break; }
            cocos2d::Node* retval = cobj->getChildByTag(arg0);
            mrb_value ret;
            ret = object_to_rubyval<cocos2d::Node>(mrb, "CC::Node", (cocos2d::Node*)retval, nullptr);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::Node#getChildByTag");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Node_setOrderOfArrival(mrb_state* mrb, mrb_value self)
{
    cocos2d::Node* cobj = static_cast<cocos2d::Node*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            int arg0;
            ok = rubyval_to_int32(mrb, argv[0], (int*)&arg0, "CC::Node.setOrderOfArrival");
            if (!ok) { break; }
            cobj->setOrderOfArrival(arg0);
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::Node#setOrderOfArrival");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Node_getScaleZ(mrb_state* mrb, mrb_value self)
{
    cocos2d::Node* cobj = static_cast<cocos2d::Node*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            double retval = cobj->getScaleZ();
            mrb_value ret;
            ret = mrb_float_value(mrb, (mrb_float)retval);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::Node#getScaleZ");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Node_getScaleY(mrb_state* mrb, mrb_value self)
{
    cocos2d::Node* cobj = static_cast<cocos2d::Node*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            double retval = cobj->getScaleY();
            mrb_value ret;
            ret = mrb_float_value(mrb, (mrb_float)retval);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::Node#getScaleY");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Node_getScaleX(mrb_state* mrb, mrb_value self)
{
    cocos2d::Node* cobj = static_cast<cocos2d::Node*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            double retval = cobj->getScaleX();
            mrb_value ret;
            ret = mrb_float_value(mrb, (mrb_float)retval);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::Node#getScaleX");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Node_setLocalZOrder(mrb_state* mrb, mrb_value self)
{
    cocos2d::Node* cobj = static_cast<cocos2d::Node*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            int arg0;
            ok = rubyval_to_int32(mrb, argv[0], (int*)&arg0, "CC::Node.setLocalZOrder");
            if (!ok) { break; }
            cobj->setLocalZOrder(arg0);
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::Node#setLocalZOrder");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Node_getWorldToNodeAffineTransform(mrb_state* mrb, mrb_value self)
{
    cocos2d::Node* cobj = static_cast<cocos2d::Node*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            cocos2d::AffineTransform retval = cobj->getWorldToNodeAffineTransform();
            cocos2d::AffineTransform* retval_ptr = new cocos2d::AffineTransform(retval);
            mrb_value ret;
            ret = object_to_rubyval<cocos2d::AffineTransform>(mrb, "CC::AffineTransform", (cocos2d::AffineTransform*)retval_ptr, nullptr);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::Node#getWorldToNodeAffineTransform");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Node_setCascadeColorEnabled(mrb_state* mrb, mrb_value self)
{
    cocos2d::Node* cobj = static_cast<cocos2d::Node*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            bool arg0;
            ok = rubyval_to_boolean(mrb, argv[0], &arg0, "CC::Node.setCascadeColorEnabled");
            if (!ok) { break; }
            cobj->setCascadeColorEnabled(arg0);
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::Node#setCascadeColorEnabled");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Node_setOpacity(mrb_state* mrb, mrb_value self)
{
    cocos2d::Node* cobj = static_cast<cocos2d::Node*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            uint16_t arg0;
            ok = rubyval_to_uint16(mrb, argv[0], &arg0, "CC::Node.setOpacity");
            if (!ok) { break; }
            cobj->setOpacity(arg0);
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::Node#setOpacity");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Node_cleanup(mrb_state* mrb, mrb_value self)
{
    cocos2d::Node* cobj = static_cast<cocos2d::Node*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            cobj->cleanup();
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::Node#cleanup");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Node_getComponent(mrb_state* mrb, mrb_value self)
{
    cocos2d::Node* cobj = static_cast<cocos2d::Node*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            std::string arg0;
            ok = rubyval_to_std_string(mrb, argv[0], &arg0, "CC::Node.getComponent");
            if (!ok) { break; }
            cocos2d::Component* retval = cobj->getComponent(arg0);
            mrb_value ret;
            ret = object_to_rubyval<cocos2d::Component>(mrb, "CC::Component", (cocos2d::Component*)retval, nullptr);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::Node#getComponent");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Node_getContentSize(mrb_state* mrb, mrb_value self)
{
    cocos2d::Node* cobj = static_cast<cocos2d::Node*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            cocos2d::Size retval = cobj->getContentSize();
            cocos2d::Size* retval_ptr = new cocos2d::Size(retval);
            mrb_value ret;
            ret = object_to_rubyval<cocos2d::Size>(mrb, "CC::Size", (cocos2d::Size*)retval_ptr, nullptr);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::Node#getContentSize");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Node_stopAllActionsByTag(mrb_state* mrb, mrb_value self)
{
    cocos2d::Node* cobj = static_cast<cocos2d::Node*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            int arg0;
            ok = rubyval_to_int32(mrb, argv[0], (int*)&arg0, "CC::Node.stopAllActionsByTag");
            if (!ok) { break; }
            cobj->stopAllActionsByTag(arg0);
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::Node#stopAllActionsByTag");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Node_getColor(mrb_state* mrb, mrb_value self)
{
    cocos2d::Node* cobj = static_cast<cocos2d::Node*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            cocos2d::Color3B retval = cobj->getColor();
            cocos2d::Color3B* retval_ptr = new cocos2d::Color3B(retval);
            mrb_value ret;
            ret = object_to_rubyval<cocos2d::Color3B>(mrb, "CC::Color3B", (cocos2d::Color3B*)retval_ptr, nullptr);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::Node#getColor");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Node_getBoundingBox(mrb_state* mrb, mrb_value self)
{
    cocos2d::Node* cobj = static_cast<cocos2d::Node*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            cocos2d::Rect retval = cobj->getBoundingBox();
            cocos2d::Rect* retval_ptr = new cocos2d::Rect(retval);
            mrb_value ret;
            ret = object_to_rubyval<cocos2d::Rect>(mrb, "CC::Rect", (cocos2d::Rect*)retval_ptr, nullptr);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::Node#getBoundingBox");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Node_setEventDispatcher(mrb_state* mrb, mrb_value self)
{
    cocos2d::Node* cobj = static_cast<cocos2d::Node*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            cocos2d::EventDispatcher* arg0;
            ok = rubyval_to_object<cocos2d::EventDispatcher>(mrb, argv[0], "CC::EventDispatcher", &arg0);
            if (!ok) { break; }
            cobj->setEventDispatcher(arg0);
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::Node#setEventDispatcher");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Node_getGlobalZOrder(mrb_state* mrb, mrb_value self)
{
    cocos2d::Node* cobj = static_cast<cocos2d::Node*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            double retval = cobj->getGlobalZOrder();
            mrb_value ret;
            ret = mrb_float_value(mrb, (mrb_float)retval);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::Node#getGlobalZOrder");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Node_draw(mrb_state* mrb, mrb_value self)
{
    cocos2d::Node* cobj = static_cast<cocos2d::Node*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 0) {
            cobj->draw();
            return self;
        }
    } while (0);
    do {
        if (argc == 3) {
            cocos2d::Renderer* arg0;
            ok = rubyval_to_object<cocos2d::Renderer>(mrb, argv[0], "CC::Renderer", &arg0);
            if (!ok) { break; }
            cocos2d::Mat4* arg1;
            ok = rubyval_to_object<cocos2d::Mat4>(mrb, argv[1], "CC::Mat4", &arg1);
            if (!ok) { break; }
            unsigned int arg2;
            ok = rubyval_to_uint32(mrb, argv[2], &arg2, "CC::Node.draw");
            if (!ok) { break; }
            cobj->draw(arg0, *arg1, arg2);
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::Node#draw");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Node_setUserObject(mrb_state* mrb, mrb_value self)
{
    cocos2d::Node* cobj = static_cast<cocos2d::Node*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            cocos2d::Ref* arg0;
            ok = rubyval_to_object<cocos2d::Ref>(mrb, argv[0], "CC::Ref", &arg0);
            if (!ok) { break; }
            cobj->setUserObject(arg0);
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::Node#setUserObject");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Node_enumerateChildren(mrb_state* mrb, mrb_value self)
{
    cocos2d::Node* cobj = static_cast<cocos2d::Node*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 2) {
            std::string arg0;
            ok = rubyval_to_std_string(mrb, argv[0], &arg0, "CC::Node.enumerateChildren");
            if (!ok) { break; }
            std::function<bool (cocos2d::Node *)> arg1;
            do {
			    // Lambda binding for ruby.
			    unsigned long idx = -1;
			    arg1 = [mrb, self, idx](cocos2d::Node* larg0) -> bool {
			        mrb_value ruby_arg0;
			        ruby_arg0 = object_to_rubyval<cocos2d::Node>(mrb, "CC::Node", (cocos2d::Node*)larg0, nullptr);
			        mrb_value hash = mrb_iv_get(mrb, self, mrb_intern_cstr(mrb, "__callback_hash"));
			        mrb_value func = mrb_hash_get(mrb, hash, mrb_str_new_cstr(mrb, "enumerateChildren->arg1"));
			        mrb_value mrb_ret = mrb_funcall(mrb, func, "call", 1, ruby_arg0);
			        if (mrb_exception_p(mrb_ret)) {
			            mrb_exc_raise(mrb, mrb_ret);
			        }
			        bool ok = true;
			        bool lret;
			        ok = rubyval_to_boolean(mrb, mrb_ret, &lret, ".Proc.call");
			        return lret;
			    };
			    mrb_value hash = mrb_iv_get(mrb, self, mrb_intern_cstr(mrb, "__callback_hash"));
			    if (!mrb_hash_p(hash)) {
			        hash = mrb_hash_new(mrb);
			    }
			    mrb_hash_set(mrb, hash, mrb_str_new_cstr(mrb, "enumerateChildren->arg1"), argv[1]);
			    mrb_iv_set(mrb, self, mrb_intern_cstr(mrb, "__callback_hash"), hash);
			    break;
			} while(0);
            cobj->enumerateChildren(arg0, arg1);
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::Node#enumerateChildren");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Node_getonExitTransitionDidStartCallback(mrb_state* mrb, mrb_value self)
{
    cocos2d::Node* cobj = static_cast<cocos2d::Node*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            std::function<void ()> retval = cobj->getonExitTransitionDidStartCallback();
            mrb_value ret;
            #pragma warning NO CONVERSION FROM NATIVE FOR std::function;
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::Node#getonExitTransitionDidStartCallback");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Node_removeFromParentAndCleanup(mrb_state* mrb, mrb_value self)
{
    cocos2d::Node* cobj = static_cast<cocos2d::Node*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            bool arg0;
            ok = rubyval_to_boolean(mrb, argv[0], &arg0, "CC::Node.removeFromParentAndCleanup");
            if (!ok) { break; }
            cobj->removeFromParentAndCleanup(arg0);
            return self;
        }
    } while (0);
    do {
        if (argc == 0) {
            cobj->removeFromParent();
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::Node#removeFromParentAndCleanup");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Node_setPosition3D(mrb_state* mrb, mrb_value self)
{
    cocos2d::Node* cobj = static_cast<cocos2d::Node*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            cocos2d::Vec3* arg0;
            ok = rubyval_to_object<cocos2d::Vec3>(mrb, argv[0], "CC::Vec3", &arg0);
            if (!ok) { break; }
            cobj->setPosition3D(*arg0);
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::Node#setPosition3D");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Node_update(mrb_state* mrb, mrb_value self)
{
    cocos2d::Node* cobj = static_cast<cocos2d::Node*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            double arg0;
            ok = rubyval_to_number(mrb, argv[0], (double*)&arg0, "CC::Node.update");
            if (!ok) { break; }
            cobj->update(arg0);
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::Node#update");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Node_sortAllChildren(mrb_state* mrb, mrb_value self)
{
    cocos2d::Node* cobj = static_cast<cocos2d::Node*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            cobj->sortAllChildren();
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::Node#sortAllChildren");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Node_getWorldToNodeTransform(mrb_state* mrb, mrb_value self)
{
    cocos2d::Node* cobj = static_cast<cocos2d::Node*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            cocos2d::Mat4 retval = cobj->getWorldToNodeTransform();
            cocos2d::Mat4* retval_ptr = new cocos2d::Mat4(retval);
            mrb_value ret;
            ret = object_to_rubyval<cocos2d::Mat4>(mrb, "CC::Mat4", (cocos2d::Mat4*)retval_ptr, nullptr);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::Node#getWorldToNodeTransform");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Node_setGLProgram(mrb_state* mrb, mrb_value self)
{
    cocos2d::Node* cobj = static_cast<cocos2d::Node*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            cocos2d::GLProgram* arg0;
            ok = rubyval_to_object<cocos2d::GLProgram>(mrb, argv[0], "CC::GLProgram", &arg0);
            if (!ok) { break; }
            cobj->setGLProgram(arg0);
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::Node#setGLProgram");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Node_getScale(mrb_state* mrb, mrb_value self)
{
    cocos2d::Node* cobj = static_cast<cocos2d::Node*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            double retval = cobj->getScale();
            mrb_value ret;
            ret = mrb_float_value(mrb, (mrb_float)retval);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::Node#getScale");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Node_getNormalizedPosition(mrb_state* mrb, mrb_value self)
{
    cocos2d::Node* cobj = static_cast<cocos2d::Node*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            cocos2d::Vec2 retval = cobj->getNormalizedPosition();
            cocos2d::Vec2* retval_ptr = new cocos2d::Vec2(retval);
            mrb_value ret;
            ret = object_to_rubyval<cocos2d::Vec2>(mrb, "CC::Vec2", (cocos2d::Vec2*)retval_ptr, nullptr);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::Node#getNormalizedPosition");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Node_setUserData(mrb_state* mrb, mrb_value self)
{
    cocos2d::Node* cobj = static_cast<cocos2d::Node*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            void* arg0;
            #pragma warning NO CONVERSION TO NATIVE FOR void*
		ok = false;
            if (!ok) { break; }
            cobj->setUserData(arg0);
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::Node#setUserData");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Node_getRotationSkewX(mrb_state* mrb, mrb_value self)
{
    cocos2d::Node* cobj = static_cast<cocos2d::Node*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            double retval = cobj->getRotationSkewX();
            mrb_value ret;
            ret = mrb_float_value(mrb, (mrb_float)retval);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::Node#getRotationSkewX");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Node_getRotationSkewY(mrb_state* mrb, mrb_value self)
{
    cocos2d::Node* cobj = static_cast<cocos2d::Node*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            double retval = cobj->getRotationSkewY();
            mrb_value ret;
            ret = mrb_float_value(mrb, (mrb_float)retval);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::Node#getRotationSkewY");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Node_setTag(mrb_state* mrb, mrb_value self)
{
    cocos2d::Node* cobj = static_cast<cocos2d::Node*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            int arg0;
            ok = rubyval_to_int32(mrb, argv[0], (int*)&arg0, "CC::Node.setTag");
            if (!ok) { break; }
            cobj->setTag(arg0);
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::Node#setTag");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Node_isCascadeColorEnabled(mrb_state* mrb, mrb_value self)
{
    cocos2d::Node* cobj = static_cast<cocos2d::Node*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            bool retval = cobj->isCascadeColorEnabled();
            mrb_value ret;
            ret = mrb_bool_value((mrb_bool)retval);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::Node#isCascadeColorEnabled");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Node_scheduleUpdate(mrb_state* mrb, mrb_value self)
{
    cocos2d::Node* cobj = static_cast<cocos2d::Node*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            cobj->scheduleUpdate();
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::Node#scheduleUpdate");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Node_stopAction(mrb_state* mrb, mrb_value self)
{
    cocos2d::Node* cobj = static_cast<cocos2d::Node*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            cocos2d::Action* arg0;
            ok = rubyval_to_object<cocos2d::Action>(mrb, argv[0], "CC::Action", &arg0);
            if (!ok) { break; }
            cobj->stopAction(arg0);
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::Node#stopAction");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Node_getActionManager(mrb_state* mrb, mrb_value self)
{
    cocos2d::Node* cobj = static_cast<cocos2d::Node*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            const cocos2d::ActionManager* retval = cobj->getActionManager();
            mrb_value ret;
            ret = object_to_rubyval<cocos2d::ActionManager>(mrb, "CC::ActionManager", (cocos2d::ActionManager*)retval, nullptr);
            return ret;
        }
    } while (0);
    do {
        if (argc == 0) {
            cocos2d::ActionManager* retval = cobj->getActionManager();
            mrb_value ret;
            ret = object_to_rubyval<cocos2d::ActionManager>(mrb, "CC::ActionManager", (cocos2d::ActionManager*)retval, nullptr);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::Node#getActionManager");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Node_create_static(mrb_state* mrb, mrb_value self)
{
    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            std::map<std::string, mrb_value> callbacks;
            cocos2d::Node* retval = cocos2d::Node::create();
            mrb_value ret;
            RClass* rclass = mrb_class_ptr(self);
            ret = object_to_rubyval<cocos2d::Node>(mrb, "CC::Node", (cocos2d::Node*)retval, rclass);
            if (callbacks.size() > 0) {
                mrb_value hash = mrb_iv_get(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"));
                if (!mrb_hash_p(hash)) {
                    hash = mrb_hash_new(mrb);
                }
                for (auto elm : callbacks) {
                    mrb_hash_set(mrb, hash, mrb_str_new_cstr(mrb, elm.first.c_str()), elm.second);
                    mrb_iv_set(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"), hash);
                }
            }
            g_rubyValue.push_back(ret);
            mrb_funcall(mrb, ret, "initialize", 0);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined static method : cocos2d::Node#create");

    return mrb_nil_value();
}

void ruby_cocos2dx_Node_constants_init(mrb_state* mrb, struct RClass* rclass)
{
    do {
        mrb_value ret;
        ret = mrb_fixnum_value((mrb_int)cocos2d::Node::INVALID_TAG);
        mrb_mod_cv_set(mrb, rclass, mrb_intern_cstr(mrb, "INVALID_TAG"), ret);
    } while (0);

}

void ruby_cocos2dx_Node_N_enum_init(mrb_state* mrb, struct RClass* renum)
{
    do {
        mrb_value ev = mrb_fixnum_value((mrb_int)cocos2d::Node::FLAGS_TRANSFORM_DIRTY);
        mrb_mod_cv_set(mrb, renum, mrb_intern_cstr(mrb, "FLAGS_TRANSFORM_DIRTY"), ev);
    } while (0);

    do {
        mrb_value ev = mrb_fixnum_value((mrb_int)cocos2d::Node::FLAGS_CONTENT_SIZE_DIRTY);
        mrb_mod_cv_set(mrb, renum, mrb_intern_cstr(mrb, "FLAGS_CONTENT_SIZE_DIRTY"), ev);
    } while (0);

    do {
        mrb_value ev = mrb_fixnum_value((mrb_int)cocos2d::Node::FLAGS_RENDER_AS_3D);
        mrb_mod_cv_set(mrb, renum, mrb_intern_cstr(mrb, "FLAGS_RENDER_AS_3D"), ev);
    } while (0);

    do {
        mrb_value ev = mrb_fixnum_value((mrb_int)cocos2d::Node::FLAGS_DIRTY_MASK);
        mrb_mod_cv_set(mrb, renum, mrb_intern_cstr(mrb, "FLAGS_DIRTY_MASK"), ev);
    } while (0);

}

void ruby_register_cocos2dx_Node(mrb_state* mrb, struct RClass* rmodule)
{
    std::string typeName = typeid(cocos2d::Node).name();
    g_rubyType[typeName] = "CC::Node";
    g_rubyDataType[typeName] = &ruby_cocos2dx_Ref_type;

    struct RClass* p_rmodule = mrb->object_class;
    p_rmodule = mrb_module_get_under(mrb, p_rmodule, "CC");
    struct RClass* p_rclass = mrb_class_get_under(mrb, p_rmodule, "Ref");
    struct RClass *rclass = mrb_define_class_under(mrb, rmodule, "Node", p_rclass);
    MRB_SET_INSTANCE_TT(rclass, MRB_TT_DATA);

    mrb_define_method(mrb, rclass, "add_child", ruby_cocos2dx_Node_addChild, ARGS_REQ(1)|ARGS_OPT(2));
    mrb_define_method(mrb, rclass, "remove_component", ruby_cocos2dx_Node_removeComponent, ARGS_REQ(1));
    mrb_define_method(mrb, rclass, "get_user_object", ruby_cocos2dx_Node_getUserObject, ARGS_NONE());
    mrb_define_method(mrb, rclass, "get_description", ruby_cocos2dx_Node_getDescription, ARGS_NONE());
    mrb_define_method(mrb, rclass, "set_rotation_skew_y", ruby_cocos2dx_Node_setRotationSkewY, ARGS_REQ(1));
    mrb_define_method(mrb, rclass, "set_opacity_modify_rgb", ruby_cocos2dx_Node_setOpacityModifyRGB, ARGS_REQ(1));
    mrb_define_method(mrb, rclass, "set_cascade_opacity_enabled", ruby_cocos2dx_Node_setCascadeOpacityEnabled, ARGS_REQ(1));
    mrb_define_method(mrb, rclass, "get_children", ruby_cocos2dx_Node_getChildren, ARGS_NONE());
    mrb_define_method(mrb, rclass, "unschedule", ruby_cocos2dx_Node_unschedule, ARGS_REQ(1));
    mrb_define_method(mrb, rclass, "schedule_once", ruby_cocos2dx_Node_scheduleOnce, ARGS_REQ(3));
    mrb_define_method(mrb, rclass, "set_on_exit_callback", ruby_cocos2dx_Node_setOnExitCallback, ARGS_REQ(1));
    mrb_define_method(mrb, rclass, "pause", ruby_cocos2dx_Node_pause, ARGS_NONE());
    mrb_define_method(mrb, rclass, "convert_to_world_space_ar", ruby_cocos2dx_Node_convertToWorldSpaceAR, ARGS_REQ(1));
    mrb_define_method(mrb, rclass, "ignore_anchor_point_for_position?", ruby_cocos2dx_Node_isIgnoreAnchorPointForPosition, ARGS_NONE());
    mrb_define_method(mrb, rclass, "get_child_by_name", ruby_cocos2dx_Node_getChildByName, ARGS_REQ(1));
    mrb_define_method(mrb, rclass, "update_displayed_opacity", ruby_cocos2dx_Node_updateDisplayedOpacity, ARGS_REQ(1));
    mrb_define_method(mrb, rclass, "get_camera_mask", ruby_cocos2dx_Node_getCameraMask, ARGS_NONE());
    mrb_define_method(mrb, rclass, "set_rotation", ruby_cocos2dx_Node_setRotation, ARGS_REQ(1));
    mrb_define_method(mrb, rclass, "set_scale_z", ruby_cocos2dx_Node_setScaleZ, ARGS_REQ(1));
    mrb_define_method(mrb, rclass, "set_scale_y", ruby_cocos2dx_Node_setScaleY, ARGS_REQ(1));
    mrb_define_method(mrb, rclass, "set_scale_x", ruby_cocos2dx_Node_setScaleX, ARGS_REQ(1));
    mrb_define_method(mrb, rclass, "set_rotation_skew_x", ruby_cocos2dx_Node_setRotationSkewX, ARGS_REQ(1));
    mrb_define_method(mrb, rclass, "schedule_update_with_priority", ruby_cocos2dx_Node_scheduleUpdateWithPriority, ARGS_REQ(1));
    mrb_define_method(mrb, rclass, "seton_enter_transition_did_finish_callback", ruby_cocos2dx_Node_setonEnterTransitionDidFinishCallback, ARGS_REQ(1));
    mrb_define_method(mrb, rclass, "remove_all_components", ruby_cocos2dx_Node_removeAllComponents, ARGS_NONE());
    mrb_define_method(mrb, rclass, "get_opacity", ruby_cocos2dx_Node_getOpacity, ARGS_NONE());
    mrb_define_method(mrb, rclass, "set_camera_mask", ruby_cocos2dx_Node_setCameraMask, ARGS_REQ(2));
    mrb_define_method(mrb, rclass, "get_tag", ruby_cocos2dx_Node_getTag, ARGS_NONE());
    mrb_define_method(mrb, rclass, "geton_enter_transition_did_finish_callback", ruby_cocos2dx_Node_getonEnterTransitionDidFinishCallback, ARGS_NONE());
    mrb_define_method(mrb, rclass, "get_glprogram", ruby_cocos2dx_Node_getGLProgram, ARGS_NONE());
    mrb_define_method(mrb, rclass, "get_node_to_world_transform", ruby_cocos2dx_Node_getNodeToWorldTransform, ARGS_NONE());
    mrb_define_method(mrb, rclass, "get_position3_d", ruby_cocos2dx_Node_getPosition3D, ARGS_NONE());
    mrb_define_method(mrb, rclass, "remove_child", ruby_cocos2dx_Node_removeChild, ARGS_REQ(2));
    mrb_define_method(mrb, rclass, "convert_to_world_space", ruby_cocos2dx_Node_convertToWorldSpace, ARGS_REQ(1));
    mrb_define_method(mrb, rclass, "get_scene", ruby_cocos2dx_Node_getScene, ARGS_NONE());
    mrb_define_method(mrb, rclass, "get_event_dispatcher", ruby_cocos2dx_Node_getEventDispatcher, ARGS_NONE());
    mrb_define_method(mrb, rclass, "set_skew_x", ruby_cocos2dx_Node_setSkewX, ARGS_REQ(1));
    mrb_define_method(mrb, rclass, "set_glprogram_state", ruby_cocos2dx_Node_setGLProgramState, ARGS_REQ(1));
    mrb_define_method(mrb, rclass, "set_on_enter_callback", ruby_cocos2dx_Node_setOnEnterCallback, ARGS_REQ(1));
    mrb_define_method(mrb, rclass, "set_normalized_position", ruby_cocos2dx_Node_setNormalizedPosition, ARGS_REQ(1));
    mrb_define_method(mrb, rclass, "seton_exit_transition_did_start_callback", ruby_cocos2dx_Node_setonExitTransitionDidStartCallback, ARGS_REQ(1));
    mrb_define_method(mrb, rclass, "unschedule_all_callbacks", ruby_cocos2dx_Node_unscheduleAllCallbacks, ARGS_NONE());
    mrb_define_method(mrb, rclass, "convert_touch_to_node_space", ruby_cocos2dx_Node_convertTouchToNodeSpace, ARGS_REQ(1));
    mrb_define_method(mrb, rclass, "remove_all_children", ruby_cocos2dx_Node_removeAllChildrenWithCleanup, ARGS_REQ(0)|ARGS_OPT(1));
    mrb_define_method(mrb, rclass, "get_node_to_parent_affine_transform", ruby_cocos2dx_Node_getNodeToParentAffineTransform, ARGS_NONE());
    mrb_define_method(mrb, rclass, "unschedule_update", ruby_cocos2dx_Node_unscheduleUpdate, ARGS_NONE());
    mrb_define_method(mrb, rclass, "get_user_data", ruby_cocos2dx_Node_getUserData, ARGS_NONE());
    mrb_define_method(mrb, rclass, "cascade_opacity_enabled?", ruby_cocos2dx_Node_isCascadeOpacityEnabled, ARGS_NONE());
    mrb_define_method(mrb, rclass, "set_parent", ruby_cocos2dx_Node_setParent, ARGS_REQ(1));
    mrb_define_method(mrb, rclass, "get_name", ruby_cocos2dx_Node_getName, ARGS_NONE());
    mrb_define_method(mrb, rclass, "resume", ruby_cocos2dx_Node_resume, ARGS_NONE());
    mrb_define_method(mrb, rclass, "get_rotation3_d", ruby_cocos2dx_Node_getRotation3D, ARGS_NONE());
    mrb_define_method(mrb, rclass, "get_node_to_parent_transform", ruby_cocos2dx_Node_getNodeToParentTransform, ARGS_NONE());
    mrb_define_method(mrb, rclass, "convert_touch_to_node_space_ar", ruby_cocos2dx_Node_convertTouchToNodeSpaceAR, ARGS_REQ(1));
    mrb_define_method(mrb, rclass, "get_on_enter_callback", ruby_cocos2dx_Node_getOnEnterCallback, ARGS_NONE());
    mrb_define_method(mrb, rclass, "convert_to_node_space", ruby_cocos2dx_Node_convertToNodeSpace, ARGS_REQ(1));
    mrb_define_method(mrb, rclass, "schedule", ruby_cocos2dx_Node_schedule, ARGS_REQ(2)|ARGS_OPT(3));
    mrb_define_method(mrb, rclass, "set_position", ruby_cocos2dx_Node_setPosition, ARGS_REQ(1)|ARGS_OPT(1));
    mrb_define_method(mrb, rclass, "stop_action_by_tag", ruby_cocos2dx_Node_stopActionByTag, ARGS_REQ(1));
    mrb_define_method(mrb, rclass, "reorder_child", ruby_cocos2dx_Node_reorderChild, ARGS_REQ(2));
    mrb_define_method(mrb, rclass, "ignore_anchor_point_for_position", ruby_cocos2dx_Node_ignoreAnchorPointForPosition, ARGS_REQ(1));
    mrb_define_method(mrb, rclass, "set_skew_y", ruby_cocos2dx_Node_setSkewY, ARGS_REQ(1));
    mrb_define_method(mrb, rclass, "set_position_z", ruby_cocos2dx_Node_setPositionZ, ARGS_REQ(1));
    mrb_define_method(mrb, rclass, "set_rotation3_d", ruby_cocos2dx_Node_setRotation3D, ARGS_REQ(1));
    mrb_define_method(mrb, rclass, "set_position_x", ruby_cocos2dx_Node_setPositionX, ARGS_REQ(1));
    mrb_define_method(mrb, rclass, "set_node_to_parent_transform", ruby_cocos2dx_Node_setNodeToParentTransform, ARGS_REQ(1));
    mrb_define_method(mrb, rclass, "get_anchor_point", ruby_cocos2dx_Node_getAnchorPoint, ARGS_NONE());
    mrb_define_method(mrb, rclass, "get_number_of_running_actions", ruby_cocos2dx_Node_getNumberOfRunningActions, ARGS_NONE());
    mrb_define_method(mrb, rclass, "update_transform", ruby_cocos2dx_Node_updateTransform, ARGS_NONE());
    mrb_define_method(mrb, rclass, "visible?", ruby_cocos2dx_Node_isVisible, ARGS_NONE());
    mrb_define_method(mrb, rclass, "get_children_count", ruby_cocos2dx_Node_getChildrenCount, ARGS_NONE());
    mrb_define_method(mrb, rclass, "set_anchor_point", ruby_cocos2dx_Node_setAnchorPoint, ARGS_REQ(1));
    mrb_define_method(mrb, rclass, "convert_to_node_space_ar", ruby_cocos2dx_Node_convertToNodeSpaceAR, ARGS_REQ(1));
    mrb_define_method(mrb, rclass, "add_component", ruby_cocos2dx_Node_addComponent, ARGS_REQ(1));
    mrb_define_method(mrb, rclass, "run_action", ruby_cocos2dx_Node_runAction, ARGS_REQ(1));
    mrb_define_method(mrb, rclass, "visit", ruby_cocos2dx_Node_visit, ARGS_REQ(0)|ARGS_OPT(3));
    mrb_define_method(mrb, rclass, "opacity_modify_rgb?", ruby_cocos2dx_Node_isOpacityModifyRGB, ARGS_NONE());
    mrb_define_method(mrb, rclass, "schedule_update_with_priority_lua", ruby_cocos2dx_Node_scheduleUpdateWithPriorityLua, ARGS_REQ(2));
    mrb_define_method(mrb, rclass, "get_rotation", ruby_cocos2dx_Node_getRotation, ARGS_NONE());
    mrb_define_method(mrb, rclass, "get_anchor_point_in_points", ruby_cocos2dx_Node_getAnchorPointInPoints, ARGS_NONE());
    mrb_define_method(mrb, rclass, "remove_child_by_name", ruby_cocos2dx_Node_removeChildByName, ARGS_REQ(2));
    mrb_define_method(mrb, rclass, "get_glprogram_state", ruby_cocos2dx_Node_getGLProgramState, ARGS_NONE());
    mrb_define_method(mrb, rclass, "set_scheduler", ruby_cocos2dx_Node_setScheduler, ARGS_REQ(1));
    mrb_define_method(mrb, rclass, "stop_all_actions", ruby_cocos2dx_Node_stopAllActions, ARGS_NONE());
    mrb_define_method(mrb, rclass, "get_skew_x", ruby_cocos2dx_Node_getSkewX, ARGS_NONE());
    mrb_define_method(mrb, rclass, "get_skew_y", ruby_cocos2dx_Node_getSkewY, ARGS_NONE());
    mrb_define_method(mrb, rclass, "get_displayed_color", ruby_cocos2dx_Node_getDisplayedColor, ARGS_NONE());
    mrb_define_method(mrb, rclass, "get_action_by_tag", ruby_cocos2dx_Node_getActionByTag, ARGS_REQ(1));
    mrb_define_method(mrb, rclass, "set_name", ruby_cocos2dx_Node_setName, ARGS_REQ(1));
    mrb_define_method(mrb, rclass, "get_displayed_opacity", ruby_cocos2dx_Node_getDisplayedOpacity, ARGS_NONE());
    mrb_define_method(mrb, rclass, "get_local_zorder", ruby_cocos2dx_Node_getLocalZOrder, ARGS_NONE());
    mrb_define_method(mrb, rclass, "get_scheduler", ruby_cocos2dx_Node_getScheduler, ARGS_NONE());
    mrb_define_method(mrb, rclass, "get_parent_to_node_affine_transform", ruby_cocos2dx_Node_getParentToNodeAffineTransform, ARGS_NONE());
    mrb_define_method(mrb, rclass, "get_order_of_arrival", ruby_cocos2dx_Node_getOrderOfArrival, ARGS_NONE());
    mrb_define_method(mrb, rclass, "set_content_size", ruby_cocos2dx_Node_setContentSize, ARGS_REQ(1));
    mrb_define_method(mrb, rclass, "set_action_manager", ruby_cocos2dx_Node_setActionManager, ARGS_REQ(1));
    mrb_define_method(mrb, rclass, "get_position", ruby_cocos2dx_Node_getPosition, ARGS_REQ(0)|ARGS_OPT(2));
    mrb_define_method(mrb, rclass, "set_color", ruby_cocos2dx_Node_setColor, ARGS_REQ(1));
    mrb_define_method(mrb, rclass, "running?", ruby_cocos2dx_Node_isRunning, ARGS_NONE());
    mrb_define_method(mrb, rclass, "get_parent", ruby_cocos2dx_Node_getParent, ARGS_NONE());
    mrb_define_method(mrb, rclass, "get_position_z", ruby_cocos2dx_Node_getPositionZ, ARGS_NONE());
    mrb_define_method(mrb, rclass, "get_position_y", ruby_cocos2dx_Node_getPositionY, ARGS_NONE());
    mrb_define_method(mrb, rclass, "get_position_x", ruby_cocos2dx_Node_getPositionX, ARGS_NONE());
    mrb_define_method(mrb, rclass, "remove_child_by_tag", ruby_cocos2dx_Node_removeChildByTag, ARGS_REQ(2));
    mrb_define_method(mrb, rclass, "set_position_y", ruby_cocos2dx_Node_setPositionY, ARGS_REQ(1));
    mrb_define_method(mrb, rclass, "get_node_to_world_affine_transform", ruby_cocos2dx_Node_getNodeToWorldAffineTransform, ARGS_NONE());
    mrb_define_method(mrb, rclass, "update_displayed_color", ruby_cocos2dx_Node_updateDisplayedColor, ARGS_REQ(1));
    mrb_define_method(mrb, rclass, "set_visible", ruby_cocos2dx_Node_setVisible, ARGS_REQ(1));
    mrb_define_method(mrb, rclass, "get_parent_to_node_transform", ruby_cocos2dx_Node_getParentToNodeTransform, ARGS_NONE());
    mrb_define_method(mrb, rclass, "scheduled?", ruby_cocos2dx_Node_isScheduled, ARGS_REQ(1));
    mrb_define_method(mrb, rclass, "set_global_zorder", ruby_cocos2dx_Node_setGlobalZOrder, ARGS_REQ(1));
    mrb_define_method(mrb, rclass, "set_scale", ruby_cocos2dx_Node_setScale, ARGS_REQ(1)|ARGS_OPT(1));
    mrb_define_method(mrb, rclass, "get_on_exit_callback", ruby_cocos2dx_Node_getOnExitCallback, ARGS_NONE());
    mrb_define_method(mrb, rclass, "get_child_by_tag", ruby_cocos2dx_Node_getChildByTag, ARGS_REQ(1));
    mrb_define_method(mrb, rclass, "set_order_of_arrival", ruby_cocos2dx_Node_setOrderOfArrival, ARGS_REQ(1));
    mrb_define_method(mrb, rclass, "get_scale_z", ruby_cocos2dx_Node_getScaleZ, ARGS_NONE());
    mrb_define_method(mrb, rclass, "get_scale_y", ruby_cocos2dx_Node_getScaleY, ARGS_NONE());
    mrb_define_method(mrb, rclass, "get_scale_x", ruby_cocos2dx_Node_getScaleX, ARGS_NONE());
    mrb_define_method(mrb, rclass, "set_local_zorder", ruby_cocos2dx_Node_setLocalZOrder, ARGS_REQ(1));
    mrb_define_method(mrb, rclass, "get_world_to_node_affine_transform", ruby_cocos2dx_Node_getWorldToNodeAffineTransform, ARGS_NONE());
    mrb_define_method(mrb, rclass, "set_cascade_color_enabled", ruby_cocos2dx_Node_setCascadeColorEnabled, ARGS_REQ(1));
    mrb_define_method(mrb, rclass, "set_opacity", ruby_cocos2dx_Node_setOpacity, ARGS_REQ(1));
    mrb_define_method(mrb, rclass, "cleanup", ruby_cocos2dx_Node_cleanup, ARGS_NONE());
    mrb_define_method(mrb, rclass, "get_component", ruby_cocos2dx_Node_getComponent, ARGS_REQ(1));
    mrb_define_method(mrb, rclass, "get_content_size", ruby_cocos2dx_Node_getContentSize, ARGS_NONE());
    mrb_define_method(mrb, rclass, "stop_all_actions_by_tag", ruby_cocos2dx_Node_stopAllActionsByTag, ARGS_REQ(1));
    mrb_define_method(mrb, rclass, "get_color", ruby_cocos2dx_Node_getColor, ARGS_NONE());
    mrb_define_method(mrb, rclass, "get_bounding_box", ruby_cocos2dx_Node_getBoundingBox, ARGS_NONE());
    mrb_define_method(mrb, rclass, "set_event_dispatcher", ruby_cocos2dx_Node_setEventDispatcher, ARGS_REQ(1));
    mrb_define_method(mrb, rclass, "get_global_zorder", ruby_cocos2dx_Node_getGlobalZOrder, ARGS_NONE());
    mrb_define_method(mrb, rclass, "draw", ruby_cocos2dx_Node_draw, ARGS_REQ(0)|ARGS_OPT(3));
    mrb_define_method(mrb, rclass, "set_user_object", ruby_cocos2dx_Node_setUserObject, ARGS_REQ(1));
    mrb_define_method(mrb, rclass, "enumerate_children", ruby_cocos2dx_Node_enumerateChildren, ARGS_REQ(2));
    mrb_define_method(mrb, rclass, "geton_exit_transition_did_start_callback", ruby_cocos2dx_Node_getonExitTransitionDidStartCallback, ARGS_NONE());
    mrb_define_method(mrb, rclass, "remove_from_parent", ruby_cocos2dx_Node_removeFromParentAndCleanup, ARGS_REQ(0)|ARGS_OPT(1));
    mrb_define_method(mrb, rclass, "set_position3_d", ruby_cocos2dx_Node_setPosition3D, ARGS_REQ(1));
    mrb_define_method(mrb, rclass, "update", ruby_cocos2dx_Node_update, ARGS_REQ(1));
    mrb_define_method(mrb, rclass, "sort_all_children", ruby_cocos2dx_Node_sortAllChildren, ARGS_NONE());
    mrb_define_method(mrb, rclass, "get_world_to_node_transform", ruby_cocos2dx_Node_getWorldToNodeTransform, ARGS_NONE());
    mrb_define_method(mrb, rclass, "set_glprogram", ruby_cocos2dx_Node_setGLProgram, ARGS_REQ(1));
    mrb_define_method(mrb, rclass, "get_scale", ruby_cocos2dx_Node_getScale, ARGS_NONE());
    mrb_define_method(mrb, rclass, "get_normalized_position", ruby_cocos2dx_Node_getNormalizedPosition, ARGS_NONE());
    mrb_define_method(mrb, rclass, "set_user_data", ruby_cocos2dx_Node_setUserData, ARGS_REQ(1));
    mrb_define_method(mrb, rclass, "get_rotation_skew_x", ruby_cocos2dx_Node_getRotationSkewX, ARGS_NONE());
    mrb_define_method(mrb, rclass, "get_rotation_skew_y", ruby_cocos2dx_Node_getRotationSkewY, ARGS_NONE());
    mrb_define_method(mrb, rclass, "set_tag", ruby_cocos2dx_Node_setTag, ARGS_REQ(1));
    mrb_define_method(mrb, rclass, "cascade_color_enabled?", ruby_cocos2dx_Node_isCascadeColorEnabled, ARGS_NONE());
    mrb_define_method(mrb, rclass, "schedule_update", ruby_cocos2dx_Node_scheduleUpdate, ARGS_NONE());
    mrb_define_method(mrb, rclass, "stop_action", ruby_cocos2dx_Node_stopAction, ARGS_REQ(1));
    mrb_define_method(mrb, rclass, "get_action_manager", ruby_cocos2dx_Node_getActionManager, ARGS_NONE());
    mrb_define_class_method(mrb, rclass, "create", ruby_cocos2dx_Node_create_static, ARGS_NONE());
    ruby_cocos2dx_Node_constants_init(mrb, rclass);
    mrb_define_class_method(mrb, rclass, "INVALID_TAG", ruby_cocos2dx_constant_get, ARGS_NONE());
    ruby_cocos2dx_Node_N_enum_init(mrb, rclass);
    mrb_define_class_method(mrb, rclass, "FLAGS_TRANSFORM_DIRTY", ruby_cocos2dx_constant_get, ARGS_NONE());
    mrb_define_class_method(mrb, rclass, "FLAGS_CONTENT_SIZE_DIRTY", ruby_cocos2dx_constant_get, ARGS_NONE());
    mrb_define_class_method(mrb, rclass, "FLAGS_RENDER_AS_3D", ruby_cocos2dx_constant_get, ARGS_NONE());
    mrb_define_class_method(mrb, rclass, "FLAGS_DIRTY_MASK", ruby_cocos2dx_constant_get, ARGS_NONE());
}
mrb_value ruby_cocos2dx_Scene_render(mrb_state* mrb, mrb_value self)
{
    cocos2d::Scene* cobj = static_cast<cocos2d::Scene*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            cocos2d::Renderer* arg0;
            ok = rubyval_to_object<cocos2d::Renderer>(mrb, argv[0], "CC::Renderer", &arg0);
            if (!ok) { break; }
            cobj->render(arg0);
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::Scene#render");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Scene_getDefaultCamera(mrb_state* mrb, mrb_value self)
{
    cocos2d::Scene* cobj = static_cast<cocos2d::Scene*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            cocos2d::Camera* retval = cobj->getDefaultCamera();
            mrb_value ret;
            ret = object_to_rubyval<cocos2d::Camera>(mrb, "CC::Camera", (cocos2d::Camera*)retval, nullptr);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::Scene#getDefaultCamera");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Scene_createWithSize_static(mrb_state* mrb, mrb_value self)
{
    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            std::map<std::string, mrb_value> callbacks;
            cocos2d::Size* arg0;
            ok = rubyval_to_object<cocos2d::Size>(mrb, argv[0], "CC::Size", &arg0);
            if (!ok) { break; }

            cocos2d::Scene* retval = cocos2d::Scene::createWithSize(*arg0);
            mrb_value ret;
            RClass* rclass = mrb_class_ptr(self);
            ret = object_to_rubyval<cocos2d::Scene>(mrb, "CC::Scene", (cocos2d::Scene*)retval, rclass);
            if (callbacks.size() > 0) {
                mrb_value hash = mrb_iv_get(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"));
                if (!mrb_hash_p(hash)) {
                    hash = mrb_hash_new(mrb);
                }
                for (auto elm : callbacks) {
                    mrb_hash_set(mrb, hash, mrb_str_new_cstr(mrb, elm.first.c_str()), elm.second);
                    mrb_iv_set(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"), hash);
                }
            }
            g_rubyValue.push_back(ret);
            mrb_funcall(mrb, ret, "initialize", 0);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined static method : cocos2d::Scene#createWithSize");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Scene_create_static(mrb_state* mrb, mrb_value self)
{
    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            std::map<std::string, mrb_value> callbacks;
            cocos2d::Scene* retval = cocos2d::Scene::create();
            mrb_value ret;
            RClass* rclass = mrb_class_ptr(self);
            ret = object_to_rubyval<cocos2d::Scene>(mrb, "CC::Scene", (cocos2d::Scene*)retval, rclass);
            if (callbacks.size() > 0) {
                mrb_value hash = mrb_iv_get(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"));
                if (!mrb_hash_p(hash)) {
                    hash = mrb_hash_new(mrb);
                }
                for (auto elm : callbacks) {
                    mrb_hash_set(mrb, hash, mrb_str_new_cstr(mrb, elm.first.c_str()), elm.second);
                    mrb_iv_set(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"), hash);
                }
            }
            g_rubyValue.push_back(ret);
            mrb_funcall(mrb, ret, "initialize", 0);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined static method : cocos2d::Scene#create");

    return mrb_nil_value();
}

void ruby_register_cocos2dx_Scene(mrb_state* mrb, struct RClass* rmodule)
{
    std::string typeName = typeid(cocos2d::Scene).name();
    g_rubyType[typeName] = "CC::Scene";
    g_rubyDataType[typeName] = &ruby_cocos2dx_Ref_type;

    struct RClass* p_rmodule = mrb->object_class;
    p_rmodule = mrb_module_get_under(mrb, p_rmodule, "CC");
    struct RClass* p_rclass = mrb_class_get_under(mrb, p_rmodule, "Node");
    struct RClass *rclass = mrb_define_class_under(mrb, rmodule, "Scene", p_rclass);
    MRB_SET_INSTANCE_TT(rclass, MRB_TT_DATA);

    mrb_define_method(mrb, rclass, "render", ruby_cocos2dx_Scene_render, ARGS_REQ(1));
    mrb_define_method(mrb, rclass, "get_default_camera", ruby_cocos2dx_Scene_getDefaultCamera, ARGS_NONE());
    mrb_define_class_method(mrb, rclass, "create_with_size", ruby_cocos2dx_Scene_createWithSize_static, ARGS_REQ(1));
    mrb_define_class_method(mrb, rclass, "create", ruby_cocos2dx_Scene_create_static, ARGS_NONE());
}
void ruby_cocos2dx_global_ResolutionPolicy_enum_init(mrb_state* mrb)
{
    do {
        mrb_value ev = mrb_fixnum_value((mrb_int)ResolutionPolicy::EXACT_FIT);
        mrb_gv_set(mrb, mrb_intern_cstr(mrb, "EXACT_FIT"), ev);
    } while (0);

    do {
        mrb_value ev = mrb_fixnum_value((mrb_int)ResolutionPolicy::NO_BORDER);
        mrb_gv_set(mrb, mrb_intern_cstr(mrb, "NO_BORDER"), ev);
    } while (0);

    do {
        mrb_value ev = mrb_fixnum_value((mrb_int)ResolutionPolicy::SHOW_ALL);
        mrb_gv_set(mrb, mrb_intern_cstr(mrb, "SHOW_ALL"), ev);
    } while (0);

    do {
        mrb_value ev = mrb_fixnum_value((mrb_int)ResolutionPolicy::FIXED_HEIGHT);
        mrb_gv_set(mrb, mrb_intern_cstr(mrb, "FIXED_HEIGHT"), ev);
    } while (0);

    do {
        mrb_value ev = mrb_fixnum_value((mrb_int)ResolutionPolicy::FIXED_WIDTH);
        mrb_gv_set(mrb, mrb_intern_cstr(mrb, "FIXED_WIDTH"), ev);
    } while (0);

    do {
        mrb_value ev = mrb_fixnum_value((mrb_int)ResolutionPolicy::UNKNOWN);
        mrb_gv_set(mrb, mrb_intern_cstr(mrb, "UNKNOWN"), ev);
    } while (0);

}
mrb_value ruby_cocos2dx_GLView_setFrameSize(mrb_state* mrb, mrb_value self)
{
    cocos2d::GLView* cobj = static_cast<cocos2d::GLView*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 2) {
            double arg0;
            ok = rubyval_to_number(mrb, argv[0], (double*)&arg0, "CC::GLView.setFrameSize");
            if (!ok) { break; }
            double arg1;
            ok = rubyval_to_number(mrb, argv[1], (double*)&arg1, "CC::GLView.setFrameSize");
            if (!ok) { break; }
            cobj->setFrameSize(arg0, arg1);
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::GLView#setFrameSize");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_GLView_getViewPortRect(mrb_state* mrb, mrb_value self)
{
    cocos2d::GLView* cobj = static_cast<cocos2d::GLView*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            cocos2d::Rect retval = cobj->getViewPortRect();
            cocos2d::Rect* retval_ptr = new cocos2d::Rect(retval);
            mrb_value ret;
            ret = object_to_rubyval<cocos2d::Rect>(mrb, "CC::Rect", (cocos2d::Rect*)retval_ptr, nullptr);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::GLView#getViewPortRect");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_GLView_setContentScaleFactor(mrb_state* mrb, mrb_value self)
{
    cocos2d::GLView* cobj = static_cast<cocos2d::GLView*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            double arg0;
            ok = rubyval_to_number(mrb, argv[0], (double*)&arg0, "CC::GLView.setContentScaleFactor");
            if (!ok) { break; }
            bool retval = cobj->setContentScaleFactor(arg0);
            mrb_value ret;
            ret = mrb_bool_value((mrb_bool)retval);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::GLView#setContentScaleFactor");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_GLView_getContentScaleFactor(mrb_state* mrb, mrb_value self)
{
    cocos2d::GLView* cobj = static_cast<cocos2d::GLView*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            double retval = cobj->getContentScaleFactor();
            mrb_value ret;
            ret = mrb_float_value(mrb, (mrb_float)retval);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::GLView#getContentScaleFactor");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_GLView_setIMEKeyboardState(mrb_state* mrb, mrb_value self)
{
    cocos2d::GLView* cobj = static_cast<cocos2d::GLView*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            bool arg0;
            ok = rubyval_to_boolean(mrb, argv[0], &arg0, "CC::GLView.setIMEKeyboardState");
            if (!ok) { break; }
            cobj->setIMEKeyboardState(arg0);
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::GLView#setIMEKeyboardState");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_GLView_setScissorInPoints(mrb_state* mrb, mrb_value self)
{
    cocos2d::GLView* cobj = static_cast<cocos2d::GLView*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 4) {
            double arg0;
            ok = rubyval_to_number(mrb, argv[0], (double*)&arg0, "CC::GLView.setScissorInPoints");
            if (!ok) { break; }
            double arg1;
            ok = rubyval_to_number(mrb, argv[1], (double*)&arg1, "CC::GLView.setScissorInPoints");
            if (!ok) { break; }
            double arg2;
            ok = rubyval_to_number(mrb, argv[2], (double*)&arg2, "CC::GLView.setScissorInPoints");
            if (!ok) { break; }
            double arg3;
            ok = rubyval_to_number(mrb, argv[3], (double*)&arg3, "CC::GLView.setScissorInPoints");
            if (!ok) { break; }
            cobj->setScissorInPoints(arg0, arg1, arg2, arg3);
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::GLView#setScissorInPoints");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_GLView_getViewName(mrb_state* mrb, mrb_value self)
{
    cocos2d::GLView* cobj = static_cast<cocos2d::GLView*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            std::string retval = cobj->getViewName();
            mrb_value ret;
            ret = mrb_str_new_cstr(mrb, retval.c_str());
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::GLView#getViewName");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_GLView_isOpenGLReady(mrb_state* mrb, mrb_value self)
{
    cocos2d::GLView* cobj = static_cast<cocos2d::GLView*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            bool retval = cobj->isOpenGLReady();
            mrb_value ret;
            ret = mrb_bool_value((mrb_bool)retval);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::GLView#isOpenGLReady");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_GLView_end(mrb_state* mrb, mrb_value self)
{
    cocos2d::GLView* cobj = static_cast<cocos2d::GLView*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            cobj->end();
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::GLView#end");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_GLView_getScaleY(mrb_state* mrb, mrb_value self)
{
    cocos2d::GLView* cobj = static_cast<cocos2d::GLView*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            double retval = cobj->getScaleY();
            mrb_value ret;
            ret = mrb_float_value(mrb, (mrb_float)retval);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::GLView#getScaleY");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_GLView_getScaleX(mrb_state* mrb, mrb_value self)
{
    cocos2d::GLView* cobj = static_cast<cocos2d::GLView*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            double retval = cobj->getScaleX();
            mrb_value ret;
            ret = mrb_float_value(mrb, (mrb_float)retval);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::GLView#getScaleX");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_GLView_getVisibleOrigin(mrb_state* mrb, mrb_value self)
{
    cocos2d::GLView* cobj = static_cast<cocos2d::GLView*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            cocos2d::Vec2 retval = cobj->getVisibleOrigin();
            cocos2d::Vec2* retval_ptr = new cocos2d::Vec2(retval);
            mrb_value ret;
            ret = object_to_rubyval<cocos2d::Vec2>(mrb, "CC::Vec2", (cocos2d::Vec2*)retval_ptr, nullptr);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::GLView#getVisibleOrigin");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_GLView_getFrameSize(mrb_state* mrb, mrb_value self)
{
    cocos2d::GLView* cobj = static_cast<cocos2d::GLView*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            cocos2d::Size retval = cobj->getFrameSize();
            cocos2d::Size* retval_ptr = new cocos2d::Size(retval);
            mrb_value ret;
            ret = object_to_rubyval<cocos2d::Size>(mrb, "CC::Size", (cocos2d::Size*)retval_ptr, nullptr);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::GLView#getFrameSize");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_GLView_setFrameZoomFactor(mrb_state* mrb, mrb_value self)
{
    cocos2d::GLView* cobj = static_cast<cocos2d::GLView*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            double arg0;
            ok = rubyval_to_number(mrb, argv[0], (double*)&arg0, "CC::GLView.setFrameZoomFactor");
            if (!ok) { break; }
            cobj->setFrameZoomFactor(arg0);
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::GLView#setFrameZoomFactor");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_GLView_getFrameZoomFactor(mrb_state* mrb, mrb_value self)
{
    cocos2d::GLView* cobj = static_cast<cocos2d::GLView*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            double retval = cobj->getFrameZoomFactor();
            mrb_value ret;
            ret = mrb_float_value(mrb, (mrb_float)retval);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::GLView#getFrameZoomFactor");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_GLView_getDesignResolutionSize(mrb_state* mrb, mrb_value self)
{
    cocos2d::GLView* cobj = static_cast<cocos2d::GLView*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            cocos2d::Size retval = cobj->getDesignResolutionSize();
            cocos2d::Size* retval_ptr = new cocos2d::Size(retval);
            mrb_value ret;
            ret = object_to_rubyval<cocos2d::Size>(mrb, "CC::Size", (cocos2d::Size*)retval_ptr, nullptr);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::GLView#getDesignResolutionSize");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_GLView_windowShouldClose(mrb_state* mrb, mrb_value self)
{
    cocos2d::GLView* cobj = static_cast<cocos2d::GLView*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            bool retval = cobj->windowShouldClose();
            mrb_value ret;
            ret = mrb_bool_value((mrb_bool)retval);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::GLView#windowShouldClose");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_GLView_swapBuffers(mrb_state* mrb, mrb_value self)
{
    cocos2d::GLView* cobj = static_cast<cocos2d::GLView*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            cobj->swapBuffers();
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::GLView#swapBuffers");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_GLView_setDesignResolutionSize(mrb_state* mrb, mrb_value self)
{
    cocos2d::GLView* cobj = static_cast<cocos2d::GLView*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 3) {
            double arg0;
            ok = rubyval_to_number(mrb, argv[0], (double*)&arg0, "CC::GLView.setDesignResolutionSize");
            if (!ok) { break; }
            double arg1;
            ok = rubyval_to_number(mrb, argv[1], (double*)&arg1, "CC::GLView.setDesignResolutionSize");
            if (!ok) { break; }
            ResolutionPolicy arg2;
            ok = rubyval_to_int32(mrb, argv[2], (int*)&arg2, "CC::GLView.setDesignResolutionSize");
            if (!ok) { break; }
            cobj->setDesignResolutionSize(arg0, arg1, arg2);
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::GLView#setDesignResolutionSize");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_GLView_getResolutionPolicy(mrb_state* mrb, mrb_value self)
{
    cocos2d::GLView* cobj = static_cast<cocos2d::GLView*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            int retval = (int)cobj->getResolutionPolicy();
            mrb_value ret;
            ret = mrb_fixnum_value((mrb_int)retval);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::GLView#getResolutionPolicy");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_GLView_isRetinaDisplay(mrb_state* mrb, mrb_value self)
{
    cocos2d::GLView* cobj = static_cast<cocos2d::GLView*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            bool retval = cobj->isRetinaDisplay();
            mrb_value ret;
            ret = mrb_bool_value((mrb_bool)retval);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::GLView#isRetinaDisplay");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_GLView_setViewPortInPoints(mrb_state* mrb, mrb_value self)
{
    cocos2d::GLView* cobj = static_cast<cocos2d::GLView*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 4) {
            double arg0;
            ok = rubyval_to_number(mrb, argv[0], (double*)&arg0, "CC::GLView.setViewPortInPoints");
            if (!ok) { break; }
            double arg1;
            ok = rubyval_to_number(mrb, argv[1], (double*)&arg1, "CC::GLView.setViewPortInPoints");
            if (!ok) { break; }
            double arg2;
            ok = rubyval_to_number(mrb, argv[2], (double*)&arg2, "CC::GLView.setViewPortInPoints");
            if (!ok) { break; }
            double arg3;
            ok = rubyval_to_number(mrb, argv[3], (double*)&arg3, "CC::GLView.setViewPortInPoints");
            if (!ok) { break; }
            cobj->setViewPortInPoints(arg0, arg1, arg2, arg3);
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::GLView#setViewPortInPoints");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_GLView_getScissorRect(mrb_state* mrb, mrb_value self)
{
    cocos2d::GLView* cobj = static_cast<cocos2d::GLView*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            cocos2d::Rect retval = cobj->getScissorRect();
            cocos2d::Rect* retval_ptr = new cocos2d::Rect(retval);
            mrb_value ret;
            ret = object_to_rubyval<cocos2d::Rect>(mrb, "CC::Rect", (cocos2d::Rect*)retval_ptr, nullptr);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::GLView#getScissorRect");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_GLView_getRetinaFactor(mrb_state* mrb, mrb_value self)
{
    cocos2d::GLView* cobj = static_cast<cocos2d::GLView*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            int retval = cobj->getRetinaFactor();
            mrb_value ret;
            ret = mrb_fixnum_value((mrb_int)retval);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::GLView#getRetinaFactor");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_GLView_setViewName(mrb_state* mrb, mrb_value self)
{
    cocos2d::GLView* cobj = static_cast<cocos2d::GLView*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            std::string arg0;
            ok = rubyval_to_std_string(mrb, argv[0], &arg0, "CC::GLView.setViewName");
            if (!ok) { break; }
            cobj->setViewName(arg0);
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::GLView#setViewName");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_GLView_getVisibleRect(mrb_state* mrb, mrb_value self)
{
    cocos2d::GLView* cobj = static_cast<cocos2d::GLView*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            cocos2d::Rect retval = cobj->getVisibleRect();
            cocos2d::Rect* retval_ptr = new cocos2d::Rect(retval);
            mrb_value ret;
            ret = object_to_rubyval<cocos2d::Rect>(mrb, "CC::Rect", (cocos2d::Rect*)retval_ptr, nullptr);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::GLView#getVisibleRect");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_GLView_getVisibleSize(mrb_state* mrb, mrb_value self)
{
    cocos2d::GLView* cobj = static_cast<cocos2d::GLView*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            cocos2d::Size retval = cobj->getVisibleSize();
            cocos2d::Size* retval_ptr = new cocos2d::Size(retval);
            mrb_value ret;
            ret = object_to_rubyval<cocos2d::Size>(mrb, "CC::Size", (cocos2d::Size*)retval_ptr, nullptr);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::GLView#getVisibleSize");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_GLView_isScissorEnabled(mrb_state* mrb, mrb_value self)
{
    cocos2d::GLView* cobj = static_cast<cocos2d::GLView*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            bool retval = cobj->isScissorEnabled();
            mrb_value ret;
            ret = mrb_bool_value((mrb_bool)retval);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::GLView#isScissorEnabled");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_GLView_pollEvents(mrb_state* mrb, mrb_value self)
{
    cocos2d::GLView* cobj = static_cast<cocos2d::GLView*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            cobj->pollEvents();
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::GLView#pollEvents");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_GLView_setGLContextAttrs_static(mrb_state* mrb, mrb_value self)
{
    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            GLContextAttrs* arg0;
            ok = rubyval_to_object<GLContextAttrs>(mrb, argv[0], "GLContextAttrs", &arg0);
            if (!ok) { break; }

            cocos2d::GLView::setGLContextAttrs(*arg0);
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined static method : cocos2d::GLView#setGLContextAttrs");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_GLView_getGLContextAttrs_static(mrb_state* mrb, mrb_value self)
{
    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            GLContextAttrs retval = cocos2d::GLView::getGLContextAttrs();
            GLContextAttrs* retval_ptr = new GLContextAttrs(retval);
            mrb_value ret;
            ret = object_to_rubyval<GLContextAttrs>(mrb, "GLContextAttrs", (GLContextAttrs*)retval_ptr, nullptr);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined static method : cocos2d::GLView#getGLContextAttrs");

    return mrb_nil_value();
}

void ruby_register_cocos2dx_GLView(mrb_state* mrb, struct RClass* rmodule)
{
    std::string typeName = typeid(cocos2d::GLView).name();
    g_rubyType[typeName] = "CC::GLView";
    g_rubyDataType[typeName] = &ruby_cocos2dx_Ref_type;

    struct RClass* p_rmodule = mrb->object_class;
    p_rmodule = mrb_module_get_under(mrb, p_rmodule, "CC");
    struct RClass* p_rclass = mrb_class_get_under(mrb, p_rmodule, "Ref");
    struct RClass *rclass = mrb_define_class_under(mrb, rmodule, "GLView", p_rclass);
    MRB_SET_INSTANCE_TT(rclass, MRB_TT_DATA);

    mrb_define_method(mrb, rclass, "set_frame_size", ruby_cocos2dx_GLView_setFrameSize, ARGS_REQ(2));
    mrb_define_method(mrb, rclass, "get_view_port_rect", ruby_cocos2dx_GLView_getViewPortRect, ARGS_NONE());
    mrb_define_method(mrb, rclass, "set_content_scale_factor", ruby_cocos2dx_GLView_setContentScaleFactor, ARGS_REQ(1));
    mrb_define_method(mrb, rclass, "get_content_scale_factor", ruby_cocos2dx_GLView_getContentScaleFactor, ARGS_NONE());
    mrb_define_method(mrb, rclass, "set_imekeyboard_state", ruby_cocos2dx_GLView_setIMEKeyboardState, ARGS_REQ(1));
    mrb_define_method(mrb, rclass, "set_scissor_in_points", ruby_cocos2dx_GLView_setScissorInPoints, ARGS_REQ(4));
    mrb_define_method(mrb, rclass, "get_view_name", ruby_cocos2dx_GLView_getViewName, ARGS_NONE());
    mrb_define_method(mrb, rclass, "open_glready?", ruby_cocos2dx_GLView_isOpenGLReady, ARGS_NONE());
    mrb_define_method(mrb, rclass, "end", ruby_cocos2dx_GLView_end, ARGS_NONE());
    mrb_define_method(mrb, rclass, "get_scale_y", ruby_cocos2dx_GLView_getScaleY, ARGS_NONE());
    mrb_define_method(mrb, rclass, "get_scale_x", ruby_cocos2dx_GLView_getScaleX, ARGS_NONE());
    mrb_define_method(mrb, rclass, "get_visible_origin", ruby_cocos2dx_GLView_getVisibleOrigin, ARGS_NONE());
    mrb_define_method(mrb, rclass, "get_frame_size", ruby_cocos2dx_GLView_getFrameSize, ARGS_NONE());
    mrb_define_method(mrb, rclass, "set_frame_zoom_factor", ruby_cocos2dx_GLView_setFrameZoomFactor, ARGS_REQ(1));
    mrb_define_method(mrb, rclass, "get_frame_zoom_factor", ruby_cocos2dx_GLView_getFrameZoomFactor, ARGS_NONE());
    mrb_define_method(mrb, rclass, "get_design_resolution_size", ruby_cocos2dx_GLView_getDesignResolutionSize, ARGS_NONE());
    mrb_define_method(mrb, rclass, "window_should_close", ruby_cocos2dx_GLView_windowShouldClose, ARGS_NONE());
    mrb_define_method(mrb, rclass, "swap_buffers", ruby_cocos2dx_GLView_swapBuffers, ARGS_NONE());
    mrb_define_method(mrb, rclass, "set_design_resolution_size", ruby_cocos2dx_GLView_setDesignResolutionSize, ARGS_REQ(3));
    mrb_define_method(mrb, rclass, "get_resolution_policy", ruby_cocos2dx_GLView_getResolutionPolicy, ARGS_NONE());
    mrb_define_method(mrb, rclass, "retina_display?", ruby_cocos2dx_GLView_isRetinaDisplay, ARGS_NONE());
    mrb_define_method(mrb, rclass, "set_view_port_in_points", ruby_cocos2dx_GLView_setViewPortInPoints, ARGS_REQ(4));
    mrb_define_method(mrb, rclass, "get_scissor_rect", ruby_cocos2dx_GLView_getScissorRect, ARGS_NONE());
    mrb_define_method(mrb, rclass, "get_retina_factor", ruby_cocos2dx_GLView_getRetinaFactor, ARGS_NONE());
    mrb_define_method(mrb, rclass, "set_view_name", ruby_cocos2dx_GLView_setViewName, ARGS_REQ(1));
    mrb_define_method(mrb, rclass, "get_visible_rect", ruby_cocos2dx_GLView_getVisibleRect, ARGS_NONE());
    mrb_define_method(mrb, rclass, "get_visible_size", ruby_cocos2dx_GLView_getVisibleSize, ARGS_NONE());
    mrb_define_method(mrb, rclass, "scissor_enabled?", ruby_cocos2dx_GLView_isScissorEnabled, ARGS_NONE());
    mrb_define_method(mrb, rclass, "poll_events", ruby_cocos2dx_GLView_pollEvents, ARGS_NONE());
    mrb_define_class_method(mrb, rclass, "set_glcontext_attrs", ruby_cocos2dx_GLView_setGLContextAttrs_static, ARGS_REQ(1));
    mrb_define_class_method(mrb, rclass, "get_glcontext_attrs", ruby_cocos2dx_GLView_getGLContextAttrs_static, ARGS_NONE());
}
void ruby_cocos2dx_global_MATRIX_STACK_TYPE_enum_init(mrb_state* mrb)
{
    do {
        mrb_value ev = mrb_fixnum_value((mrb_int)MATRIX_STACK_TYPE::MATRIX_STACK_MODELVIEW);
        mrb_gv_set(mrb, mrb_intern_cstr(mrb, "MATRIX_STACK_MODELVIEW"), ev);
    } while (0);

    do {
        mrb_value ev = mrb_fixnum_value((mrb_int)MATRIX_STACK_TYPE::MATRIX_STACK_PROJECTION);
        mrb_gv_set(mrb, mrb_intern_cstr(mrb, "MATRIX_STACK_PROJECTION"), ev);
    } while (0);

    do {
        mrb_value ev = mrb_fixnum_value((mrb_int)MATRIX_STACK_TYPE::MATRIX_STACK_TEXTURE);
        mrb_gv_set(mrb, mrb_intern_cstr(mrb, "MATRIX_STACK_TEXTURE"), ev);
    } while (0);

}
mrb_value ruby_cocos2dx_Director_pause(mrb_state* mrb, mrb_value self)
{
    cocos2d::Director* cobj = static_cast<cocos2d::Director*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            cobj->pause();
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::Director#pause");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Director_end(mrb_state* mrb, mrb_value self)
{
    cocos2d::Director* cobj = static_cast<cocos2d::Director*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            cobj->end();
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::Director#end");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Director_setEventDispatcher(mrb_state* mrb, mrb_value self)
{
    cocos2d::Director* cobj = static_cast<cocos2d::Director*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            cocos2d::EventDispatcher* arg0;
            ok = rubyval_to_object<cocos2d::EventDispatcher>(mrb, argv[0], "CC::EventDispatcher", &arg0);
            if (!ok) { break; }
            cobj->setEventDispatcher(arg0);
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::Director#setEventDispatcher");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Director_setContentScaleFactor(mrb_state* mrb, mrb_value self)
{
    cocos2d::Director* cobj = static_cast<cocos2d::Director*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            double arg0;
            ok = rubyval_to_number(mrb, argv[0], (double*)&arg0, "CC::Director.setContentScaleFactor");
            if (!ok) { break; }
            cobj->setContentScaleFactor(arg0);
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::Director#setContentScaleFactor");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Director_getContentScaleFactor(mrb_state* mrb, mrb_value self)
{
    cocos2d::Director* cobj = static_cast<cocos2d::Director*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            double retval = cobj->getContentScaleFactor();
            mrb_value ret;
            ret = mrb_float_value(mrb, (mrb_float)retval);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::Director#getContentScaleFactor");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Director_getWinSizeInPixels(mrb_state* mrb, mrb_value self)
{
    cocos2d::Director* cobj = static_cast<cocos2d::Director*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            cocos2d::Size retval = cobj->getWinSizeInPixels();
            cocos2d::Size* retval_ptr = new cocos2d::Size(retval);
            mrb_value ret;
            ret = object_to_rubyval<cocos2d::Size>(mrb, "CC::Size", (cocos2d::Size*)retval_ptr, nullptr);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::Director#getWinSizeInPixels");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Director_getDeltaTime(mrb_state* mrb, mrb_value self)
{
    cocos2d::Director* cobj = static_cast<cocos2d::Director*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            double retval = cobj->getDeltaTime();
            mrb_value ret;
            ret = mrb_float_value(mrb, (mrb_float)retval);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::Director#getDeltaTime");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Director_setGLDefaultValues(mrb_state* mrb, mrb_value self)
{
    cocos2d::Director* cobj = static_cast<cocos2d::Director*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            cobj->setGLDefaultValues();
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::Director#setGLDefaultValues");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Director_setActionManager(mrb_state* mrb, mrb_value self)
{
    cocos2d::Director* cobj = static_cast<cocos2d::Director*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            cocos2d::ActionManager* arg0;
            ok = rubyval_to_object<cocos2d::ActionManager>(mrb, argv[0], "CC::ActionManager", &arg0);
            if (!ok) { break; }
            cobj->setActionManager(arg0);
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::Director#setActionManager");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Director_setAlphaBlending(mrb_state* mrb, mrb_value self)
{
    cocos2d::Director* cobj = static_cast<cocos2d::Director*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            bool arg0;
            ok = rubyval_to_boolean(mrb, argv[0], &arg0, "CC::Director.setAlphaBlending");
            if (!ok) { break; }
            cobj->setAlphaBlending(arg0);
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::Director#setAlphaBlending");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Director_popToRootScene(mrb_state* mrb, mrb_value self)
{
    cocos2d::Director* cobj = static_cast<cocos2d::Director*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            cobj->popToRootScene();
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::Director#popToRootScene");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Director_loadMatrix(mrb_state* mrb, mrb_value self)
{
    cocos2d::Director* cobj = static_cast<cocos2d::Director*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 2) {
            cocos2d::MATRIX_STACK_TYPE arg0;
            ok = rubyval_to_int32(mrb, argv[0], (int*)&arg0, "CC::Director.loadMatrix");
            if (!ok) { break; }
            cocos2d::Mat4* arg1;
            ok = rubyval_to_object<cocos2d::Mat4>(mrb, argv[1], "CC::Mat4", &arg1);
            if (!ok) { break; }
            cobj->loadMatrix(arg0, *arg1);
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::Director#loadMatrix");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Director_getNotificationNode(mrb_state* mrb, mrb_value self)
{
    cocos2d::Director* cobj = static_cast<cocos2d::Director*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            cocos2d::Node* retval = cobj->getNotificationNode();
            mrb_value ret;
            ret = object_to_rubyval<cocos2d::Node>(mrb, "CC::Node", (cocos2d::Node*)retval, nullptr);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::Director#getNotificationNode");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Director_getWinSize(mrb_state* mrb, mrb_value self)
{
    cocos2d::Director* cobj = static_cast<cocos2d::Director*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            cocos2d::Size retval = cobj->getWinSize();
            cocos2d::Size* retval_ptr = new cocos2d::Size(retval);
            mrb_value ret;
            ret = object_to_rubyval<cocos2d::Size>(mrb, "CC::Size", (cocos2d::Size*)retval_ptr, nullptr);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::Director#getWinSize");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Director_getTextureCache(mrb_state* mrb, mrb_value self)
{
    cocos2d::Director* cobj = static_cast<cocos2d::Director*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            cocos2d::TextureCache* retval = cobj->getTextureCache();
            mrb_value ret;
            ret = object_to_rubyval<cocos2d::TextureCache>(mrb, "CC::TextureCache", (cocos2d::TextureCache*)retval, nullptr);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::Director#getTextureCache");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Director_isSendCleanupToScene(mrb_state* mrb, mrb_value self)
{
    cocos2d::Director* cobj = static_cast<cocos2d::Director*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            bool retval = cobj->isSendCleanupToScene();
            mrb_value ret;
            ret = mrb_bool_value((mrb_bool)retval);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::Director#isSendCleanupToScene");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Director_getVisibleOrigin(mrb_state* mrb, mrb_value self)
{
    cocos2d::Director* cobj = static_cast<cocos2d::Director*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            cocos2d::Vec2 retval = cobj->getVisibleOrigin();
            cocos2d::Vec2* retval_ptr = new cocos2d::Vec2(retval);
            mrb_value ret;
            ret = object_to_rubyval<cocos2d::Vec2>(mrb, "CC::Vec2", (cocos2d::Vec2*)retval_ptr, nullptr);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::Director#getVisibleOrigin");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Director_mainLoop(mrb_state* mrb, mrb_value self)
{
    cocos2d::Director* cobj = static_cast<cocos2d::Director*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            cobj->mainLoop();
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::Director#mainLoop");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Director_setDepthTest(mrb_state* mrb, mrb_value self)
{
    cocos2d::Director* cobj = static_cast<cocos2d::Director*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            bool arg0;
            ok = rubyval_to_boolean(mrb, argv[0], &arg0, "CC::Director.setDepthTest");
            if (!ok) { break; }
            cobj->setDepthTest(arg0);
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::Director#setDepthTest");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Director_getFrameRate(mrb_state* mrb, mrb_value self)
{
    cocos2d::Director* cobj = static_cast<cocos2d::Director*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            double retval = cobj->getFrameRate();
            mrb_value ret;
            ret = mrb_float_value(mrb, (mrb_float)retval);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::Director#getFrameRate");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Director_getSecondsPerFrame(mrb_state* mrb, mrb_value self)
{
    cocos2d::Director* cobj = static_cast<cocos2d::Director*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            double retval = cobj->getSecondsPerFrame();
            mrb_value ret;
            ret = mrb_float_value(mrb, (mrb_float)retval);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::Director#getSecondsPerFrame");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Director_resetMatrixStack(mrb_state* mrb, mrb_value self)
{
    cocos2d::Director* cobj = static_cast<cocos2d::Director*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            cobj->resetMatrixStack();
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::Director#resetMatrixStack");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Director_convertToUI(mrb_state* mrb, mrb_value self)
{
    cocos2d::Director* cobj = static_cast<cocos2d::Director*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            cocos2d::Vec2* arg0;
            ok = rubyval_to_object<cocos2d::Vec2>(mrb, argv[0], "CC::Vec2", &arg0);
            if (!ok) { break; }
            cocos2d::Vec2 retval = cobj->convertToUI(*arg0);
            cocos2d::Vec2* retval_ptr = new cocos2d::Vec2(retval);
            mrb_value ret;
            ret = object_to_rubyval<cocos2d::Vec2>(mrb, "CC::Vec2", (cocos2d::Vec2*)retval_ptr, nullptr);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::Director#convertToUI");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Director_pushMatrix(mrb_state* mrb, mrb_value self)
{
    cocos2d::Director* cobj = static_cast<cocos2d::Director*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            cocos2d::MATRIX_STACK_TYPE arg0;
            ok = rubyval_to_int32(mrb, argv[0], (int*)&arg0, "CC::Director.pushMatrix");
            if (!ok) { break; }
            cobj->pushMatrix(arg0);
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::Director#pushMatrix");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Director_setDefaultValues(mrb_state* mrb, mrb_value self)
{
    cocos2d::Director* cobj = static_cast<cocos2d::Director*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            cobj->setDefaultValues();
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::Director#setDefaultValues");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Director_init(mrb_state* mrb, mrb_value self)
{
    cocos2d::Director* cobj = static_cast<cocos2d::Director*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            bool retval = cobj->init();
            mrb_value ret;
            ret = mrb_bool_value((mrb_bool)retval);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::Director#init");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Director_setScheduler(mrb_state* mrb, mrb_value self)
{
    cocos2d::Director* cobj = static_cast<cocos2d::Director*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            cocos2d::Scheduler* arg0;
            ok = rubyval_to_object<cocos2d::Scheduler>(mrb, argv[0], "CC::Scheduler", &arg0);
            if (!ok) { break; }
            cobj->setScheduler(arg0);
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::Director#setScheduler");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Director_getMatrix(mrb_state* mrb, mrb_value self)
{
    cocos2d::Director* cobj = static_cast<cocos2d::Director*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            cocos2d::MATRIX_STACK_TYPE arg0;
            ok = rubyval_to_int32(mrb, argv[0], (int*)&arg0, "CC::Director.getMatrix");
            if (!ok) { break; }
            cocos2d::Mat4 retval = cobj->getMatrix(arg0);
            cocos2d::Mat4* retval_ptr = new cocos2d::Mat4(retval);
            mrb_value ret;
            ret = object_to_rubyval<cocos2d::Mat4>(mrb, "CC::Mat4", (cocos2d::Mat4*)retval_ptr, nullptr);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::Director#getMatrix");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Director_startAnimation(mrb_state* mrb, mrb_value self)
{
    cocos2d::Director* cobj = static_cast<cocos2d::Director*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            cobj->startAnimation();
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::Director#startAnimation");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Director_getOpenGLView(mrb_state* mrb, mrb_value self)
{
    cocos2d::Director* cobj = static_cast<cocos2d::Director*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            cocos2d::GLView* retval = cobj->getOpenGLView();
            mrb_value ret;
            ret = object_to_rubyval<cocos2d::GLView>(mrb, "CC::GLView", (cocos2d::GLView*)retval, nullptr);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::Director#getOpenGLView");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Director_getRunningScene(mrb_state* mrb, mrb_value self)
{
    cocos2d::Director* cobj = static_cast<cocos2d::Director*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            cocos2d::Scene* retval = cobj->getRunningScene();
            mrb_value ret;
            ret = object_to_rubyval<cocos2d::Scene>(mrb, "CC::Scene", (cocos2d::Scene*)retval, nullptr);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::Director#getRunningScene");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Director_setViewport(mrb_state* mrb, mrb_value self)
{
    cocos2d::Director* cobj = static_cast<cocos2d::Director*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            cobj->setViewport();
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::Director#setViewport");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Director_stopAnimation(mrb_state* mrb, mrb_value self)
{
    cocos2d::Director* cobj = static_cast<cocos2d::Director*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            cobj->stopAnimation();
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::Director#stopAnimation");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Director_popToSceneStackLevel(mrb_state* mrb, mrb_value self)
{
    cocos2d::Director* cobj = static_cast<cocos2d::Director*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            int arg0;
            ok = rubyval_to_int32(mrb, argv[0], (int*)&arg0, "CC::Director.popToSceneStackLevel");
            if (!ok) { break; }
            cobj->popToSceneStackLevel(arg0);
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::Director#popToSceneStackLevel");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Director_resume(mrb_state* mrb, mrb_value self)
{
    cocos2d::Director* cobj = static_cast<cocos2d::Director*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            cobj->resume();
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::Director#resume");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Director_isNextDeltaTimeZero(mrb_state* mrb, mrb_value self)
{
    cocos2d::Director* cobj = static_cast<cocos2d::Director*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            bool retval = cobj->isNextDeltaTimeZero();
            mrb_value ret;
            ret = mrb_bool_value((mrb_bool)retval);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::Director#isNextDeltaTimeZero");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Director_setClearColor(mrb_state* mrb, mrb_value self)
{
    cocos2d::Director* cobj = static_cast<cocos2d::Director*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            cocos2d::Color4F* arg0;
            ok = rubyval_to_object<cocos2d::Color4F>(mrb, argv[0], "CC::Color4F", &arg0);
            if (!ok) { break; }
            cobj->setClearColor(*arg0);
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::Director#setClearColor");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Director_setOpenGLView(mrb_state* mrb, mrb_value self)
{
    cocos2d::Director* cobj = static_cast<cocos2d::Director*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            cocos2d::GLView* arg0;
            ok = rubyval_to_object<cocos2d::GLView>(mrb, argv[0], "CC::GLView", &arg0);
            if (!ok) { break; }
            cobj->setOpenGLView(arg0);
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::Director#setOpenGLView");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Director_convertToGL(mrb_state* mrb, mrb_value self)
{
    cocos2d::Director* cobj = static_cast<cocos2d::Director*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            cocos2d::Vec2* arg0;
            ok = rubyval_to_object<cocos2d::Vec2>(mrb, argv[0], "CC::Vec2", &arg0);
            if (!ok) { break; }
            cocos2d::Vec2 retval = cobj->convertToGL(*arg0);
            cocos2d::Vec2* retval_ptr = new cocos2d::Vec2(retval);
            mrb_value ret;
            ret = object_to_rubyval<cocos2d::Vec2>(mrb, "CC::Vec2", (cocos2d::Vec2*)retval_ptr, nullptr);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::Director#convertToGL");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Director_purgeCachedData(mrb_state* mrb, mrb_value self)
{
    cocos2d::Director* cobj = static_cast<cocos2d::Director*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            cobj->purgeCachedData();
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::Director#purgeCachedData");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Director_getTotalFrames(mrb_state* mrb, mrb_value self)
{
    cocos2d::Director* cobj = static_cast<cocos2d::Director*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            unsigned int retval = cobj->getTotalFrames();
            mrb_value ret;
            ret = mrb_fixnum_value((mrb_int)retval);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::Director#getTotalFrames");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Director_runWithScene(mrb_state* mrb, mrb_value self)
{
    cocos2d::Director* cobj = static_cast<cocos2d::Director*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            cocos2d::Scene* arg0;
            ok = rubyval_to_object<cocos2d::Scene>(mrb, argv[0], "CC::Scene", &arg0);
            if (!ok) { break; }
            cobj->runWithScene(arg0);
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::Director#runWithScene");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Director_setNotificationNode(mrb_state* mrb, mrb_value self)
{
    cocos2d::Director* cobj = static_cast<cocos2d::Director*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            cocos2d::Node* arg0;
            ok = rubyval_to_object<cocos2d::Node>(mrb, argv[0], "CC::Node", &arg0);
            if (!ok) { break; }
            cobj->setNotificationNode(arg0);
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::Director#setNotificationNode");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Director_drawScene(mrb_state* mrb, mrb_value self)
{
    cocos2d::Director* cobj = static_cast<cocos2d::Director*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            cobj->drawScene();
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::Director#drawScene");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Director_restart(mrb_state* mrb, mrb_value self)
{
    cocos2d::Director* cobj = static_cast<cocos2d::Director*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            cobj->restart();
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::Director#restart");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Director_popScene(mrb_state* mrb, mrb_value self)
{
    cocos2d::Director* cobj = static_cast<cocos2d::Director*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            cobj->popScene();
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::Director#popScene");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Director_loadIdentityMatrix(mrb_state* mrb, mrb_value self)
{
    cocos2d::Director* cobj = static_cast<cocos2d::Director*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            cocos2d::MATRIX_STACK_TYPE arg0;
            ok = rubyval_to_int32(mrb, argv[0], (int*)&arg0, "CC::Director.loadIdentityMatrix");
            if (!ok) { break; }
            cobj->loadIdentityMatrix(arg0);
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::Director#loadIdentityMatrix");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Director_isDisplayStats(mrb_state* mrb, mrb_value self)
{
    cocos2d::Director* cobj = static_cast<cocos2d::Director*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            bool retval = cobj->isDisplayStats();
            mrb_value ret;
            ret = mrb_bool_value((mrb_bool)retval);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::Director#isDisplayStats");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Director_setProjection(mrb_state* mrb, mrb_value self)
{
    cocos2d::Director* cobj = static_cast<cocos2d::Director*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            cocos2d::Director::Projection arg0;
            ok = rubyval_to_int32(mrb, argv[0], (int*)&arg0, "CC::Director.setProjection");
            if (!ok) { break; }
            cobj->setProjection(arg0);
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::Director#setProjection");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Director_getConsole(mrb_state* mrb, mrb_value self)
{
    cocos2d::Director* cobj = static_cast<cocos2d::Director*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            cocos2d::Console* retval = cobj->getConsole();
            mrb_value ret;
            ret = object_to_rubyval<cocos2d::Console>(mrb, "CC::Console", (cocos2d::Console*)retval, nullptr);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::Director#getConsole");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Director_multiplyMatrix(mrb_state* mrb, mrb_value self)
{
    cocos2d::Director* cobj = static_cast<cocos2d::Director*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 2) {
            cocos2d::MATRIX_STACK_TYPE arg0;
            ok = rubyval_to_int32(mrb, argv[0], (int*)&arg0, "CC::Director.multiplyMatrix");
            if (!ok) { break; }
            cocos2d::Mat4* arg1;
            ok = rubyval_to_object<cocos2d::Mat4>(mrb, argv[1], "CC::Mat4", &arg1);
            if (!ok) { break; }
            cobj->multiplyMatrix(arg0, *arg1);
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::Director#multiplyMatrix");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Director_getZEye(mrb_state* mrb, mrb_value self)
{
    cocos2d::Director* cobj = static_cast<cocos2d::Director*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            double retval = cobj->getZEye();
            mrb_value ret;
            ret = mrb_float_value(mrb, (mrb_float)retval);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::Director#getZEye");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Director_setNextDeltaTimeZero(mrb_state* mrb, mrb_value self)
{
    cocos2d::Director* cobj = static_cast<cocos2d::Director*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            bool arg0;
            ok = rubyval_to_boolean(mrb, argv[0], &arg0, "CC::Director.setNextDeltaTimeZero");
            if (!ok) { break; }
            cobj->setNextDeltaTimeZero(arg0);
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::Director#setNextDeltaTimeZero");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Director_popMatrix(mrb_state* mrb, mrb_value self)
{
    cocos2d::Director* cobj = static_cast<cocos2d::Director*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            cocos2d::MATRIX_STACK_TYPE arg0;
            ok = rubyval_to_int32(mrb, argv[0], (int*)&arg0, "CC::Director.popMatrix");
            if (!ok) { break; }
            cobj->popMatrix(arg0);
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::Director#popMatrix");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Director_getVisibleSize(mrb_state* mrb, mrb_value self)
{
    cocos2d::Director* cobj = static_cast<cocos2d::Director*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            cocos2d::Size retval = cobj->getVisibleSize();
            cocos2d::Size* retval_ptr = new cocos2d::Size(retval);
            mrb_value ret;
            ret = object_to_rubyval<cocos2d::Size>(mrb, "CC::Size", (cocos2d::Size*)retval_ptr, nullptr);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::Director#getVisibleSize");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Director_getScheduler(mrb_state* mrb, mrb_value self)
{
    cocos2d::Director* cobj = static_cast<cocos2d::Director*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            cocos2d::Scheduler* retval = cobj->getScheduler();
            mrb_value ret;
            ret = object_to_rubyval<cocos2d::Scheduler>(mrb, "CC::Scheduler", (cocos2d::Scheduler*)retval, nullptr);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::Director#getScheduler");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Director_pushScene(mrb_state* mrb, mrb_value self)
{
    cocos2d::Director* cobj = static_cast<cocos2d::Director*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            cocos2d::Scene* arg0;
            ok = rubyval_to_object<cocos2d::Scene>(mrb, argv[0], "CC::Scene", &arg0);
            if (!ok) { break; }
            cobj->pushScene(arg0);
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::Director#pushScene");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Director_getAnimationInterval(mrb_state* mrb, mrb_value self)
{
    cocos2d::Director* cobj = static_cast<cocos2d::Director*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            double retval = cobj->getAnimationInterval();
            mrb_value ret;
            ret = mrb_float_value(mrb, (mrb_float)retval);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::Director#getAnimationInterval");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Director_isPaused(mrb_state* mrb, mrb_value self)
{
    cocos2d::Director* cobj = static_cast<cocos2d::Director*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            bool retval = cobj->isPaused();
            mrb_value ret;
            ret = mrb_bool_value((mrb_bool)retval);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::Director#isPaused");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Director_setDisplayStats(mrb_state* mrb, mrb_value self)
{
    cocos2d::Director* cobj = static_cast<cocos2d::Director*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            bool arg0;
            ok = rubyval_to_boolean(mrb, argv[0], &arg0, "CC::Director.setDisplayStats");
            if (!ok) { break; }
            cobj->setDisplayStats(arg0);
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::Director#setDisplayStats");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Director_getEventDispatcher(mrb_state* mrb, mrb_value self)
{
    cocos2d::Director* cobj = static_cast<cocos2d::Director*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            cocos2d::EventDispatcher* retval = cobj->getEventDispatcher();
            mrb_value ret;
            ret = object_to_rubyval<cocos2d::EventDispatcher>(mrb, "CC::EventDispatcher", (cocos2d::EventDispatcher*)retval, nullptr);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::Director#getEventDispatcher");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Director_replaceScene(mrb_state* mrb, mrb_value self)
{
    cocos2d::Director* cobj = static_cast<cocos2d::Director*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            cocos2d::Scene* arg0;
            ok = rubyval_to_object<cocos2d::Scene>(mrb, argv[0], "CC::Scene", &arg0);
            if (!ok) { break; }
            cobj->replaceScene(arg0);
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::Director#replaceScene");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Director_setAnimationInterval(mrb_state* mrb, mrb_value self)
{
    cocos2d::Director* cobj = static_cast<cocos2d::Director*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            double arg0;
            ok = rubyval_to_number(mrb, argv[0], &arg0, "CC::Director.setAnimationInterval");
            if (!ok) { break; }
            cobj->setAnimationInterval(arg0);
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::Director#setAnimationInterval");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Director_getActionManager(mrb_state* mrb, mrb_value self)
{
    cocos2d::Director* cobj = static_cast<cocos2d::Director*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            cocos2d::ActionManager* retval = cobj->getActionManager();
            mrb_value ret;
            ret = object_to_rubyval<cocos2d::ActionManager>(mrb, "CC::ActionManager", (cocos2d::ActionManager*)retval, nullptr);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::Director#getActionManager");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Director_getInstance_static(mrb_state* mrb, mrb_value self)
{
    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            cocos2d::Director* retval = cocos2d::Director::getInstance();
            mrb_value ret;
            ret = object_to_rubyval<cocos2d::Director>(mrb, "CC::Director", (cocos2d::Director*)retval, nullptr);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined static method : cocos2d::Director#getInstance");

    return mrb_nil_value();
}

void ruby_cocos2dx_Director_constants_init(mrb_state* mrb, struct RClass* rclass)
{
    do {
        mrb_value ret;
        ret = mrb_str_new_cstr(mrb, (const char*)cocos2d::Director::EVENT_PROJECTION_CHANGED);
        mrb_mod_cv_set(mrb, rclass, mrb_intern_cstr(mrb, "EVENT_PROJECTION_CHANGED"), ret);
    } while (0);

    do {
        mrb_value ret;
        ret = mrb_str_new_cstr(mrb, (const char*)cocos2d::Director::EVENT_AFTER_UPDATE);
        mrb_mod_cv_set(mrb, rclass, mrb_intern_cstr(mrb, "EVENT_AFTER_UPDATE"), ret);
    } while (0);

    do {
        mrb_value ret;
        ret = mrb_str_new_cstr(mrb, (const char*)cocos2d::Director::EVENT_AFTER_VISIT);
        mrb_mod_cv_set(mrb, rclass, mrb_intern_cstr(mrb, "EVENT_AFTER_VISIT"), ret);
    } while (0);

    do {
        mrb_value ret;
        ret = mrb_str_new_cstr(mrb, (const char*)cocos2d::Director::EVENT_AFTER_DRAW);
        mrb_mod_cv_set(mrb, rclass, mrb_intern_cstr(mrb, "EVENT_AFTER_DRAW"), ret);
    } while (0);

}

void ruby_cocos2dx_Director_Projection_enum_init(mrb_state* mrb, struct RClass* renum)
{
    do {
        mrb_value ev = mrb_fixnum_value((mrb_int)cocos2d::Director::Projection::CUSTOM);
        mrb_mod_cv_set(mrb, renum, mrb_intern_cstr(mrb, "CUSTOM"), ev);
    } while (0);

    do {
        mrb_value ev = mrb_fixnum_value((mrb_int)cocos2d::Director::Projection::DEFAULT);
        mrb_mod_cv_set(mrb, renum, mrb_intern_cstr(mrb, "DEFAULT"), ev);
    } while (0);

}

void ruby_register_cocos2dx_Director(mrb_state* mrb, struct RClass* rmodule)
{
    std::string typeName = typeid(cocos2d::Director).name();
    g_rubyType[typeName] = "CC::Director";
    g_rubyDataType[typeName] = &ruby_cocos2dx_Ref_type;

    struct RClass *rclass = mrb_define_class_under(mrb, rmodule, "Director", mrb->object_class);
    MRB_SET_INSTANCE_TT(rclass, MRB_TT_DATA);

    mrb_define_method(mrb, rclass, "pause", ruby_cocos2dx_Director_pause, ARGS_NONE());
    mrb_define_method(mrb, rclass, "end_to_ruby", ruby_cocos2dx_Director_end, ARGS_NONE());
    mrb_define_method(mrb, rclass, "set_event_dispatcher", ruby_cocos2dx_Director_setEventDispatcher, ARGS_REQ(1));
    mrb_define_method(mrb, rclass, "set_content_scale_factor", ruby_cocos2dx_Director_setContentScaleFactor, ARGS_REQ(1));
    mrb_define_method(mrb, rclass, "get_content_scale_factor", ruby_cocos2dx_Director_getContentScaleFactor, ARGS_NONE());
    mrb_define_method(mrb, rclass, "get_win_size_in_pixels", ruby_cocos2dx_Director_getWinSizeInPixels, ARGS_NONE());
    mrb_define_method(mrb, rclass, "get_delta_time", ruby_cocos2dx_Director_getDeltaTime, ARGS_NONE());
    mrb_define_method(mrb, rclass, "set_gldefault_values", ruby_cocos2dx_Director_setGLDefaultValues, ARGS_NONE());
    mrb_define_method(mrb, rclass, "set_action_manager", ruby_cocos2dx_Director_setActionManager, ARGS_REQ(1));
    mrb_define_method(mrb, rclass, "set_alpha_blending", ruby_cocos2dx_Director_setAlphaBlending, ARGS_REQ(1));
    mrb_define_method(mrb, rclass, "pop_to_root_scene", ruby_cocos2dx_Director_popToRootScene, ARGS_NONE());
    mrb_define_method(mrb, rclass, "load_matrix", ruby_cocos2dx_Director_loadMatrix, ARGS_REQ(2));
    mrb_define_method(mrb, rclass, "get_notification_node", ruby_cocos2dx_Director_getNotificationNode, ARGS_NONE());
    mrb_define_method(mrb, rclass, "get_win_size", ruby_cocos2dx_Director_getWinSize, ARGS_NONE());
    mrb_define_method(mrb, rclass, "get_texture_cache", ruby_cocos2dx_Director_getTextureCache, ARGS_NONE());
    mrb_define_method(mrb, rclass, "send_cleanup_to_scene?", ruby_cocos2dx_Director_isSendCleanupToScene, ARGS_NONE());
    mrb_define_method(mrb, rclass, "get_visible_origin", ruby_cocos2dx_Director_getVisibleOrigin, ARGS_NONE());
    mrb_define_method(mrb, rclass, "main_loop", ruby_cocos2dx_Director_mainLoop, ARGS_NONE());
    mrb_define_method(mrb, rclass, "set_depth_test", ruby_cocos2dx_Director_setDepthTest, ARGS_REQ(1));
    mrb_define_method(mrb, rclass, "get_frame_rate", ruby_cocos2dx_Director_getFrameRate, ARGS_NONE());
    mrb_define_method(mrb, rclass, "get_seconds_per_frame", ruby_cocos2dx_Director_getSecondsPerFrame, ARGS_NONE());
    mrb_define_method(mrb, rclass, "reset_matrix_stack", ruby_cocos2dx_Director_resetMatrixStack, ARGS_NONE());
    mrb_define_method(mrb, rclass, "convert_to_ui", ruby_cocos2dx_Director_convertToUI, ARGS_REQ(1));
    mrb_define_method(mrb, rclass, "push_matrix", ruby_cocos2dx_Director_pushMatrix, ARGS_REQ(1));
    mrb_define_method(mrb, rclass, "set_default_values", ruby_cocos2dx_Director_setDefaultValues, ARGS_NONE());
    mrb_define_method(mrb, rclass, "init", ruby_cocos2dx_Director_init, ARGS_NONE());
    mrb_define_method(mrb, rclass, "set_scheduler", ruby_cocos2dx_Director_setScheduler, ARGS_REQ(1));
    mrb_define_method(mrb, rclass, "get_matrix", ruby_cocos2dx_Director_getMatrix, ARGS_REQ(1));
    mrb_define_method(mrb, rclass, "start_animation", ruby_cocos2dx_Director_startAnimation, ARGS_NONE());
    mrb_define_method(mrb, rclass, "get_open_glview", ruby_cocos2dx_Director_getOpenGLView, ARGS_NONE());
    mrb_define_method(mrb, rclass, "get_running_scene", ruby_cocos2dx_Director_getRunningScene, ARGS_NONE());
    mrb_define_method(mrb, rclass, "set_viewport", ruby_cocos2dx_Director_setViewport, ARGS_NONE());
    mrb_define_method(mrb, rclass, "stop_animation", ruby_cocos2dx_Director_stopAnimation, ARGS_NONE());
    mrb_define_method(mrb, rclass, "pop_to_scene_stack_level", ruby_cocos2dx_Director_popToSceneStackLevel, ARGS_REQ(1));
    mrb_define_method(mrb, rclass, "resume", ruby_cocos2dx_Director_resume, ARGS_NONE());
    mrb_define_method(mrb, rclass, "next_delta_time_zero?", ruby_cocos2dx_Director_isNextDeltaTimeZero, ARGS_NONE());
    mrb_define_method(mrb, rclass, "set_clear_color", ruby_cocos2dx_Director_setClearColor, ARGS_REQ(1));
    mrb_define_method(mrb, rclass, "set_open_glview", ruby_cocos2dx_Director_setOpenGLView, ARGS_REQ(1));
    mrb_define_method(mrb, rclass, "convert_to_gl", ruby_cocos2dx_Director_convertToGL, ARGS_REQ(1));
    mrb_define_method(mrb, rclass, "purge_cached_data", ruby_cocos2dx_Director_purgeCachedData, ARGS_NONE());
    mrb_define_method(mrb, rclass, "get_total_frames", ruby_cocos2dx_Director_getTotalFrames, ARGS_NONE());
    mrb_define_method(mrb, rclass, "run_with_scene", ruby_cocos2dx_Director_runWithScene, ARGS_REQ(1));
    mrb_define_method(mrb, rclass, "set_notification_node", ruby_cocos2dx_Director_setNotificationNode, ARGS_REQ(1));
    mrb_define_method(mrb, rclass, "draw_scene", ruby_cocos2dx_Director_drawScene, ARGS_NONE());
    mrb_define_method(mrb, rclass, "restart", ruby_cocos2dx_Director_restart, ARGS_NONE());
    mrb_define_method(mrb, rclass, "pop_scene", ruby_cocos2dx_Director_popScene, ARGS_NONE());
    mrb_define_method(mrb, rclass, "load_identity_matrix", ruby_cocos2dx_Director_loadIdentityMatrix, ARGS_REQ(1));
    mrb_define_method(mrb, rclass, "display_stats?", ruby_cocos2dx_Director_isDisplayStats, ARGS_NONE());
    mrb_define_method(mrb, rclass, "set_projection", ruby_cocos2dx_Director_setProjection, ARGS_REQ(1));
    mrb_define_method(mrb, rclass, "get_console", ruby_cocos2dx_Director_getConsole, ARGS_NONE());
    mrb_define_method(mrb, rclass, "multiply_matrix", ruby_cocos2dx_Director_multiplyMatrix, ARGS_REQ(2));
    mrb_define_method(mrb, rclass, "get_zeye", ruby_cocos2dx_Director_getZEye, ARGS_NONE());
    mrb_define_method(mrb, rclass, "set_next_delta_time_zero", ruby_cocos2dx_Director_setNextDeltaTimeZero, ARGS_REQ(1));
    mrb_define_method(mrb, rclass, "pop_matrix", ruby_cocos2dx_Director_popMatrix, ARGS_REQ(1));
    mrb_define_method(mrb, rclass, "get_visible_size", ruby_cocos2dx_Director_getVisibleSize, ARGS_NONE());
    mrb_define_method(mrb, rclass, "get_scheduler", ruby_cocos2dx_Director_getScheduler, ARGS_NONE());
    mrb_define_method(mrb, rclass, "push_scene", ruby_cocos2dx_Director_pushScene, ARGS_REQ(1));
    mrb_define_method(mrb, rclass, "get_animation_interval", ruby_cocos2dx_Director_getAnimationInterval, ARGS_NONE());
    mrb_define_method(mrb, rclass, "paused?", ruby_cocos2dx_Director_isPaused, ARGS_NONE());
    mrb_define_method(mrb, rclass, "set_display_stats", ruby_cocos2dx_Director_setDisplayStats, ARGS_REQ(1));
    mrb_define_method(mrb, rclass, "get_event_dispatcher", ruby_cocos2dx_Director_getEventDispatcher, ARGS_NONE());
    mrb_define_method(mrb, rclass, "replace_scene", ruby_cocos2dx_Director_replaceScene, ARGS_REQ(1));
    mrb_define_method(mrb, rclass, "set_animation_interval", ruby_cocos2dx_Director_setAnimationInterval, ARGS_REQ(1));
    mrb_define_method(mrb, rclass, "get_action_manager", ruby_cocos2dx_Director_getActionManager, ARGS_NONE());
    mrb_define_class_method(mrb, rclass, "get_instance", ruby_cocos2dx_Director_getInstance_static, ARGS_NONE());
    ruby_cocos2dx_Director_constants_init(mrb, rclass);
    mrb_define_class_method(mrb, rclass, "EVENT_PROJECTION_CHANGED", ruby_cocos2dx_constant_get, ARGS_NONE());
    mrb_define_class_method(mrb, rclass, "EVENT_AFTER_UPDATE", ruby_cocos2dx_constant_get, ARGS_NONE());
    mrb_define_class_method(mrb, rclass, "EVENT_AFTER_VISIT", ruby_cocos2dx_constant_get, ARGS_NONE());
    mrb_define_class_method(mrb, rclass, "EVENT_AFTER_DRAW", ruby_cocos2dx_constant_get, ARGS_NONE());
    struct RClass* renum_Projection = mrb_define_module_under(mrb, rclass, "Projection");
    ruby_cocos2dx_Director_Projection_enum_init(mrb, renum_Projection);
    mrb_define_class_method(mrb, renum_Projection, "CUSTOM", ruby_cocos2dx_constant_get, ARGS_NONE());
    mrb_define_class_method(mrb, renum_Projection, "DEFAULT", ruby_cocos2dx_constant_get, ARGS_NONE());
}
mrb_value ruby_cocos2dx_Timer_getInterval(mrb_state* mrb, mrb_value self)
{
    cocos2d::Timer* cobj = static_cast<cocos2d::Timer*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            double retval = cobj->getInterval();
            mrb_value ret;
            ret = mrb_float_value(mrb, (mrb_float)retval);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::Timer#getInterval");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Timer_setupTimerWithInterval(mrb_state* mrb, mrb_value self)
{
    cocos2d::Timer* cobj = static_cast<cocos2d::Timer*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 3) {
            double arg0;
            ok = rubyval_to_number(mrb, argv[0], (double*)&arg0, "CC::Timer.setupTimerWithInterval");
            if (!ok) { break; }
            unsigned int arg1;
            ok = rubyval_to_uint32(mrb, argv[1], &arg1, "CC::Timer.setupTimerWithInterval");
            if (!ok) { break; }
            double arg2;
            ok = rubyval_to_number(mrb, argv[2], (double*)&arg2, "CC::Timer.setupTimerWithInterval");
            if (!ok) { break; }
            cobj->setupTimerWithInterval(arg0, arg1, arg2);
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::Timer#setupTimerWithInterval");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Timer_setInterval(mrb_state* mrb, mrb_value self)
{
    cocos2d::Timer* cobj = static_cast<cocos2d::Timer*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            double arg0;
            ok = rubyval_to_number(mrb, argv[0], (double*)&arg0, "CC::Timer.setInterval");
            if (!ok) { break; }
            cobj->setInterval(arg0);
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::Timer#setInterval");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Timer_update(mrb_state* mrb, mrb_value self)
{
    cocos2d::Timer* cobj = static_cast<cocos2d::Timer*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            double arg0;
            ok = rubyval_to_number(mrb, argv[0], (double*)&arg0, "CC::Timer.update");
            if (!ok) { break; }
            cobj->update(arg0);
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::Timer#update");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Timer_trigger(mrb_state* mrb, mrb_value self)
{
    cocos2d::Timer* cobj = static_cast<cocos2d::Timer*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            cobj->trigger();
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::Timer#trigger");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Timer_cancel(mrb_state* mrb, mrb_value self)
{
    cocos2d::Timer* cobj = static_cast<cocos2d::Timer*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            cobj->cancel();
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::Timer#cancel");

    return mrb_nil_value();
}

void ruby_register_cocos2dx_Timer(mrb_state* mrb, struct RClass* rmodule)
{
    std::string typeName = typeid(cocos2d::Timer).name();
    g_rubyType[typeName] = "CC::Timer";
    g_rubyDataType[typeName] = &ruby_cocos2dx_Ref_type;

    struct RClass* p_rmodule = mrb->object_class;
    p_rmodule = mrb_module_get_under(mrb, p_rmodule, "CC");
    struct RClass* p_rclass = mrb_class_get_under(mrb, p_rmodule, "Ref");
    struct RClass *rclass = mrb_define_class_under(mrb, rmodule, "Timer", p_rclass);
    MRB_SET_INSTANCE_TT(rclass, MRB_TT_DATA);

    mrb_define_method(mrb, rclass, "get_interval", ruby_cocos2dx_Timer_getInterval, ARGS_NONE());
    mrb_define_method(mrb, rclass, "setup_timer_with_interval", ruby_cocos2dx_Timer_setupTimerWithInterval, ARGS_REQ(3));
    mrb_define_method(mrb, rclass, "set_interval", ruby_cocos2dx_Timer_setInterval, ARGS_REQ(1));
    mrb_define_method(mrb, rclass, "update", ruby_cocos2dx_Timer_update, ARGS_REQ(1));
    mrb_define_method(mrb, rclass, "trigger", ruby_cocos2dx_Timer_trigger, ARGS_NONE());
    mrb_define_method(mrb, rclass, "cancel", ruby_cocos2dx_Timer_cancel, ARGS_NONE());
}
mrb_value ruby_cocos2dx_Scheduler_setTimeScale(mrb_state* mrb, mrb_value self)
{
    cocos2d::Scheduler* cobj = static_cast<cocos2d::Scheduler*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            double arg0;
            ok = rubyval_to_number(mrb, argv[0], (double*)&arg0, "CC::Scheduler.setTimeScale");
            if (!ok) { break; }
            cobj->setTimeScale(arg0);
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::Scheduler#setTimeScale");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Scheduler_getTimeScale(mrb_state* mrb, mrb_value self)
{
    cocos2d::Scheduler* cobj = static_cast<cocos2d::Scheduler*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            double retval = cobj->getTimeScale();
            mrb_value ret;
            ret = mrb_float_value(mrb, (mrb_float)retval);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::Scheduler#getTimeScale");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Scheduler_constructor(mrb_state* mrb, mrb_value self)
{

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            cocos2d::Scheduler* cobj = new cocos2d::Scheduler();
            DATA_TYPE(self) = &ruby_cocos2dx_Ref_type;
            DATA_PTR(self) = cobj;
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::Scheduler#Scheduler");

    return mrb_nil_value();
}


void ruby_cocos2dx_Scheduler_constants_init(mrb_state* mrb, struct RClass* rclass)
{
    do {
        mrb_value ret;
        ret = mrb_fixnum_value((mrb_int)cocos2d::Scheduler::PRIORITY_SYSTEM);
        mrb_mod_cv_set(mrb, rclass, mrb_intern_cstr(mrb, "PRIORITY_SYSTEM"), ret);
    } while (0);

    do {
        mrb_value ret;
        ret = mrb_fixnum_value((mrb_int)cocos2d::Scheduler::PRIORITY_NON_SYSTEM_MIN);
        mrb_mod_cv_set(mrb, rclass, mrb_intern_cstr(mrb, "PRIORITY_NON_SYSTEM_MIN"), ret);
    } while (0);

}

void ruby_register_cocos2dx_Scheduler(mrb_state* mrb, struct RClass* rmodule)
{
    std::string typeName = typeid(cocos2d::Scheduler).name();
    g_rubyType[typeName] = "CC::Scheduler";
    g_rubyDataType[typeName] = &ruby_cocos2dx_Ref_type;

    struct RClass* p_rmodule = mrb->object_class;
    p_rmodule = mrb_module_get_under(mrb, p_rmodule, "CC");
    struct RClass* p_rclass = mrb_class_get_under(mrb, p_rmodule, "Ref");
    struct RClass *rclass = mrb_define_class_under(mrb, rmodule, "Scheduler", p_rclass);
    MRB_SET_INSTANCE_TT(rclass, MRB_TT_DATA);

    mrb_define_method(mrb, rclass, "initialize", ruby_cocos2dx_Scheduler_constructor, ARGS_NONE());
    mrb_define_method(mrb, rclass, "set_time_scale", ruby_cocos2dx_Scheduler_setTimeScale, ARGS_REQ(1));
    mrb_define_method(mrb, rclass, "get_time_scale", ruby_cocos2dx_Scheduler_getTimeScale, ARGS_NONE());
    ruby_cocos2dx_Scheduler_constants_init(mrb, rclass);
    mrb_define_class_method(mrb, rclass, "PRIORITY_SYSTEM", ruby_cocos2dx_constant_get, ARGS_NONE());
    mrb_define_class_method(mrb, rclass, "PRIORITY_NON_SYSTEM_MIN", ruby_cocos2dx_constant_get, ARGS_NONE());
}
mrb_value ruby_cocos2dx_FileUtils_fullPathForFilename(mrb_state* mrb, mrb_value self)
{
    cocos2d::FileUtils* cobj = static_cast<cocos2d::FileUtils*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_FileUtils_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            std::string arg0;
            ok = rubyval_to_std_string(mrb, argv[0], &arg0, "CC::FileUtils.fullPathForFilename");
            if (!ok) { break; }
            std::string retval = cobj->fullPathForFilename(arg0);
            mrb_value ret;
            ret = mrb_str_new_cstr(mrb, retval.c_str());
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::FileUtils#fullPathForFilename");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_FileUtils_getStringFromFile(mrb_state* mrb, mrb_value self)
{
    cocos2d::FileUtils* cobj = static_cast<cocos2d::FileUtils*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_FileUtils_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            std::string arg0;
            ok = rubyval_to_std_string(mrb, argv[0], &arg0, "CC::FileUtils.getStringFromFile");
            if (!ok) { break; }
            std::string retval = cobj->getStringFromFile(arg0);
            mrb_value ret;
            ret = mrb_str_new_cstr(mrb, retval.c_str());
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::FileUtils#getStringFromFile");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_FileUtils_setFilenameLookupDictionary(mrb_state* mrb, mrb_value self)
{
    cocos2d::FileUtils* cobj = static_cast<cocos2d::FileUtils*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_FileUtils_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            cocos2d::ValueMap arg0;
            ok = rubyval_to_ccvaluemap(mrb, argv[0], &arg0, "CC::FileUtils.setFilenameLookupDictionary");
            if (!ok) { break; }
            cobj->setFilenameLookupDictionary(arg0);
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::FileUtils#setFilenameLookupDictionary");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_FileUtils_removeFile(mrb_state* mrb, mrb_value self)
{
    cocos2d::FileUtils* cobj = static_cast<cocos2d::FileUtils*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_FileUtils_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            std::string arg0;
            ok = rubyval_to_std_string(mrb, argv[0], &arg0, "CC::FileUtils.removeFile");
            if (!ok) { break; }
            bool retval = cobj->removeFile(arg0);
            mrb_value ret;
            ret = mrb_bool_value((mrb_bool)retval);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::FileUtils#removeFile");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_FileUtils_isAbsolutePath(mrb_state* mrb, mrb_value self)
{
    cocos2d::FileUtils* cobj = static_cast<cocos2d::FileUtils*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_FileUtils_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            std::string arg0;
            ok = rubyval_to_std_string(mrb, argv[0], &arg0, "CC::FileUtils.isAbsolutePath");
            if (!ok) { break; }
            bool retval = cobj->isAbsolutePath(arg0);
            mrb_value ret;
            ret = mrb_bool_value((mrb_bool)retval);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::FileUtils#isAbsolutePath");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_FileUtils_renameFile(mrb_state* mrb, mrb_value self)
{
    cocos2d::FileUtils* cobj = static_cast<cocos2d::FileUtils*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_FileUtils_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 3) {
            std::string arg0;
            ok = rubyval_to_std_string(mrb, argv[0], &arg0, "CC::FileUtils.renameFile");
            if (!ok) { break; }
            std::string arg1;
            ok = rubyval_to_std_string(mrb, argv[1], &arg1, "CC::FileUtils.renameFile");
            if (!ok) { break; }
            std::string arg2;
            ok = rubyval_to_std_string(mrb, argv[2], &arg2, "CC::FileUtils.renameFile");
            if (!ok) { break; }
            bool retval = cobj->renameFile(arg0, arg1, arg2);
            mrb_value ret;
            ret = mrb_bool_value((mrb_bool)retval);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::FileUtils#renameFile");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_FileUtils_loadFilenameLookupDictionaryFromFile(mrb_state* mrb, mrb_value self)
{
    cocos2d::FileUtils* cobj = static_cast<cocos2d::FileUtils*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_FileUtils_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            std::string arg0;
            ok = rubyval_to_std_string(mrb, argv[0], &arg0, "CC::FileUtils.loadFilenameLookupDictionaryFromFile");
            if (!ok) { break; }
            cobj->loadFilenameLookupDictionaryFromFile(arg0);
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::FileUtils#loadFilenameLookupDictionaryFromFile");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_FileUtils_isPopupNotify(mrb_state* mrb, mrb_value self)
{
    cocos2d::FileUtils* cobj = static_cast<cocos2d::FileUtils*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_FileUtils_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            bool retval = cobj->isPopupNotify();
            mrb_value ret;
            ret = mrb_bool_value((mrb_bool)retval);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::FileUtils#isPopupNotify");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_FileUtils_getValueVectorFromFile(mrb_state* mrb, mrb_value self)
{
    cocos2d::FileUtils* cobj = static_cast<cocos2d::FileUtils*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_FileUtils_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            std::string arg0;
            ok = rubyval_to_std_string(mrb, argv[0], &arg0, "CC::FileUtils.getValueVectorFromFile");
            if (!ok) { break; }
            cocos2d::ValueVector retval = cobj->getValueVectorFromFile(arg0);
            mrb_value ret;
            ret = ccvaluevector_to_rubyval(mrb, retval);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::FileUtils#getValueVectorFromFile");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_FileUtils_getSearchPaths(mrb_state* mrb, mrb_value self)
{
    cocos2d::FileUtils* cobj = static_cast<cocos2d::FileUtils*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_FileUtils_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            std::vector<std::string> retval = cobj->getSearchPaths();
            mrb_value ret;
            ret = std_vector_std_string_to_rubyval(mrb, retval);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::FileUtils#getSearchPaths");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_FileUtils_writeToFile(mrb_state* mrb, mrb_value self)
{
    cocos2d::FileUtils* cobj = static_cast<cocos2d::FileUtils*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_FileUtils_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 2) {
            cocos2d::ValueMap arg0;
            ok = rubyval_to_ccvaluemap(mrb, argv[0], &arg0, "CC::FileUtils.writeToFile");
            if (!ok) { break; }
            std::string arg1;
            ok = rubyval_to_std_string(mrb, argv[1], &arg1, "CC::FileUtils.writeToFile");
            if (!ok) { break; }
            bool retval = cobj->writeToFile(arg0, arg1);
            mrb_value ret;
            ret = mrb_bool_value((mrb_bool)retval);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::FileUtils#writeToFile");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_FileUtils_getValueMapFromFile(mrb_state* mrb, mrb_value self)
{
    cocos2d::FileUtils* cobj = static_cast<cocos2d::FileUtils*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_FileUtils_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            std::string arg0;
            ok = rubyval_to_std_string(mrb, argv[0], &arg0, "CC::FileUtils.getValueMapFromFile");
            if (!ok) { break; }
            cocos2d::ValueMap retval = cobj->getValueMapFromFile(arg0);
            mrb_value ret;
            ret = ccvaluemap_to_rubyval(mrb, retval);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::FileUtils#getValueMapFromFile");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_FileUtils_getValueMapFromData(mrb_state* mrb, mrb_value self)
{
    cocos2d::FileUtils* cobj = static_cast<cocos2d::FileUtils*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_FileUtils_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 2) {
            const char* arg0;
            std::string arg0_tmp; ok = rubyval_to_std_string(mrb, argv[0], &arg0_tmp, "CC::FileUtils:getValueMapFromData"); arg0 = arg0_tmp.c_str();
            if (!ok) { break; }
            int arg1;
            ok = rubyval_to_int32(mrb, argv[1], (int*)&arg1, "CC::FileUtils.getValueMapFromData");
            if (!ok) { break; }
            cocos2d::ValueMap retval = cobj->getValueMapFromData(arg0, arg1);
            mrb_value ret;
            ret = ccvaluemap_to_rubyval(mrb, retval);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::FileUtils#getValueMapFromData");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_FileUtils_removeDirectory(mrb_state* mrb, mrb_value self)
{
    cocos2d::FileUtils* cobj = static_cast<cocos2d::FileUtils*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_FileUtils_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            std::string arg0;
            ok = rubyval_to_std_string(mrb, argv[0], &arg0, "CC::FileUtils.removeDirectory");
            if (!ok) { break; }
            bool retval = cobj->removeDirectory(arg0);
            mrb_value ret;
            ret = mrb_bool_value((mrb_bool)retval);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::FileUtils#removeDirectory");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_FileUtils_setSearchPaths(mrb_state* mrb, mrb_value self)
{
    cocos2d::FileUtils* cobj = static_cast<cocos2d::FileUtils*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_FileUtils_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            std::vector<std::string> arg0;
            ok = rubyval_to_std_vector_string(mrb, argv[0], &arg0, "CC::FileUtils.setSearchPaths");
            if (!ok) { break; }
            cobj->setSearchPaths(arg0);
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::FileUtils#setSearchPaths");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_FileUtils_getFileSize(mrb_state* mrb, mrb_value self)
{
    cocos2d::FileUtils* cobj = static_cast<cocos2d::FileUtils*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_FileUtils_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            std::string arg0;
            ok = rubyval_to_std_string(mrb, argv[0], &arg0, "CC::FileUtils.getFileSize");
            if (!ok) { break; }
            long retval = cobj->getFileSize(arg0);
            mrb_value ret;
            ret = mrb_fixnum_value((mrb_int)retval);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::FileUtils#getFileSize");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_FileUtils_setSearchResolutionsOrder(mrb_state* mrb, mrb_value self)
{
    cocos2d::FileUtils* cobj = static_cast<cocos2d::FileUtils*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_FileUtils_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            std::vector<std::string> arg0;
            ok = rubyval_to_std_vector_string(mrb, argv[0], &arg0, "CC::FileUtils.setSearchResolutionsOrder");
            if (!ok) { break; }
            cobj->setSearchResolutionsOrder(arg0);
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::FileUtils#setSearchResolutionsOrder");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_FileUtils_addSearchResolutionsOrder(mrb_state* mrb, mrb_value self)
{
    cocos2d::FileUtils* cobj = static_cast<cocos2d::FileUtils*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_FileUtils_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            std::string arg0;
            ok = rubyval_to_std_string(mrb, argv[0], &arg0, "CC::FileUtils.addSearchResolutionsOrder");
            if (!ok) { break; }
            cobj->addSearchResolutionsOrder(arg0);
            return self;
        }
    } while (0);
    do {
        if (argc == 2) {
            std::string arg0;
            ok = rubyval_to_std_string(mrb, argv[0], &arg0, "CC::FileUtils.addSearchResolutionsOrder");
            if (!ok) { break; }
            bool arg1;
            ok = rubyval_to_boolean(mrb, argv[1], &arg1, "CC::FileUtils.addSearchResolutionsOrder");
            if (!ok) { break; }
            cobj->addSearchResolutionsOrder(arg0, arg1);
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::FileUtils#addSearchResolutionsOrder");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_FileUtils_addSearchPath(mrb_state* mrb, mrb_value self)
{
    cocos2d::FileUtils* cobj = static_cast<cocos2d::FileUtils*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_FileUtils_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            std::string arg0;
            ok = rubyval_to_std_string(mrb, argv[0], &arg0, "CC::FileUtils.addSearchPath");
            if (!ok) { break; }
            cobj->addSearchPath(arg0);
            return self;
        }
    } while (0);
    do {
        if (argc == 2) {
            std::string arg0;
            ok = rubyval_to_std_string(mrb, argv[0], &arg0, "CC::FileUtils.addSearchPath");
            if (!ok) { break; }
            bool arg1;
            ok = rubyval_to_boolean(mrb, argv[1], &arg1, "CC::FileUtils.addSearchPath");
            if (!ok) { break; }
            cobj->addSearchPath(arg0, arg1);
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::FileUtils#addSearchPath");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_FileUtils_isFileExist(mrb_state* mrb, mrb_value self)
{
    cocos2d::FileUtils* cobj = static_cast<cocos2d::FileUtils*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_FileUtils_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            std::string arg0;
            ok = rubyval_to_std_string(mrb, argv[0], &arg0, "CC::FileUtils.isFileExist");
            if (!ok) { break; }
            bool retval = cobj->isFileExist(arg0);
            mrb_value ret;
            ret = mrb_bool_value((mrb_bool)retval);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::FileUtils#isFileExist");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_FileUtils_purgeCachedEntries(mrb_state* mrb, mrb_value self)
{
    cocos2d::FileUtils* cobj = static_cast<cocos2d::FileUtils*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_FileUtils_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            cobj->purgeCachedEntries();
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::FileUtils#purgeCachedEntries");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_FileUtils_fullPathFromRelativeFile(mrb_state* mrb, mrb_value self)
{
    cocos2d::FileUtils* cobj = static_cast<cocos2d::FileUtils*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_FileUtils_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 2) {
            std::string arg0;
            ok = rubyval_to_std_string(mrb, argv[0], &arg0, "CC::FileUtils.fullPathFromRelativeFile");
            if (!ok) { break; }
            std::string arg1;
            ok = rubyval_to_std_string(mrb, argv[1], &arg1, "CC::FileUtils.fullPathFromRelativeFile");
            if (!ok) { break; }
            std::string retval = cobj->fullPathFromRelativeFile(arg0, arg1);
            mrb_value ret;
            ret = mrb_str_new_cstr(mrb, retval.c_str());
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::FileUtils#fullPathFromRelativeFile");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_FileUtils_setWritablePath(mrb_state* mrb, mrb_value self)
{
    cocos2d::FileUtils* cobj = static_cast<cocos2d::FileUtils*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_FileUtils_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            std::string arg0;
            ok = rubyval_to_std_string(mrb, argv[0], &arg0, "CC::FileUtils.setWritablePath");
            if (!ok) { break; }
            cobj->setWritablePath(arg0);
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::FileUtils#setWritablePath");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_FileUtils_setPopupNotify(mrb_state* mrb, mrb_value self)
{
    cocos2d::FileUtils* cobj = static_cast<cocos2d::FileUtils*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_FileUtils_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            bool arg0;
            ok = rubyval_to_boolean(mrb, argv[0], &arg0, "CC::FileUtils.setPopupNotify");
            if (!ok) { break; }
            cobj->setPopupNotify(arg0);
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::FileUtils#setPopupNotify");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_FileUtils_isDirectoryExist(mrb_state* mrb, mrb_value self)
{
    cocos2d::FileUtils* cobj = static_cast<cocos2d::FileUtils*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_FileUtils_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            std::string arg0;
            ok = rubyval_to_std_string(mrb, argv[0], &arg0, "CC::FileUtils.isDirectoryExist");
            if (!ok) { break; }
            bool retval = cobj->isDirectoryExist(arg0);
            mrb_value ret;
            ret = mrb_bool_value((mrb_bool)retval);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::FileUtils#isDirectoryExist");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_FileUtils_setDefaultResourceRootPath(mrb_state* mrb, mrb_value self)
{
    cocos2d::FileUtils* cobj = static_cast<cocos2d::FileUtils*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_FileUtils_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            std::string arg0;
            ok = rubyval_to_std_string(mrb, argv[0], &arg0, "CC::FileUtils.setDefaultResourceRootPath");
            if (!ok) { break; }
            cobj->setDefaultResourceRootPath(arg0);
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::FileUtils#setDefaultResourceRootPath");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_FileUtils_getSearchResolutionsOrder(mrb_state* mrb, mrb_value self)
{
    cocos2d::FileUtils* cobj = static_cast<cocos2d::FileUtils*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_FileUtils_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            std::vector<std::string> retval = cobj->getSearchResolutionsOrder();
            mrb_value ret;
            ret = std_vector_std_string_to_rubyval(mrb, retval);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::FileUtils#getSearchResolutionsOrder");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_FileUtils_createDirectory(mrb_state* mrb, mrb_value self)
{
    cocos2d::FileUtils* cobj = static_cast<cocos2d::FileUtils*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_FileUtils_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            std::string arg0;
            ok = rubyval_to_std_string(mrb, argv[0], &arg0, "CC::FileUtils.createDirectory");
            if (!ok) { break; }
            bool retval = cobj->createDirectory(arg0);
            mrb_value ret;
            ret = mrb_bool_value((mrb_bool)retval);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::FileUtils#createDirectory");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_FileUtils_getWritablePath(mrb_state* mrb, mrb_value self)
{
    cocos2d::FileUtils* cobj = static_cast<cocos2d::FileUtils*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_FileUtils_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            std::string retval = cobj->getWritablePath();
            mrb_value ret;
            ret = mrb_str_new_cstr(mrb, retval.c_str());
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::FileUtils#getWritablePath");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_FileUtils_destroyInstance_static(mrb_state* mrb, mrb_value self)
{
    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            cocos2d::FileUtils::destroyInstance();
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined static method : cocos2d::FileUtils#destroyInstance");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_FileUtils_getInstance_static(mrb_state* mrb, mrb_value self)
{
    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            cocos2d::FileUtils* retval = cocos2d::FileUtils::getInstance();
            mrb_value ret;
            ret = object_to_rubyval<cocos2d::FileUtils>(mrb, "CC::FileUtils", (cocos2d::FileUtils*)retval, nullptr);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined static method : cocos2d::FileUtils#getInstance");

    return mrb_nil_value();
}

void ruby_register_cocos2dx_FileUtils(mrb_state* mrb, struct RClass* rmodule)
{
    std::string typeName = typeid(cocos2d::FileUtils).name();
    g_rubyType[typeName] = "CC::FileUtils";
    g_rubyDataType[typeName] = &ruby_cocos2dx_FileUtils_type;

    struct RClass *rclass = mrb_define_class_under(mrb, rmodule, "FileUtils", mrb->object_class);
    MRB_SET_INSTANCE_TT(rclass, MRB_TT_DATA);

    mrb_define_method(mrb, rclass, "full_path_for_filename", ruby_cocos2dx_FileUtils_fullPathForFilename, ARGS_REQ(1));
    mrb_define_method(mrb, rclass, "get_string_from_file", ruby_cocos2dx_FileUtils_getStringFromFile, ARGS_REQ(1));
    mrb_define_method(mrb, rclass, "set_filename_lookup_dictionary", ruby_cocos2dx_FileUtils_setFilenameLookupDictionary, ARGS_REQ(1));
    mrb_define_method(mrb, rclass, "remove_file", ruby_cocos2dx_FileUtils_removeFile, ARGS_REQ(1));
    mrb_define_method(mrb, rclass, "absolute_path?", ruby_cocos2dx_FileUtils_isAbsolutePath, ARGS_REQ(1));
    mrb_define_method(mrb, rclass, "rename_file", ruby_cocos2dx_FileUtils_renameFile, ARGS_REQ(3));
    mrb_define_method(mrb, rclass, "load_filename_lookup", ruby_cocos2dx_FileUtils_loadFilenameLookupDictionaryFromFile, ARGS_REQ(1));
    mrb_define_method(mrb, rclass, "popup_notify?", ruby_cocos2dx_FileUtils_isPopupNotify, ARGS_NONE());
    mrb_define_method(mrb, rclass, "get_value_vector_from_file", ruby_cocos2dx_FileUtils_getValueVectorFromFile, ARGS_REQ(1));
    mrb_define_method(mrb, rclass, "get_search_paths", ruby_cocos2dx_FileUtils_getSearchPaths, ARGS_NONE());
    mrb_define_method(mrb, rclass, "write_to_file", ruby_cocos2dx_FileUtils_writeToFile, ARGS_REQ(2));
    mrb_define_method(mrb, rclass, "get_value_map_from_file", ruby_cocos2dx_FileUtils_getValueMapFromFile, ARGS_REQ(1));
    mrb_define_method(mrb, rclass, "get_value_map_from_data", ruby_cocos2dx_FileUtils_getValueMapFromData, ARGS_REQ(2));
    mrb_define_method(mrb, rclass, "remove_directory", ruby_cocos2dx_FileUtils_removeDirectory, ARGS_REQ(1));
    mrb_define_method(mrb, rclass, "set_search_paths", ruby_cocos2dx_FileUtils_setSearchPaths, ARGS_REQ(1));
    mrb_define_method(mrb, rclass, "get_file_size", ruby_cocos2dx_FileUtils_getFileSize, ARGS_REQ(1));
    mrb_define_method(mrb, rclass, "set_search_resolutions_order", ruby_cocos2dx_FileUtils_setSearchResolutionsOrder, ARGS_REQ(1));
    mrb_define_method(mrb, rclass, "add_search_resolutions_order", ruby_cocos2dx_FileUtils_addSearchResolutionsOrder, ARGS_REQ(2));
    mrb_define_method(mrb, rclass, "add_search_path", ruby_cocos2dx_FileUtils_addSearchPath, ARGS_REQ(2));
    mrb_define_method(mrb, rclass, "file_exist?", ruby_cocos2dx_FileUtils_isFileExist, ARGS_REQ(1));
    mrb_define_method(mrb, rclass, "purge_cached_entries", ruby_cocos2dx_FileUtils_purgeCachedEntries, ARGS_NONE());
    mrb_define_method(mrb, rclass, "full_path_from_relative_file", ruby_cocos2dx_FileUtils_fullPathFromRelativeFile, ARGS_REQ(2));
    mrb_define_method(mrb, rclass, "set_writable_path", ruby_cocos2dx_FileUtils_setWritablePath, ARGS_REQ(1));
    mrb_define_method(mrb, rclass, "set_popup_notify", ruby_cocos2dx_FileUtils_setPopupNotify, ARGS_REQ(1));
    mrb_define_method(mrb, rclass, "directory_exist?", ruby_cocos2dx_FileUtils_isDirectoryExist, ARGS_REQ(1));
    mrb_define_method(mrb, rclass, "set_default_resource_root_path", ruby_cocos2dx_FileUtils_setDefaultResourceRootPath, ARGS_REQ(1));
    mrb_define_method(mrb, rclass, "get_search_resolutions_order", ruby_cocos2dx_FileUtils_getSearchResolutionsOrder, ARGS_NONE());
    mrb_define_method(mrb, rclass, "create_directory", ruby_cocos2dx_FileUtils_createDirectory, ARGS_REQ(1));
    mrb_define_method(mrb, rclass, "get_writable_path", ruby_cocos2dx_FileUtils_getWritablePath, ARGS_NONE());
    mrb_define_class_method(mrb, rclass, "destroy_instance", ruby_cocos2dx_FileUtils_destroyInstance_static, ARGS_NONE());
    mrb_define_class_method(mrb, rclass, "get_instance", ruby_cocos2dx_FileUtils_getInstance_static, ARGS_NONE());
}
mrb_value ruby_cocos2dx_UserDefault_setIntegerForKey(mrb_state* mrb, mrb_value self)
{
    cocos2d::UserDefault* cobj = static_cast<cocos2d::UserDefault*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_UserDefault_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 2) {
            const char* arg0;
            std::string arg0_tmp; ok = rubyval_to_std_string(mrb, argv[0], &arg0_tmp, "CC::UserDefault:setIntegerForKey"); arg0 = arg0_tmp.c_str();
            if (!ok) { break; }
            int arg1;
            ok = rubyval_to_int32(mrb, argv[1], (int*)&arg1, "CC::UserDefault.setIntegerForKey");
            if (!ok) { break; }
            cobj->setIntegerForKey(arg0, arg1);
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::UserDefault#setIntegerForKey");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_UserDefault_getFloatForKey(mrb_state* mrb, mrb_value self)
{
    cocos2d::UserDefault* cobj = static_cast<cocos2d::UserDefault*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_UserDefault_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 2) {
            const char* arg0;
            std::string arg0_tmp; ok = rubyval_to_std_string(mrb, argv[0], &arg0_tmp, "CC::UserDefault:getFloatForKey"); arg0 = arg0_tmp.c_str();
            if (!ok) { break; }
            double arg1;
            ok = rubyval_to_number(mrb, argv[1], (double*)&arg1, "CC::UserDefault.getFloatForKey");
            if (!ok) { break; }
            double retval = cobj->getFloatForKey(arg0, arg1);
            mrb_value ret;
            ret = mrb_float_value(mrb, (mrb_float)retval);
            return ret;
        }
    } while (0);
    do {
        if (argc == 1) {
            const char* arg0;
            std::string arg0_tmp; ok = rubyval_to_std_string(mrb, argv[0], &arg0_tmp, "CC::UserDefault:getFloatForKey"); arg0 = arg0_tmp.c_str();
            if (!ok) { break; }
            double retval = cobj->getFloatForKey(arg0);
            mrb_value ret;
            ret = mrb_float_value(mrb, (mrb_float)retval);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::UserDefault#getFloatForKey");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_UserDefault_getBoolForKey(mrb_state* mrb, mrb_value self)
{
    cocos2d::UserDefault* cobj = static_cast<cocos2d::UserDefault*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_UserDefault_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 2) {
            const char* arg0;
            std::string arg0_tmp; ok = rubyval_to_std_string(mrb, argv[0], &arg0_tmp, "CC::UserDefault:getBoolForKey"); arg0 = arg0_tmp.c_str();
            if (!ok) { break; }
            bool arg1;
            ok = rubyval_to_boolean(mrb, argv[1], &arg1, "CC::UserDefault.getBoolForKey");
            if (!ok) { break; }
            bool retval = cobj->getBoolForKey(arg0, arg1);
            mrb_value ret;
            ret = mrb_bool_value((mrb_bool)retval);
            return ret;
        }
    } while (0);
    do {
        if (argc == 1) {
            const char* arg0;
            std::string arg0_tmp; ok = rubyval_to_std_string(mrb, argv[0], &arg0_tmp, "CC::UserDefault:getBoolForKey"); arg0 = arg0_tmp.c_str();
            if (!ok) { break; }
            bool retval = cobj->getBoolForKey(arg0);
            mrb_value ret;
            ret = mrb_bool_value((mrb_bool)retval);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::UserDefault#getBoolForKey");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_UserDefault_setDoubleForKey(mrb_state* mrb, mrb_value self)
{
    cocos2d::UserDefault* cobj = static_cast<cocos2d::UserDefault*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_UserDefault_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 2) {
            const char* arg0;
            std::string arg0_tmp; ok = rubyval_to_std_string(mrb, argv[0], &arg0_tmp, "CC::UserDefault:setDoubleForKey"); arg0 = arg0_tmp.c_str();
            if (!ok) { break; }
            double arg1;
            ok = rubyval_to_number(mrb, argv[1], &arg1, "CC::UserDefault.setDoubleForKey");
            if (!ok) { break; }
            cobj->setDoubleForKey(arg0, arg1);
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::UserDefault#setDoubleForKey");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_UserDefault_setFloatForKey(mrb_state* mrb, mrb_value self)
{
    cocos2d::UserDefault* cobj = static_cast<cocos2d::UserDefault*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_UserDefault_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 2) {
            const char* arg0;
            std::string arg0_tmp; ok = rubyval_to_std_string(mrb, argv[0], &arg0_tmp, "CC::UserDefault:setFloatForKey"); arg0 = arg0_tmp.c_str();
            if (!ok) { break; }
            double arg1;
            ok = rubyval_to_number(mrb, argv[1], (double*)&arg1, "CC::UserDefault.setFloatForKey");
            if (!ok) { break; }
            cobj->setFloatForKey(arg0, arg1);
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::UserDefault#setFloatForKey");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_UserDefault_getStringForKey(mrb_state* mrb, mrb_value self)
{
    cocos2d::UserDefault* cobj = static_cast<cocos2d::UserDefault*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_UserDefault_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 2) {
            const char* arg0;
            std::string arg0_tmp; ok = rubyval_to_std_string(mrb, argv[0], &arg0_tmp, "CC::UserDefault:getStringForKey"); arg0 = arg0_tmp.c_str();
            if (!ok) { break; }
            std::string arg1;
            ok = rubyval_to_std_string(mrb, argv[1], &arg1, "CC::UserDefault.getStringForKey");
            if (!ok) { break; }
            std::string retval = cobj->getStringForKey(arg0, arg1);
            mrb_value ret;
            ret = mrb_str_new_cstr(mrb, retval.c_str());
            return ret;
        }
    } while (0);
    do {
        if (argc == 1) {
            const char* arg0;
            std::string arg0_tmp; ok = rubyval_to_std_string(mrb, argv[0], &arg0_tmp, "CC::UserDefault:getStringForKey"); arg0 = arg0_tmp.c_str();
            if (!ok) { break; }
            std::string retval = cobj->getStringForKey(arg0);
            mrb_value ret;
            ret = mrb_str_new_cstr(mrb, retval.c_str());
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::UserDefault#getStringForKey");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_UserDefault_setStringForKey(mrb_state* mrb, mrb_value self)
{
    cocos2d::UserDefault* cobj = static_cast<cocos2d::UserDefault*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_UserDefault_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 2) {
            const char* arg0;
            std::string arg0_tmp; ok = rubyval_to_std_string(mrb, argv[0], &arg0_tmp, "CC::UserDefault:setStringForKey"); arg0 = arg0_tmp.c_str();
            if (!ok) { break; }
            std::string arg1;
            ok = rubyval_to_std_string(mrb, argv[1], &arg1, "CC::UserDefault.setStringForKey");
            if (!ok) { break; }
            cobj->setStringForKey(arg0, arg1);
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::UserDefault#setStringForKey");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_UserDefault_flush(mrb_state* mrb, mrb_value self)
{
    cocos2d::UserDefault* cobj = static_cast<cocos2d::UserDefault*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_UserDefault_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            cobj->flush();
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::UserDefault#flush");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_UserDefault_getIntegerForKey(mrb_state* mrb, mrb_value self)
{
    cocos2d::UserDefault* cobj = static_cast<cocos2d::UserDefault*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_UserDefault_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 2) {
            const char* arg0;
            std::string arg0_tmp; ok = rubyval_to_std_string(mrb, argv[0], &arg0_tmp, "CC::UserDefault:getIntegerForKey"); arg0 = arg0_tmp.c_str();
            if (!ok) { break; }
            int arg1;
            ok = rubyval_to_int32(mrb, argv[1], (int*)&arg1, "CC::UserDefault.getIntegerForKey");
            if (!ok) { break; }
            int retval = cobj->getIntegerForKey(arg0, arg1);
            mrb_value ret;
            ret = mrb_fixnum_value((mrb_int)retval);
            return ret;
        }
    } while (0);
    do {
        if (argc == 1) {
            const char* arg0;
            std::string arg0_tmp; ok = rubyval_to_std_string(mrb, argv[0], &arg0_tmp, "CC::UserDefault:getIntegerForKey"); arg0 = arg0_tmp.c_str();
            if (!ok) { break; }
            int retval = cobj->getIntegerForKey(arg0);
            mrb_value ret;
            ret = mrb_fixnum_value((mrb_int)retval);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::UserDefault#getIntegerForKey");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_UserDefault_getDoubleForKey(mrb_state* mrb, mrb_value self)
{
    cocos2d::UserDefault* cobj = static_cast<cocos2d::UserDefault*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_UserDefault_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 2) {
            const char* arg0;
            std::string arg0_tmp; ok = rubyval_to_std_string(mrb, argv[0], &arg0_tmp, "CC::UserDefault:getDoubleForKey"); arg0 = arg0_tmp.c_str();
            if (!ok) { break; }
            double arg1;
            ok = rubyval_to_number(mrb, argv[1], &arg1, "CC::UserDefault.getDoubleForKey");
            if (!ok) { break; }
            double retval = cobj->getDoubleForKey(arg0, arg1);
            mrb_value ret;
            ret = mrb_float_value(mrb, (mrb_float)retval);
            return ret;
        }
    } while (0);
    do {
        if (argc == 1) {
            const char* arg0;
            std::string arg0_tmp; ok = rubyval_to_std_string(mrb, argv[0], &arg0_tmp, "CC::UserDefault:getDoubleForKey"); arg0 = arg0_tmp.c_str();
            if (!ok) { break; }
            double retval = cobj->getDoubleForKey(arg0);
            mrb_value ret;
            ret = mrb_float_value(mrb, (mrb_float)retval);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::UserDefault#getDoubleForKey");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_UserDefault_setBoolForKey(mrb_state* mrb, mrb_value self)
{
    cocos2d::UserDefault* cobj = static_cast<cocos2d::UserDefault*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_UserDefault_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 2) {
            const char* arg0;
            std::string arg0_tmp; ok = rubyval_to_std_string(mrb, argv[0], &arg0_tmp, "CC::UserDefault:setBoolForKey"); arg0 = arg0_tmp.c_str();
            if (!ok) { break; }
            bool arg1;
            ok = rubyval_to_boolean(mrb, argv[1], &arg1, "CC::UserDefault.setBoolForKey");
            if (!ok) { break; }
            cobj->setBoolForKey(arg0, arg1);
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::UserDefault#setBoolForKey");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_UserDefault_destroyInstance_static(mrb_state* mrb, mrb_value self)
{
    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            cocos2d::UserDefault::destroyInstance();
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined static method : cocos2d::UserDefault#destroyInstance");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_UserDefault_getXMLFilePath_static(mrb_state* mrb, mrb_value self)
{
    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            std::string retval = cocos2d::UserDefault::getXMLFilePath();
            mrb_value ret;
            ret = mrb_str_new_cstr(mrb, retval.c_str());
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined static method : cocos2d::UserDefault#getXMLFilePath");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_UserDefault_isXMLFileExist_static(mrb_state* mrb, mrb_value self)
{
    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            bool retval = cocos2d::UserDefault::isXMLFileExist();
            mrb_value ret;
            ret = mrb_bool_value((mrb_bool)retval);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined static method : cocos2d::UserDefault#isXMLFileExist");

    return mrb_nil_value();
}

void ruby_register_cocos2dx_UserDefault(mrb_state* mrb, struct RClass* rmodule)
{
    std::string typeName = typeid(cocos2d::UserDefault).name();
    g_rubyType[typeName] = "CC::UserDefault";
    g_rubyDataType[typeName] = &ruby_cocos2dx_UserDefault_type;

    struct RClass *rclass = mrb_define_class_under(mrb, rmodule, "UserDefault", mrb->object_class);
    MRB_SET_INSTANCE_TT(rclass, MRB_TT_DATA);

    mrb_define_method(mrb, rclass, "set_integer_for_key", ruby_cocos2dx_UserDefault_setIntegerForKey, ARGS_REQ(2));
    mrb_define_method(mrb, rclass, "get_float_for_key", ruby_cocos2dx_UserDefault_getFloatForKey, ARGS_REQ(1)|ARGS_OPT(1));
    mrb_define_method(mrb, rclass, "get_bool_for_key", ruby_cocos2dx_UserDefault_getBoolForKey, ARGS_REQ(1)|ARGS_OPT(1));
    mrb_define_method(mrb, rclass, "set_double_for_key", ruby_cocos2dx_UserDefault_setDoubleForKey, ARGS_REQ(2));
    mrb_define_method(mrb, rclass, "set_float_for_key", ruby_cocos2dx_UserDefault_setFloatForKey, ARGS_REQ(2));
    mrb_define_method(mrb, rclass, "get_string_for_key", ruby_cocos2dx_UserDefault_getStringForKey, ARGS_REQ(1)|ARGS_OPT(1));
    mrb_define_method(mrb, rclass, "set_string_for_key", ruby_cocos2dx_UserDefault_setStringForKey, ARGS_REQ(2));
    mrb_define_method(mrb, rclass, "flush", ruby_cocos2dx_UserDefault_flush, ARGS_NONE());
    mrb_define_method(mrb, rclass, "get_integer_for_key", ruby_cocos2dx_UserDefault_getIntegerForKey, ARGS_REQ(1)|ARGS_OPT(1));
    mrb_define_method(mrb, rclass, "get_double_for_key", ruby_cocos2dx_UserDefault_getDoubleForKey, ARGS_REQ(1)|ARGS_OPT(1));
    mrb_define_method(mrb, rclass, "set_bool_for_key", ruby_cocos2dx_UserDefault_setBoolForKey, ARGS_REQ(2));
    mrb_define_class_method(mrb, rclass, "destroy_instance", ruby_cocos2dx_UserDefault_destroyInstance_static, ARGS_NONE());
    mrb_define_class_method(mrb, rclass, "get_xmlfile_path", ruby_cocos2dx_UserDefault_getXMLFilePath_static, ARGS_NONE());
    mrb_define_class_method(mrb, rclass, "xmlfile_exist?", ruby_cocos2dx_UserDefault_isXMLFileExist_static, ARGS_NONE());
}
mrb_value ruby_cocos2dx_EventListener_setEnabled(mrb_state* mrb, mrb_value self)
{
    cocos2d::EventListener* cobj = static_cast<cocos2d::EventListener*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            bool arg0;
            ok = rubyval_to_boolean(mrb, argv[0], &arg0, "CC::EventListener.setEnabled");
            if (!ok) { break; }
            cobj->setEnabled(arg0);
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::EventListener#setEnabled");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_EventListener_clone(mrb_state* mrb, mrb_value self)
{
    cocos2d::EventListener* cobj = static_cast<cocos2d::EventListener*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            cocos2d::EventListener* retval = cobj->clone();
            mrb_value ret;
            ret = object_to_rubyval<cocos2d::EventListener>(mrb, "CC::EventListener", (cocos2d::EventListener*)retval, nullptr);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::EventListener#clone");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_EventListener_isEnabled(mrb_state* mrb, mrb_value self)
{
    cocos2d::EventListener* cobj = static_cast<cocos2d::EventListener*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            bool retval = cobj->isEnabled();
            mrb_value ret;
            ret = mrb_bool_value((mrb_bool)retval);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::EventListener#isEnabled");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_EventListener_checkAvailable(mrb_state* mrb, mrb_value self)
{
    cocos2d::EventListener* cobj = static_cast<cocos2d::EventListener*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            bool retval = cobj->checkAvailable();
            mrb_value ret;
            ret = mrb_bool_value((mrb_bool)retval);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::EventListener#checkAvailable");

    return mrb_nil_value();
}

void ruby_cocos2dx_EventListener_Type_enum_init(mrb_state* mrb, struct RClass* renum)
{
    do {
        mrb_value ev = mrb_fixnum_value((mrb_int)cocos2d::EventListener::Type::UNKNOWN);
        mrb_mod_cv_set(mrb, renum, mrb_intern_cstr(mrb, "UNKNOWN"), ev);
    } while (0);

    do {
        mrb_value ev = mrb_fixnum_value((mrb_int)cocos2d::EventListener::Type::TOUCH_ONE_BY_ONE);
        mrb_mod_cv_set(mrb, renum, mrb_intern_cstr(mrb, "TOUCH_ONE_BY_ONE"), ev);
    } while (0);

    do {
        mrb_value ev = mrb_fixnum_value((mrb_int)cocos2d::EventListener::Type::TOUCH_ALL_AT_ONCE);
        mrb_mod_cv_set(mrb, renum, mrb_intern_cstr(mrb, "TOUCH_ALL_AT_ONCE"), ev);
    } while (0);

    do {
        mrb_value ev = mrb_fixnum_value((mrb_int)cocos2d::EventListener::Type::KEYBOARD);
        mrb_mod_cv_set(mrb, renum, mrb_intern_cstr(mrb, "KEYBOARD"), ev);
    } while (0);

    do {
        mrb_value ev = mrb_fixnum_value((mrb_int)cocos2d::EventListener::Type::MOUSE);
        mrb_mod_cv_set(mrb, renum, mrb_intern_cstr(mrb, "MOUSE"), ev);
    } while (0);

    do {
        mrb_value ev = mrb_fixnum_value((mrb_int)cocos2d::EventListener::Type::ACCELERATION);
        mrb_mod_cv_set(mrb, renum, mrb_intern_cstr(mrb, "ACCELERATION"), ev);
    } while (0);

    do {
        mrb_value ev = mrb_fixnum_value((mrb_int)cocos2d::EventListener::Type::FOCUS);
        mrb_mod_cv_set(mrb, renum, mrb_intern_cstr(mrb, "FOCUS"), ev);
    } while (0);

    do {
        mrb_value ev = mrb_fixnum_value((mrb_int)cocos2d::EventListener::Type::GAME_CONTROLLER);
        mrb_mod_cv_set(mrb, renum, mrb_intern_cstr(mrb, "GAME_CONTROLLER"), ev);
    } while (0);

    do {
        mrb_value ev = mrb_fixnum_value((mrb_int)cocos2d::EventListener::Type::CUSTOM);
        mrb_mod_cv_set(mrb, renum, mrb_intern_cstr(mrb, "CUSTOM"), ev);
    } while (0);

}

void ruby_register_cocos2dx_EventListener(mrb_state* mrb, struct RClass* rmodule)
{
    std::string typeName = typeid(cocos2d::EventListener).name();
    g_rubyType[typeName] = "CC::EventListener";
    g_rubyDataType[typeName] = &ruby_cocos2dx_Ref_type;

    struct RClass* p_rmodule = mrb->object_class;
    p_rmodule = mrb_module_get_under(mrb, p_rmodule, "CC");
    struct RClass* p_rclass = mrb_class_get_under(mrb, p_rmodule, "Ref");
    struct RClass *rclass = mrb_define_class_under(mrb, rmodule, "EventListener", p_rclass);
    MRB_SET_INSTANCE_TT(rclass, MRB_TT_DATA);

    mrb_define_method(mrb, rclass, "set_enabled", ruby_cocos2dx_EventListener_setEnabled, ARGS_REQ(1));
    mrb_define_method(mrb, rclass, "clone", ruby_cocos2dx_EventListener_clone, ARGS_NONE());
    mrb_define_method(mrb, rclass, "enabled?", ruby_cocos2dx_EventListener_isEnabled, ARGS_NONE());
    mrb_define_method(mrb, rclass, "check_available", ruby_cocos2dx_EventListener_checkAvailable, ARGS_NONE());
    struct RClass* renum_Type = mrb_define_module_under(mrb, rclass, "Type");
    ruby_cocos2dx_EventListener_Type_enum_init(mrb, renum_Type);
    mrb_define_class_method(mrb, renum_Type, "UNKNOWN", ruby_cocos2dx_constant_get, ARGS_NONE());
    mrb_define_class_method(mrb, renum_Type, "TOUCH_ONE_BY_ONE", ruby_cocos2dx_constant_get, ARGS_NONE());
    mrb_define_class_method(mrb, renum_Type, "TOUCH_ALL_AT_ONCE", ruby_cocos2dx_constant_get, ARGS_NONE());
    mrb_define_class_method(mrb, renum_Type, "KEYBOARD", ruby_cocos2dx_constant_get, ARGS_NONE());
    mrb_define_class_method(mrb, renum_Type, "MOUSE", ruby_cocos2dx_constant_get, ARGS_NONE());
    mrb_define_class_method(mrb, renum_Type, "ACCELERATION", ruby_cocos2dx_constant_get, ARGS_NONE());
    mrb_define_class_method(mrb, renum_Type, "FOCUS", ruby_cocos2dx_constant_get, ARGS_NONE());
    mrb_define_class_method(mrb, renum_Type, "GAME_CONTROLLER", ruby_cocos2dx_constant_get, ARGS_NONE());
    mrb_define_class_method(mrb, renum_Type, "CUSTOM", ruby_cocos2dx_constant_get, ARGS_NONE());
}
mrb_value ruby_cocos2dx_EventDispatcher_pauseEventListenersForTarget(mrb_state* mrb, mrb_value self)
{
    cocos2d::EventDispatcher* cobj = static_cast<cocos2d::EventDispatcher*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            cocos2d::Node* arg0;
            ok = rubyval_to_object<cocos2d::Node>(mrb, argv[0], "CC::Node", &arg0);
            if (!ok) { break; }
            cobj->pauseEventListenersForTarget(arg0);
            return self;
        }
    } while (0);
    do {
        if (argc == 2) {
            cocos2d::Node* arg0;
            ok = rubyval_to_object<cocos2d::Node>(mrb, argv[0], "CC::Node", &arg0);
            if (!ok) { break; }
            bool arg1;
            ok = rubyval_to_boolean(mrb, argv[1], &arg1, "CC::EventDispatcher.pauseEventListenersForTarget");
            if (!ok) { break; }
            cobj->pauseEventListenersForTarget(arg0, arg1);
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::EventDispatcher#pauseEventListenersForTarget");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_EventDispatcher_addEventListenerWithSceneGraphPriority(mrb_state* mrb, mrb_value self)
{
    cocos2d::EventDispatcher* cobj = static_cast<cocos2d::EventDispatcher*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 2) {
            cocos2d::EventListener* arg0;
            ok = rubyval_to_object<cocos2d::EventListener>(mrb, argv[0], "CC::EventListener", &arg0);
            if (!ok) { break; }
            cocos2d::Node* arg1;
            ok = rubyval_to_object<cocos2d::Node>(mrb, argv[1], "CC::Node", &arg1);
            if (!ok) { break; }
            cobj->addEventListenerWithSceneGraphPriority(arg0, arg1);
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::EventDispatcher#addEventListenerWithSceneGraphPriority");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_EventDispatcher_setEnabled(mrb_state* mrb, mrb_value self)
{
    cocos2d::EventDispatcher* cobj = static_cast<cocos2d::EventDispatcher*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            bool arg0;
            ok = rubyval_to_boolean(mrb, argv[0], &arg0, "CC::EventDispatcher.setEnabled");
            if (!ok) { break; }
            cobj->setEnabled(arg0);
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::EventDispatcher#setEnabled");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_EventDispatcher_addEventListenerWithFixedPriority(mrb_state* mrb, mrb_value self)
{
    cocos2d::EventDispatcher* cobj = static_cast<cocos2d::EventDispatcher*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 2) {
            cocos2d::EventListener* arg0;
            ok = rubyval_to_object<cocos2d::EventListener>(mrb, argv[0], "CC::EventListener", &arg0);
            if (!ok) { break; }
            int arg1;
            ok = rubyval_to_int32(mrb, argv[1], (int*)&arg1, "CC::EventDispatcher.addEventListenerWithFixedPriority");
            if (!ok) { break; }
            cobj->addEventListenerWithFixedPriority(arg0, arg1);
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::EventDispatcher#addEventListenerWithFixedPriority");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_EventDispatcher_removeEventListener(mrb_state* mrb, mrb_value self)
{
    cocos2d::EventDispatcher* cobj = static_cast<cocos2d::EventDispatcher*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            cocos2d::EventListener* arg0;
            ok = rubyval_to_object<cocos2d::EventListener>(mrb, argv[0], "CC::EventListener", &arg0);
            if (!ok) { break; }
            cobj->removeEventListener(arg0);
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::EventDispatcher#removeEventListener");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_EventDispatcher_resumeEventListenersForTarget(mrb_state* mrb, mrb_value self)
{
    cocos2d::EventDispatcher* cobj = static_cast<cocos2d::EventDispatcher*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            cocos2d::Node* arg0;
            ok = rubyval_to_object<cocos2d::Node>(mrb, argv[0], "CC::Node", &arg0);
            if (!ok) { break; }
            cobj->resumeEventListenersForTarget(arg0);
            return self;
        }
    } while (0);
    do {
        if (argc == 2) {
            cocos2d::Node* arg0;
            ok = rubyval_to_object<cocos2d::Node>(mrb, argv[0], "CC::Node", &arg0);
            if (!ok) { break; }
            bool arg1;
            ok = rubyval_to_boolean(mrb, argv[1], &arg1, "CC::EventDispatcher.resumeEventListenersForTarget");
            if (!ok) { break; }
            cobj->resumeEventListenersForTarget(arg0, arg1);
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::EventDispatcher#resumeEventListenersForTarget");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_EventDispatcher_removeEventListenersForTarget(mrb_state* mrb, mrb_value self)
{
    cocos2d::EventDispatcher* cobj = static_cast<cocos2d::EventDispatcher*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            cocos2d::Node* arg0;
            ok = rubyval_to_object<cocos2d::Node>(mrb, argv[0], "CC::Node", &arg0);
            if (!ok) { break; }
            cobj->removeEventListenersForTarget(arg0);
            return self;
        }
    } while (0);
    do {
        if (argc == 2) {
            cocos2d::Node* arg0;
            ok = rubyval_to_object<cocos2d::Node>(mrb, argv[0], "CC::Node", &arg0);
            if (!ok) { break; }
            bool arg1;
            ok = rubyval_to_boolean(mrb, argv[1], &arg1, "CC::EventDispatcher.removeEventListenersForTarget");
            if (!ok) { break; }
            cobj->removeEventListenersForTarget(arg0, arg1);
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::EventDispatcher#removeEventListenersForTarget");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_EventDispatcher_setPriority(mrb_state* mrb, mrb_value self)
{
    cocos2d::EventDispatcher* cobj = static_cast<cocos2d::EventDispatcher*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 2) {
            cocos2d::EventListener* arg0;
            ok = rubyval_to_object<cocos2d::EventListener>(mrb, argv[0], "CC::EventListener", &arg0);
            if (!ok) { break; }
            int arg1;
            ok = rubyval_to_int32(mrb, argv[1], (int*)&arg1, "CC::EventDispatcher.setPriority");
            if (!ok) { break; }
            cobj->setPriority(arg0, arg1);
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::EventDispatcher#setPriority");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_EventDispatcher_addCustomEventListener(mrb_state* mrb, mrb_value self)
{
    cocos2d::EventDispatcher* cobj = static_cast<cocos2d::EventDispatcher*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 2) {
            std::string arg0;
            ok = rubyval_to_std_string(mrb, argv[0], &arg0, "CC::EventDispatcher.addCustomEventListener");
            if (!ok) { break; }
            std::function<void (cocos2d::EventCustom *)> arg1;
            do {
			    // Lambda binding for ruby.
			    unsigned long idx = -1;
			    arg1 = [mrb, self, idx](cocos2d::EventCustom* larg0) -> void {
			        mrb_value ruby_arg0;
			        ruby_arg0 = object_to_rubyval<cocos2d::EventCustom>(mrb, "CC::EventCustom", (cocos2d::EventCustom*)larg0, nullptr);
			        mrb_value hash = mrb_iv_get(mrb, self, mrb_intern_cstr(mrb, "__callback_hash"));
			        mrb_value func = mrb_hash_get(mrb, hash, mrb_str_new_cstr(mrb, "addCustomEventListener->arg1"));
			        mrb_value mrb_ret = mrb_funcall(mrb, func, "call", 1, ruby_arg0);
			        if (mrb_exception_p(mrb_ret)) {
			            mrb_exc_raise(mrb, mrb_ret);
			        }
			    };
			    mrb_value hash = mrb_iv_get(mrb, self, mrb_intern_cstr(mrb, "__callback_hash"));
			    if (!mrb_hash_p(hash)) {
			        hash = mrb_hash_new(mrb);
			    }
			    mrb_hash_set(mrb, hash, mrb_str_new_cstr(mrb, "addCustomEventListener->arg1"), argv[1]);
			    mrb_iv_set(mrb, self, mrb_intern_cstr(mrb, "__callback_hash"), hash);
			    break;
			} while(0);
            cocos2d::EventListenerCustom* retval = cobj->addCustomEventListener(arg0, arg1);
            mrb_value ret;
            ret = object_to_rubyval<cocos2d::EventListenerCustom>(mrb, "CC::EventListenerCustom", (cocos2d::EventListenerCustom*)retval, nullptr);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::EventDispatcher#addCustomEventListener");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_EventDispatcher_dispatchEvent(mrb_state* mrb, mrb_value self)
{
    cocos2d::EventDispatcher* cobj = static_cast<cocos2d::EventDispatcher*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            cocos2d::Event* arg0;
            ok = rubyval_to_object<cocos2d::Event>(mrb, argv[0], "CC::Event", &arg0);
            if (!ok) { break; }
            cobj->dispatchEvent(arg0);
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::EventDispatcher#dispatchEvent");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_EventDispatcher_removeAllEventListeners(mrb_state* mrb, mrb_value self)
{
    cocos2d::EventDispatcher* cobj = static_cast<cocos2d::EventDispatcher*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            cobj->removeAllEventListeners();
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::EventDispatcher#removeAllEventListeners");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_EventDispatcher_removeCustomEventListeners(mrb_state* mrb, mrb_value self)
{
    cocos2d::EventDispatcher* cobj = static_cast<cocos2d::EventDispatcher*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            std::string arg0;
            ok = rubyval_to_std_string(mrb, argv[0], &arg0, "CC::EventDispatcher.removeCustomEventListeners");
            if (!ok) { break; }
            cobj->removeCustomEventListeners(arg0);
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::EventDispatcher#removeCustomEventListeners");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_EventDispatcher_isEnabled(mrb_state* mrb, mrb_value self)
{
    cocos2d::EventDispatcher* cobj = static_cast<cocos2d::EventDispatcher*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            bool retval = cobj->isEnabled();
            mrb_value ret;
            ret = mrb_bool_value((mrb_bool)retval);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::EventDispatcher#isEnabled");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_EventDispatcher_removeEventListenersForType(mrb_state* mrb, mrb_value self)
{
    cocos2d::EventDispatcher* cobj = static_cast<cocos2d::EventDispatcher*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            cocos2d::EventListener::Type arg0;
            ok = rubyval_to_int32(mrb, argv[0], (int*)&arg0, "CC::EventDispatcher.removeEventListenersForType");
            if (!ok) { break; }
            cobj->removeEventListenersForType(arg0);
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::EventDispatcher#removeEventListenersForType");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_EventDispatcher_constructor(mrb_state* mrb, mrb_value self)
{

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            cocos2d::EventDispatcher* cobj = new cocos2d::EventDispatcher();
            DATA_TYPE(self) = &ruby_cocos2dx_Ref_type;
            DATA_PTR(self) = cobj;
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::EventDispatcher#EventDispatcher");

    return mrb_nil_value();
}


void ruby_register_cocos2dx_EventDispatcher(mrb_state* mrb, struct RClass* rmodule)
{
    std::string typeName = typeid(cocos2d::EventDispatcher).name();
    g_rubyType[typeName] = "CC::EventDispatcher";
    g_rubyDataType[typeName] = &ruby_cocos2dx_Ref_type;

    struct RClass* p_rmodule = mrb->object_class;
    p_rmodule = mrb_module_get_under(mrb, p_rmodule, "CC");
    struct RClass* p_rclass = mrb_class_get_under(mrb, p_rmodule, "Ref");
    struct RClass *rclass = mrb_define_class_under(mrb, rmodule, "EventDispatcher", p_rclass);
    MRB_SET_INSTANCE_TT(rclass, MRB_TT_DATA);

    mrb_define_method(mrb, rclass, "initialize", ruby_cocos2dx_EventDispatcher_constructor, ARGS_NONE());
    mrb_define_method(mrb, rclass, "pause_event_listeners_for_target", ruby_cocos2dx_EventDispatcher_pauseEventListenersForTarget, ARGS_REQ(2));
    mrb_define_method(mrb, rclass, "add_event_listener_with_scene_graph_priority", ruby_cocos2dx_EventDispatcher_addEventListenerWithSceneGraphPriority, ARGS_REQ(2));
    mrb_define_method(mrb, rclass, "set_enabled", ruby_cocos2dx_EventDispatcher_setEnabled, ARGS_REQ(1));
    mrb_define_method(mrb, rclass, "add_event_listener_with_fixed_priority", ruby_cocos2dx_EventDispatcher_addEventListenerWithFixedPriority, ARGS_REQ(2));
    mrb_define_method(mrb, rclass, "remove_event_listener", ruby_cocos2dx_EventDispatcher_removeEventListener, ARGS_REQ(1));
    mrb_define_method(mrb, rclass, "resume_event_listeners_for_target", ruby_cocos2dx_EventDispatcher_resumeEventListenersForTarget, ARGS_REQ(2));
    mrb_define_method(mrb, rclass, "remove_event_listeners_for_target", ruby_cocos2dx_EventDispatcher_removeEventListenersForTarget, ARGS_REQ(2));
    mrb_define_method(mrb, rclass, "set_priority", ruby_cocos2dx_EventDispatcher_setPriority, ARGS_REQ(2));
    mrb_define_method(mrb, rclass, "add_custom_event_listener", ruby_cocos2dx_EventDispatcher_addCustomEventListener, ARGS_REQ(2));
    mrb_define_method(mrb, rclass, "dispatch_event", ruby_cocos2dx_EventDispatcher_dispatchEvent, ARGS_REQ(1));
    mrb_define_method(mrb, rclass, "remove_all_event_listeners", ruby_cocos2dx_EventDispatcher_removeAllEventListeners, ARGS_NONE());
    mrb_define_method(mrb, rclass, "remove_custom_event_listeners", ruby_cocos2dx_EventDispatcher_removeCustomEventListeners, ARGS_REQ(1));
    mrb_define_method(mrb, rclass, "enabled?", ruby_cocos2dx_EventDispatcher_isEnabled, ARGS_NONE());
    mrb_define_method(mrb, rclass, "remove_event_listeners_for_type", ruby_cocos2dx_EventDispatcher_removeEventListenersForType, ARGS_REQ(1));
}
mrb_value ruby_cocos2dx_EventListenerTouchOneByOne_isSwallowTouches(mrb_state* mrb, mrb_value self)
{
    cocos2d::EventListenerTouchOneByOne* cobj = static_cast<cocos2d::EventListenerTouchOneByOne*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            bool retval = cobj->isSwallowTouches();
            mrb_value ret;
            ret = mrb_bool_value((mrb_bool)retval);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::EventListenerTouchOneByOne#isSwallowTouches");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_EventListenerTouchOneByOne_setSwallowTouches(mrb_state* mrb, mrb_value self)
{
    cocos2d::EventListenerTouchOneByOne* cobj = static_cast<cocos2d::EventListenerTouchOneByOne*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            bool arg0;
            ok = rubyval_to_boolean(mrb, argv[0], &arg0, "CC::EventListenerTouchOneByOne.setSwallowTouches");
            if (!ok) { break; }
            cobj->setSwallowTouches(arg0);
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::EventListenerTouchOneByOne#setSwallowTouches");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_EventListenerTouchOneByOne_create_static(mrb_state* mrb, mrb_value self)
{
    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            std::map<std::string, mrb_value> callbacks;
            cocos2d::EventListenerTouchOneByOne* retval = cocos2d::EventListenerTouchOneByOne::create();
            mrb_value ret;
            RClass* rclass = mrb_class_ptr(self);
            ret = object_to_rubyval<cocos2d::EventListenerTouchOneByOne>(mrb, "CC::EventListenerTouchOneByOne", (cocos2d::EventListenerTouchOneByOne*)retval, rclass);
            if (callbacks.size() > 0) {
                mrb_value hash = mrb_iv_get(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"));
                if (!mrb_hash_p(hash)) {
                    hash = mrb_hash_new(mrb);
                }
                for (auto elm : callbacks) {
                    mrb_hash_set(mrb, hash, mrb_str_new_cstr(mrb, elm.first.c_str()), elm.second);
                    mrb_iv_set(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"), hash);
                }
            }
            g_rubyValue.push_back(ret);
            mrb_funcall(mrb, ret, "initialize", 0);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined static method : cocos2d::EventListenerTouchOneByOne#create");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_EventListenerTouchOneByOne_property_onTouchBegan_get(mrb_state* mrb, mrb_value self)
{
    cocos2d::EventListenerTouchOneByOne* cobj = static_cast<cocos2d::EventListenerTouchOneByOne*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value ret;
    #pragma warning NO CONVERSION FROM NATIVE FOR std::function;
    return ret;
}

mrb_value ruby_cocos2dx_EventListenerTouchOneByOne_property_onTouchBegan_set(mrb_state* mrb, mrb_value self)
{
    cocos2d::EventListenerTouchOneByOne* cobj = static_cast<cocos2d::EventListenerTouchOneByOne*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value argv;
    mrb_get_args(mrb, "o", &argv);

    bool ok = true;
    cocos2d::EventListenerTouchOneByOne::ccTouchBeganCallback val;
    do {
	    // Lambda binding for ruby.
	    unsigned long idx = -1;
	    val = [mrb, self, idx](cocos2d::Touch* larg0, cocos2d::Event* larg1) -> bool {
	        mrb_value ruby_arg0;
	        ruby_arg0 = object_to_rubyval<cocos2d::Touch>(mrb, "CC::Touch", (cocos2d::Touch*)larg0, nullptr);
	        mrb_value ruby_arg1;
	        ruby_arg1 = object_to_rubyval<cocos2d::Event>(mrb, "CC::Event", (cocos2d::Event*)larg1, nullptr);
	        mrb_value hash = mrb_iv_get(mrb, self, mrb_intern_cstr(mrb, "__callback_hash"));
	        mrb_value func = mrb_hash_get(mrb, hash, mrb_str_new_cstr(mrb, "onTouchBegan->val"));
	        mrb_value mrb_ret = mrb_funcall(mrb, func, "call", 2, ruby_arg0, ruby_arg1);
	        if (mrb_exception_p(mrb_ret)) {
	            mrb_exc_raise(mrb, mrb_ret);
	        }
	        bool ok = true;
	        bool lret;
	        ok = rubyval_to_boolean(mrb, mrb_ret, &lret, ".Proc.call");
	        return lret;
	    };
	    mrb_value hash = mrb_iv_get(mrb, self, mrb_intern_cstr(mrb, "__callback_hash"));
	    if (!mrb_hash_p(hash)) {
	        hash = mrb_hash_new(mrb);
	    }
	    mrb_hash_set(mrb, hash, mrb_str_new_cstr(mrb, "onTouchBegan->val"), argv);
	    mrb_iv_set(mrb, self, mrb_intern_cstr(mrb, "__callback_hash"), hash);
	    break;
	} while(0);
    if (! ok) {
        mrb_raise(mrb, E_RUNTIME_ERROR, "convert to native failed : EventListenerTouchOneByOne#onTouchBegan");
    }
    cobj->onTouchBegan = val;

    return self;
}

mrb_value ruby_cocos2dx_EventListenerTouchOneByOne_property_onTouchMoved_get(mrb_state* mrb, mrb_value self)
{
    cocos2d::EventListenerTouchOneByOne* cobj = static_cast<cocos2d::EventListenerTouchOneByOne*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value ret;
    #pragma warning NO CONVERSION FROM NATIVE FOR std::function;
    return ret;
}

mrb_value ruby_cocos2dx_EventListenerTouchOneByOne_property_onTouchMoved_set(mrb_state* mrb, mrb_value self)
{
    cocos2d::EventListenerTouchOneByOne* cobj = static_cast<cocos2d::EventListenerTouchOneByOne*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value argv;
    mrb_get_args(mrb, "o", &argv);

    bool ok = true;
    cocos2d::EventListenerTouchOneByOne::ccTouchCallback val;
    do {
	    // Lambda binding for ruby.
	    unsigned long idx = -1;
	    val = [mrb, self, idx](cocos2d::Touch* larg0, cocos2d::Event* larg1) -> void {
	        mrb_value ruby_arg0;
	        ruby_arg0 = object_to_rubyval<cocos2d::Touch>(mrb, "CC::Touch", (cocos2d::Touch*)larg0, nullptr);
	        mrb_value ruby_arg1;
	        ruby_arg1 = object_to_rubyval<cocos2d::Event>(mrb, "CC::Event", (cocos2d::Event*)larg1, nullptr);
	        mrb_value hash = mrb_iv_get(mrb, self, mrb_intern_cstr(mrb, "__callback_hash"));
	        mrb_value func = mrb_hash_get(mrb, hash, mrb_str_new_cstr(mrb, "onTouchMoved->val"));
	        mrb_value mrb_ret = mrb_funcall(mrb, func, "call", 2, ruby_arg0, ruby_arg1);
	        if (mrb_exception_p(mrb_ret)) {
	            mrb_exc_raise(mrb, mrb_ret);
	        }
	    };
	    mrb_value hash = mrb_iv_get(mrb, self, mrb_intern_cstr(mrb, "__callback_hash"));
	    if (!mrb_hash_p(hash)) {
	        hash = mrb_hash_new(mrb);
	    }
	    mrb_hash_set(mrb, hash, mrb_str_new_cstr(mrb, "onTouchMoved->val"), argv);
	    mrb_iv_set(mrb, self, mrb_intern_cstr(mrb, "__callback_hash"), hash);
	    break;
	} while(0);
    if (! ok) {
        mrb_raise(mrb, E_RUNTIME_ERROR, "convert to native failed : EventListenerTouchOneByOne#onTouchMoved");
    }
    cobj->onTouchMoved = val;

    return self;
}

mrb_value ruby_cocos2dx_EventListenerTouchOneByOne_property_onTouchEnded_get(mrb_state* mrb, mrb_value self)
{
    cocos2d::EventListenerTouchOneByOne* cobj = static_cast<cocos2d::EventListenerTouchOneByOne*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value ret;
    #pragma warning NO CONVERSION FROM NATIVE FOR std::function;
    return ret;
}

mrb_value ruby_cocos2dx_EventListenerTouchOneByOne_property_onTouchEnded_set(mrb_state* mrb, mrb_value self)
{
    cocos2d::EventListenerTouchOneByOne* cobj = static_cast<cocos2d::EventListenerTouchOneByOne*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value argv;
    mrb_get_args(mrb, "o", &argv);

    bool ok = true;
    cocos2d::EventListenerTouchOneByOne::ccTouchCallback val;
    do {
	    // Lambda binding for ruby.
	    unsigned long idx = -1;
	    val = [mrb, self, idx](cocos2d::Touch* larg0, cocos2d::Event* larg1) -> void {
	        mrb_value ruby_arg0;
	        ruby_arg0 = object_to_rubyval<cocos2d::Touch>(mrb, "CC::Touch", (cocos2d::Touch*)larg0, nullptr);
	        mrb_value ruby_arg1;
	        ruby_arg1 = object_to_rubyval<cocos2d::Event>(mrb, "CC::Event", (cocos2d::Event*)larg1, nullptr);
	        mrb_value hash = mrb_iv_get(mrb, self, mrb_intern_cstr(mrb, "__callback_hash"));
	        mrb_value func = mrb_hash_get(mrb, hash, mrb_str_new_cstr(mrb, "onTouchEnded->val"));
	        mrb_value mrb_ret = mrb_funcall(mrb, func, "call", 2, ruby_arg0, ruby_arg1);
	        if (mrb_exception_p(mrb_ret)) {
	            mrb_exc_raise(mrb, mrb_ret);
	        }
	    };
	    mrb_value hash = mrb_iv_get(mrb, self, mrb_intern_cstr(mrb, "__callback_hash"));
	    if (!mrb_hash_p(hash)) {
	        hash = mrb_hash_new(mrb);
	    }
	    mrb_hash_set(mrb, hash, mrb_str_new_cstr(mrb, "onTouchEnded->val"), argv);
	    mrb_iv_set(mrb, self, mrb_intern_cstr(mrb, "__callback_hash"), hash);
	    break;
	} while(0);
    if (! ok) {
        mrb_raise(mrb, E_RUNTIME_ERROR, "convert to native failed : EventListenerTouchOneByOne#onTouchEnded");
    }
    cobj->onTouchEnded = val;

    return self;
}

mrb_value ruby_cocos2dx_EventListenerTouchOneByOne_property_onTouchCancelled_get(mrb_state* mrb, mrb_value self)
{
    cocos2d::EventListenerTouchOneByOne* cobj = static_cast<cocos2d::EventListenerTouchOneByOne*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value ret;
    #pragma warning NO CONVERSION FROM NATIVE FOR std::function;
    return ret;
}

mrb_value ruby_cocos2dx_EventListenerTouchOneByOne_property_onTouchCancelled_set(mrb_state* mrb, mrb_value self)
{
    cocos2d::EventListenerTouchOneByOne* cobj = static_cast<cocos2d::EventListenerTouchOneByOne*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value argv;
    mrb_get_args(mrb, "o", &argv);

    bool ok = true;
    cocos2d::EventListenerTouchOneByOne::ccTouchCallback val;
    do {
	    // Lambda binding for ruby.
	    unsigned long idx = -1;
	    val = [mrb, self, idx](cocos2d::Touch* larg0, cocos2d::Event* larg1) -> void {
	        mrb_value ruby_arg0;
	        ruby_arg0 = object_to_rubyval<cocos2d::Touch>(mrb, "CC::Touch", (cocos2d::Touch*)larg0, nullptr);
	        mrb_value ruby_arg1;
	        ruby_arg1 = object_to_rubyval<cocos2d::Event>(mrb, "CC::Event", (cocos2d::Event*)larg1, nullptr);
	        mrb_value hash = mrb_iv_get(mrb, self, mrb_intern_cstr(mrb, "__callback_hash"));
	        mrb_value func = mrb_hash_get(mrb, hash, mrb_str_new_cstr(mrb, "onTouchCancelled->val"));
	        mrb_value mrb_ret = mrb_funcall(mrb, func, "call", 2, ruby_arg0, ruby_arg1);
	        if (mrb_exception_p(mrb_ret)) {
	            mrb_exc_raise(mrb, mrb_ret);
	        }
	    };
	    mrb_value hash = mrb_iv_get(mrb, self, mrb_intern_cstr(mrb, "__callback_hash"));
	    if (!mrb_hash_p(hash)) {
	        hash = mrb_hash_new(mrb);
	    }
	    mrb_hash_set(mrb, hash, mrb_str_new_cstr(mrb, "onTouchCancelled->val"), argv);
	    mrb_iv_set(mrb, self, mrb_intern_cstr(mrb, "__callback_hash"), hash);
	    break;
	} while(0);
    if (! ok) {
        mrb_raise(mrb, E_RUNTIME_ERROR, "convert to native failed : EventListenerTouchOneByOne#onTouchCancelled");
    }
    cobj->onTouchCancelled = val;

    return self;
}

void ruby_cocos2dx_EventListenerTouchOneByOne_constants_init(mrb_state* mrb, struct RClass* rclass)
{
    do {
        mrb_value ret;
        ret = mrb_str_new_cstr(mrb, cocos2d::EventListenerTouchOneByOne::LISTENER_ID.c_str());
        mrb_mod_cv_set(mrb, rclass, mrb_intern_cstr(mrb, "LISTENER_ID"), ret);
    } while (0);

}

void ruby_register_cocos2dx_EventListenerTouchOneByOne(mrb_state* mrb, struct RClass* rmodule)
{
    std::string typeName = typeid(cocos2d::EventListenerTouchOneByOne).name();
    g_rubyType[typeName] = "CC::EventListenerTouchOneByOne";
    g_rubyDataType[typeName] = &ruby_cocos2dx_Ref_type;

    struct RClass* p_rmodule = mrb->object_class;
    p_rmodule = mrb_module_get_under(mrb, p_rmodule, "CC");
    struct RClass* p_rclass = mrb_class_get_under(mrb, p_rmodule, "EventListener");
    struct RClass *rclass = mrb_define_class_under(mrb, rmodule, "EventListenerTouchOneByOne", p_rclass);
    MRB_SET_INSTANCE_TT(rclass, MRB_TT_DATA);

    mrb_define_method(mrb, rclass, "swallow_touches?", ruby_cocos2dx_EventListenerTouchOneByOne_isSwallowTouches, ARGS_NONE());
    mrb_define_method(mrb, rclass, "set_swallow_touches", ruby_cocos2dx_EventListenerTouchOneByOne_setSwallowTouches, ARGS_REQ(1));
    mrb_define_class_method(mrb, rclass, "create", ruby_cocos2dx_EventListenerTouchOneByOne_create_static, ARGS_NONE());
    mrb_define_method(mrb, rclass, "on_touch_began", ruby_cocos2dx_EventListenerTouchOneByOne_property_onTouchBegan_get, ARGS_NONE());
    mrb_define_method(mrb, rclass, "on_touch_began=", ruby_cocos2dx_EventListenerTouchOneByOne_property_onTouchBegan_set, ARGS_REQ(1));
    mrb_define_method(mrb, rclass, "on_touch_moved", ruby_cocos2dx_EventListenerTouchOneByOne_property_onTouchMoved_get, ARGS_NONE());
    mrb_define_method(mrb, rclass, "on_touch_moved=", ruby_cocos2dx_EventListenerTouchOneByOne_property_onTouchMoved_set, ARGS_REQ(1));
    mrb_define_method(mrb, rclass, "on_touch_ended", ruby_cocos2dx_EventListenerTouchOneByOne_property_onTouchEnded_get, ARGS_NONE());
    mrb_define_method(mrb, rclass, "on_touch_ended=", ruby_cocos2dx_EventListenerTouchOneByOne_property_onTouchEnded_set, ARGS_REQ(1));
    mrb_define_method(mrb, rclass, "on_touch_cancelled", ruby_cocos2dx_EventListenerTouchOneByOne_property_onTouchCancelled_get, ARGS_NONE());
    mrb_define_method(mrb, rclass, "on_touch_cancelled=", ruby_cocos2dx_EventListenerTouchOneByOne_property_onTouchCancelled_set, ARGS_REQ(1));
    ruby_cocos2dx_EventListenerTouchOneByOne_constants_init(mrb, rclass);
    mrb_define_class_method(mrb, rclass, "LISTENER_ID", ruby_cocos2dx_constant_get, ARGS_NONE());
}
mrb_value ruby_cocos2dx_EventListenerTouchAllAtOnce_create_static(mrb_state* mrb, mrb_value self)
{
    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            std::map<std::string, mrb_value> callbacks;
            cocos2d::EventListenerTouchAllAtOnce* retval = cocos2d::EventListenerTouchAllAtOnce::create();
            mrb_value ret;
            RClass* rclass = mrb_class_ptr(self);
            ret = object_to_rubyval<cocos2d::EventListenerTouchAllAtOnce>(mrb, "CC::EventListenerTouchAllAtOnce", (cocos2d::EventListenerTouchAllAtOnce*)retval, rclass);
            if (callbacks.size() > 0) {
                mrb_value hash = mrb_iv_get(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"));
                if (!mrb_hash_p(hash)) {
                    hash = mrb_hash_new(mrb);
                }
                for (auto elm : callbacks) {
                    mrb_hash_set(mrb, hash, mrb_str_new_cstr(mrb, elm.first.c_str()), elm.second);
                    mrb_iv_set(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"), hash);
                }
            }
            g_rubyValue.push_back(ret);
            mrb_funcall(mrb, ret, "initialize", 0);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined static method : cocos2d::EventListenerTouchAllAtOnce#create");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_EventListenerTouchAllAtOnce_property_onTouchesBegan_get(mrb_state* mrb, mrb_value self)
{
    cocos2d::EventListenerTouchAllAtOnce* cobj = static_cast<cocos2d::EventListenerTouchAllAtOnce*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value ret;
    #pragma warning NO CONVERSION FROM NATIVE FOR std::function;
    return ret;
}

mrb_value ruby_cocos2dx_EventListenerTouchAllAtOnce_property_onTouchesBegan_set(mrb_state* mrb, mrb_value self)
{
    cocos2d::EventListenerTouchAllAtOnce* cobj = static_cast<cocos2d::EventListenerTouchAllAtOnce*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value argv;
    mrb_get_args(mrb, "o", &argv);

    bool ok = true;
    cocos2d::EventListenerTouchAllAtOnce::ccTouchesCallback val;
    do {
	    // Lambda binding for ruby.
	    unsigned long idx = -1;
	    val = [mrb, self, idx](const std::vector<cocos2d::Touch*> & larg0, cocos2d::Event* larg1) -> void {
	        mrb_value ruby_arg0;
	        ruby_arg0 = std_vector_object_to_rubyval(mrb, larg0, "CC::Touch");
	        mrb_value ruby_arg1;
	        ruby_arg1 = object_to_rubyval<cocos2d::Event>(mrb, "CC::Event", (cocos2d::Event*)larg1, nullptr);
	        mrb_value hash = mrb_iv_get(mrb, self, mrb_intern_cstr(mrb, "__callback_hash"));
	        mrb_value func = mrb_hash_get(mrb, hash, mrb_str_new_cstr(mrb, "onTouchesBegan->val"));
	        mrb_value mrb_ret = mrb_funcall(mrb, func, "call", 2, ruby_arg0, ruby_arg1);
	        if (mrb_exception_p(mrb_ret)) {
	            mrb_exc_raise(mrb, mrb_ret);
	        }
	    };
	    mrb_value hash = mrb_iv_get(mrb, self, mrb_intern_cstr(mrb, "__callback_hash"));
	    if (!mrb_hash_p(hash)) {
	        hash = mrb_hash_new(mrb);
	    }
	    mrb_hash_set(mrb, hash, mrb_str_new_cstr(mrb, "onTouchesBegan->val"), argv);
	    mrb_iv_set(mrb, self, mrb_intern_cstr(mrb, "__callback_hash"), hash);
	    break;
	} while(0);
    if (! ok) {
        mrb_raise(mrb, E_RUNTIME_ERROR, "convert to native failed : EventListenerTouchAllAtOnce#onTouchesBegan");
    }
    cobj->onTouchesBegan = val;

    return self;
}

mrb_value ruby_cocos2dx_EventListenerTouchAllAtOnce_property_onTouchesMoved_get(mrb_state* mrb, mrb_value self)
{
    cocos2d::EventListenerTouchAllAtOnce* cobj = static_cast<cocos2d::EventListenerTouchAllAtOnce*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value ret;
    #pragma warning NO CONVERSION FROM NATIVE FOR std::function;
    return ret;
}

mrb_value ruby_cocos2dx_EventListenerTouchAllAtOnce_property_onTouchesMoved_set(mrb_state* mrb, mrb_value self)
{
    cocos2d::EventListenerTouchAllAtOnce* cobj = static_cast<cocos2d::EventListenerTouchAllAtOnce*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value argv;
    mrb_get_args(mrb, "o", &argv);

    bool ok = true;
    cocos2d::EventListenerTouchAllAtOnce::ccTouchesCallback val;
    do {
	    // Lambda binding for ruby.
	    unsigned long idx = -1;
	    val = [mrb, self, idx](const std::vector<cocos2d::Touch*> & larg0, cocos2d::Event* larg1) -> void {
	        mrb_value ruby_arg0;
	        ruby_arg0 = std_vector_object_to_rubyval(mrb, larg0, "CC::Touch");
	        mrb_value ruby_arg1;
	        ruby_arg1 = object_to_rubyval<cocos2d::Event>(mrb, "CC::Event", (cocos2d::Event*)larg1, nullptr);
	        mrb_value hash = mrb_iv_get(mrb, self, mrb_intern_cstr(mrb, "__callback_hash"));
	        mrb_value func = mrb_hash_get(mrb, hash, mrb_str_new_cstr(mrb, "onTouchesMoved->val"));
	        mrb_value mrb_ret = mrb_funcall(mrb, func, "call", 2, ruby_arg0, ruby_arg1);
	        if (mrb_exception_p(mrb_ret)) {
	            mrb_exc_raise(mrb, mrb_ret);
	        }
	    };
	    mrb_value hash = mrb_iv_get(mrb, self, mrb_intern_cstr(mrb, "__callback_hash"));
	    if (!mrb_hash_p(hash)) {
	        hash = mrb_hash_new(mrb);
	    }
	    mrb_hash_set(mrb, hash, mrb_str_new_cstr(mrb, "onTouchesMoved->val"), argv);
	    mrb_iv_set(mrb, self, mrb_intern_cstr(mrb, "__callback_hash"), hash);
	    break;
	} while(0);
    if (! ok) {
        mrb_raise(mrb, E_RUNTIME_ERROR, "convert to native failed : EventListenerTouchAllAtOnce#onTouchesMoved");
    }
    cobj->onTouchesMoved = val;

    return self;
}

mrb_value ruby_cocos2dx_EventListenerTouchAllAtOnce_property_onTouchesEnded_get(mrb_state* mrb, mrb_value self)
{
    cocos2d::EventListenerTouchAllAtOnce* cobj = static_cast<cocos2d::EventListenerTouchAllAtOnce*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value ret;
    #pragma warning NO CONVERSION FROM NATIVE FOR std::function;
    return ret;
}

mrb_value ruby_cocos2dx_EventListenerTouchAllAtOnce_property_onTouchesEnded_set(mrb_state* mrb, mrb_value self)
{
    cocos2d::EventListenerTouchAllAtOnce* cobj = static_cast<cocos2d::EventListenerTouchAllAtOnce*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value argv;
    mrb_get_args(mrb, "o", &argv);

    bool ok = true;
    cocos2d::EventListenerTouchAllAtOnce::ccTouchesCallback val;
    do {
	    // Lambda binding for ruby.
	    unsigned long idx = -1;
	    val = [mrb, self, idx](const std::vector<cocos2d::Touch*> & larg0, cocos2d::Event* larg1) -> void {
	        mrb_value ruby_arg0;
	        ruby_arg0 = std_vector_object_to_rubyval(mrb, larg0, "CC::Touch");
	        mrb_value ruby_arg1;
	        ruby_arg1 = object_to_rubyval<cocos2d::Event>(mrb, "CC::Event", (cocos2d::Event*)larg1, nullptr);
	        mrb_value hash = mrb_iv_get(mrb, self, mrb_intern_cstr(mrb, "__callback_hash"));
	        mrb_value func = mrb_hash_get(mrb, hash, mrb_str_new_cstr(mrb, "onTouchesEnded->val"));
	        mrb_value mrb_ret = mrb_funcall(mrb, func, "call", 2, ruby_arg0, ruby_arg1);
	        if (mrb_exception_p(mrb_ret)) {
	            mrb_exc_raise(mrb, mrb_ret);
	        }
	    };
	    mrb_value hash = mrb_iv_get(mrb, self, mrb_intern_cstr(mrb, "__callback_hash"));
	    if (!mrb_hash_p(hash)) {
	        hash = mrb_hash_new(mrb);
	    }
	    mrb_hash_set(mrb, hash, mrb_str_new_cstr(mrb, "onTouchesEnded->val"), argv);
	    mrb_iv_set(mrb, self, mrb_intern_cstr(mrb, "__callback_hash"), hash);
	    break;
	} while(0);
    if (! ok) {
        mrb_raise(mrb, E_RUNTIME_ERROR, "convert to native failed : EventListenerTouchAllAtOnce#onTouchesEnded");
    }
    cobj->onTouchesEnded = val;

    return self;
}

mrb_value ruby_cocos2dx_EventListenerTouchAllAtOnce_property_onTouchesCancelled_get(mrb_state* mrb, mrb_value self)
{
    cocos2d::EventListenerTouchAllAtOnce* cobj = static_cast<cocos2d::EventListenerTouchAllAtOnce*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value ret;
    #pragma warning NO CONVERSION FROM NATIVE FOR std::function;
    return ret;
}

mrb_value ruby_cocos2dx_EventListenerTouchAllAtOnce_property_onTouchesCancelled_set(mrb_state* mrb, mrb_value self)
{
    cocos2d::EventListenerTouchAllAtOnce* cobj = static_cast<cocos2d::EventListenerTouchAllAtOnce*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value argv;
    mrb_get_args(mrb, "o", &argv);

    bool ok = true;
    cocos2d::EventListenerTouchAllAtOnce::ccTouchesCallback val;
    do {
	    // Lambda binding for ruby.
	    unsigned long idx = -1;
	    val = [mrb, self, idx](const std::vector<cocos2d::Touch*> & larg0, cocos2d::Event* larg1) -> void {
	        mrb_value ruby_arg0;
	        ruby_arg0 = std_vector_object_to_rubyval(mrb, larg0, "CC::Touch");
	        mrb_value ruby_arg1;
	        ruby_arg1 = object_to_rubyval<cocos2d::Event>(mrb, "CC::Event", (cocos2d::Event*)larg1, nullptr);
	        mrb_value hash = mrb_iv_get(mrb, self, mrb_intern_cstr(mrb, "__callback_hash"));
	        mrb_value func = mrb_hash_get(mrb, hash, mrb_str_new_cstr(mrb, "onTouchesCancelled->val"));
	        mrb_value mrb_ret = mrb_funcall(mrb, func, "call", 2, ruby_arg0, ruby_arg1);
	        if (mrb_exception_p(mrb_ret)) {
	            mrb_exc_raise(mrb, mrb_ret);
	        }
	    };
	    mrb_value hash = mrb_iv_get(mrb, self, mrb_intern_cstr(mrb, "__callback_hash"));
	    if (!mrb_hash_p(hash)) {
	        hash = mrb_hash_new(mrb);
	    }
	    mrb_hash_set(mrb, hash, mrb_str_new_cstr(mrb, "onTouchesCancelled->val"), argv);
	    mrb_iv_set(mrb, self, mrb_intern_cstr(mrb, "__callback_hash"), hash);
	    break;
	} while(0);
    if (! ok) {
        mrb_raise(mrb, E_RUNTIME_ERROR, "convert to native failed : EventListenerTouchAllAtOnce#onTouchesCancelled");
    }
    cobj->onTouchesCancelled = val;

    return self;
}

void ruby_cocos2dx_EventListenerTouchAllAtOnce_constants_init(mrb_state* mrb, struct RClass* rclass)
{
    do {
        mrb_value ret;
        ret = mrb_str_new_cstr(mrb, cocos2d::EventListenerTouchAllAtOnce::LISTENER_ID.c_str());
        mrb_mod_cv_set(mrb, rclass, mrb_intern_cstr(mrb, "LISTENER_ID"), ret);
    } while (0);

}

void ruby_register_cocos2dx_EventListenerTouchAllAtOnce(mrb_state* mrb, struct RClass* rmodule)
{
    std::string typeName = typeid(cocos2d::EventListenerTouchAllAtOnce).name();
    g_rubyType[typeName] = "CC::EventListenerTouchAllAtOnce";
    g_rubyDataType[typeName] = &ruby_cocos2dx_Ref_type;

    struct RClass* p_rmodule = mrb->object_class;
    p_rmodule = mrb_module_get_under(mrb, p_rmodule, "CC");
    struct RClass* p_rclass = mrb_class_get_under(mrb, p_rmodule, "EventListener");
    struct RClass *rclass = mrb_define_class_under(mrb, rmodule, "EventListenerTouchAllAtOnce", p_rclass);
    MRB_SET_INSTANCE_TT(rclass, MRB_TT_DATA);

    mrb_define_class_method(mrb, rclass, "create", ruby_cocos2dx_EventListenerTouchAllAtOnce_create_static, ARGS_NONE());
    mrb_define_method(mrb, rclass, "on_touches_began", ruby_cocos2dx_EventListenerTouchAllAtOnce_property_onTouchesBegan_get, ARGS_NONE());
    mrb_define_method(mrb, rclass, "on_touches_began=", ruby_cocos2dx_EventListenerTouchAllAtOnce_property_onTouchesBegan_set, ARGS_REQ(1));
    mrb_define_method(mrb, rclass, "on_touches_moved", ruby_cocos2dx_EventListenerTouchAllAtOnce_property_onTouchesMoved_get, ARGS_NONE());
    mrb_define_method(mrb, rclass, "on_touches_moved=", ruby_cocos2dx_EventListenerTouchAllAtOnce_property_onTouchesMoved_set, ARGS_REQ(1));
    mrb_define_method(mrb, rclass, "on_touches_ended", ruby_cocos2dx_EventListenerTouchAllAtOnce_property_onTouchesEnded_get, ARGS_NONE());
    mrb_define_method(mrb, rclass, "on_touches_ended=", ruby_cocos2dx_EventListenerTouchAllAtOnce_property_onTouchesEnded_set, ARGS_REQ(1));
    mrb_define_method(mrb, rclass, "on_touches_cancelled", ruby_cocos2dx_EventListenerTouchAllAtOnce_property_onTouchesCancelled_get, ARGS_NONE());
    mrb_define_method(mrb, rclass, "on_touches_cancelled=", ruby_cocos2dx_EventListenerTouchAllAtOnce_property_onTouchesCancelled_set, ARGS_REQ(1));
    ruby_cocos2dx_EventListenerTouchAllAtOnce_constants_init(mrb, rclass);
    mrb_define_class_method(mrb, rclass, "LISTENER_ID", ruby_cocos2dx_constant_get, ARGS_NONE());
}
mrb_value ruby_cocos2dx_EventListenerKeyboard_create_static(mrb_state* mrb, mrb_value self)
{
    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            std::map<std::string, mrb_value> callbacks;
            cocos2d::EventListenerKeyboard* retval = cocos2d::EventListenerKeyboard::create();
            mrb_value ret;
            RClass* rclass = mrb_class_ptr(self);
            ret = object_to_rubyval<cocos2d::EventListenerKeyboard>(mrb, "CC::EventListenerKeyboard", (cocos2d::EventListenerKeyboard*)retval, rclass);
            if (callbacks.size() > 0) {
                mrb_value hash = mrb_iv_get(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"));
                if (!mrb_hash_p(hash)) {
                    hash = mrb_hash_new(mrb);
                }
                for (auto elm : callbacks) {
                    mrb_hash_set(mrb, hash, mrb_str_new_cstr(mrb, elm.first.c_str()), elm.second);
                    mrb_iv_set(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"), hash);
                }
            }
            g_rubyValue.push_back(ret);
            mrb_funcall(mrb, ret, "initialize", 0);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined static method : cocos2d::EventListenerKeyboard#create");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_EventListenerKeyboard_property_onKeyPressed_get(mrb_state* mrb, mrb_value self)
{
    cocos2d::EventListenerKeyboard* cobj = static_cast<cocos2d::EventListenerKeyboard*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value ret;
    #pragma warning NO CONVERSION FROM NATIVE FOR std::function;
    return ret;
}

mrb_value ruby_cocos2dx_EventListenerKeyboard_property_onKeyPressed_set(mrb_state* mrb, mrb_value self)
{
    cocos2d::EventListenerKeyboard* cobj = static_cast<cocos2d::EventListenerKeyboard*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value argv;
    mrb_get_args(mrb, "o", &argv);

    bool ok = true;
    std::function<void (cocos2d::EventKeyboard::KeyCode, cocos2d::Event *)> val;
    do {
	    // Lambda binding for ruby.
	    unsigned long idx = -1;
	    val = [mrb, self, idx](cocos2d::EventKeyboard::KeyCode larg0, cocos2d::Event* larg1) -> void {
	        mrb_value ruby_arg0;
	        ruby_arg0 = mrb_fixnum_value((mrb_int)larg0);
	        mrb_value ruby_arg1;
	        ruby_arg1 = object_to_rubyval<cocos2d::Event>(mrb, "CC::Event", (cocos2d::Event*)larg1, nullptr);
	        mrb_value hash = mrb_iv_get(mrb, self, mrb_intern_cstr(mrb, "__callback_hash"));
	        mrb_value func = mrb_hash_get(mrb, hash, mrb_str_new_cstr(mrb, "onKeyPressed->val"));
	        mrb_value mrb_ret = mrb_funcall(mrb, func, "call", 2, ruby_arg0, ruby_arg1);
	        if (mrb_exception_p(mrb_ret)) {
	            mrb_exc_raise(mrb, mrb_ret);
	        }
	    };
	    mrb_value hash = mrb_iv_get(mrb, self, mrb_intern_cstr(mrb, "__callback_hash"));
	    if (!mrb_hash_p(hash)) {
	        hash = mrb_hash_new(mrb);
	    }
	    mrb_hash_set(mrb, hash, mrb_str_new_cstr(mrb, "onKeyPressed->val"), argv);
	    mrb_iv_set(mrb, self, mrb_intern_cstr(mrb, "__callback_hash"), hash);
	    break;
	} while(0);
    if (! ok) {
        mrb_raise(mrb, E_RUNTIME_ERROR, "convert to native failed : EventListenerKeyboard#onKeyPressed");
    }
    cobj->onKeyPressed = val;

    return self;
}

mrb_value ruby_cocos2dx_EventListenerKeyboard_property_onKeyReleased_get(mrb_state* mrb, mrb_value self)
{
    cocos2d::EventListenerKeyboard* cobj = static_cast<cocos2d::EventListenerKeyboard*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value ret;
    #pragma warning NO CONVERSION FROM NATIVE FOR std::function;
    return ret;
}

mrb_value ruby_cocos2dx_EventListenerKeyboard_property_onKeyReleased_set(mrb_state* mrb, mrb_value self)
{
    cocos2d::EventListenerKeyboard* cobj = static_cast<cocos2d::EventListenerKeyboard*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value argv;
    mrb_get_args(mrb, "o", &argv);

    bool ok = true;
    std::function<void (cocos2d::EventKeyboard::KeyCode, cocos2d::Event *)> val;
    do {
	    // Lambda binding for ruby.
	    unsigned long idx = -1;
	    val = [mrb, self, idx](cocos2d::EventKeyboard::KeyCode larg0, cocos2d::Event* larg1) -> void {
	        mrb_value ruby_arg0;
	        ruby_arg0 = mrb_fixnum_value((mrb_int)larg0);
	        mrb_value ruby_arg1;
	        ruby_arg1 = object_to_rubyval<cocos2d::Event>(mrb, "CC::Event", (cocos2d::Event*)larg1, nullptr);
	        mrb_value hash = mrb_iv_get(mrb, self, mrb_intern_cstr(mrb, "__callback_hash"));
	        mrb_value func = mrb_hash_get(mrb, hash, mrb_str_new_cstr(mrb, "onKeyReleased->val"));
	        mrb_value mrb_ret = mrb_funcall(mrb, func, "call", 2, ruby_arg0, ruby_arg1);
	        if (mrb_exception_p(mrb_ret)) {
	            mrb_exc_raise(mrb, mrb_ret);
	        }
	    };
	    mrb_value hash = mrb_iv_get(mrb, self, mrb_intern_cstr(mrb, "__callback_hash"));
	    if (!mrb_hash_p(hash)) {
	        hash = mrb_hash_new(mrb);
	    }
	    mrb_hash_set(mrb, hash, mrb_str_new_cstr(mrb, "onKeyReleased->val"), argv);
	    mrb_iv_set(mrb, self, mrb_intern_cstr(mrb, "__callback_hash"), hash);
	    break;
	} while(0);
    if (! ok) {
        mrb_raise(mrb, E_RUNTIME_ERROR, "convert to native failed : EventListenerKeyboard#onKeyReleased");
    }
    cobj->onKeyReleased = val;

    return self;
}

void ruby_cocos2dx_EventListenerKeyboard_constants_init(mrb_state* mrb, struct RClass* rclass)
{
    do {
        mrb_value ret;
        ret = mrb_str_new_cstr(mrb, cocos2d::EventListenerKeyboard::LISTENER_ID.c_str());
        mrb_mod_cv_set(mrb, rclass, mrb_intern_cstr(mrb, "LISTENER_ID"), ret);
    } while (0);

}

void ruby_register_cocos2dx_EventListenerKeyboard(mrb_state* mrb, struct RClass* rmodule)
{
    std::string typeName = typeid(cocos2d::EventListenerKeyboard).name();
    g_rubyType[typeName] = "CC::EventListenerKeyboard";
    g_rubyDataType[typeName] = &ruby_cocos2dx_Ref_type;

    struct RClass* p_rmodule = mrb->object_class;
    p_rmodule = mrb_module_get_under(mrb, p_rmodule, "CC");
    struct RClass* p_rclass = mrb_class_get_under(mrb, p_rmodule, "EventListener");
    struct RClass *rclass = mrb_define_class_under(mrb, rmodule, "EventListenerKeyboard", p_rclass);
    MRB_SET_INSTANCE_TT(rclass, MRB_TT_DATA);

    mrb_define_class_method(mrb, rclass, "create", ruby_cocos2dx_EventListenerKeyboard_create_static, ARGS_NONE());
    mrb_define_method(mrb, rclass, "on_key_pressed", ruby_cocos2dx_EventListenerKeyboard_property_onKeyPressed_get, ARGS_NONE());
    mrb_define_method(mrb, rclass, "on_key_pressed=", ruby_cocos2dx_EventListenerKeyboard_property_onKeyPressed_set, ARGS_REQ(1));
    mrb_define_method(mrb, rclass, "on_key_released", ruby_cocos2dx_EventListenerKeyboard_property_onKeyReleased_get, ARGS_NONE());
    mrb_define_method(mrb, rclass, "on_key_released=", ruby_cocos2dx_EventListenerKeyboard_property_onKeyReleased_set, ARGS_REQ(1));
    ruby_cocos2dx_EventListenerKeyboard_constants_init(mrb, rclass);
    mrb_define_class_method(mrb, rclass, "LISTENER_ID", ruby_cocos2dx_constant_get, ARGS_NONE());
}
mrb_value ruby_cocos2dx_EventMouse_getPreviousLocationInView(mrb_state* mrb, mrb_value self)
{
    cocos2d::EventMouse* cobj = static_cast<cocos2d::EventMouse*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            cocos2d::Vec2 retval = cobj->getPreviousLocationInView();
            cocos2d::Vec2* retval_ptr = new cocos2d::Vec2(retval);
            mrb_value ret;
            ret = object_to_rubyval<cocos2d::Vec2>(mrb, "CC::Vec2", (cocos2d::Vec2*)retval_ptr, nullptr);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::EventMouse#getPreviousLocationInView");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_EventMouse_getLocation(mrb_state* mrb, mrb_value self)
{
    cocos2d::EventMouse* cobj = static_cast<cocos2d::EventMouse*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            cocos2d::Vec2 retval = cobj->getLocation();
            cocos2d::Vec2* retval_ptr = new cocos2d::Vec2(retval);
            mrb_value ret;
            ret = object_to_rubyval<cocos2d::Vec2>(mrb, "CC::Vec2", (cocos2d::Vec2*)retval_ptr, nullptr);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::EventMouse#getLocation");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_EventMouse_getMouseButton(mrb_state* mrb, mrb_value self)
{
    cocos2d::EventMouse* cobj = static_cast<cocos2d::EventMouse*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            int retval = cobj->getMouseButton();
            mrb_value ret;
            ret = mrb_fixnum_value((mrb_int)retval);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::EventMouse#getMouseButton");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_EventMouse_getPreviousLocation(mrb_state* mrb, mrb_value self)
{
    cocos2d::EventMouse* cobj = static_cast<cocos2d::EventMouse*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            cocos2d::Vec2 retval = cobj->getPreviousLocation();
            cocos2d::Vec2* retval_ptr = new cocos2d::Vec2(retval);
            mrb_value ret;
            ret = object_to_rubyval<cocos2d::Vec2>(mrb, "CC::Vec2", (cocos2d::Vec2*)retval_ptr, nullptr);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::EventMouse#getPreviousLocation");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_EventMouse_getDelta(mrb_state* mrb, mrb_value self)
{
    cocos2d::EventMouse* cobj = static_cast<cocos2d::EventMouse*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            cocos2d::Vec2 retval = cobj->getDelta();
            cocos2d::Vec2* retval_ptr = new cocos2d::Vec2(retval);
            mrb_value ret;
            ret = object_to_rubyval<cocos2d::Vec2>(mrb, "CC::Vec2", (cocos2d::Vec2*)retval_ptr, nullptr);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::EventMouse#getDelta");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_EventMouse_setScrollData(mrb_state* mrb, mrb_value self)
{
    cocos2d::EventMouse* cobj = static_cast<cocos2d::EventMouse*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 2) {
            double arg0;
            ok = rubyval_to_number(mrb, argv[0], (double*)&arg0, "CC::EventMouse.setScrollData");
            if (!ok) { break; }
            double arg1;
            ok = rubyval_to_number(mrb, argv[1], (double*)&arg1, "CC::EventMouse.setScrollData");
            if (!ok) { break; }
            cobj->setScrollData(arg0, arg1);
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::EventMouse#setScrollData");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_EventMouse_getStartLocationInView(mrb_state* mrb, mrb_value self)
{
    cocos2d::EventMouse* cobj = static_cast<cocos2d::EventMouse*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            cocos2d::Vec2 retval = cobj->getStartLocationInView();
            cocos2d::Vec2* retval_ptr = new cocos2d::Vec2(retval);
            mrb_value ret;
            ret = object_to_rubyval<cocos2d::Vec2>(mrb, "CC::Vec2", (cocos2d::Vec2*)retval_ptr, nullptr);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::EventMouse#getStartLocationInView");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_EventMouse_getStartLocation(mrb_state* mrb, mrb_value self)
{
    cocos2d::EventMouse* cobj = static_cast<cocos2d::EventMouse*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            cocos2d::Vec2 retval = cobj->getStartLocation();
            cocos2d::Vec2* retval_ptr = new cocos2d::Vec2(retval);
            mrb_value ret;
            ret = object_to_rubyval<cocos2d::Vec2>(mrb, "CC::Vec2", (cocos2d::Vec2*)retval_ptr, nullptr);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::EventMouse#getStartLocation");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_EventMouse_setMouseButton(mrb_state* mrb, mrb_value self)
{
    cocos2d::EventMouse* cobj = static_cast<cocos2d::EventMouse*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            int arg0;
            ok = rubyval_to_int32(mrb, argv[0], (int*)&arg0, "CC::EventMouse.setMouseButton");
            if (!ok) { break; }
            cobj->setMouseButton(arg0);
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::EventMouse#setMouseButton");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_EventMouse_getLocationInView(mrb_state* mrb, mrb_value self)
{
    cocos2d::EventMouse* cobj = static_cast<cocos2d::EventMouse*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            cocos2d::Vec2 retval = cobj->getLocationInView();
            cocos2d::Vec2* retval_ptr = new cocos2d::Vec2(retval);
            mrb_value ret;
            ret = object_to_rubyval<cocos2d::Vec2>(mrb, "CC::Vec2", (cocos2d::Vec2*)retval_ptr, nullptr);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::EventMouse#getLocationInView");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_EventMouse_getScrollY(mrb_state* mrb, mrb_value self)
{
    cocos2d::EventMouse* cobj = static_cast<cocos2d::EventMouse*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            double retval = cobj->getScrollY();
            mrb_value ret;
            ret = mrb_float_value(mrb, (mrb_float)retval);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::EventMouse#getScrollY");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_EventMouse_getScrollX(mrb_state* mrb, mrb_value self)
{
    cocos2d::EventMouse* cobj = static_cast<cocos2d::EventMouse*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            double retval = cobj->getScrollX();
            mrb_value ret;
            ret = mrb_float_value(mrb, (mrb_float)retval);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::EventMouse#getScrollX");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_EventMouse_getCursorX(mrb_state* mrb, mrb_value self)
{
    cocos2d::EventMouse* cobj = static_cast<cocos2d::EventMouse*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            double retval = cobj->getCursorX();
            mrb_value ret;
            ret = mrb_float_value(mrb, (mrb_float)retval);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::EventMouse#getCursorX");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_EventMouse_getCursorY(mrb_state* mrb, mrb_value self)
{
    cocos2d::EventMouse* cobj = static_cast<cocos2d::EventMouse*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            double retval = cobj->getCursorY();
            mrb_value ret;
            ret = mrb_float_value(mrb, (mrb_float)retval);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::EventMouse#getCursorY");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_EventMouse_setCursorPosition(mrb_state* mrb, mrb_value self)
{
    cocos2d::EventMouse* cobj = static_cast<cocos2d::EventMouse*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 2) {
            double arg0;
            ok = rubyval_to_number(mrb, argv[0], (double*)&arg0, "CC::EventMouse.setCursorPosition");
            if (!ok) { break; }
            double arg1;
            ok = rubyval_to_number(mrb, argv[1], (double*)&arg1, "CC::EventMouse.setCursorPosition");
            if (!ok) { break; }
            cobj->setCursorPosition(arg0, arg1);
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::EventMouse#setCursorPosition");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_EventMouse_constructor(mrb_state* mrb, mrb_value self)
{

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            cocos2d::EventMouse::MouseEventType arg0;
            ok = rubyval_to_int32(mrb, argv[0], (int*)&arg0, "CC::EventMouse.EventMouse");
            if (!ok) { break; }
            cocos2d::EventMouse* cobj = new cocos2d::EventMouse(arg0);
            DATA_TYPE(self) = &ruby_cocos2dx_Ref_type;
            DATA_PTR(self) = cobj;
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::EventMouse#EventMouse");

    return mrb_nil_value();
}


void ruby_cocos2dx_EventMouse_MouseEventType_enum_init(mrb_state* mrb, struct RClass* renum)
{
    do {
        mrb_value ev = mrb_fixnum_value((mrb_int)cocos2d::EventMouse::MouseEventType::MOUSE_NONE);
        mrb_mod_cv_set(mrb, renum, mrb_intern_cstr(mrb, "MOUSE_NONE"), ev);
    } while (0);

    do {
        mrb_value ev = mrb_fixnum_value((mrb_int)cocos2d::EventMouse::MouseEventType::MOUSE_DOWN);
        mrb_mod_cv_set(mrb, renum, mrb_intern_cstr(mrb, "MOUSE_DOWN"), ev);
    } while (0);

    do {
        mrb_value ev = mrb_fixnum_value((mrb_int)cocos2d::EventMouse::MouseEventType::MOUSE_UP);
        mrb_mod_cv_set(mrb, renum, mrb_intern_cstr(mrb, "MOUSE_UP"), ev);
    } while (0);

    do {
        mrb_value ev = mrb_fixnum_value((mrb_int)cocos2d::EventMouse::MouseEventType::MOUSE_MOVE);
        mrb_mod_cv_set(mrb, renum, mrb_intern_cstr(mrb, "MOUSE_MOVE"), ev);
    } while (0);

    do {
        mrb_value ev = mrb_fixnum_value((mrb_int)cocos2d::EventMouse::MouseEventType::MOUSE_SCROLL);
        mrb_mod_cv_set(mrb, renum, mrb_intern_cstr(mrb, "MOUSE_SCROLL"), ev);
    } while (0);

}

void ruby_register_cocos2dx_EventMouse(mrb_state* mrb, struct RClass* rmodule)
{
    std::string typeName = typeid(cocos2d::EventMouse).name();
    g_rubyType[typeName] = "CC::EventMouse";
    g_rubyDataType[typeName] = &ruby_cocos2dx_Ref_type;

    struct RClass* p_rmodule = mrb->object_class;
    p_rmodule = mrb_module_get_under(mrb, p_rmodule, "CC");
    struct RClass* p_rclass = mrb_class_get_under(mrb, p_rmodule, "Event");
    struct RClass *rclass = mrb_define_class_under(mrb, rmodule, "EventMouse", p_rclass);
    MRB_SET_INSTANCE_TT(rclass, MRB_TT_DATA);

    mrb_define_method(mrb, rclass, "initialize", ruby_cocos2dx_EventMouse_constructor, ARGS_REQ(1));
    mrb_define_method(mrb, rclass, "get_previous_location_in_view", ruby_cocos2dx_EventMouse_getPreviousLocationInView, ARGS_NONE());
    mrb_define_method(mrb, rclass, "get_location", ruby_cocos2dx_EventMouse_getLocation, ARGS_NONE());
    mrb_define_method(mrb, rclass, "get_mouse_button", ruby_cocos2dx_EventMouse_getMouseButton, ARGS_NONE());
    mrb_define_method(mrb, rclass, "get_previous_location", ruby_cocos2dx_EventMouse_getPreviousLocation, ARGS_NONE());
    mrb_define_method(mrb, rclass, "get_delta", ruby_cocos2dx_EventMouse_getDelta, ARGS_NONE());
    mrb_define_method(mrb, rclass, "set_scroll_data", ruby_cocos2dx_EventMouse_setScrollData, ARGS_REQ(2));
    mrb_define_method(mrb, rclass, "get_start_location_in_view", ruby_cocos2dx_EventMouse_getStartLocationInView, ARGS_NONE());
    mrb_define_method(mrb, rclass, "get_start_location", ruby_cocos2dx_EventMouse_getStartLocation, ARGS_NONE());
    mrb_define_method(mrb, rclass, "set_mouse_button", ruby_cocos2dx_EventMouse_setMouseButton, ARGS_REQ(1));
    mrb_define_method(mrb, rclass, "get_location_in_view", ruby_cocos2dx_EventMouse_getLocationInView, ARGS_NONE());
    mrb_define_method(mrb, rclass, "get_scroll_y", ruby_cocos2dx_EventMouse_getScrollY, ARGS_NONE());
    mrb_define_method(mrb, rclass, "get_scroll_x", ruby_cocos2dx_EventMouse_getScrollX, ARGS_NONE());
    mrb_define_method(mrb, rclass, "get_cursor_x", ruby_cocos2dx_EventMouse_getCursorX, ARGS_NONE());
    mrb_define_method(mrb, rclass, "get_cursor_y", ruby_cocos2dx_EventMouse_getCursorY, ARGS_NONE());
    mrb_define_method(mrb, rclass, "set_cursor_position", ruby_cocos2dx_EventMouse_setCursorPosition, ARGS_REQ(2));
    struct RClass* renum_MouseEventType = mrb_define_module_under(mrb, rclass, "MouseEventType");
    ruby_cocos2dx_EventMouse_MouseEventType_enum_init(mrb, renum_MouseEventType);
    mrb_define_class_method(mrb, renum_MouseEventType, "MOUSE_NONE", ruby_cocos2dx_constant_get, ARGS_NONE());
    mrb_define_class_method(mrb, renum_MouseEventType, "MOUSE_DOWN", ruby_cocos2dx_constant_get, ARGS_NONE());
    mrb_define_class_method(mrb, renum_MouseEventType, "MOUSE_UP", ruby_cocos2dx_constant_get, ARGS_NONE());
    mrb_define_class_method(mrb, renum_MouseEventType, "MOUSE_MOVE", ruby_cocos2dx_constant_get, ARGS_NONE());
    mrb_define_class_method(mrb, renum_MouseEventType, "MOUSE_SCROLL", ruby_cocos2dx_constant_get, ARGS_NONE());
}
mrb_value ruby_cocos2dx_EventListenerMouse_create_static(mrb_state* mrb, mrb_value self)
{
    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            std::map<std::string, mrb_value> callbacks;
            cocos2d::EventListenerMouse* retval = cocos2d::EventListenerMouse::create();
            mrb_value ret;
            RClass* rclass = mrb_class_ptr(self);
            ret = object_to_rubyval<cocos2d::EventListenerMouse>(mrb, "CC::EventListenerMouse", (cocos2d::EventListenerMouse*)retval, rclass);
            if (callbacks.size() > 0) {
                mrb_value hash = mrb_iv_get(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"));
                if (!mrb_hash_p(hash)) {
                    hash = mrb_hash_new(mrb);
                }
                for (auto elm : callbacks) {
                    mrb_hash_set(mrb, hash, mrb_str_new_cstr(mrb, elm.first.c_str()), elm.second);
                    mrb_iv_set(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"), hash);
                }
            }
            g_rubyValue.push_back(ret);
            mrb_funcall(mrb, ret, "initialize", 0);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined static method : cocos2d::EventListenerMouse#create");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_EventListenerMouse_property_onMouseDown_get(mrb_state* mrb, mrb_value self)
{
    cocos2d::EventListenerMouse* cobj = static_cast<cocos2d::EventListenerMouse*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value ret;
    #pragma warning NO CONVERSION FROM NATIVE FOR std::function;
    return ret;
}

mrb_value ruby_cocos2dx_EventListenerMouse_property_onMouseDown_set(mrb_state* mrb, mrb_value self)
{
    cocos2d::EventListenerMouse* cobj = static_cast<cocos2d::EventListenerMouse*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value argv;
    mrb_get_args(mrb, "o", &argv);

    bool ok = true;
    std::function<void (cocos2d::Event *)> val;
    do {
	    // Lambda binding for ruby.
	    unsigned long idx = -1;
	    val = [mrb, self, idx](cocos2d::Event* larg0) -> void {
	        mrb_value ruby_arg0;
	        ruby_arg0 = object_to_rubyval<cocos2d::Event>(mrb, "CC::Event", (cocos2d::Event*)larg0, nullptr);
	        mrb_value hash = mrb_iv_get(mrb, self, mrb_intern_cstr(mrb, "__callback_hash"));
	        mrb_value func = mrb_hash_get(mrb, hash, mrb_str_new_cstr(mrb, "onMouseDown->val"));
	        mrb_value mrb_ret = mrb_funcall(mrb, func, "call", 1, ruby_arg0);
	        if (mrb_exception_p(mrb_ret)) {
	            mrb_exc_raise(mrb, mrb_ret);
	        }
	    };
	    mrb_value hash = mrb_iv_get(mrb, self, mrb_intern_cstr(mrb, "__callback_hash"));
	    if (!mrb_hash_p(hash)) {
	        hash = mrb_hash_new(mrb);
	    }
	    mrb_hash_set(mrb, hash, mrb_str_new_cstr(mrb, "onMouseDown->val"), argv);
	    mrb_iv_set(mrb, self, mrb_intern_cstr(mrb, "__callback_hash"), hash);
	    break;
	} while(0);
    if (! ok) {
        mrb_raise(mrb, E_RUNTIME_ERROR, "convert to native failed : EventListenerMouse#onMouseDown");
    }
    cobj->onMouseDown = val;

    return self;
}

mrb_value ruby_cocos2dx_EventListenerMouse_property_onMouseUp_get(mrb_state* mrb, mrb_value self)
{
    cocos2d::EventListenerMouse* cobj = static_cast<cocos2d::EventListenerMouse*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value ret;
    #pragma warning NO CONVERSION FROM NATIVE FOR std::function;
    return ret;
}

mrb_value ruby_cocos2dx_EventListenerMouse_property_onMouseUp_set(mrb_state* mrb, mrb_value self)
{
    cocos2d::EventListenerMouse* cobj = static_cast<cocos2d::EventListenerMouse*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value argv;
    mrb_get_args(mrb, "o", &argv);

    bool ok = true;
    std::function<void (cocos2d::Event *)> val;
    do {
	    // Lambda binding for ruby.
	    unsigned long idx = -1;
	    val = [mrb, self, idx](cocos2d::Event* larg0) -> void {
	        mrb_value ruby_arg0;
	        ruby_arg0 = object_to_rubyval<cocos2d::Event>(mrb, "CC::Event", (cocos2d::Event*)larg0, nullptr);
	        mrb_value hash = mrb_iv_get(mrb, self, mrb_intern_cstr(mrb, "__callback_hash"));
	        mrb_value func = mrb_hash_get(mrb, hash, mrb_str_new_cstr(mrb, "onMouseUp->val"));
	        mrb_value mrb_ret = mrb_funcall(mrb, func, "call", 1, ruby_arg0);
	        if (mrb_exception_p(mrb_ret)) {
	            mrb_exc_raise(mrb, mrb_ret);
	        }
	    };
	    mrb_value hash = mrb_iv_get(mrb, self, mrb_intern_cstr(mrb, "__callback_hash"));
	    if (!mrb_hash_p(hash)) {
	        hash = mrb_hash_new(mrb);
	    }
	    mrb_hash_set(mrb, hash, mrb_str_new_cstr(mrb, "onMouseUp->val"), argv);
	    mrb_iv_set(mrb, self, mrb_intern_cstr(mrb, "__callback_hash"), hash);
	    break;
	} while(0);
    if (! ok) {
        mrb_raise(mrb, E_RUNTIME_ERROR, "convert to native failed : EventListenerMouse#onMouseUp");
    }
    cobj->onMouseUp = val;

    return self;
}

mrb_value ruby_cocos2dx_EventListenerMouse_property_onMouseMove_get(mrb_state* mrb, mrb_value self)
{
    cocos2d::EventListenerMouse* cobj = static_cast<cocos2d::EventListenerMouse*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value ret;
    #pragma warning NO CONVERSION FROM NATIVE FOR std::function;
    return ret;
}

mrb_value ruby_cocos2dx_EventListenerMouse_property_onMouseMove_set(mrb_state* mrb, mrb_value self)
{
    cocos2d::EventListenerMouse* cobj = static_cast<cocos2d::EventListenerMouse*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value argv;
    mrb_get_args(mrb, "o", &argv);

    bool ok = true;
    std::function<void (cocos2d::Event *)> val;
    do {
	    // Lambda binding for ruby.
	    unsigned long idx = -1;
	    val = [mrb, self, idx](cocos2d::Event* larg0) -> void {
	        mrb_value ruby_arg0;
	        ruby_arg0 = object_to_rubyval<cocos2d::Event>(mrb, "CC::Event", (cocos2d::Event*)larg0, nullptr);
	        mrb_value hash = mrb_iv_get(mrb, self, mrb_intern_cstr(mrb, "__callback_hash"));
	        mrb_value func = mrb_hash_get(mrb, hash, mrb_str_new_cstr(mrb, "onMouseMove->val"));
	        mrb_value mrb_ret = mrb_funcall(mrb, func, "call", 1, ruby_arg0);
	        if (mrb_exception_p(mrb_ret)) {
	            mrb_exc_raise(mrb, mrb_ret);
	        }
	    };
	    mrb_value hash = mrb_iv_get(mrb, self, mrb_intern_cstr(mrb, "__callback_hash"));
	    if (!mrb_hash_p(hash)) {
	        hash = mrb_hash_new(mrb);
	    }
	    mrb_hash_set(mrb, hash, mrb_str_new_cstr(mrb, "onMouseMove->val"), argv);
	    mrb_iv_set(mrb, self, mrb_intern_cstr(mrb, "__callback_hash"), hash);
	    break;
	} while(0);
    if (! ok) {
        mrb_raise(mrb, E_RUNTIME_ERROR, "convert to native failed : EventListenerMouse#onMouseMove");
    }
    cobj->onMouseMove = val;

    return self;
}

mrb_value ruby_cocos2dx_EventListenerMouse_property_onMouseScroll_get(mrb_state* mrb, mrb_value self)
{
    cocos2d::EventListenerMouse* cobj = static_cast<cocos2d::EventListenerMouse*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value ret;
    #pragma warning NO CONVERSION FROM NATIVE FOR std::function;
    return ret;
}

mrb_value ruby_cocos2dx_EventListenerMouse_property_onMouseScroll_set(mrb_state* mrb, mrb_value self)
{
    cocos2d::EventListenerMouse* cobj = static_cast<cocos2d::EventListenerMouse*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value argv;
    mrb_get_args(mrb, "o", &argv);

    bool ok = true;
    std::function<void (cocos2d::Event *)> val;
    do {
	    // Lambda binding for ruby.
	    unsigned long idx = -1;
	    val = [mrb, self, idx](cocos2d::Event* larg0) -> void {
	        mrb_value ruby_arg0;
	        ruby_arg0 = object_to_rubyval<cocos2d::Event>(mrb, "CC::Event", (cocos2d::Event*)larg0, nullptr);
	        mrb_value hash = mrb_iv_get(mrb, self, mrb_intern_cstr(mrb, "__callback_hash"));
	        mrb_value func = mrb_hash_get(mrb, hash, mrb_str_new_cstr(mrb, "onMouseScroll->val"));
	        mrb_value mrb_ret = mrb_funcall(mrb, func, "call", 1, ruby_arg0);
	        if (mrb_exception_p(mrb_ret)) {
	            mrb_exc_raise(mrb, mrb_ret);
	        }
	    };
	    mrb_value hash = mrb_iv_get(mrb, self, mrb_intern_cstr(mrb, "__callback_hash"));
	    if (!mrb_hash_p(hash)) {
	        hash = mrb_hash_new(mrb);
	    }
	    mrb_hash_set(mrb, hash, mrb_str_new_cstr(mrb, "onMouseScroll->val"), argv);
	    mrb_iv_set(mrb, self, mrb_intern_cstr(mrb, "__callback_hash"), hash);
	    break;
	} while(0);
    if (! ok) {
        mrb_raise(mrb, E_RUNTIME_ERROR, "convert to native failed : EventListenerMouse#onMouseScroll");
    }
    cobj->onMouseScroll = val;

    return self;
}

void ruby_cocos2dx_EventListenerMouse_constants_init(mrb_state* mrb, struct RClass* rclass)
{
    do {
        mrb_value ret;
        ret = mrb_str_new_cstr(mrb, cocos2d::EventListenerMouse::LISTENER_ID.c_str());
        mrb_mod_cv_set(mrb, rclass, mrb_intern_cstr(mrb, "LISTENER_ID"), ret);
    } while (0);

}

void ruby_register_cocos2dx_EventListenerMouse(mrb_state* mrb, struct RClass* rmodule)
{
    std::string typeName = typeid(cocos2d::EventListenerMouse).name();
    g_rubyType[typeName] = "CC::EventListenerMouse";
    g_rubyDataType[typeName] = &ruby_cocos2dx_Ref_type;

    struct RClass* p_rmodule = mrb->object_class;
    p_rmodule = mrb_module_get_under(mrb, p_rmodule, "CC");
    struct RClass* p_rclass = mrb_class_get_under(mrb, p_rmodule, "EventListener");
    struct RClass *rclass = mrb_define_class_under(mrb, rmodule, "EventListenerMouse", p_rclass);
    MRB_SET_INSTANCE_TT(rclass, MRB_TT_DATA);

    mrb_define_class_method(mrb, rclass, "create", ruby_cocos2dx_EventListenerMouse_create_static, ARGS_NONE());
    mrb_define_method(mrb, rclass, "on_mouse_down", ruby_cocos2dx_EventListenerMouse_property_onMouseDown_get, ARGS_NONE());
    mrb_define_method(mrb, rclass, "on_mouse_down=", ruby_cocos2dx_EventListenerMouse_property_onMouseDown_set, ARGS_REQ(1));
    mrb_define_method(mrb, rclass, "on_mouse_up", ruby_cocos2dx_EventListenerMouse_property_onMouseUp_get, ARGS_NONE());
    mrb_define_method(mrb, rclass, "on_mouse_up=", ruby_cocos2dx_EventListenerMouse_property_onMouseUp_set, ARGS_REQ(1));
    mrb_define_method(mrb, rclass, "on_mouse_move", ruby_cocos2dx_EventListenerMouse_property_onMouseMove_get, ARGS_NONE());
    mrb_define_method(mrb, rclass, "on_mouse_move=", ruby_cocos2dx_EventListenerMouse_property_onMouseMove_set, ARGS_REQ(1));
    mrb_define_method(mrb, rclass, "on_mouse_scroll", ruby_cocos2dx_EventListenerMouse_property_onMouseScroll_get, ARGS_NONE());
    mrb_define_method(mrb, rclass, "on_mouse_scroll=", ruby_cocos2dx_EventListenerMouse_property_onMouseScroll_set, ARGS_REQ(1));
    ruby_cocos2dx_EventListenerMouse_constants_init(mrb, rclass);
    mrb_define_class_method(mrb, rclass, "LISTENER_ID", ruby_cocos2dx_constant_get, ARGS_NONE());
}
void ruby_register_cocos2dx_EventAcceleration(mrb_state* mrb, struct RClass* rmodule)
{
    std::string typeName = typeid(cocos2d::EventAcceleration).name();
    g_rubyType[typeName] = "CC::EventAcceleration";
    g_rubyDataType[typeName] = &ruby_cocos2dx_Ref_type;

    struct RClass* p_rmodule = mrb->object_class;
    p_rmodule = mrb_module_get_under(mrb, p_rmodule, "CC");
    struct RClass* p_rclass = mrb_class_get_under(mrb, p_rmodule, "Event");
    struct RClass *rclass = mrb_define_class_under(mrb, rmodule, "EventAcceleration", p_rclass);
    MRB_SET_INSTANCE_TT(rclass, MRB_TT_DATA);

}
mrb_value ruby_cocos2dx_EventListenerAcceleration_create_static(mrb_state* mrb, mrb_value self)
{
    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            std::map<std::string, mrb_value> callbacks;
            std::function<void (cocos2d::Acceleration *, cocos2d::Event *)> arg0;
            do {
			    // Lambda binding for ruby.
			    unsigned long idx = g_rubyValue.size();
			    arg0 = [mrb, self, idx](cocos2d::Acceleration* larg0, cocos2d::Event* larg1) -> void {
			        mrb_value ruby_arg0;
			        ruby_arg0 = object_to_rubyval<cocos2d::Acceleration>(mrb, "CC::Acceleration", (cocos2d::Acceleration*)larg0, nullptr);
			        mrb_value ruby_arg1;
			        ruby_arg1 = object_to_rubyval<cocos2d::Event>(mrb, "CC::Event", (cocos2d::Event*)larg1, nullptr);
			        mrb_value _self = g_rubyValue[idx];
			        mrb_value hash = mrb_iv_get(mrb, _self, mrb_intern_cstr(mrb, "__callback_hash"));
			        mrb_value func = mrb_hash_get(mrb, hash, mrb_str_new_cstr(mrb, "create->arg0"));
			        mrb_value mrb_ret = mrb_funcall(mrb, func, "call", 2, ruby_arg0, ruby_arg1);
			        if (mrb_exception_p(mrb_ret)) {
			            mrb_exc_raise(mrb, mrb_ret);
			        }
			    };
			    callbacks["create->arg0"] = argv[0];
			    break;
			} while(0);
            if (!ok) { break; }

            cocos2d::EventListenerAcceleration* retval = cocos2d::EventListenerAcceleration::create(arg0);
            mrb_value ret;
            RClass* rclass = mrb_class_ptr(self);
            ret = object_to_rubyval<cocos2d::EventListenerAcceleration>(mrb, "CC::EventListenerAcceleration", (cocos2d::EventListenerAcceleration*)retval, rclass);
            if (callbacks.size() > 0) {
                mrb_value hash = mrb_iv_get(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"));
                if (!mrb_hash_p(hash)) {
                    hash = mrb_hash_new(mrb);
                }
                for (auto elm : callbacks) {
                    mrb_hash_set(mrb, hash, mrb_str_new_cstr(mrb, elm.first.c_str()), elm.second);
                    mrb_iv_set(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"), hash);
                }
            }
            g_rubyValue.push_back(ret);
            mrb_funcall(mrb, ret, "initialize", 0);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined static method : cocos2d::EventListenerAcceleration#create");

    return mrb_nil_value();
}

void ruby_cocos2dx_EventListenerAcceleration_constants_init(mrb_state* mrb, struct RClass* rclass)
{
    do {
        mrb_value ret;
        ret = mrb_str_new_cstr(mrb, cocos2d::EventListenerAcceleration::LISTENER_ID.c_str());
        mrb_mod_cv_set(mrb, rclass, mrb_intern_cstr(mrb, "LISTENER_ID"), ret);
    } while (0);

}

void ruby_register_cocos2dx_EventListenerAcceleration(mrb_state* mrb, struct RClass* rmodule)
{
    std::string typeName = typeid(cocos2d::EventListenerAcceleration).name();
    g_rubyType[typeName] = "CC::EventListenerAcceleration";
    g_rubyDataType[typeName] = &ruby_cocos2dx_Ref_type;

    struct RClass* p_rmodule = mrb->object_class;
    p_rmodule = mrb_module_get_under(mrb, p_rmodule, "CC");
    struct RClass* p_rclass = mrb_class_get_under(mrb, p_rmodule, "EventListener");
    struct RClass *rclass = mrb_define_class_under(mrb, rmodule, "EventListenerAcceleration", p_rclass);
    MRB_SET_INSTANCE_TT(rclass, MRB_TT_DATA);

    mrb_define_class_method(mrb, rclass, "create", ruby_cocos2dx_EventListenerAcceleration_create_static, ARGS_REQ(1));
    ruby_cocos2dx_EventListenerAcceleration_constants_init(mrb, rclass);
    mrb_define_class_method(mrb, rclass, "LISTENER_ID", ruby_cocos2dx_constant_get, ARGS_NONE());
}
mrb_value ruby_cocos2dx_EventCustom_getEventName(mrb_state* mrb, mrb_value self)
{
    cocos2d::EventCustom* cobj = static_cast<cocos2d::EventCustom*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            std::string retval = cobj->getEventName();
            mrb_value ret;
            ret = mrb_str_new_cstr(mrb, retval.c_str());
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::EventCustom#getEventName");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_EventCustom_setUserData(mrb_state* mrb, mrb_value self)
{
    cocos2d::EventCustom* cobj = static_cast<cocos2d::EventCustom*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            void* arg0;
            #pragma warning NO CONVERSION TO NATIVE FOR void*
		ok = false;
            if (!ok) { break; }
            cobj->setUserData(arg0);
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::EventCustom#setUserData");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_EventCustom_getUserData(mrb_state* mrb, mrb_value self)
{
    cocos2d::EventCustom* cobj = static_cast<cocos2d::EventCustom*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            void* retval = cobj->getUserData();
            mrb_value ret;
            #pragma warning NO CONVERSION FROM NATIVE FOR void*;
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::EventCustom#getUserData");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_EventCustom_constructor(mrb_state* mrb, mrb_value self)
{

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            std::string arg0;
            ok = rubyval_to_std_string(mrb, argv[0], &arg0, "CC::EventCustom.EventCustom");
            if (!ok) { break; }
            cocos2d::EventCustom* cobj = new cocos2d::EventCustom(arg0);
            DATA_TYPE(self) = &ruby_cocos2dx_Ref_type;
            DATA_PTR(self) = cobj;
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::EventCustom#EventCustom");

    return mrb_nil_value();
}


void ruby_register_cocos2dx_EventCustom(mrb_state* mrb, struct RClass* rmodule)
{
    std::string typeName = typeid(cocos2d::EventCustom).name();
    g_rubyType[typeName] = "CC::EventCustom";
    g_rubyDataType[typeName] = &ruby_cocos2dx_Ref_type;

    struct RClass* p_rmodule = mrb->object_class;
    p_rmodule = mrb_module_get_under(mrb, p_rmodule, "CC");
    struct RClass* p_rclass = mrb_class_get_under(mrb, p_rmodule, "Event");
    struct RClass *rclass = mrb_define_class_under(mrb, rmodule, "EventCustom", p_rclass);
    MRB_SET_INSTANCE_TT(rclass, MRB_TT_DATA);

    mrb_define_method(mrb, rclass, "initialize", ruby_cocos2dx_EventCustom_constructor, ARGS_REQ(1));
    mrb_define_method(mrb, rclass, "get_event_name", ruby_cocos2dx_EventCustom_getEventName, ARGS_NONE());
    mrb_define_method(mrb, rclass, "set_user_data", ruby_cocos2dx_EventCustom_setUserData, ARGS_REQ(1));
    mrb_define_method(mrb, rclass, "get_user_data", ruby_cocos2dx_EventCustom_getUserData, ARGS_NONE());
}
mrb_value ruby_cocos2dx_EventListenerCustom_create_static(mrb_state* mrb, mrb_value self)
{
    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 2) {
            std::map<std::string, mrb_value> callbacks;
            std::string arg0;
            ok = rubyval_to_std_string(mrb, argv[0], &arg0, "CC::EventListenerCustom.create");
            if (!ok) { break; }

            std::function<void (cocos2d::EventCustom *)> arg1;
            do {
			    // Lambda binding for ruby.
			    unsigned long idx = g_rubyValue.size();
			    arg1 = [mrb, self, idx](cocos2d::EventCustom* larg0) -> void {
			        mrb_value ruby_arg0;
			        ruby_arg0 = object_to_rubyval<cocos2d::EventCustom>(mrb, "CC::EventCustom", (cocos2d::EventCustom*)larg0, nullptr);
			        mrb_value _self = g_rubyValue[idx];
			        mrb_value hash = mrb_iv_get(mrb, _self, mrb_intern_cstr(mrb, "__callback_hash"));
			        mrb_value func = mrb_hash_get(mrb, hash, mrb_str_new_cstr(mrb, "create->arg1"));
			        mrb_value mrb_ret = mrb_funcall(mrb, func, "call", 1, ruby_arg0);
			        if (mrb_exception_p(mrb_ret)) {
			            mrb_exc_raise(mrb, mrb_ret);
			        }
			    };
			    callbacks["create->arg1"] = argv[1];
			    break;
			} while(0);
            if (!ok) { break; }

            cocos2d::EventListenerCustom* retval = cocos2d::EventListenerCustom::create(arg0, arg1);
            mrb_value ret;
            RClass* rclass = mrb_class_ptr(self);
            ret = object_to_rubyval<cocos2d::EventListenerCustom>(mrb, "CC::EventListenerCustom", (cocos2d::EventListenerCustom*)retval, rclass);
            if (callbacks.size() > 0) {
                mrb_value hash = mrb_iv_get(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"));
                if (!mrb_hash_p(hash)) {
                    hash = mrb_hash_new(mrb);
                }
                for (auto elm : callbacks) {
                    mrb_hash_set(mrb, hash, mrb_str_new_cstr(mrb, elm.first.c_str()), elm.second);
                    mrb_iv_set(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"), hash);
                }
            }
            g_rubyValue.push_back(ret);
            mrb_funcall(mrb, ret, "initialize", 0);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined static method : cocos2d::EventListenerCustom#create");

    return mrb_nil_value();
}

void ruby_register_cocos2dx_EventListenerCustom(mrb_state* mrb, struct RClass* rmodule)
{
    std::string typeName = typeid(cocos2d::EventListenerCustom).name();
    g_rubyType[typeName] = "CC::EventListenerCustom";
    g_rubyDataType[typeName] = &ruby_cocos2dx_Ref_type;

    struct RClass* p_rmodule = mrb->object_class;
    p_rmodule = mrb_module_get_under(mrb, p_rmodule, "CC");
    struct RClass* p_rclass = mrb_class_get_under(mrb, p_rmodule, "EventListener");
    struct RClass *rclass = mrb_define_class_under(mrb, rmodule, "EventListenerCustom", p_rclass);
    MRB_SET_INSTANCE_TT(rclass, MRB_TT_DATA);

    mrb_define_class_method(mrb, rclass, "create", ruby_cocos2dx_EventListenerCustom_create_static, ARGS_REQ(2));
}
mrb_value ruby_cocos2dx_EventFocus_constructor(mrb_state* mrb, mrb_value self)
{

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 2) {
            cocos2d::ui::Widget* arg0;
            ok = rubyval_to_object<cocos2d::ui::Widget>(mrb, argv[0], "CCUI::Widget", &arg0);
            if (!ok) { break; }
            cocos2d::ui::Widget* arg1;
            ok = rubyval_to_object<cocos2d::ui::Widget>(mrb, argv[1], "CCUI::Widget", &arg1);
            if (!ok) { break; }
            cocos2d::EventFocus* cobj = new cocos2d::EventFocus(arg0, arg1);
            DATA_TYPE(self) = &ruby_cocos2dx_Ref_type;
            DATA_PTR(self) = cobj;
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::EventFocus#EventFocus");

    return mrb_nil_value();
}


void ruby_register_cocos2dx_EventFocus(mrb_state* mrb, struct RClass* rmodule)
{
    std::string typeName = typeid(cocos2d::EventFocus).name();
    g_rubyType[typeName] = "CC::EventFocus";
    g_rubyDataType[typeName] = &ruby_cocos2dx_Ref_type;

    struct RClass* p_rmodule = mrb->object_class;
    p_rmodule = mrb_module_get_under(mrb, p_rmodule, "CC");
    struct RClass* p_rclass = mrb_class_get_under(mrb, p_rmodule, "Event");
    struct RClass *rclass = mrb_define_class_under(mrb, rmodule, "EventFocus", p_rclass);
    MRB_SET_INSTANCE_TT(rclass, MRB_TT_DATA);

    mrb_define_method(mrb, rclass, "initialize", ruby_cocos2dx_EventFocus_constructor, ARGS_REQ(2));
}
mrb_value ruby_cocos2dx_EventListenerFocus_create_static(mrb_state* mrb, mrb_value self)
{
    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            std::map<std::string, mrb_value> callbacks;
            cocos2d::EventListenerFocus* retval = cocos2d::EventListenerFocus::create();
            mrb_value ret;
            RClass* rclass = mrb_class_ptr(self);
            ret = object_to_rubyval<cocos2d::EventListenerFocus>(mrb, "CC::EventListenerFocus", (cocos2d::EventListenerFocus*)retval, rclass);
            if (callbacks.size() > 0) {
                mrb_value hash = mrb_iv_get(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"));
                if (!mrb_hash_p(hash)) {
                    hash = mrb_hash_new(mrb);
                }
                for (auto elm : callbacks) {
                    mrb_hash_set(mrb, hash, mrb_str_new_cstr(mrb, elm.first.c_str()), elm.second);
                    mrb_iv_set(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"), hash);
                }
            }
            g_rubyValue.push_back(ret);
            mrb_funcall(mrb, ret, "initialize", 0);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined static method : cocos2d::EventListenerFocus#create");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_EventListenerFocus_property_onFocusChanged_get(mrb_state* mrb, mrb_value self)
{
    cocos2d::EventListenerFocus* cobj = static_cast<cocos2d::EventListenerFocus*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value ret;
    #pragma warning NO CONVERSION FROM NATIVE FOR std::function;
    return ret;
}

mrb_value ruby_cocos2dx_EventListenerFocus_property_onFocusChanged_set(mrb_state* mrb, mrb_value self)
{
    cocos2d::EventListenerFocus* cobj = static_cast<cocos2d::EventListenerFocus*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value argv;
    mrb_get_args(mrb, "o", &argv);

    bool ok = true;
    std::function<void (cocos2d::ui::Widget *, cocos2d::ui::Widget *)> val;
    do {
	    // Lambda binding for ruby.
	    unsigned long idx = -1;
	    val = [mrb, self, idx](cocos2d::ui::Widget* larg0, cocos2d::ui::Widget* larg1) -> void {
	        mrb_value ruby_arg0;
	        ruby_arg0 = object_to_rubyval<cocos2d::ui::Widget>(mrb, "CCUI::Widget", (cocos2d::ui::Widget*)larg0, nullptr);
	        mrb_value ruby_arg1;
	        ruby_arg1 = object_to_rubyval<cocos2d::ui::Widget>(mrb, "CCUI::Widget", (cocos2d::ui::Widget*)larg1, nullptr);
	        mrb_value hash = mrb_iv_get(mrb, self, mrb_intern_cstr(mrb, "__callback_hash"));
	        mrb_value func = mrb_hash_get(mrb, hash, mrb_str_new_cstr(mrb, "onFocusChanged->val"));
	        mrb_value mrb_ret = mrb_funcall(mrb, func, "call", 2, ruby_arg0, ruby_arg1);
	        if (mrb_exception_p(mrb_ret)) {
	            mrb_exc_raise(mrb, mrb_ret);
	        }
	    };
	    mrb_value hash = mrb_iv_get(mrb, self, mrb_intern_cstr(mrb, "__callback_hash"));
	    if (!mrb_hash_p(hash)) {
	        hash = mrb_hash_new(mrb);
	    }
	    mrb_hash_set(mrb, hash, mrb_str_new_cstr(mrb, "onFocusChanged->val"), argv);
	    mrb_iv_set(mrb, self, mrb_intern_cstr(mrb, "__callback_hash"), hash);
	    break;
	} while(0);
    if (! ok) {
        mrb_raise(mrb, E_RUNTIME_ERROR, "convert to native failed : EventListenerFocus#onFocusChanged");
    }
    cobj->onFocusChanged = val;

    return self;
}

void ruby_cocos2dx_EventListenerFocus_constants_init(mrb_state* mrb, struct RClass* rclass)
{
    do {
        mrb_value ret;
        ret = mrb_str_new_cstr(mrb, cocos2d::EventListenerFocus::LISTENER_ID.c_str());
        mrb_mod_cv_set(mrb, rclass, mrb_intern_cstr(mrb, "LISTENER_ID"), ret);
    } while (0);

}

void ruby_register_cocos2dx_EventListenerFocus(mrb_state* mrb, struct RClass* rmodule)
{
    std::string typeName = typeid(cocos2d::EventListenerFocus).name();
    g_rubyType[typeName] = "CC::EventListenerFocus";
    g_rubyDataType[typeName] = &ruby_cocos2dx_Ref_type;

    struct RClass* p_rmodule = mrb->object_class;
    p_rmodule = mrb_module_get_under(mrb, p_rmodule, "CC");
    struct RClass* p_rclass = mrb_class_get_under(mrb, p_rmodule, "EventListener");
    struct RClass *rclass = mrb_define_class_under(mrb, rmodule, "EventListenerFocus", p_rclass);
    MRB_SET_INSTANCE_TT(rclass, MRB_TT_DATA);

    mrb_define_class_method(mrb, rclass, "create", ruby_cocos2dx_EventListenerFocus_create_static, ARGS_NONE());
    mrb_define_method(mrb, rclass, "on_focus_changed", ruby_cocos2dx_EventListenerFocus_property_onFocusChanged_get, ARGS_NONE());
    mrb_define_method(mrb, rclass, "on_focus_changed=", ruby_cocos2dx_EventListenerFocus_property_onFocusChanged_set, ARGS_REQ(1));
    ruby_cocos2dx_EventListenerFocus_constants_init(mrb, rclass);
    mrb_define_class_method(mrb, rclass, "LISTENER_ID", ruby_cocos2dx_constant_get, ARGS_NONE());
}
mrb_value ruby_cocos2dx_Action_startWithTarget(mrb_state* mrb, mrb_value self)
{
    cocos2d::Action* cobj = static_cast<cocos2d::Action*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            cocos2d::Node* arg0;
            ok = rubyval_to_object<cocos2d::Node>(mrb, argv[0], "CC::Node", &arg0);
            if (!ok) { break; }
            cobj->startWithTarget(arg0);
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::Action#startWithTarget");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Action_setOriginalTarget(mrb_state* mrb, mrb_value self)
{
    cocos2d::Action* cobj = static_cast<cocos2d::Action*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            cocos2d::Node* arg0;
            ok = rubyval_to_object<cocos2d::Node>(mrb, argv[0], "CC::Node", &arg0);
            if (!ok) { break; }
            cobj->setOriginalTarget(arg0);
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::Action#setOriginalTarget");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Action_clone(mrb_state* mrb, mrb_value self)
{
    cocos2d::Action* cobj = static_cast<cocos2d::Action*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            cocos2d::Action* retval = cobj->clone();
            mrb_value ret;
            ret = object_to_rubyval<cocos2d::Action>(mrb, "CC::Action", (cocos2d::Action*)retval, nullptr);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::Action#clone");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Action_getOriginalTarget(mrb_state* mrb, mrb_value self)
{
    cocos2d::Action* cobj = static_cast<cocos2d::Action*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            cocos2d::Node* retval = cobj->getOriginalTarget();
            mrb_value ret;
            ret = object_to_rubyval<cocos2d::Node>(mrb, "CC::Node", (cocos2d::Node*)retval, nullptr);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::Action#getOriginalTarget");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Action_stop(mrb_state* mrb, mrb_value self)
{
    cocos2d::Action* cobj = static_cast<cocos2d::Action*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            cobj->stop();
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::Action#stop");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Action_update(mrb_state* mrb, mrb_value self)
{
    cocos2d::Action* cobj = static_cast<cocos2d::Action*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            double arg0;
            ok = rubyval_to_number(mrb, argv[0], (double*)&arg0, "CC::Action.update");
            if (!ok) { break; }
            cobj->update(arg0);
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::Action#update");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Action_getTarget(mrb_state* mrb, mrb_value self)
{
    cocos2d::Action* cobj = static_cast<cocos2d::Action*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            cocos2d::Node* retval = cobj->getTarget();
            mrb_value ret;
            ret = object_to_rubyval<cocos2d::Node>(mrb, "CC::Node", (cocos2d::Node*)retval, nullptr);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::Action#getTarget");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Action_step(mrb_state* mrb, mrb_value self)
{
    cocos2d::Action* cobj = static_cast<cocos2d::Action*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            double arg0;
            ok = rubyval_to_number(mrb, argv[0], (double*)&arg0, "CC::Action.step");
            if (!ok) { break; }
            cobj->step(arg0);
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::Action#step");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Action_setTag(mrb_state* mrb, mrb_value self)
{
    cocos2d::Action* cobj = static_cast<cocos2d::Action*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            int arg0;
            ok = rubyval_to_int32(mrb, argv[0], (int*)&arg0, "CC::Action.setTag");
            if (!ok) { break; }
            cobj->setTag(arg0);
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::Action#setTag");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Action_getTag(mrb_state* mrb, mrb_value self)
{
    cocos2d::Action* cobj = static_cast<cocos2d::Action*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            int retval = cobj->getTag();
            mrb_value ret;
            ret = mrb_fixnum_value((mrb_int)retval);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::Action#getTag");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Action_setTarget(mrb_state* mrb, mrb_value self)
{
    cocos2d::Action* cobj = static_cast<cocos2d::Action*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            cocos2d::Node* arg0;
            ok = rubyval_to_object<cocos2d::Node>(mrb, argv[0], "CC::Node", &arg0);
            if (!ok) { break; }
            cobj->setTarget(arg0);
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::Action#setTarget");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Action_isDone(mrb_state* mrb, mrb_value self)
{
    cocos2d::Action* cobj = static_cast<cocos2d::Action*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            bool retval = cobj->isDone();
            mrb_value ret;
            ret = mrb_bool_value((mrb_bool)retval);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::Action#isDone");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Action_reverse(mrb_state* mrb, mrb_value self)
{
    cocos2d::Action* cobj = static_cast<cocos2d::Action*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            cocos2d::Action* retval = cobj->reverse();
            mrb_value ret;
            ret = object_to_rubyval<cocos2d::Action>(mrb, "CC::Action", (cocos2d::Action*)retval, nullptr);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::Action#reverse");

    return mrb_nil_value();
}

void ruby_cocos2dx_Action_constants_init(mrb_state* mrb, struct RClass* rclass)
{
    do {
        mrb_value ret;
        ret = mrb_fixnum_value((mrb_int)cocos2d::Action::INVALID_TAG);
        mrb_mod_cv_set(mrb, rclass, mrb_intern_cstr(mrb, "INVALID_TAG"), ret);
    } while (0);

}

void ruby_register_cocos2dx_Action(mrb_state* mrb, struct RClass* rmodule)
{
    std::string typeName = typeid(cocos2d::Action).name();
    g_rubyType[typeName] = "CC::Action";
    g_rubyDataType[typeName] = &ruby_cocos2dx_Ref_type;

    struct RClass* p_rmodule = mrb->object_class;
    p_rmodule = mrb_module_get_under(mrb, p_rmodule, "CC");
    struct RClass* p_rclass = mrb_class_get_under(mrb, p_rmodule, "Ref");
    struct RClass *rclass = mrb_define_class_under(mrb, rmodule, "Action", p_rclass);
    MRB_SET_INSTANCE_TT(rclass, MRB_TT_DATA);

    mrb_define_method(mrb, rclass, "start_with_target", ruby_cocos2dx_Action_startWithTarget, ARGS_REQ(1));
    mrb_define_method(mrb, rclass, "set_original_target", ruby_cocos2dx_Action_setOriginalTarget, ARGS_REQ(1));
    mrb_define_method(mrb, rclass, "clone", ruby_cocos2dx_Action_clone, ARGS_NONE());
    mrb_define_method(mrb, rclass, "get_original_target", ruby_cocos2dx_Action_getOriginalTarget, ARGS_NONE());
    mrb_define_method(mrb, rclass, "stop", ruby_cocos2dx_Action_stop, ARGS_NONE());
    mrb_define_method(mrb, rclass, "update", ruby_cocos2dx_Action_update, ARGS_REQ(1));
    mrb_define_method(mrb, rclass, "get_target", ruby_cocos2dx_Action_getTarget, ARGS_NONE());
    mrb_define_method(mrb, rclass, "step", ruby_cocos2dx_Action_step, ARGS_REQ(1));
    mrb_define_method(mrb, rclass, "set_tag", ruby_cocos2dx_Action_setTag, ARGS_REQ(1));
    mrb_define_method(mrb, rclass, "get_tag", ruby_cocos2dx_Action_getTag, ARGS_NONE());
    mrb_define_method(mrb, rclass, "set_target", ruby_cocos2dx_Action_setTarget, ARGS_REQ(1));
    mrb_define_method(mrb, rclass, "done?", ruby_cocos2dx_Action_isDone, ARGS_NONE());
    mrb_define_method(mrb, rclass, "reverse", ruby_cocos2dx_Action_reverse, ARGS_NONE());
    ruby_cocos2dx_Action_constants_init(mrb, rclass);
    mrb_define_class_method(mrb, rclass, "INVALID_TAG", ruby_cocos2dx_constant_get, ARGS_NONE());
}
mrb_value ruby_cocos2dx_FiniteTimeAction_setDuration(mrb_state* mrb, mrb_value self)
{
    cocos2d::FiniteTimeAction* cobj = static_cast<cocos2d::FiniteTimeAction*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            double arg0;
            ok = rubyval_to_number(mrb, argv[0], (double*)&arg0, "CC::FiniteTimeAction.setDuration");
            if (!ok) { break; }
            cobj->setDuration(arg0);
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::FiniteTimeAction#setDuration");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_FiniteTimeAction_getDuration(mrb_state* mrb, mrb_value self)
{
    cocos2d::FiniteTimeAction* cobj = static_cast<cocos2d::FiniteTimeAction*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            double retval = cobj->getDuration();
            mrb_value ret;
            ret = mrb_float_value(mrb, (mrb_float)retval);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::FiniteTimeAction#getDuration");

    return mrb_nil_value();
}

void ruby_register_cocos2dx_FiniteTimeAction(mrb_state* mrb, struct RClass* rmodule)
{
    std::string typeName = typeid(cocos2d::FiniteTimeAction).name();
    g_rubyType[typeName] = "CC::FiniteTimeAction";
    g_rubyDataType[typeName] = &ruby_cocos2dx_Ref_type;

    struct RClass* p_rmodule = mrb->object_class;
    p_rmodule = mrb_module_get_under(mrb, p_rmodule, "CC");
    struct RClass* p_rclass = mrb_class_get_under(mrb, p_rmodule, "Action");
    struct RClass *rclass = mrb_define_class_under(mrb, rmodule, "FiniteTimeAction", p_rclass);
    MRB_SET_INSTANCE_TT(rclass, MRB_TT_DATA);

    mrb_define_method(mrb, rclass, "set_duration", ruby_cocos2dx_FiniteTimeAction_setDuration, ARGS_REQ(1));
    mrb_define_method(mrb, rclass, "get_duration", ruby_cocos2dx_FiniteTimeAction_getDuration, ARGS_NONE());
}
mrb_value ruby_cocos2dx_Speed_setInnerAction(mrb_state* mrb, mrb_value self)
{
    cocos2d::Speed* cobj = static_cast<cocos2d::Speed*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            cocos2d::ActionInterval* arg0;
            ok = rubyval_to_object<cocos2d::ActionInterval>(mrb, argv[0], "CC::ActionInterval", &arg0);
            if (!ok) { break; }
            cobj->setInnerAction(arg0);
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::Speed#setInnerAction");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Speed_setSpeed(mrb_state* mrb, mrb_value self)
{
    cocos2d::Speed* cobj = static_cast<cocos2d::Speed*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            double arg0;
            ok = rubyval_to_number(mrb, argv[0], (double*)&arg0, "CC::Speed.setSpeed");
            if (!ok) { break; }
            cobj->setSpeed(arg0);
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::Speed#setSpeed");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Speed_getInnerAction(mrb_state* mrb, mrb_value self)
{
    cocos2d::Speed* cobj = static_cast<cocos2d::Speed*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            cocos2d::ActionInterval* retval = cobj->getInnerAction();
            mrb_value ret;
            ret = object_to_rubyval<cocos2d::ActionInterval>(mrb, "CC::ActionInterval", (cocos2d::ActionInterval*)retval, nullptr);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::Speed#getInnerAction");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Speed_getSpeed(mrb_state* mrb, mrb_value self)
{
    cocos2d::Speed* cobj = static_cast<cocos2d::Speed*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            double retval = cobj->getSpeed();
            mrb_value ret;
            ret = mrb_float_value(mrb, (mrb_float)retval);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::Speed#getSpeed");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Speed_create_static(mrb_state* mrb, mrb_value self)
{
    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 2) {
            std::map<std::string, mrb_value> callbacks;
            cocos2d::ActionInterval* arg0;
            ok = rubyval_to_object<cocos2d::ActionInterval>(mrb, argv[0], "CC::ActionInterval", &arg0);
            if (!ok) { break; }

            double arg1;
            ok = rubyval_to_number(mrb, argv[1], (double*)&arg1, "CC::Speed.create");
            if (!ok) { break; }

            cocos2d::Speed* retval = cocos2d::Speed::create(arg0, arg1);
            mrb_value ret;
            RClass* rclass = mrb_class_ptr(self);
            ret = object_to_rubyval<cocos2d::Speed>(mrb, "CC::Speed", (cocos2d::Speed*)retval, rclass);
            if (callbacks.size() > 0) {
                mrb_value hash = mrb_iv_get(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"));
                if (!mrb_hash_p(hash)) {
                    hash = mrb_hash_new(mrb);
                }
                for (auto elm : callbacks) {
                    mrb_hash_set(mrb, hash, mrb_str_new_cstr(mrb, elm.first.c_str()), elm.second);
                    mrb_iv_set(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"), hash);
                }
            }
            g_rubyValue.push_back(ret);
            mrb_funcall(mrb, ret, "initialize", 0);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined static method : cocos2d::Speed#create");

    return mrb_nil_value();
}

void ruby_register_cocos2dx_Speed(mrb_state* mrb, struct RClass* rmodule)
{
    std::string typeName = typeid(cocos2d::Speed).name();
    g_rubyType[typeName] = "CC::Speed";
    g_rubyDataType[typeName] = &ruby_cocos2dx_Ref_type;

    struct RClass* p_rmodule = mrb->object_class;
    p_rmodule = mrb_module_get_under(mrb, p_rmodule, "CC");
    struct RClass* p_rclass = mrb_class_get_under(mrb, p_rmodule, "Action");
    struct RClass *rclass = mrb_define_class_under(mrb, rmodule, "Speed", p_rclass);
    MRB_SET_INSTANCE_TT(rclass, MRB_TT_DATA);

    mrb_define_method(mrb, rclass, "set_inner_action", ruby_cocos2dx_Speed_setInnerAction, ARGS_REQ(1));
    mrb_define_method(mrb, rclass, "set_speed", ruby_cocos2dx_Speed_setSpeed, ARGS_REQ(1));
    mrb_define_method(mrb, rclass, "get_inner_action", ruby_cocos2dx_Speed_getInnerAction, ARGS_NONE());
    mrb_define_method(mrb, rclass, "get_speed", ruby_cocos2dx_Speed_getSpeed, ARGS_NONE());
    mrb_define_class_method(mrb, rclass, "create", ruby_cocos2dx_Speed_create_static, ARGS_REQ(2));
}
mrb_value ruby_cocos2dx_Follow_setBoundarySet(mrb_state* mrb, mrb_value self)
{
    cocos2d::Follow* cobj = static_cast<cocos2d::Follow*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            bool arg0;
            ok = rubyval_to_boolean(mrb, argv[0], &arg0, "CC::Follow.setBoundarySet");
            if (!ok) { break; }
            cobj->setBoundarySet(arg0);
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::Follow#setBoundarySet");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Follow_isBoundarySet(mrb_state* mrb, mrb_value self)
{
    cocos2d::Follow* cobj = static_cast<cocos2d::Follow*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            bool retval = cobj->isBoundarySet();
            mrb_value ret;
            ret = mrb_bool_value((mrb_bool)retval);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::Follow#isBoundarySet");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Follow_create_static(mrb_state* mrb, mrb_value self)
{
    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            std::map<std::string, mrb_value> callbacks;
            cocos2d::Node* arg0;
            ok = rubyval_to_object<cocos2d::Node>(mrb, argv[0], "CC::Node", &arg0);
            if (!ok) { break; }

            cocos2d::Follow* retval = cocos2d::Follow::create(arg0);
            mrb_value ret;
            RClass* rclass = mrb_class_ptr(self);
            ret = object_to_rubyval<cocos2d::Follow>(mrb, "CC::Follow", (cocos2d::Follow*)retval, rclass);
            if (callbacks.size() > 0) {
                mrb_value hash = mrb_iv_get(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"));
                if (!mrb_hash_p(hash)) {
                    hash = mrb_hash_new(mrb);
                }
                for (auto elm : callbacks) {
                    mrb_hash_set(mrb, hash, mrb_str_new_cstr(mrb, elm.first.c_str()), elm.second);
                    mrb_iv_set(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"), hash);
                }
            }
            g_rubyValue.push_back(ret);
            mrb_funcall(mrb, ret, "initialize", 0);
            return ret;
        }
    } while (0);
    do {
        if (argc == 2) {
            std::map<std::string, mrb_value> callbacks;
            cocos2d::Node* arg0;
            ok = rubyval_to_object<cocos2d::Node>(mrb, argv[0], "CC::Node", &arg0);
            if (!ok) { break; }

            cocos2d::Rect* arg1;
            ok = rubyval_to_object<cocos2d::Rect>(mrb, argv[1], "CC::Rect", &arg1);
            if (!ok) { break; }

            cocos2d::Follow* retval = cocos2d::Follow::create(arg0, *arg1);
            mrb_value ret;
            RClass* rclass = mrb_class_ptr(self);
            ret = object_to_rubyval<cocos2d::Follow>(mrb, "CC::Follow", (cocos2d::Follow*)retval, rclass);
            if (callbacks.size() > 0) {
                mrb_value hash = mrb_iv_get(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"));
                if (!mrb_hash_p(hash)) {
                    hash = mrb_hash_new(mrb);
                }
                for (auto elm : callbacks) {
                    mrb_hash_set(mrb, hash, mrb_str_new_cstr(mrb, elm.first.c_str()), elm.second);
                    mrb_iv_set(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"), hash);
                }
            }
            g_rubyValue.push_back(ret);
            mrb_funcall(mrb, ret, "initialize", 0);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined static method : cocos2d::Follow#create");

    return mrb_nil_value();
}

void ruby_register_cocos2dx_Follow(mrb_state* mrb, struct RClass* rmodule)
{
    std::string typeName = typeid(cocos2d::Follow).name();
    g_rubyType[typeName] = "CC::Follow";
    g_rubyDataType[typeName] = &ruby_cocos2dx_Ref_type;

    struct RClass* p_rmodule = mrb->object_class;
    p_rmodule = mrb_module_get_under(mrb, p_rmodule, "CC");
    struct RClass* p_rclass = mrb_class_get_under(mrb, p_rmodule, "Action");
    struct RClass *rclass = mrb_define_class_under(mrb, rmodule, "Follow", p_rclass);
    MRB_SET_INSTANCE_TT(rclass, MRB_TT_DATA);

    mrb_define_method(mrb, rclass, "set_boundary_set", ruby_cocos2dx_Follow_setBoundarySet, ARGS_REQ(1));
    mrb_define_method(mrb, rclass, "boundary_set?", ruby_cocos2dx_Follow_isBoundarySet, ARGS_NONE());
    mrb_define_class_method(mrb, rclass, "create", ruby_cocos2dx_Follow_create_static, ARGS_REQ(2));
}
mrb_value ruby_cocos2dx_SpriteFrame_clone(mrb_state* mrb, mrb_value self)
{
    cocos2d::SpriteFrame* cobj = static_cast<cocos2d::SpriteFrame*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            cocos2d::SpriteFrame* retval = cobj->clone();
            mrb_value ret;
            ret = object_to_rubyval<cocos2d::SpriteFrame>(mrb, "CC::SpriteFrame", (cocos2d::SpriteFrame*)retval, nullptr);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::SpriteFrame#clone");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_SpriteFrame_setRotated(mrb_state* mrb, mrb_value self)
{
    cocos2d::SpriteFrame* cobj = static_cast<cocos2d::SpriteFrame*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            bool arg0;
            ok = rubyval_to_boolean(mrb, argv[0], &arg0, "CC::SpriteFrame.setRotated");
            if (!ok) { break; }
            cobj->setRotated(arg0);
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::SpriteFrame#setRotated");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_SpriteFrame_setTexture(mrb_state* mrb, mrb_value self)
{
    cocos2d::SpriteFrame* cobj = static_cast<cocos2d::SpriteFrame*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            cocos2d::Texture2D* arg0;
            ok = rubyval_to_object<cocos2d::Texture2D>(mrb, argv[0], "CC::Texture2D", &arg0);
            if (!ok) { break; }
            cobj->setTexture(arg0);
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::SpriteFrame#setTexture");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_SpriteFrame_getOffset(mrb_state* mrb, mrb_value self)
{
    cocos2d::SpriteFrame* cobj = static_cast<cocos2d::SpriteFrame*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            cocos2d::Vec2 retval = cobj->getOffset();
            cocos2d::Vec2* retval_ptr = new cocos2d::Vec2(retval);
            mrb_value ret;
            ret = object_to_rubyval<cocos2d::Vec2>(mrb, "CC::Vec2", (cocos2d::Vec2*)retval_ptr, nullptr);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::SpriteFrame#getOffset");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_SpriteFrame_setRectInPixels(mrb_state* mrb, mrb_value self)
{
    cocos2d::SpriteFrame* cobj = static_cast<cocos2d::SpriteFrame*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            cocos2d::Rect* arg0;
            ok = rubyval_to_object<cocos2d::Rect>(mrb, argv[0], "CC::Rect", &arg0);
            if (!ok) { break; }
            cobj->setRectInPixels(*arg0);
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::SpriteFrame#setRectInPixels");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_SpriteFrame_getTexture(mrb_state* mrb, mrb_value self)
{
    cocos2d::SpriteFrame* cobj = static_cast<cocos2d::SpriteFrame*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            cocos2d::Texture2D* retval = cobj->getTexture();
            mrb_value ret;
            ret = object_to_rubyval<cocos2d::Texture2D>(mrb, "CC::Texture2D", (cocos2d::Texture2D*)retval, nullptr);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::SpriteFrame#getTexture");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_SpriteFrame_getRect(mrb_state* mrb, mrb_value self)
{
    cocos2d::SpriteFrame* cobj = static_cast<cocos2d::SpriteFrame*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            cocos2d::Rect retval = cobj->getRect();
            cocos2d::Rect* retval_ptr = new cocos2d::Rect(retval);
            mrb_value ret;
            ret = object_to_rubyval<cocos2d::Rect>(mrb, "CC::Rect", (cocos2d::Rect*)retval_ptr, nullptr);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::SpriteFrame#getRect");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_SpriteFrame_setOffsetInPixels(mrb_state* mrb, mrb_value self)
{
    cocos2d::SpriteFrame* cobj = static_cast<cocos2d::SpriteFrame*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            cocos2d::Vec2* arg0;
            ok = rubyval_to_object<cocos2d::Vec2>(mrb, argv[0], "CC::Vec2", &arg0);
            if (!ok) { break; }
            cobj->setOffsetInPixels(*arg0);
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::SpriteFrame#setOffsetInPixels");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_SpriteFrame_getRectInPixels(mrb_state* mrb, mrb_value self)
{
    cocos2d::SpriteFrame* cobj = static_cast<cocos2d::SpriteFrame*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            cocos2d::Rect retval = cobj->getRectInPixels();
            cocos2d::Rect* retval_ptr = new cocos2d::Rect(retval);
            mrb_value ret;
            ret = object_to_rubyval<cocos2d::Rect>(mrb, "CC::Rect", (cocos2d::Rect*)retval_ptr, nullptr);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::SpriteFrame#getRectInPixels");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_SpriteFrame_setOriginalSize(mrb_state* mrb, mrb_value self)
{
    cocos2d::SpriteFrame* cobj = static_cast<cocos2d::SpriteFrame*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            cocos2d::Size* arg0;
            ok = rubyval_to_object<cocos2d::Size>(mrb, argv[0], "CC::Size", &arg0);
            if (!ok) { break; }
            cobj->setOriginalSize(*arg0);
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::SpriteFrame#setOriginalSize");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_SpriteFrame_getOriginalSizeInPixels(mrb_state* mrb, mrb_value self)
{
    cocos2d::SpriteFrame* cobj = static_cast<cocos2d::SpriteFrame*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            cocos2d::Size retval = cobj->getOriginalSizeInPixels();
            cocos2d::Size* retval_ptr = new cocos2d::Size(retval);
            mrb_value ret;
            ret = object_to_rubyval<cocos2d::Size>(mrb, "CC::Size", (cocos2d::Size*)retval_ptr, nullptr);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::SpriteFrame#getOriginalSizeInPixels");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_SpriteFrame_setOriginalSizeInPixels(mrb_state* mrb, mrb_value self)
{
    cocos2d::SpriteFrame* cobj = static_cast<cocos2d::SpriteFrame*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            cocos2d::Size* arg0;
            ok = rubyval_to_object<cocos2d::Size>(mrb, argv[0], "CC::Size", &arg0);
            if (!ok) { break; }
            cobj->setOriginalSizeInPixels(*arg0);
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::SpriteFrame#setOriginalSizeInPixels");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_SpriteFrame_setOffset(mrb_state* mrb, mrb_value self)
{
    cocos2d::SpriteFrame* cobj = static_cast<cocos2d::SpriteFrame*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            cocos2d::Vec2* arg0;
            ok = rubyval_to_object<cocos2d::Vec2>(mrb, argv[0], "CC::Vec2", &arg0);
            if (!ok) { break; }
            cobj->setOffset(*arg0);
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::SpriteFrame#setOffset");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_SpriteFrame_isRotated(mrb_state* mrb, mrb_value self)
{
    cocos2d::SpriteFrame* cobj = static_cast<cocos2d::SpriteFrame*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            bool retval = cobj->isRotated();
            mrb_value ret;
            ret = mrb_bool_value((mrb_bool)retval);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::SpriteFrame#isRotated");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_SpriteFrame_setRect(mrb_state* mrb, mrb_value self)
{
    cocos2d::SpriteFrame* cobj = static_cast<cocos2d::SpriteFrame*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            cocos2d::Rect* arg0;
            ok = rubyval_to_object<cocos2d::Rect>(mrb, argv[0], "CC::Rect", &arg0);
            if (!ok) { break; }
            cobj->setRect(*arg0);
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::SpriteFrame#setRect");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_SpriteFrame_getOffsetInPixels(mrb_state* mrb, mrb_value self)
{
    cocos2d::SpriteFrame* cobj = static_cast<cocos2d::SpriteFrame*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            cocos2d::Vec2 retval = cobj->getOffsetInPixels();
            cocos2d::Vec2* retval_ptr = new cocos2d::Vec2(retval);
            mrb_value ret;
            ret = object_to_rubyval<cocos2d::Vec2>(mrb, "CC::Vec2", (cocos2d::Vec2*)retval_ptr, nullptr);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::SpriteFrame#getOffsetInPixels");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_SpriteFrame_getOriginalSize(mrb_state* mrb, mrb_value self)
{
    cocos2d::SpriteFrame* cobj = static_cast<cocos2d::SpriteFrame*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            cocos2d::Size retval = cobj->getOriginalSize();
            cocos2d::Size* retval_ptr = new cocos2d::Size(retval);
            mrb_value ret;
            ret = object_to_rubyval<cocos2d::Size>(mrb, "CC::Size", (cocos2d::Size*)retval_ptr, nullptr);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::SpriteFrame#getOriginalSize");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_SpriteFrame_create_static(mrb_state* mrb, mrb_value self)
{
    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 5) {
            std::map<std::string, mrb_value> callbacks;
            std::string arg0;
            ok = rubyval_to_std_string(mrb, argv[0], &arg0, "CC::SpriteFrame.create");
            if (!ok) { break; }

            cocos2d::Rect* arg1;
            ok = rubyval_to_object<cocos2d::Rect>(mrb, argv[1], "CC::Rect", &arg1);
            if (!ok) { break; }

            bool arg2;
            ok = rubyval_to_boolean(mrb, argv[2], &arg2, "CC::SpriteFrame.create");
            if (!ok) { break; }

            cocos2d::Vec2* arg3;
            ok = rubyval_to_object<cocos2d::Vec2>(mrb, argv[3], "CC::Vec2", &arg3);
            if (!ok) { break; }

            cocos2d::Size* arg4;
            ok = rubyval_to_object<cocos2d::Size>(mrb, argv[4], "CC::Size", &arg4);
            if (!ok) { break; }

            cocos2d::SpriteFrame* retval = cocos2d::SpriteFrame::create(arg0, *arg1, arg2, *arg3, *arg4);
            mrb_value ret;
            RClass* rclass = mrb_class_ptr(self);
            ret = object_to_rubyval<cocos2d::SpriteFrame>(mrb, "CC::SpriteFrame", (cocos2d::SpriteFrame*)retval, rclass);
            if (callbacks.size() > 0) {
                mrb_value hash = mrb_iv_get(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"));
                if (!mrb_hash_p(hash)) {
                    hash = mrb_hash_new(mrb);
                }
                for (auto elm : callbacks) {
                    mrb_hash_set(mrb, hash, mrb_str_new_cstr(mrb, elm.first.c_str()), elm.second);
                    mrb_iv_set(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"), hash);
                }
            }
            g_rubyValue.push_back(ret);
            mrb_funcall(mrb, ret, "initialize", 0);
            return ret;
        }
    } while (0);
    do {
        if (argc == 2) {
            std::map<std::string, mrb_value> callbacks;
            std::string arg0;
            ok = rubyval_to_std_string(mrb, argv[0], &arg0, "CC::SpriteFrame.create");
            if (!ok) { break; }

            cocos2d::Rect* arg1;
            ok = rubyval_to_object<cocos2d::Rect>(mrb, argv[1], "CC::Rect", &arg1);
            if (!ok) { break; }

            cocos2d::SpriteFrame* retval = cocos2d::SpriteFrame::create(arg0, *arg1);
            mrb_value ret;
            RClass* rclass = mrb_class_ptr(self);
            ret = object_to_rubyval<cocos2d::SpriteFrame>(mrb, "CC::SpriteFrame", (cocos2d::SpriteFrame*)retval, rclass);
            if (callbacks.size() > 0) {
                mrb_value hash = mrb_iv_get(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"));
                if (!mrb_hash_p(hash)) {
                    hash = mrb_hash_new(mrb);
                }
                for (auto elm : callbacks) {
                    mrb_hash_set(mrb, hash, mrb_str_new_cstr(mrb, elm.first.c_str()), elm.second);
                    mrb_iv_set(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"), hash);
                }
            }
            g_rubyValue.push_back(ret);
            mrb_funcall(mrb, ret, "initialize", 0);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined static method : cocos2d::SpriteFrame#create");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_SpriteFrame_createWithTexture_static(mrb_state* mrb, mrb_value self)
{
    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 5) {
            std::map<std::string, mrb_value> callbacks;
            cocos2d::Texture2D* arg0;
            ok = rubyval_to_object<cocos2d::Texture2D>(mrb, argv[0], "CC::Texture2D", &arg0);
            if (!ok) { break; }

            cocos2d::Rect* arg1;
            ok = rubyval_to_object<cocos2d::Rect>(mrb, argv[1], "CC::Rect", &arg1);
            if (!ok) { break; }

            bool arg2;
            ok = rubyval_to_boolean(mrb, argv[2], &arg2, "CC::SpriteFrame.createWithTexture");
            if (!ok) { break; }

            cocos2d::Vec2* arg3;
            ok = rubyval_to_object<cocos2d::Vec2>(mrb, argv[3], "CC::Vec2", &arg3);
            if (!ok) { break; }

            cocos2d::Size* arg4;
            ok = rubyval_to_object<cocos2d::Size>(mrb, argv[4], "CC::Size", &arg4);
            if (!ok) { break; }

            cocos2d::SpriteFrame* retval = cocos2d::SpriteFrame::createWithTexture(arg0, *arg1, arg2, *arg3, *arg4);
            mrb_value ret;
            RClass* rclass = mrb_class_ptr(self);
            ret = object_to_rubyval<cocos2d::SpriteFrame>(mrb, "CC::SpriteFrame", (cocos2d::SpriteFrame*)retval, rclass);
            if (callbacks.size() > 0) {
                mrb_value hash = mrb_iv_get(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"));
                if (!mrb_hash_p(hash)) {
                    hash = mrb_hash_new(mrb);
                }
                for (auto elm : callbacks) {
                    mrb_hash_set(mrb, hash, mrb_str_new_cstr(mrb, elm.first.c_str()), elm.second);
                    mrb_iv_set(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"), hash);
                }
            }
            g_rubyValue.push_back(ret);
            mrb_funcall(mrb, ret, "initialize", 0);
            return ret;
        }
    } while (0);
    do {
        if (argc == 2) {
            std::map<std::string, mrb_value> callbacks;
            cocos2d::Texture2D* arg0;
            ok = rubyval_to_object<cocos2d::Texture2D>(mrb, argv[0], "CC::Texture2D", &arg0);
            if (!ok) { break; }

            cocos2d::Rect* arg1;
            ok = rubyval_to_object<cocos2d::Rect>(mrb, argv[1], "CC::Rect", &arg1);
            if (!ok) { break; }

            cocos2d::SpriteFrame* retval = cocos2d::SpriteFrame::createWithTexture(arg0, *arg1);
            mrb_value ret;
            RClass* rclass = mrb_class_ptr(self);
            ret = object_to_rubyval<cocos2d::SpriteFrame>(mrb, "CC::SpriteFrame", (cocos2d::SpriteFrame*)retval, rclass);
            if (callbacks.size() > 0) {
                mrb_value hash = mrb_iv_get(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"));
                if (!mrb_hash_p(hash)) {
                    hash = mrb_hash_new(mrb);
                }
                for (auto elm : callbacks) {
                    mrb_hash_set(mrb, hash, mrb_str_new_cstr(mrb, elm.first.c_str()), elm.second);
                    mrb_iv_set(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"), hash);
                }
            }
            g_rubyValue.push_back(ret);
            mrb_funcall(mrb, ret, "initialize", 0);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined static method : cocos2d::SpriteFrame#createWithTexture");

    return mrb_nil_value();
}

void ruby_register_cocos2dx_SpriteFrame(mrb_state* mrb, struct RClass* rmodule)
{
    std::string typeName = typeid(cocos2d::SpriteFrame).name();
    g_rubyType[typeName] = "CC::SpriteFrame";
    g_rubyDataType[typeName] = &ruby_cocos2dx_Ref_type;

    struct RClass* p_rmodule = mrb->object_class;
    p_rmodule = mrb_module_get_under(mrb, p_rmodule, "CC");
    struct RClass* p_rclass = mrb_class_get_under(mrb, p_rmodule, "Ref");
    struct RClass *rclass = mrb_define_class_under(mrb, rmodule, "SpriteFrame", p_rclass);
    MRB_SET_INSTANCE_TT(rclass, MRB_TT_DATA);

    mrb_define_method(mrb, rclass, "clone", ruby_cocos2dx_SpriteFrame_clone, ARGS_NONE());
    mrb_define_method(mrb, rclass, "set_rotated", ruby_cocos2dx_SpriteFrame_setRotated, ARGS_REQ(1));
    mrb_define_method(mrb, rclass, "set_texture", ruby_cocos2dx_SpriteFrame_setTexture, ARGS_REQ(1));
    mrb_define_method(mrb, rclass, "get_offset", ruby_cocos2dx_SpriteFrame_getOffset, ARGS_NONE());
    mrb_define_method(mrb, rclass, "set_rect_in_pixels", ruby_cocos2dx_SpriteFrame_setRectInPixels, ARGS_REQ(1));
    mrb_define_method(mrb, rclass, "get_texture", ruby_cocos2dx_SpriteFrame_getTexture, ARGS_NONE());
    mrb_define_method(mrb, rclass, "get_rect", ruby_cocos2dx_SpriteFrame_getRect, ARGS_NONE());
    mrb_define_method(mrb, rclass, "set_offset_in_pixels", ruby_cocos2dx_SpriteFrame_setOffsetInPixels, ARGS_REQ(1));
    mrb_define_method(mrb, rclass, "get_rect_in_pixels", ruby_cocos2dx_SpriteFrame_getRectInPixels, ARGS_NONE());
    mrb_define_method(mrb, rclass, "set_original_size", ruby_cocos2dx_SpriteFrame_setOriginalSize, ARGS_REQ(1));
    mrb_define_method(mrb, rclass, "get_original_size_in_pixels", ruby_cocos2dx_SpriteFrame_getOriginalSizeInPixels, ARGS_NONE());
    mrb_define_method(mrb, rclass, "set_original_size_in_pixels", ruby_cocos2dx_SpriteFrame_setOriginalSizeInPixels, ARGS_REQ(1));
    mrb_define_method(mrb, rclass, "set_offset", ruby_cocos2dx_SpriteFrame_setOffset, ARGS_REQ(1));
    mrb_define_method(mrb, rclass, "rotated?", ruby_cocos2dx_SpriteFrame_isRotated, ARGS_NONE());
    mrb_define_method(mrb, rclass, "set_rect", ruby_cocos2dx_SpriteFrame_setRect, ARGS_REQ(1));
    mrb_define_method(mrb, rclass, "get_offset_in_pixels", ruby_cocos2dx_SpriteFrame_getOffsetInPixels, ARGS_NONE());
    mrb_define_method(mrb, rclass, "get_original_size", ruby_cocos2dx_SpriteFrame_getOriginalSize, ARGS_NONE());
    mrb_define_class_method(mrb, rclass, "create", ruby_cocos2dx_SpriteFrame_create_static, ARGS_REQ(2)|ARGS_OPT(3));
    mrb_define_class_method(mrb, rclass, "create_with_texture", ruby_cocos2dx_SpriteFrame_createWithTexture_static, ARGS_REQ(2)|ARGS_OPT(3));
}
mrb_value ruby_cocos2dx_AnimationFrame_setSpriteFrame(mrb_state* mrb, mrb_value self)
{
    cocos2d::AnimationFrame* cobj = static_cast<cocos2d::AnimationFrame*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            cocos2d::SpriteFrame* arg0;
            ok = rubyval_to_object<cocos2d::SpriteFrame>(mrb, argv[0], "CC::SpriteFrame", &arg0);
            if (!ok) { break; }
            cobj->setSpriteFrame(arg0);
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::AnimationFrame#setSpriteFrame");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_AnimationFrame_getUserInfo(mrb_state* mrb, mrb_value self)
{
    cocos2d::AnimationFrame* cobj = static_cast<cocos2d::AnimationFrame*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            cocos2d::ValueMap retval = cobj->getUserInfo();
            mrb_value ret;
            ret = ccvaluemap_to_rubyval(mrb, retval);
            return ret;
        }
    } while (0);
    do {
        if (argc == 0) {
            cocos2d::ValueMap retval = cobj->getUserInfo();
            mrb_value ret;
            ret = ccvaluemap_to_rubyval(mrb, retval);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::AnimationFrame#getUserInfo");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_AnimationFrame_setDelayUnits(mrb_state* mrb, mrb_value self)
{
    cocos2d::AnimationFrame* cobj = static_cast<cocos2d::AnimationFrame*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            double arg0;
            ok = rubyval_to_number(mrb, argv[0], (double*)&arg0, "CC::AnimationFrame.setDelayUnits");
            if (!ok) { break; }
            cobj->setDelayUnits(arg0);
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::AnimationFrame#setDelayUnits");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_AnimationFrame_clone(mrb_state* mrb, mrb_value self)
{
    cocos2d::AnimationFrame* cobj = static_cast<cocos2d::AnimationFrame*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            cocos2d::AnimationFrame* retval = cobj->clone();
            mrb_value ret;
            ret = object_to_rubyval<cocos2d::AnimationFrame>(mrb, "CC::AnimationFrame", (cocos2d::AnimationFrame*)retval, nullptr);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::AnimationFrame#clone");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_AnimationFrame_getSpriteFrame(mrb_state* mrb, mrb_value self)
{
    cocos2d::AnimationFrame* cobj = static_cast<cocos2d::AnimationFrame*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            cocos2d::SpriteFrame* retval = cobj->getSpriteFrame();
            mrb_value ret;
            ret = object_to_rubyval<cocos2d::SpriteFrame>(mrb, "CC::SpriteFrame", (cocos2d::SpriteFrame*)retval, nullptr);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::AnimationFrame#getSpriteFrame");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_AnimationFrame_getDelayUnits(mrb_state* mrb, mrb_value self)
{
    cocos2d::AnimationFrame* cobj = static_cast<cocos2d::AnimationFrame*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            double retval = cobj->getDelayUnits();
            mrb_value ret;
            ret = mrb_float_value(mrb, (mrb_float)retval);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::AnimationFrame#getDelayUnits");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_AnimationFrame_setUserInfo(mrb_state* mrb, mrb_value self)
{
    cocos2d::AnimationFrame* cobj = static_cast<cocos2d::AnimationFrame*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            cocos2d::ValueMap arg0;
            ok = rubyval_to_ccvaluemap(mrb, argv[0], &arg0, "CC::AnimationFrame.setUserInfo");
            if (!ok) { break; }
            cobj->setUserInfo(arg0);
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::AnimationFrame#setUserInfo");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_AnimationFrame_create_static(mrb_state* mrb, mrb_value self)
{
    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 3) {
            std::map<std::string, mrb_value> callbacks;
            cocos2d::SpriteFrame* arg0;
            ok = rubyval_to_object<cocos2d::SpriteFrame>(mrb, argv[0], "CC::SpriteFrame", &arg0);
            if (!ok) { break; }

            double arg1;
            ok = rubyval_to_number(mrb, argv[1], (double*)&arg1, "CC::AnimationFrame.create");
            if (!ok) { break; }

            cocos2d::ValueMap arg2;
            ok = rubyval_to_ccvaluemap(mrb, argv[2], &arg2, "CC::AnimationFrame.create");
            if (!ok) { break; }

            cocos2d::AnimationFrame* retval = cocos2d::AnimationFrame::create(arg0, arg1, arg2);
            mrb_value ret;
            RClass* rclass = mrb_class_ptr(self);
            ret = object_to_rubyval<cocos2d::AnimationFrame>(mrb, "CC::AnimationFrame", (cocos2d::AnimationFrame*)retval, rclass);
            if (callbacks.size() > 0) {
                mrb_value hash = mrb_iv_get(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"));
                if (!mrb_hash_p(hash)) {
                    hash = mrb_hash_new(mrb);
                }
                for (auto elm : callbacks) {
                    mrb_hash_set(mrb, hash, mrb_str_new_cstr(mrb, elm.first.c_str()), elm.second);
                    mrb_iv_set(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"), hash);
                }
            }
            g_rubyValue.push_back(ret);
            mrb_funcall(mrb, ret, "initialize", 0);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined static method : cocos2d::AnimationFrame#create");

    return mrb_nil_value();
}

void ruby_register_cocos2dx_AnimationFrame(mrb_state* mrb, struct RClass* rmodule)
{
    std::string typeName = typeid(cocos2d::AnimationFrame).name();
    g_rubyType[typeName] = "CC::AnimationFrame";
    g_rubyDataType[typeName] = &ruby_cocos2dx_Ref_type;

    struct RClass* p_rmodule = mrb->object_class;
    p_rmodule = mrb_module_get_under(mrb, p_rmodule, "CC");
    struct RClass* p_rclass = mrb_class_get_under(mrb, p_rmodule, "Ref");
    struct RClass *rclass = mrb_define_class_under(mrb, rmodule, "AnimationFrame", p_rclass);
    MRB_SET_INSTANCE_TT(rclass, MRB_TT_DATA);

    mrb_define_method(mrb, rclass, "set_sprite_frame", ruby_cocos2dx_AnimationFrame_setSpriteFrame, ARGS_REQ(1));
    mrb_define_method(mrb, rclass, "get_user_info", ruby_cocos2dx_AnimationFrame_getUserInfo, ARGS_NONE());
    mrb_define_method(mrb, rclass, "set_delay_units", ruby_cocos2dx_AnimationFrame_setDelayUnits, ARGS_REQ(1));
    mrb_define_method(mrb, rclass, "clone", ruby_cocos2dx_AnimationFrame_clone, ARGS_NONE());
    mrb_define_method(mrb, rclass, "get_sprite_frame", ruby_cocos2dx_AnimationFrame_getSpriteFrame, ARGS_NONE());
    mrb_define_method(mrb, rclass, "get_delay_units", ruby_cocos2dx_AnimationFrame_getDelayUnits, ARGS_NONE());
    mrb_define_method(mrb, rclass, "set_user_info", ruby_cocos2dx_AnimationFrame_setUserInfo, ARGS_REQ(1));
    mrb_define_class_method(mrb, rclass, "create", ruby_cocos2dx_AnimationFrame_create_static, ARGS_REQ(3));
}
mrb_value ruby_cocos2dx_Animation_getLoops(mrb_state* mrb, mrb_value self)
{
    cocos2d::Animation* cobj = static_cast<cocos2d::Animation*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            unsigned int retval = cobj->getLoops();
            mrb_value ret;
            ret = mrb_fixnum_value((mrb_int)retval);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::Animation#getLoops");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Animation_addSpriteFrame(mrb_state* mrb, mrb_value self)
{
    cocos2d::Animation* cobj = static_cast<cocos2d::Animation*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            cocos2d::SpriteFrame* arg0;
            ok = rubyval_to_object<cocos2d::SpriteFrame>(mrb, argv[0], "CC::SpriteFrame", &arg0);
            if (!ok) { break; }
            cobj->addSpriteFrame(arg0);
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::Animation#addSpriteFrame");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Animation_setRestoreOriginalFrame(mrb_state* mrb, mrb_value self)
{
    cocos2d::Animation* cobj = static_cast<cocos2d::Animation*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            bool arg0;
            ok = rubyval_to_boolean(mrb, argv[0], &arg0, "CC::Animation.setRestoreOriginalFrame");
            if (!ok) { break; }
            cobj->setRestoreOriginalFrame(arg0);
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::Animation#setRestoreOriginalFrame");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Animation_clone(mrb_state* mrb, mrb_value self)
{
    cocos2d::Animation* cobj = static_cast<cocos2d::Animation*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            cocos2d::Animation* retval = cobj->clone();
            mrb_value ret;
            ret = object_to_rubyval<cocos2d::Animation>(mrb, "CC::Animation", (cocos2d::Animation*)retval, nullptr);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::Animation#clone");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Animation_getDuration(mrb_state* mrb, mrb_value self)
{
    cocos2d::Animation* cobj = static_cast<cocos2d::Animation*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            double retval = cobj->getDuration();
            mrb_value ret;
            ret = mrb_float_value(mrb, (mrb_float)retval);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::Animation#getDuration");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Animation_setFrames(mrb_state* mrb, mrb_value self)
{
    cocos2d::Animation* cobj = static_cast<cocos2d::Animation*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            cocos2d::Vector<cocos2d::AnimationFrame *> arg0;
            ok = rubyval_to_ccvector(mrb, argv[0], &arg0, "CC::Animation.setFrames");
            if (!ok) { break; }
            cobj->setFrames(arg0);
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::Animation#setFrames");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Animation_getFrames(mrb_state* mrb, mrb_value self)
{
    cocos2d::Animation* cobj = static_cast<cocos2d::Animation*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            cocos2d::Vector<cocos2d::AnimationFrame *> retval = cobj->getFrames();
            mrb_value ret;
            ret = ccvector_to_rubyval(mrb, retval);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::Animation#getFrames");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Animation_setLoops(mrb_state* mrb, mrb_value self)
{
    cocos2d::Animation* cobj = static_cast<cocos2d::Animation*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            unsigned int arg0;
            ok = rubyval_to_uint32(mrb, argv[0], &arg0, "CC::Animation.setLoops");
            if (!ok) { break; }
            cobj->setLoops(arg0);
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::Animation#setLoops");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Animation_setDelayPerUnit(mrb_state* mrb, mrb_value self)
{
    cocos2d::Animation* cobj = static_cast<cocos2d::Animation*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            double arg0;
            ok = rubyval_to_number(mrb, argv[0], (double*)&arg0, "CC::Animation.setDelayPerUnit");
            if (!ok) { break; }
            cobj->setDelayPerUnit(arg0);
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::Animation#setDelayPerUnit");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Animation_addSpriteFrameWithFile(mrb_state* mrb, mrb_value self)
{
    cocos2d::Animation* cobj = static_cast<cocos2d::Animation*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            std::string arg0;
            ok = rubyval_to_std_string(mrb, argv[0], &arg0, "CC::Animation.addSpriteFrameWithFile");
            if (!ok) { break; }
            cobj->addSpriteFrameWithFile(arg0);
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::Animation#addSpriteFrameWithFile");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Animation_getTotalDelayUnits(mrb_state* mrb, mrb_value self)
{
    cocos2d::Animation* cobj = static_cast<cocos2d::Animation*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            double retval = cobj->getTotalDelayUnits();
            mrb_value ret;
            ret = mrb_float_value(mrb, (mrb_float)retval);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::Animation#getTotalDelayUnits");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Animation_getDelayPerUnit(mrb_state* mrb, mrb_value self)
{
    cocos2d::Animation* cobj = static_cast<cocos2d::Animation*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            double retval = cobj->getDelayPerUnit();
            mrb_value ret;
            ret = mrb_float_value(mrb, (mrb_float)retval);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::Animation#getDelayPerUnit");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Animation_getRestoreOriginalFrame(mrb_state* mrb, mrb_value self)
{
    cocos2d::Animation* cobj = static_cast<cocos2d::Animation*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            bool retval = cobj->getRestoreOriginalFrame();
            mrb_value ret;
            ret = mrb_bool_value((mrb_bool)retval);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::Animation#getRestoreOriginalFrame");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Animation_addSpriteFrameWithTexture(mrb_state* mrb, mrb_value self)
{
    cocos2d::Animation* cobj = static_cast<cocos2d::Animation*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 2) {
            cocos2d::Texture2D* arg0;
            ok = rubyval_to_object<cocos2d::Texture2D>(mrb, argv[0], "CC::Texture2D", &arg0);
            if (!ok) { break; }
            cocos2d::Rect* arg1;
            ok = rubyval_to_object<cocos2d::Rect>(mrb, argv[1], "CC::Rect", &arg1);
            if (!ok) { break; }
            cobj->addSpriteFrameWithTexture(arg0, *arg1);
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::Animation#addSpriteFrameWithTexture");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Animation_create_static(mrb_state* mrb, mrb_value self)
{
    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 2) {
            std::map<std::string, mrb_value> callbacks;
            cocos2d::Vector<cocos2d::AnimationFrame *> arg0;
            ok = rubyval_to_ccvector(mrb, argv[0], &arg0, "CC::Animation.create");
            if (!ok) { break; }

            double arg1;
            ok = rubyval_to_number(mrb, argv[1], (double*)&arg1, "CC::Animation.create");
            if (!ok) { break; }

            cocos2d::Animation* retval = cocos2d::Animation::create(arg0, arg1);
            mrb_value ret;
            RClass* rclass = mrb_class_ptr(self);
            ret = object_to_rubyval<cocos2d::Animation>(mrb, "CC::Animation", (cocos2d::Animation*)retval, rclass);
            if (callbacks.size() > 0) {
                mrb_value hash = mrb_iv_get(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"));
                if (!mrb_hash_p(hash)) {
                    hash = mrb_hash_new(mrb);
                }
                for (auto elm : callbacks) {
                    mrb_hash_set(mrb, hash, mrb_str_new_cstr(mrb, elm.first.c_str()), elm.second);
                    mrb_iv_set(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"), hash);
                }
            }
            g_rubyValue.push_back(ret);
            mrb_funcall(mrb, ret, "initialize", 0);
            return ret;
        }
    } while (0);
    do {
        if (argc == 3) {
            std::map<std::string, mrb_value> callbacks;
            cocos2d::Vector<cocos2d::AnimationFrame *> arg0;
            ok = rubyval_to_ccvector(mrb, argv[0], &arg0, "CC::Animation.create");
            if (!ok) { break; }

            double arg1;
            ok = rubyval_to_number(mrb, argv[1], (double*)&arg1, "CC::Animation.create");
            if (!ok) { break; }

            unsigned int arg2;
            ok = rubyval_to_uint32(mrb, argv[2], &arg2, "CC::Animation.create");
            if (!ok) { break; }

            cocos2d::Animation* retval = cocos2d::Animation::create(arg0, arg1, arg2);
            mrb_value ret;
            RClass* rclass = mrb_class_ptr(self);
            ret = object_to_rubyval<cocos2d::Animation>(mrb, "CC::Animation", (cocos2d::Animation*)retval, rclass);
            if (callbacks.size() > 0) {
                mrb_value hash = mrb_iv_get(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"));
                if (!mrb_hash_p(hash)) {
                    hash = mrb_hash_new(mrb);
                }
                for (auto elm : callbacks) {
                    mrb_hash_set(mrb, hash, mrb_str_new_cstr(mrb, elm.first.c_str()), elm.second);
                    mrb_iv_set(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"), hash);
                }
            }
            g_rubyValue.push_back(ret);
            mrb_funcall(mrb, ret, "initialize", 0);
            return ret;
        }
    } while (0);
    do {
        if (argc == 0) {
            std::map<std::string, mrb_value> callbacks;
            cocos2d::Animation* retval = cocos2d::Animation::create();
            mrb_value ret;
            RClass* rclass = mrb_class_ptr(self);
            ret = object_to_rubyval<cocos2d::Animation>(mrb, "CC::Animation", (cocos2d::Animation*)retval, rclass);
            if (callbacks.size() > 0) {
                mrb_value hash = mrb_iv_get(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"));
                if (!mrb_hash_p(hash)) {
                    hash = mrb_hash_new(mrb);
                }
                for (auto elm : callbacks) {
                    mrb_hash_set(mrb, hash, mrb_str_new_cstr(mrb, elm.first.c_str()), elm.second);
                    mrb_iv_set(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"), hash);
                }
            }
            g_rubyValue.push_back(ret);
            mrb_funcall(mrb, ret, "initialize", 0);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined static method : cocos2d::Animation#create");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Animation_createWithSpriteFrames_static(mrb_state* mrb, mrb_value self)
{
    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            std::map<std::string, mrb_value> callbacks;
            cocos2d::Vector<cocos2d::SpriteFrame *> arg0;
            ok = rubyval_to_ccvector(mrb, argv[0], &arg0, "CC::Animation.createWithSpriteFrames");
            if (!ok) { break; }

            cocos2d::Animation* retval = cocos2d::Animation::createWithSpriteFrames(arg0);
            mrb_value ret;
            RClass* rclass = mrb_class_ptr(self);
            ret = object_to_rubyval<cocos2d::Animation>(mrb, "CC::Animation", (cocos2d::Animation*)retval, rclass);
            if (callbacks.size() > 0) {
                mrb_value hash = mrb_iv_get(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"));
                if (!mrb_hash_p(hash)) {
                    hash = mrb_hash_new(mrb);
                }
                for (auto elm : callbacks) {
                    mrb_hash_set(mrb, hash, mrb_str_new_cstr(mrb, elm.first.c_str()), elm.second);
                    mrb_iv_set(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"), hash);
                }
            }
            g_rubyValue.push_back(ret);
            mrb_funcall(mrb, ret, "initialize", 0);
            return ret;
        }
    } while (0);
    do {
        if (argc == 2) {
            std::map<std::string, mrb_value> callbacks;
            cocos2d::Vector<cocos2d::SpriteFrame *> arg0;
            ok = rubyval_to_ccvector(mrb, argv[0], &arg0, "CC::Animation.createWithSpriteFrames");
            if (!ok) { break; }

            double arg1;
            ok = rubyval_to_number(mrb, argv[1], (double*)&arg1, "CC::Animation.createWithSpriteFrames");
            if (!ok) { break; }

            cocos2d::Animation* retval = cocos2d::Animation::createWithSpriteFrames(arg0, arg1);
            mrb_value ret;
            RClass* rclass = mrb_class_ptr(self);
            ret = object_to_rubyval<cocos2d::Animation>(mrb, "CC::Animation", (cocos2d::Animation*)retval, rclass);
            if (callbacks.size() > 0) {
                mrb_value hash = mrb_iv_get(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"));
                if (!mrb_hash_p(hash)) {
                    hash = mrb_hash_new(mrb);
                }
                for (auto elm : callbacks) {
                    mrb_hash_set(mrb, hash, mrb_str_new_cstr(mrb, elm.first.c_str()), elm.second);
                    mrb_iv_set(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"), hash);
                }
            }
            g_rubyValue.push_back(ret);
            mrb_funcall(mrb, ret, "initialize", 0);
            return ret;
        }
    } while (0);
    do {
        if (argc == 3) {
            std::map<std::string, mrb_value> callbacks;
            cocos2d::Vector<cocos2d::SpriteFrame *> arg0;
            ok = rubyval_to_ccvector(mrb, argv[0], &arg0, "CC::Animation.createWithSpriteFrames");
            if (!ok) { break; }

            double arg1;
            ok = rubyval_to_number(mrb, argv[1], (double*)&arg1, "CC::Animation.createWithSpriteFrames");
            if (!ok) { break; }

            unsigned int arg2;
            ok = rubyval_to_uint32(mrb, argv[2], &arg2, "CC::Animation.createWithSpriteFrames");
            if (!ok) { break; }

            cocos2d::Animation* retval = cocos2d::Animation::createWithSpriteFrames(arg0, arg1, arg2);
            mrb_value ret;
            RClass* rclass = mrb_class_ptr(self);
            ret = object_to_rubyval<cocos2d::Animation>(mrb, "CC::Animation", (cocos2d::Animation*)retval, rclass);
            if (callbacks.size() > 0) {
                mrb_value hash = mrb_iv_get(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"));
                if (!mrb_hash_p(hash)) {
                    hash = mrb_hash_new(mrb);
                }
                for (auto elm : callbacks) {
                    mrb_hash_set(mrb, hash, mrb_str_new_cstr(mrb, elm.first.c_str()), elm.second);
                    mrb_iv_set(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"), hash);
                }
            }
            g_rubyValue.push_back(ret);
            mrb_funcall(mrb, ret, "initialize", 0);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined static method : cocos2d::Animation#createWithSpriteFrames");

    return mrb_nil_value();
}

void ruby_register_cocos2dx_Animation(mrb_state* mrb, struct RClass* rmodule)
{
    std::string typeName = typeid(cocos2d::Animation).name();
    g_rubyType[typeName] = "CC::Animation";
    g_rubyDataType[typeName] = &ruby_cocos2dx_Ref_type;

    struct RClass* p_rmodule = mrb->object_class;
    p_rmodule = mrb_module_get_under(mrb, p_rmodule, "CC");
    struct RClass* p_rclass = mrb_class_get_under(mrb, p_rmodule, "Ref");
    struct RClass *rclass = mrb_define_class_under(mrb, rmodule, "Animation", p_rclass);
    MRB_SET_INSTANCE_TT(rclass, MRB_TT_DATA);

    mrb_define_method(mrb, rclass, "get_loops", ruby_cocos2dx_Animation_getLoops, ARGS_NONE());
    mrb_define_method(mrb, rclass, "add_sprite_frame", ruby_cocos2dx_Animation_addSpriteFrame, ARGS_REQ(1));
    mrb_define_method(mrb, rclass, "set_restore_original_frame", ruby_cocos2dx_Animation_setRestoreOriginalFrame, ARGS_REQ(1));
    mrb_define_method(mrb, rclass, "clone", ruby_cocos2dx_Animation_clone, ARGS_NONE());
    mrb_define_method(mrb, rclass, "get_duration", ruby_cocos2dx_Animation_getDuration, ARGS_NONE());
    mrb_define_method(mrb, rclass, "set_frames", ruby_cocos2dx_Animation_setFrames, ARGS_REQ(1));
    mrb_define_method(mrb, rclass, "get_frames", ruby_cocos2dx_Animation_getFrames, ARGS_NONE());
    mrb_define_method(mrb, rclass, "set_loops", ruby_cocos2dx_Animation_setLoops, ARGS_REQ(1));
    mrb_define_method(mrb, rclass, "set_delay_per_unit", ruby_cocos2dx_Animation_setDelayPerUnit, ARGS_REQ(1));
    mrb_define_method(mrb, rclass, "add_sprite_frame_with_file", ruby_cocos2dx_Animation_addSpriteFrameWithFile, ARGS_REQ(1));
    mrb_define_method(mrb, rclass, "get_total_delay_units", ruby_cocos2dx_Animation_getTotalDelayUnits, ARGS_NONE());
    mrb_define_method(mrb, rclass, "get_delay_per_unit", ruby_cocos2dx_Animation_getDelayPerUnit, ARGS_NONE());
    mrb_define_method(mrb, rclass, "get_restore_original_frame", ruby_cocos2dx_Animation_getRestoreOriginalFrame, ARGS_NONE());
    mrb_define_method(mrb, rclass, "add_sprite_frame_with_texture", ruby_cocos2dx_Animation_addSpriteFrameWithTexture, ARGS_REQ(2));
    mrb_define_class_method(mrb, rclass, "create", ruby_cocos2dx_Animation_create_static, ARGS_REQ(0)|ARGS_OPT(3));
    mrb_define_class_method(mrb, rclass, "create_with_sprite_frames", ruby_cocos2dx_Animation_createWithSpriteFrames_static, ARGS_REQ(3));
}
mrb_value ruby_cocos2dx_ActionInterval_getAmplitudeRate(mrb_state* mrb, mrb_value self)
{
    cocos2d::ActionInterval* cobj = static_cast<cocos2d::ActionInterval*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            double retval = cobj->getAmplitudeRate();
            mrb_value ret;
            ret = mrb_float_value(mrb, (mrb_float)retval);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::ActionInterval#getAmplitudeRate");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_ActionInterval_setAmplitudeRate(mrb_state* mrb, mrb_value self)
{
    cocos2d::ActionInterval* cobj = static_cast<cocos2d::ActionInterval*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            double arg0;
            ok = rubyval_to_number(mrb, argv[0], (double*)&arg0, "CC::ActionInterval.setAmplitudeRate");
            if (!ok) { break; }
            cobj->setAmplitudeRate(arg0);
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::ActionInterval#setAmplitudeRate");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_ActionInterval_getElapsed(mrb_state* mrb, mrb_value self)
{
    cocos2d::ActionInterval* cobj = static_cast<cocos2d::ActionInterval*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            double retval = cobj->getElapsed();
            mrb_value ret;
            ret = mrb_float_value(mrb, (mrb_float)retval);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::ActionInterval#getElapsed");

    return mrb_nil_value();
}

void ruby_register_cocos2dx_ActionInterval(mrb_state* mrb, struct RClass* rmodule)
{
    std::string typeName = typeid(cocos2d::ActionInterval).name();
    g_rubyType[typeName] = "CC::ActionInterval";
    g_rubyDataType[typeName] = &ruby_cocos2dx_Ref_type;

    struct RClass* p_rmodule = mrb->object_class;
    p_rmodule = mrb_module_get_under(mrb, p_rmodule, "CC");
    struct RClass* p_rclass = mrb_class_get_under(mrb, p_rmodule, "FiniteTimeAction");
    struct RClass *rclass = mrb_define_class_under(mrb, rmodule, "ActionInterval", p_rclass);
    MRB_SET_INSTANCE_TT(rclass, MRB_TT_DATA);

    mrb_define_method(mrb, rclass, "get_amplitude_rate", ruby_cocos2dx_ActionInterval_getAmplitudeRate, ARGS_NONE());
    mrb_define_method(mrb, rclass, "set_amplitude_rate", ruby_cocos2dx_ActionInterval_setAmplitudeRate, ARGS_REQ(1));
    mrb_define_method(mrb, rclass, "get_elapsed", ruby_cocos2dx_ActionInterval_getElapsed, ARGS_NONE());
}
mrb_value ruby_cocos2dx_Sequence_create_static(mrb_state* mrb, mrb_value self)
{
    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            std::map<std::string, mrb_value> callbacks;
            cocos2d::Vector<cocos2d::FiniteTimeAction *> arg0;
            ok = rubyval_to_ccvector(mrb, argv[0], &arg0, "CC::Sequence.create");
            if (!ok) { break; }

            cocos2d::Sequence* retval = cocos2d::Sequence::create(arg0);
            mrb_value ret;
            RClass* rclass = mrb_class_ptr(self);
            ret = object_to_rubyval<cocos2d::Sequence>(mrb, "CC::Sequence", (cocos2d::Sequence*)retval, rclass);
            if (callbacks.size() > 0) {
                mrb_value hash = mrb_iv_get(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"));
                if (!mrb_hash_p(hash)) {
                    hash = mrb_hash_new(mrb);
                }
                for (auto elm : callbacks) {
                    mrb_hash_set(mrb, hash, mrb_str_new_cstr(mrb, elm.first.c_str()), elm.second);
                    mrb_iv_set(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"), hash);
                }
            }
            g_rubyValue.push_back(ret);
            mrb_funcall(mrb, ret, "initialize", 0);
            return ret;
        }
    } while (0);
    do {
        if (argc == 1) {
            std::map<std::string, mrb_value> callbacks;
            cocos2d::FiniteTimeAction* arg0;
            ok = rubyval_to_object<cocos2d::FiniteTimeAction>(mrb, argv[0], "CC::FiniteTimeAction", &arg0);
            if (!ok) { break; }

            cocos2d::Sequence* retval = cocos2d::Sequence::create(arg0, NULL);
            mrb_value ret;
            RClass* rclass = mrb_class_ptr(self);
            ret = object_to_rubyval<cocos2d::Sequence>(mrb, "CC::Sequence", (cocos2d::Sequence*)retval, rclass);
            if (callbacks.size() > 0) {
                mrb_value hash = mrb_iv_get(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"));
                if (!mrb_hash_p(hash)) {
                    hash = mrb_hash_new(mrb);
                }
                for (auto elm : callbacks) {
                    mrb_hash_set(mrb, hash, mrb_str_new_cstr(mrb, elm.first.c_str()), elm.second);
                    mrb_iv_set(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"), hash);
                }
            }
            g_rubyValue.push_back(ret);
            mrb_funcall(mrb, ret, "initialize", 0);
            return ret;
        }
        if (argc == 2) {
            std::map<std::string, mrb_value> callbacks;
            cocos2d::FiniteTimeAction* arg0;
            ok = rubyval_to_object<cocos2d::FiniteTimeAction>(mrb, argv[0], "CC::FiniteTimeAction", &arg0);
            if (!ok) { break; }

            cocos2d::FiniteTimeAction* arg1;
            ok = rubyval_to_object<cocos2d::FiniteTimeAction>(mrb, argv[1], "CC::FiniteTimeAction", &arg1);
            if (!ok) { break; }

            cocos2d::Sequence* retval = cocos2d::Sequence::create(arg0, arg1, NULL);
            mrb_value ret;
            RClass* rclass = mrb_class_ptr(self);
            ret = object_to_rubyval<cocos2d::Sequence>(mrb, "CC::Sequence", (cocos2d::Sequence*)retval, rclass);
            if (callbacks.size() > 0) {
                mrb_value hash = mrb_iv_get(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"));
                if (!mrb_hash_p(hash)) {
                    hash = mrb_hash_new(mrb);
                }
                for (auto elm : callbacks) {
                    mrb_hash_set(mrb, hash, mrb_str_new_cstr(mrb, elm.first.c_str()), elm.second);
                    mrb_iv_set(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"), hash);
                }
            }
            g_rubyValue.push_back(ret);
            mrb_funcall(mrb, ret, "initialize", 0);
            return ret;
        }
        if (argc == 3) {
            std::map<std::string, mrb_value> callbacks;
            cocos2d::FiniteTimeAction* arg0;
            ok = rubyval_to_object<cocos2d::FiniteTimeAction>(mrb, argv[0], "CC::FiniteTimeAction", &arg0);
            if (!ok) { break; }

            cocos2d::FiniteTimeAction* arg1;
            ok = rubyval_to_object<cocos2d::FiniteTimeAction>(mrb, argv[1], "CC::FiniteTimeAction", &arg1);
            if (!ok) { break; }

            cocos2d::FiniteTimeAction* arg2;
            ok = rubyval_to_object<cocos2d::FiniteTimeAction>(mrb, argv[2], "CC::FiniteTimeAction", &arg2);
            if (!ok) { break; }

            cocos2d::Sequence* retval = cocos2d::Sequence::create(arg0, arg1, arg2, NULL);
            mrb_value ret;
            RClass* rclass = mrb_class_ptr(self);
            ret = object_to_rubyval<cocos2d::Sequence>(mrb, "CC::Sequence", (cocos2d::Sequence*)retval, rclass);
            if (callbacks.size() > 0) {
                mrb_value hash = mrb_iv_get(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"));
                if (!mrb_hash_p(hash)) {
                    hash = mrb_hash_new(mrb);
                }
                for (auto elm : callbacks) {
                    mrb_hash_set(mrb, hash, mrb_str_new_cstr(mrb, elm.first.c_str()), elm.second);
                    mrb_iv_set(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"), hash);
                }
            }
            g_rubyValue.push_back(ret);
            mrb_funcall(mrb, ret, "initialize", 0);
            return ret;
        }
        if (argc == 4) {
            std::map<std::string, mrb_value> callbacks;
            cocos2d::FiniteTimeAction* arg0;
            ok = rubyval_to_object<cocos2d::FiniteTimeAction>(mrb, argv[0], "CC::FiniteTimeAction", &arg0);
            if (!ok) { break; }

            cocos2d::FiniteTimeAction* arg1;
            ok = rubyval_to_object<cocos2d::FiniteTimeAction>(mrb, argv[1], "CC::FiniteTimeAction", &arg1);
            if (!ok) { break; }

            cocos2d::FiniteTimeAction* arg2;
            ok = rubyval_to_object<cocos2d::FiniteTimeAction>(mrb, argv[2], "CC::FiniteTimeAction", &arg2);
            if (!ok) { break; }

            cocos2d::FiniteTimeAction* arg3;
            ok = rubyval_to_object<cocos2d::FiniteTimeAction>(mrb, argv[3], "CC::FiniteTimeAction", &arg3);
            if (!ok) { break; }

            cocos2d::Sequence* retval = cocos2d::Sequence::create(arg0, arg1, arg2, arg3, NULL);
            mrb_value ret;
            RClass* rclass = mrb_class_ptr(self);
            ret = object_to_rubyval<cocos2d::Sequence>(mrb, "CC::Sequence", (cocos2d::Sequence*)retval, rclass);
            if (callbacks.size() > 0) {
                mrb_value hash = mrb_iv_get(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"));
                if (!mrb_hash_p(hash)) {
                    hash = mrb_hash_new(mrb);
                }
                for (auto elm : callbacks) {
                    mrb_hash_set(mrb, hash, mrb_str_new_cstr(mrb, elm.first.c_str()), elm.second);
                    mrb_iv_set(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"), hash);
                }
            }
            g_rubyValue.push_back(ret);
            mrb_funcall(mrb, ret, "initialize", 0);
            return ret;
        }
        if (argc == 5) {
            std::map<std::string, mrb_value> callbacks;
            cocos2d::FiniteTimeAction* arg0;
            ok = rubyval_to_object<cocos2d::FiniteTimeAction>(mrb, argv[0], "CC::FiniteTimeAction", &arg0);
            if (!ok) { break; }

            cocos2d::FiniteTimeAction* arg1;
            ok = rubyval_to_object<cocos2d::FiniteTimeAction>(mrb, argv[1], "CC::FiniteTimeAction", &arg1);
            if (!ok) { break; }

            cocos2d::FiniteTimeAction* arg2;
            ok = rubyval_to_object<cocos2d::FiniteTimeAction>(mrb, argv[2], "CC::FiniteTimeAction", &arg2);
            if (!ok) { break; }

            cocos2d::FiniteTimeAction* arg3;
            ok = rubyval_to_object<cocos2d::FiniteTimeAction>(mrb, argv[3], "CC::FiniteTimeAction", &arg3);
            if (!ok) { break; }

            cocos2d::FiniteTimeAction* arg4;
            ok = rubyval_to_object<cocos2d::FiniteTimeAction>(mrb, argv[4], "CC::FiniteTimeAction", &arg4);
            if (!ok) { break; }

            cocos2d::Sequence* retval = cocos2d::Sequence::create(arg0, arg1, arg2, arg3, arg4, NULL);
            mrb_value ret;
            RClass* rclass = mrb_class_ptr(self);
            ret = object_to_rubyval<cocos2d::Sequence>(mrb, "CC::Sequence", (cocos2d::Sequence*)retval, rclass);
            if (callbacks.size() > 0) {
                mrb_value hash = mrb_iv_get(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"));
                if (!mrb_hash_p(hash)) {
                    hash = mrb_hash_new(mrb);
                }
                for (auto elm : callbacks) {
                    mrb_hash_set(mrb, hash, mrb_str_new_cstr(mrb, elm.first.c_str()), elm.second);
                    mrb_iv_set(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"), hash);
                }
            }
            g_rubyValue.push_back(ret);
            mrb_funcall(mrb, ret, "initialize", 0);
            return ret;
        }
        if (argc == 6) {
            std::map<std::string, mrb_value> callbacks;
            cocos2d::FiniteTimeAction* arg0;
            ok = rubyval_to_object<cocos2d::FiniteTimeAction>(mrb, argv[0], "CC::FiniteTimeAction", &arg0);
            if (!ok) { break; }

            cocos2d::FiniteTimeAction* arg1;
            ok = rubyval_to_object<cocos2d::FiniteTimeAction>(mrb, argv[1], "CC::FiniteTimeAction", &arg1);
            if (!ok) { break; }

            cocos2d::FiniteTimeAction* arg2;
            ok = rubyval_to_object<cocos2d::FiniteTimeAction>(mrb, argv[2], "CC::FiniteTimeAction", &arg2);
            if (!ok) { break; }

            cocos2d::FiniteTimeAction* arg3;
            ok = rubyval_to_object<cocos2d::FiniteTimeAction>(mrb, argv[3], "CC::FiniteTimeAction", &arg3);
            if (!ok) { break; }

            cocos2d::FiniteTimeAction* arg4;
            ok = rubyval_to_object<cocos2d::FiniteTimeAction>(mrb, argv[4], "CC::FiniteTimeAction", &arg4);
            if (!ok) { break; }

            cocos2d::FiniteTimeAction* arg5;
            ok = rubyval_to_object<cocos2d::FiniteTimeAction>(mrb, argv[5], "CC::FiniteTimeAction", &arg5);
            if (!ok) { break; }

            cocos2d::Sequence* retval = cocos2d::Sequence::create(arg0, arg1, arg2, arg3, arg4, arg5, NULL);
            mrb_value ret;
            RClass* rclass = mrb_class_ptr(self);
            ret = object_to_rubyval<cocos2d::Sequence>(mrb, "CC::Sequence", (cocos2d::Sequence*)retval, rclass);
            if (callbacks.size() > 0) {
                mrb_value hash = mrb_iv_get(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"));
                if (!mrb_hash_p(hash)) {
                    hash = mrb_hash_new(mrb);
                }
                for (auto elm : callbacks) {
                    mrb_hash_set(mrb, hash, mrb_str_new_cstr(mrb, elm.first.c_str()), elm.second);
                    mrb_iv_set(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"), hash);
                }
            }
            g_rubyValue.push_back(ret);
            mrb_funcall(mrb, ret, "initialize", 0);
            return ret;
        }
        if (argc == 7) {
            std::map<std::string, mrb_value> callbacks;
            cocos2d::FiniteTimeAction* arg0;
            ok = rubyval_to_object<cocos2d::FiniteTimeAction>(mrb, argv[0], "CC::FiniteTimeAction", &arg0);
            if (!ok) { break; }

            cocos2d::FiniteTimeAction* arg1;
            ok = rubyval_to_object<cocos2d::FiniteTimeAction>(mrb, argv[1], "CC::FiniteTimeAction", &arg1);
            if (!ok) { break; }

            cocos2d::FiniteTimeAction* arg2;
            ok = rubyval_to_object<cocos2d::FiniteTimeAction>(mrb, argv[2], "CC::FiniteTimeAction", &arg2);
            if (!ok) { break; }

            cocos2d::FiniteTimeAction* arg3;
            ok = rubyval_to_object<cocos2d::FiniteTimeAction>(mrb, argv[3], "CC::FiniteTimeAction", &arg3);
            if (!ok) { break; }

            cocos2d::FiniteTimeAction* arg4;
            ok = rubyval_to_object<cocos2d::FiniteTimeAction>(mrb, argv[4], "CC::FiniteTimeAction", &arg4);
            if (!ok) { break; }

            cocos2d::FiniteTimeAction* arg5;
            ok = rubyval_to_object<cocos2d::FiniteTimeAction>(mrb, argv[5], "CC::FiniteTimeAction", &arg5);
            if (!ok) { break; }

            cocos2d::FiniteTimeAction* arg6;
            ok = rubyval_to_object<cocos2d::FiniteTimeAction>(mrb, argv[6], "CC::FiniteTimeAction", &arg6);
            if (!ok) { break; }

            cocos2d::Sequence* retval = cocos2d::Sequence::create(arg0, arg1, arg2, arg3, arg4, arg5, arg6, NULL);
            mrb_value ret;
            RClass* rclass = mrb_class_ptr(self);
            ret = object_to_rubyval<cocos2d::Sequence>(mrb, "CC::Sequence", (cocos2d::Sequence*)retval, rclass);
            if (callbacks.size() > 0) {
                mrb_value hash = mrb_iv_get(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"));
                if (!mrb_hash_p(hash)) {
                    hash = mrb_hash_new(mrb);
                }
                for (auto elm : callbacks) {
                    mrb_hash_set(mrb, hash, mrb_str_new_cstr(mrb, elm.first.c_str()), elm.second);
                    mrb_iv_set(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"), hash);
                }
            }
            g_rubyValue.push_back(ret);
            mrb_funcall(mrb, ret, "initialize", 0);
            return ret;
        }
        if (argc == 8) {
            std::map<std::string, mrb_value> callbacks;
            cocos2d::FiniteTimeAction* arg0;
            ok = rubyval_to_object<cocos2d::FiniteTimeAction>(mrb, argv[0], "CC::FiniteTimeAction", &arg0);
            if (!ok) { break; }

            cocos2d::FiniteTimeAction* arg1;
            ok = rubyval_to_object<cocos2d::FiniteTimeAction>(mrb, argv[1], "CC::FiniteTimeAction", &arg1);
            if (!ok) { break; }

            cocos2d::FiniteTimeAction* arg2;
            ok = rubyval_to_object<cocos2d::FiniteTimeAction>(mrb, argv[2], "CC::FiniteTimeAction", &arg2);
            if (!ok) { break; }

            cocos2d::FiniteTimeAction* arg3;
            ok = rubyval_to_object<cocos2d::FiniteTimeAction>(mrb, argv[3], "CC::FiniteTimeAction", &arg3);
            if (!ok) { break; }

            cocos2d::FiniteTimeAction* arg4;
            ok = rubyval_to_object<cocos2d::FiniteTimeAction>(mrb, argv[4], "CC::FiniteTimeAction", &arg4);
            if (!ok) { break; }

            cocos2d::FiniteTimeAction* arg5;
            ok = rubyval_to_object<cocos2d::FiniteTimeAction>(mrb, argv[5], "CC::FiniteTimeAction", &arg5);
            if (!ok) { break; }

            cocos2d::FiniteTimeAction* arg6;
            ok = rubyval_to_object<cocos2d::FiniteTimeAction>(mrb, argv[6], "CC::FiniteTimeAction", &arg6);
            if (!ok) { break; }

            cocos2d::FiniteTimeAction* arg7;
            ok = rubyval_to_object<cocos2d::FiniteTimeAction>(mrb, argv[7], "CC::FiniteTimeAction", &arg7);
            if (!ok) { break; }

            cocos2d::Sequence* retval = cocos2d::Sequence::create(arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7, NULL);
            mrb_value ret;
            RClass* rclass = mrb_class_ptr(self);
            ret = object_to_rubyval<cocos2d::Sequence>(mrb, "CC::Sequence", (cocos2d::Sequence*)retval, rclass);
            if (callbacks.size() > 0) {
                mrb_value hash = mrb_iv_get(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"));
                if (!mrb_hash_p(hash)) {
                    hash = mrb_hash_new(mrb);
                }
                for (auto elm : callbacks) {
                    mrb_hash_set(mrb, hash, mrb_str_new_cstr(mrb, elm.first.c_str()), elm.second);
                    mrb_iv_set(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"), hash);
                }
            }
            g_rubyValue.push_back(ret);
            mrb_funcall(mrb, ret, "initialize", 0);
            return ret;
        }
        if (argc == 9) {
            std::map<std::string, mrb_value> callbacks;
            cocos2d::FiniteTimeAction* arg0;
            ok = rubyval_to_object<cocos2d::FiniteTimeAction>(mrb, argv[0], "CC::FiniteTimeAction", &arg0);
            if (!ok) { break; }

            cocos2d::FiniteTimeAction* arg1;
            ok = rubyval_to_object<cocos2d::FiniteTimeAction>(mrb, argv[1], "CC::FiniteTimeAction", &arg1);
            if (!ok) { break; }

            cocos2d::FiniteTimeAction* arg2;
            ok = rubyval_to_object<cocos2d::FiniteTimeAction>(mrb, argv[2], "CC::FiniteTimeAction", &arg2);
            if (!ok) { break; }

            cocos2d::FiniteTimeAction* arg3;
            ok = rubyval_to_object<cocos2d::FiniteTimeAction>(mrb, argv[3], "CC::FiniteTimeAction", &arg3);
            if (!ok) { break; }

            cocos2d::FiniteTimeAction* arg4;
            ok = rubyval_to_object<cocos2d::FiniteTimeAction>(mrb, argv[4], "CC::FiniteTimeAction", &arg4);
            if (!ok) { break; }

            cocos2d::FiniteTimeAction* arg5;
            ok = rubyval_to_object<cocos2d::FiniteTimeAction>(mrb, argv[5], "CC::FiniteTimeAction", &arg5);
            if (!ok) { break; }

            cocos2d::FiniteTimeAction* arg6;
            ok = rubyval_to_object<cocos2d::FiniteTimeAction>(mrb, argv[6], "CC::FiniteTimeAction", &arg6);
            if (!ok) { break; }

            cocos2d::FiniteTimeAction* arg7;
            ok = rubyval_to_object<cocos2d::FiniteTimeAction>(mrb, argv[7], "CC::FiniteTimeAction", &arg7);
            if (!ok) { break; }

            cocos2d::FiniteTimeAction* arg8;
            ok = rubyval_to_object<cocos2d::FiniteTimeAction>(mrb, argv[8], "CC::FiniteTimeAction", &arg8);
            if (!ok) { break; }

            cocos2d::Sequence* retval = cocos2d::Sequence::create(arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, NULL);
            mrb_value ret;
            RClass* rclass = mrb_class_ptr(self);
            ret = object_to_rubyval<cocos2d::Sequence>(mrb, "CC::Sequence", (cocos2d::Sequence*)retval, rclass);
            if (callbacks.size() > 0) {
                mrb_value hash = mrb_iv_get(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"));
                if (!mrb_hash_p(hash)) {
                    hash = mrb_hash_new(mrb);
                }
                for (auto elm : callbacks) {
                    mrb_hash_set(mrb, hash, mrb_str_new_cstr(mrb, elm.first.c_str()), elm.second);
                    mrb_iv_set(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"), hash);
                }
            }
            g_rubyValue.push_back(ret);
            mrb_funcall(mrb, ret, "initialize", 0);
            return ret;
        }
        if (argc == 10) {
            std::map<std::string, mrb_value> callbacks;
            cocos2d::FiniteTimeAction* arg0;
            ok = rubyval_to_object<cocos2d::FiniteTimeAction>(mrb, argv[0], "CC::FiniteTimeAction", &arg0);
            if (!ok) { break; }

            cocos2d::FiniteTimeAction* arg1;
            ok = rubyval_to_object<cocos2d::FiniteTimeAction>(mrb, argv[1], "CC::FiniteTimeAction", &arg1);
            if (!ok) { break; }

            cocos2d::FiniteTimeAction* arg2;
            ok = rubyval_to_object<cocos2d::FiniteTimeAction>(mrb, argv[2], "CC::FiniteTimeAction", &arg2);
            if (!ok) { break; }

            cocos2d::FiniteTimeAction* arg3;
            ok = rubyval_to_object<cocos2d::FiniteTimeAction>(mrb, argv[3], "CC::FiniteTimeAction", &arg3);
            if (!ok) { break; }

            cocos2d::FiniteTimeAction* arg4;
            ok = rubyval_to_object<cocos2d::FiniteTimeAction>(mrb, argv[4], "CC::FiniteTimeAction", &arg4);
            if (!ok) { break; }

            cocos2d::FiniteTimeAction* arg5;
            ok = rubyval_to_object<cocos2d::FiniteTimeAction>(mrb, argv[5], "CC::FiniteTimeAction", &arg5);
            if (!ok) { break; }

            cocos2d::FiniteTimeAction* arg6;
            ok = rubyval_to_object<cocos2d::FiniteTimeAction>(mrb, argv[6], "CC::FiniteTimeAction", &arg6);
            if (!ok) { break; }

            cocos2d::FiniteTimeAction* arg7;
            ok = rubyval_to_object<cocos2d::FiniteTimeAction>(mrb, argv[7], "CC::FiniteTimeAction", &arg7);
            if (!ok) { break; }

            cocos2d::FiniteTimeAction* arg8;
            ok = rubyval_to_object<cocos2d::FiniteTimeAction>(mrb, argv[8], "CC::FiniteTimeAction", &arg8);
            if (!ok) { break; }

            cocos2d::FiniteTimeAction* arg9;
            ok = rubyval_to_object<cocos2d::FiniteTimeAction>(mrb, argv[9], "CC::FiniteTimeAction", &arg9);
            if (!ok) { break; }

            cocos2d::Sequence* retval = cocos2d::Sequence::create(arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, NULL);
            mrb_value ret;
            RClass* rclass = mrb_class_ptr(self);
            ret = object_to_rubyval<cocos2d::Sequence>(mrb, "CC::Sequence", (cocos2d::Sequence*)retval, rclass);
            if (callbacks.size() > 0) {
                mrb_value hash = mrb_iv_get(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"));
                if (!mrb_hash_p(hash)) {
                    hash = mrb_hash_new(mrb);
                }
                for (auto elm : callbacks) {
                    mrb_hash_set(mrb, hash, mrb_str_new_cstr(mrb, elm.first.c_str()), elm.second);
                    mrb_iv_set(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"), hash);
                }
            }
            g_rubyValue.push_back(ret);
            mrb_funcall(mrb, ret, "initialize", 0);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined static method : cocos2d::Sequence#create");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Sequence_createWithTwoActions_static(mrb_state* mrb, mrb_value self)
{
    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 2) {
            std::map<std::string, mrb_value> callbacks;
            cocos2d::FiniteTimeAction* arg0;
            ok = rubyval_to_object<cocos2d::FiniteTimeAction>(mrb, argv[0], "CC::FiniteTimeAction", &arg0);
            if (!ok) { break; }

            cocos2d::FiniteTimeAction* arg1;
            ok = rubyval_to_object<cocos2d::FiniteTimeAction>(mrb, argv[1], "CC::FiniteTimeAction", &arg1);
            if (!ok) { break; }

            cocos2d::Sequence* retval = cocos2d::Sequence::createWithTwoActions(arg0, arg1);
            mrb_value ret;
            RClass* rclass = mrb_class_ptr(self);
            ret = object_to_rubyval<cocos2d::Sequence>(mrb, "CC::Sequence", (cocos2d::Sequence*)retval, rclass);
            if (callbacks.size() > 0) {
                mrb_value hash = mrb_iv_get(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"));
                if (!mrb_hash_p(hash)) {
                    hash = mrb_hash_new(mrb);
                }
                for (auto elm : callbacks) {
                    mrb_hash_set(mrb, hash, mrb_str_new_cstr(mrb, elm.first.c_str()), elm.second);
                    mrb_iv_set(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"), hash);
                }
            }
            g_rubyValue.push_back(ret);
            mrb_funcall(mrb, ret, "initialize", 0);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined static method : cocos2d::Sequence#createWithTwoActions");

    return mrb_nil_value();
}

void ruby_register_cocos2dx_Sequence(mrb_state* mrb, struct RClass* rmodule)
{
    std::string typeName = typeid(cocos2d::Sequence).name();
    g_rubyType[typeName] = "CC::Sequence";
    g_rubyDataType[typeName] = &ruby_cocos2dx_Ref_type;

    struct RClass* p_rmodule = mrb->object_class;
    p_rmodule = mrb_module_get_under(mrb, p_rmodule, "CC");
    struct RClass* p_rclass = mrb_class_get_under(mrb, p_rmodule, "ActionInterval");
    struct RClass *rclass = mrb_define_class_under(mrb, rmodule, "Sequence", p_rclass);
    MRB_SET_INSTANCE_TT(rclass, MRB_TT_DATA);

    mrb_define_class_method(mrb, rclass, "create", ruby_cocos2dx_Sequence_create_static, ARGS_REQ(1));
    mrb_define_class_method(mrb, rclass, "create_with_two_actions", ruby_cocos2dx_Sequence_createWithTwoActions_static, ARGS_REQ(2));
}
mrb_value ruby_cocos2dx_Repeat_setInnerAction(mrb_state* mrb, mrb_value self)
{
    cocos2d::Repeat* cobj = static_cast<cocos2d::Repeat*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            cocos2d::FiniteTimeAction* arg0;
            ok = rubyval_to_object<cocos2d::FiniteTimeAction>(mrb, argv[0], "CC::FiniteTimeAction", &arg0);
            if (!ok) { break; }
            cobj->setInnerAction(arg0);
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::Repeat#setInnerAction");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Repeat_getInnerAction(mrb_state* mrb, mrb_value self)
{
    cocos2d::Repeat* cobj = static_cast<cocos2d::Repeat*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            cocos2d::FiniteTimeAction* retval = cobj->getInnerAction();
            mrb_value ret;
            ret = object_to_rubyval<cocos2d::FiniteTimeAction>(mrb, "CC::FiniteTimeAction", (cocos2d::FiniteTimeAction*)retval, nullptr);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::Repeat#getInnerAction");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Repeat_create_static(mrb_state* mrb, mrb_value self)
{
    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 2) {
            std::map<std::string, mrb_value> callbacks;
            cocos2d::FiniteTimeAction* arg0;
            ok = rubyval_to_object<cocos2d::FiniteTimeAction>(mrb, argv[0], "CC::FiniteTimeAction", &arg0);
            if (!ok) { break; }

            unsigned int arg1;
            ok = rubyval_to_uint32(mrb, argv[1], &arg1, "CC::Repeat.create");
            if (!ok) { break; }

            cocos2d::Repeat* retval = cocos2d::Repeat::create(arg0, arg1);
            mrb_value ret;
            RClass* rclass = mrb_class_ptr(self);
            ret = object_to_rubyval<cocos2d::Repeat>(mrb, "CC::Repeat", (cocos2d::Repeat*)retval, rclass);
            if (callbacks.size() > 0) {
                mrb_value hash = mrb_iv_get(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"));
                if (!mrb_hash_p(hash)) {
                    hash = mrb_hash_new(mrb);
                }
                for (auto elm : callbacks) {
                    mrb_hash_set(mrb, hash, mrb_str_new_cstr(mrb, elm.first.c_str()), elm.second);
                    mrb_iv_set(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"), hash);
                }
            }
            g_rubyValue.push_back(ret);
            mrb_funcall(mrb, ret, "initialize", 0);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined static method : cocos2d::Repeat#create");

    return mrb_nil_value();
}

void ruby_register_cocos2dx_Repeat(mrb_state* mrb, struct RClass* rmodule)
{
    std::string typeName = typeid(cocos2d::Repeat).name();
    g_rubyType[typeName] = "CC::Repeat";
    g_rubyDataType[typeName] = &ruby_cocos2dx_Ref_type;

    struct RClass* p_rmodule = mrb->object_class;
    p_rmodule = mrb_module_get_under(mrb, p_rmodule, "CC");
    struct RClass* p_rclass = mrb_class_get_under(mrb, p_rmodule, "ActionInterval");
    struct RClass *rclass = mrb_define_class_under(mrb, rmodule, "Repeat", p_rclass);
    MRB_SET_INSTANCE_TT(rclass, MRB_TT_DATA);

    mrb_define_method(mrb, rclass, "set_inner_action", ruby_cocos2dx_Repeat_setInnerAction, ARGS_REQ(1));
    mrb_define_method(mrb, rclass, "get_inner_action", ruby_cocos2dx_Repeat_getInnerAction, ARGS_NONE());
    mrb_define_class_method(mrb, rclass, "create", ruby_cocos2dx_Repeat_create_static, ARGS_REQ(2));
}
mrb_value ruby_cocos2dx_RepeatForever_setInnerAction(mrb_state* mrb, mrb_value self)
{
    cocos2d::RepeatForever* cobj = static_cast<cocos2d::RepeatForever*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            cocos2d::ActionInterval* arg0;
            ok = rubyval_to_object<cocos2d::ActionInterval>(mrb, argv[0], "CC::ActionInterval", &arg0);
            if (!ok) { break; }
            cobj->setInnerAction(arg0);
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::RepeatForever#setInnerAction");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_RepeatForever_getInnerAction(mrb_state* mrb, mrb_value self)
{
    cocos2d::RepeatForever* cobj = static_cast<cocos2d::RepeatForever*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            cocos2d::ActionInterval* retval = cobj->getInnerAction();
            mrb_value ret;
            ret = object_to_rubyval<cocos2d::ActionInterval>(mrb, "CC::ActionInterval", (cocos2d::ActionInterval*)retval, nullptr);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::RepeatForever#getInnerAction");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_RepeatForever_create_static(mrb_state* mrb, mrb_value self)
{
    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            std::map<std::string, mrb_value> callbacks;
            cocos2d::ActionInterval* arg0;
            ok = rubyval_to_object<cocos2d::ActionInterval>(mrb, argv[0], "CC::ActionInterval", &arg0);
            if (!ok) { break; }

            cocos2d::RepeatForever* retval = cocos2d::RepeatForever::create(arg0);
            mrb_value ret;
            RClass* rclass = mrb_class_ptr(self);
            ret = object_to_rubyval<cocos2d::RepeatForever>(mrb, "CC::RepeatForever", (cocos2d::RepeatForever*)retval, rclass);
            if (callbacks.size() > 0) {
                mrb_value hash = mrb_iv_get(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"));
                if (!mrb_hash_p(hash)) {
                    hash = mrb_hash_new(mrb);
                }
                for (auto elm : callbacks) {
                    mrb_hash_set(mrb, hash, mrb_str_new_cstr(mrb, elm.first.c_str()), elm.second);
                    mrb_iv_set(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"), hash);
                }
            }
            g_rubyValue.push_back(ret);
            mrb_funcall(mrb, ret, "initialize", 0);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined static method : cocos2d::RepeatForever#create");

    return mrb_nil_value();
}

void ruby_register_cocos2dx_RepeatForever(mrb_state* mrb, struct RClass* rmodule)
{
    std::string typeName = typeid(cocos2d::RepeatForever).name();
    g_rubyType[typeName] = "CC::RepeatForever";
    g_rubyDataType[typeName] = &ruby_cocos2dx_Ref_type;

    struct RClass* p_rmodule = mrb->object_class;
    p_rmodule = mrb_module_get_under(mrb, p_rmodule, "CC");
    struct RClass* p_rclass = mrb_class_get_under(mrb, p_rmodule, "ActionInterval");
    struct RClass *rclass = mrb_define_class_under(mrb, rmodule, "RepeatForever", p_rclass);
    MRB_SET_INSTANCE_TT(rclass, MRB_TT_DATA);

    mrb_define_method(mrb, rclass, "set_inner_action", ruby_cocos2dx_RepeatForever_setInnerAction, ARGS_REQ(1));
    mrb_define_method(mrb, rclass, "get_inner_action", ruby_cocos2dx_RepeatForever_getInnerAction, ARGS_NONE());
    mrb_define_class_method(mrb, rclass, "create", ruby_cocos2dx_RepeatForever_create_static, ARGS_REQ(1));
}
void ruby_register_cocos2dx_Spawn(mrb_state* mrb, struct RClass* rmodule)
{
    std::string typeName = typeid(cocos2d::Spawn).name();
    g_rubyType[typeName] = "CC::Spawn";
    g_rubyDataType[typeName] = &ruby_cocos2dx_Ref_type;

    struct RClass* p_rmodule = mrb->object_class;
    p_rmodule = mrb_module_get_under(mrb, p_rmodule, "CC");
    struct RClass* p_rclass = mrb_class_get_under(mrb, p_rmodule, "ActionInterval");
    struct RClass *rclass = mrb_define_class_under(mrb, rmodule, "Spawn", p_rclass);
    MRB_SET_INSTANCE_TT(rclass, MRB_TT_DATA);

}
mrb_value ruby_cocos2dx_RotateTo_create_static(mrb_state* mrb, mrb_value self)
{
    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 2) {
            std::map<std::string, mrb_value> callbacks;
            double arg0;
            ok = rubyval_to_number(mrb, argv[0], (double*)&arg0, "CC::RotateTo.create");
            if (!ok) { break; }

            double arg1;
            ok = rubyval_to_number(mrb, argv[1], (double*)&arg1, "CC::RotateTo.create");
            if (!ok) { break; }

            cocos2d::RotateTo* retval = cocos2d::RotateTo::create(arg0, arg1);
            mrb_value ret;
            RClass* rclass = mrb_class_ptr(self);
            ret = object_to_rubyval<cocos2d::RotateTo>(mrb, "CC::RotateTo", (cocos2d::RotateTo*)retval, rclass);
            if (callbacks.size() > 0) {
                mrb_value hash = mrb_iv_get(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"));
                if (!mrb_hash_p(hash)) {
                    hash = mrb_hash_new(mrb);
                }
                for (auto elm : callbacks) {
                    mrb_hash_set(mrb, hash, mrb_str_new_cstr(mrb, elm.first.c_str()), elm.second);
                    mrb_iv_set(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"), hash);
                }
            }
            g_rubyValue.push_back(ret);
            mrb_funcall(mrb, ret, "initialize", 0);
            return ret;
        }
    } while (0);
    do {
        if (argc == 3) {
            std::map<std::string, mrb_value> callbacks;
            double arg0;
            ok = rubyval_to_number(mrb, argv[0], (double*)&arg0, "CC::RotateTo.create");
            if (!ok) { break; }

            double arg1;
            ok = rubyval_to_number(mrb, argv[1], (double*)&arg1, "CC::RotateTo.create");
            if (!ok) { break; }

            double arg2;
            ok = rubyval_to_number(mrb, argv[2], (double*)&arg2, "CC::RotateTo.create");
            if (!ok) { break; }

            cocos2d::RotateTo* retval = cocos2d::RotateTo::create(arg0, arg1, arg2);
            mrb_value ret;
            RClass* rclass = mrb_class_ptr(self);
            ret = object_to_rubyval<cocos2d::RotateTo>(mrb, "CC::RotateTo", (cocos2d::RotateTo*)retval, rclass);
            if (callbacks.size() > 0) {
                mrb_value hash = mrb_iv_get(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"));
                if (!mrb_hash_p(hash)) {
                    hash = mrb_hash_new(mrb);
                }
                for (auto elm : callbacks) {
                    mrb_hash_set(mrb, hash, mrb_str_new_cstr(mrb, elm.first.c_str()), elm.second);
                    mrb_iv_set(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"), hash);
                }
            }
            g_rubyValue.push_back(ret);
            mrb_funcall(mrb, ret, "initialize", 0);
            return ret;
        }
    } while (0);
    do {
        if (argc == 2) {
            std::map<std::string, mrb_value> callbacks;
            double arg0;
            ok = rubyval_to_number(mrb, argv[0], (double*)&arg0, "CC::RotateTo.create");
            if (!ok) { break; }

            cocos2d::Vec3* arg1;
            ok = rubyval_to_object<cocos2d::Vec3>(mrb, argv[1], "CC::Vec3", &arg1);
            if (!ok) { break; }

            cocos2d::RotateTo* retval = cocos2d::RotateTo::create(arg0, *arg1);
            mrb_value ret;
            RClass* rclass = mrb_class_ptr(self);
            ret = object_to_rubyval<cocos2d::RotateTo>(mrb, "CC::RotateTo", (cocos2d::RotateTo*)retval, rclass);
            if (callbacks.size() > 0) {
                mrb_value hash = mrb_iv_get(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"));
                if (!mrb_hash_p(hash)) {
                    hash = mrb_hash_new(mrb);
                }
                for (auto elm : callbacks) {
                    mrb_hash_set(mrb, hash, mrb_str_new_cstr(mrb, elm.first.c_str()), elm.second);
                    mrb_iv_set(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"), hash);
                }
            }
            g_rubyValue.push_back(ret);
            mrb_funcall(mrb, ret, "initialize", 0);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined static method : cocos2d::RotateTo#create");

    return mrb_nil_value();
}

void ruby_register_cocos2dx_RotateTo(mrb_state* mrb, struct RClass* rmodule)
{
    std::string typeName = typeid(cocos2d::RotateTo).name();
    g_rubyType[typeName] = "CC::RotateTo";
    g_rubyDataType[typeName] = &ruby_cocos2dx_Ref_type;

    struct RClass* p_rmodule = mrb->object_class;
    p_rmodule = mrb_module_get_under(mrb, p_rmodule, "CC");
    struct RClass* p_rclass = mrb_class_get_under(mrb, p_rmodule, "ActionInterval");
    struct RClass *rclass = mrb_define_class_under(mrb, rmodule, "RotateTo", p_rclass);
    MRB_SET_INSTANCE_TT(rclass, MRB_TT_DATA);

    mrb_define_class_method(mrb, rclass, "create", ruby_cocos2dx_RotateTo_create_static, ARGS_REQ(2)|ARGS_OPT(1));
}
mrb_value ruby_cocos2dx_RotateBy_create_static(mrb_state* mrb, mrb_value self)
{
    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 3) {
            std::map<std::string, mrb_value> callbacks;
            double arg0;
            ok = rubyval_to_number(mrb, argv[0], (double*)&arg0, "CC::RotateBy.create");
            if (!ok) { break; }

            double arg1;
            ok = rubyval_to_number(mrb, argv[1], (double*)&arg1, "CC::RotateBy.create");
            if (!ok) { break; }

            double arg2;
            ok = rubyval_to_number(mrb, argv[2], (double*)&arg2, "CC::RotateBy.create");
            if (!ok) { break; }

            cocos2d::RotateBy* retval = cocos2d::RotateBy::create(arg0, arg1, arg2);
            mrb_value ret;
            RClass* rclass = mrb_class_ptr(self);
            ret = object_to_rubyval<cocos2d::RotateBy>(mrb, "CC::RotateBy", (cocos2d::RotateBy*)retval, rclass);
            if (callbacks.size() > 0) {
                mrb_value hash = mrb_iv_get(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"));
                if (!mrb_hash_p(hash)) {
                    hash = mrb_hash_new(mrb);
                }
                for (auto elm : callbacks) {
                    mrb_hash_set(mrb, hash, mrb_str_new_cstr(mrb, elm.first.c_str()), elm.second);
                    mrb_iv_set(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"), hash);
                }
            }
            g_rubyValue.push_back(ret);
            mrb_funcall(mrb, ret, "initialize", 0);
            return ret;
        }
    } while (0);
    do {
        if (argc == 2) {
            std::map<std::string, mrb_value> callbacks;
            double arg0;
            ok = rubyval_to_number(mrb, argv[0], (double*)&arg0, "CC::RotateBy.create");
            if (!ok) { break; }

            double arg1;
            ok = rubyval_to_number(mrb, argv[1], (double*)&arg1, "CC::RotateBy.create");
            if (!ok) { break; }

            cocos2d::RotateBy* retval = cocos2d::RotateBy::create(arg0, arg1);
            mrb_value ret;
            RClass* rclass = mrb_class_ptr(self);
            ret = object_to_rubyval<cocos2d::RotateBy>(mrb, "CC::RotateBy", (cocos2d::RotateBy*)retval, rclass);
            if (callbacks.size() > 0) {
                mrb_value hash = mrb_iv_get(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"));
                if (!mrb_hash_p(hash)) {
                    hash = mrb_hash_new(mrb);
                }
                for (auto elm : callbacks) {
                    mrb_hash_set(mrb, hash, mrb_str_new_cstr(mrb, elm.first.c_str()), elm.second);
                    mrb_iv_set(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"), hash);
                }
            }
            g_rubyValue.push_back(ret);
            mrb_funcall(mrb, ret, "initialize", 0);
            return ret;
        }
    } while (0);
    do {
        if (argc == 2) {
            std::map<std::string, mrb_value> callbacks;
            double arg0;
            ok = rubyval_to_number(mrb, argv[0], (double*)&arg0, "CC::RotateBy.create");
            if (!ok) { break; }

            cocos2d::Vec3* arg1;
            ok = rubyval_to_object<cocos2d::Vec3>(mrb, argv[1], "CC::Vec3", &arg1);
            if (!ok) { break; }

            cocos2d::RotateBy* retval = cocos2d::RotateBy::create(arg0, *arg1);
            mrb_value ret;
            RClass* rclass = mrb_class_ptr(self);
            ret = object_to_rubyval<cocos2d::RotateBy>(mrb, "CC::RotateBy", (cocos2d::RotateBy*)retval, rclass);
            if (callbacks.size() > 0) {
                mrb_value hash = mrb_iv_get(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"));
                if (!mrb_hash_p(hash)) {
                    hash = mrb_hash_new(mrb);
                }
                for (auto elm : callbacks) {
                    mrb_hash_set(mrb, hash, mrb_str_new_cstr(mrb, elm.first.c_str()), elm.second);
                    mrb_iv_set(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"), hash);
                }
            }
            g_rubyValue.push_back(ret);
            mrb_funcall(mrb, ret, "initialize", 0);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined static method : cocos2d::RotateBy#create");

    return mrb_nil_value();
}

void ruby_register_cocos2dx_RotateBy(mrb_state* mrb, struct RClass* rmodule)
{
    std::string typeName = typeid(cocos2d::RotateBy).name();
    g_rubyType[typeName] = "CC::RotateBy";
    g_rubyDataType[typeName] = &ruby_cocos2dx_Ref_type;

    struct RClass* p_rmodule = mrb->object_class;
    p_rmodule = mrb_module_get_under(mrb, p_rmodule, "CC");
    struct RClass* p_rclass = mrb_class_get_under(mrb, p_rmodule, "ActionInterval");
    struct RClass *rclass = mrb_define_class_under(mrb, rmodule, "RotateBy", p_rclass);
    MRB_SET_INSTANCE_TT(rclass, MRB_TT_DATA);

    mrb_define_class_method(mrb, rclass, "create", ruby_cocos2dx_RotateBy_create_static, ARGS_REQ(2)|ARGS_OPT(1));
}
mrb_value ruby_cocos2dx_MoveBy_create_static(mrb_state* mrb, mrb_value self)
{
    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 2) {
            std::map<std::string, mrb_value> callbacks;
            double arg0;
            ok = rubyval_to_number(mrb, argv[0], (double*)&arg0, "CC::MoveBy.create");
            if (!ok) { break; }

            cocos2d::Vec3* arg1;
            ok = rubyval_to_object<cocos2d::Vec3>(mrb, argv[1], "CC::Vec3", &arg1);
            if (!ok) { break; }

            cocos2d::MoveBy* retval = cocos2d::MoveBy::create(arg0, *arg1);
            mrb_value ret;
            RClass* rclass = mrb_class_ptr(self);
            ret = object_to_rubyval<cocos2d::MoveBy>(mrb, "CC::MoveBy", (cocos2d::MoveBy*)retval, rclass);
            if (callbacks.size() > 0) {
                mrb_value hash = mrb_iv_get(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"));
                if (!mrb_hash_p(hash)) {
                    hash = mrb_hash_new(mrb);
                }
                for (auto elm : callbacks) {
                    mrb_hash_set(mrb, hash, mrb_str_new_cstr(mrb, elm.first.c_str()), elm.second);
                    mrb_iv_set(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"), hash);
                }
            }
            g_rubyValue.push_back(ret);
            mrb_funcall(mrb, ret, "initialize", 0);
            return ret;
        }
    } while (0);
    do {
        if (argc == 2) {
            std::map<std::string, mrb_value> callbacks;
            double arg0;
            ok = rubyval_to_number(mrb, argv[0], (double*)&arg0, "CC::MoveBy.create");
            if (!ok) { break; }

            cocos2d::Vec2* arg1;
            ok = rubyval_to_object<cocos2d::Vec2>(mrb, argv[1], "CC::Vec2", &arg1);
            if (!ok) { break; }

            cocos2d::MoveBy* retval = cocos2d::MoveBy::create(arg0, *arg1);
            mrb_value ret;
            RClass* rclass = mrb_class_ptr(self);
            ret = object_to_rubyval<cocos2d::MoveBy>(mrb, "CC::MoveBy", (cocos2d::MoveBy*)retval, rclass);
            if (callbacks.size() > 0) {
                mrb_value hash = mrb_iv_get(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"));
                if (!mrb_hash_p(hash)) {
                    hash = mrb_hash_new(mrb);
                }
                for (auto elm : callbacks) {
                    mrb_hash_set(mrb, hash, mrb_str_new_cstr(mrb, elm.first.c_str()), elm.second);
                    mrb_iv_set(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"), hash);
                }
            }
            g_rubyValue.push_back(ret);
            mrb_funcall(mrb, ret, "initialize", 0);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined static method : cocos2d::MoveBy#create");

    return mrb_nil_value();
}

void ruby_register_cocos2dx_MoveBy(mrb_state* mrb, struct RClass* rmodule)
{
    std::string typeName = typeid(cocos2d::MoveBy).name();
    g_rubyType[typeName] = "CC::MoveBy";
    g_rubyDataType[typeName] = &ruby_cocos2dx_Ref_type;

    struct RClass* p_rmodule = mrb->object_class;
    p_rmodule = mrb_module_get_under(mrb, p_rmodule, "CC");
    struct RClass* p_rclass = mrb_class_get_under(mrb, p_rmodule, "ActionInterval");
    struct RClass *rclass = mrb_define_class_under(mrb, rmodule, "MoveBy", p_rclass);
    MRB_SET_INSTANCE_TT(rclass, MRB_TT_DATA);

    mrb_define_class_method(mrb, rclass, "create", ruby_cocos2dx_MoveBy_create_static, ARGS_REQ(2));
}
mrb_value ruby_cocos2dx_MoveTo_create_static(mrb_state* mrb, mrb_value self)
{
    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 2) {
            std::map<std::string, mrb_value> callbacks;
            double arg0;
            ok = rubyval_to_number(mrb, argv[0], (double*)&arg0, "CC::MoveTo.create");
            if (!ok) { break; }

            cocos2d::Vec3* arg1;
            ok = rubyval_to_object<cocos2d::Vec3>(mrb, argv[1], "CC::Vec3", &arg1);
            if (!ok) { break; }

            cocos2d::MoveTo* retval = cocos2d::MoveTo::create(arg0, *arg1);
            mrb_value ret;
            RClass* rclass = mrb_class_ptr(self);
            ret = object_to_rubyval<cocos2d::MoveTo>(mrb, "CC::MoveTo", (cocos2d::MoveTo*)retval, rclass);
            if (callbacks.size() > 0) {
                mrb_value hash = mrb_iv_get(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"));
                if (!mrb_hash_p(hash)) {
                    hash = mrb_hash_new(mrb);
                }
                for (auto elm : callbacks) {
                    mrb_hash_set(mrb, hash, mrb_str_new_cstr(mrb, elm.first.c_str()), elm.second);
                    mrb_iv_set(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"), hash);
                }
            }
            g_rubyValue.push_back(ret);
            mrb_funcall(mrb, ret, "initialize", 0);
            return ret;
        }
    } while (0);
    do {
        if (argc == 2) {
            std::map<std::string, mrb_value> callbacks;
            double arg0;
            ok = rubyval_to_number(mrb, argv[0], (double*)&arg0, "CC::MoveTo.create");
            if (!ok) { break; }

            cocos2d::Vec2* arg1;
            ok = rubyval_to_object<cocos2d::Vec2>(mrb, argv[1], "CC::Vec2", &arg1);
            if (!ok) { break; }

            cocos2d::MoveTo* retval = cocos2d::MoveTo::create(arg0, *arg1);
            mrb_value ret;
            RClass* rclass = mrb_class_ptr(self);
            ret = object_to_rubyval<cocos2d::MoveTo>(mrb, "CC::MoveTo", (cocos2d::MoveTo*)retval, rclass);
            if (callbacks.size() > 0) {
                mrb_value hash = mrb_iv_get(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"));
                if (!mrb_hash_p(hash)) {
                    hash = mrb_hash_new(mrb);
                }
                for (auto elm : callbacks) {
                    mrb_hash_set(mrb, hash, mrb_str_new_cstr(mrb, elm.first.c_str()), elm.second);
                    mrb_iv_set(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"), hash);
                }
            }
            g_rubyValue.push_back(ret);
            mrb_funcall(mrb, ret, "initialize", 0);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined static method : cocos2d::MoveTo#create");

    return mrb_nil_value();
}

void ruby_register_cocos2dx_MoveTo(mrb_state* mrb, struct RClass* rmodule)
{
    std::string typeName = typeid(cocos2d::MoveTo).name();
    g_rubyType[typeName] = "CC::MoveTo";
    g_rubyDataType[typeName] = &ruby_cocos2dx_Ref_type;

    struct RClass* p_rmodule = mrb->object_class;
    p_rmodule = mrb_module_get_under(mrb, p_rmodule, "CC");
    struct RClass* p_rclass = mrb_class_get_under(mrb, p_rmodule, "MoveBy");
    struct RClass *rclass = mrb_define_class_under(mrb, rmodule, "MoveTo", p_rclass);
    MRB_SET_INSTANCE_TT(rclass, MRB_TT_DATA);

    mrb_define_class_method(mrb, rclass, "create", ruby_cocos2dx_MoveTo_create_static, ARGS_REQ(2));
}
mrb_value ruby_cocos2dx_SkewTo_create_static(mrb_state* mrb, mrb_value self)
{
    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 3) {
            std::map<std::string, mrb_value> callbacks;
            double arg0;
            ok = rubyval_to_number(mrb, argv[0], (double*)&arg0, "CC::SkewTo.create");
            if (!ok) { break; }

            double arg1;
            ok = rubyval_to_number(mrb, argv[1], (double*)&arg1, "CC::SkewTo.create");
            if (!ok) { break; }

            double arg2;
            ok = rubyval_to_number(mrb, argv[2], (double*)&arg2, "CC::SkewTo.create");
            if (!ok) { break; }

            cocos2d::SkewTo* retval = cocos2d::SkewTo::create(arg0, arg1, arg2);
            mrb_value ret;
            RClass* rclass = mrb_class_ptr(self);
            ret = object_to_rubyval<cocos2d::SkewTo>(mrb, "CC::SkewTo", (cocos2d::SkewTo*)retval, rclass);
            if (callbacks.size() > 0) {
                mrb_value hash = mrb_iv_get(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"));
                if (!mrb_hash_p(hash)) {
                    hash = mrb_hash_new(mrb);
                }
                for (auto elm : callbacks) {
                    mrb_hash_set(mrb, hash, mrb_str_new_cstr(mrb, elm.first.c_str()), elm.second);
                    mrb_iv_set(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"), hash);
                }
            }
            g_rubyValue.push_back(ret);
            mrb_funcall(mrb, ret, "initialize", 0);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined static method : cocos2d::SkewTo#create");

    return mrb_nil_value();
}

void ruby_register_cocos2dx_SkewTo(mrb_state* mrb, struct RClass* rmodule)
{
    std::string typeName = typeid(cocos2d::SkewTo).name();
    g_rubyType[typeName] = "CC::SkewTo";
    g_rubyDataType[typeName] = &ruby_cocos2dx_Ref_type;

    struct RClass* p_rmodule = mrb->object_class;
    p_rmodule = mrb_module_get_under(mrb, p_rmodule, "CC");
    struct RClass* p_rclass = mrb_class_get_under(mrb, p_rmodule, "ActionInterval");
    struct RClass *rclass = mrb_define_class_under(mrb, rmodule, "SkewTo", p_rclass);
    MRB_SET_INSTANCE_TT(rclass, MRB_TT_DATA);

    mrb_define_class_method(mrb, rclass, "create", ruby_cocos2dx_SkewTo_create_static, ARGS_REQ(3));
}
mrb_value ruby_cocos2dx_SkewBy_create_static(mrb_state* mrb, mrb_value self)
{
    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 3) {
            std::map<std::string, mrb_value> callbacks;
            double arg0;
            ok = rubyval_to_number(mrb, argv[0], (double*)&arg0, "CC::SkewBy.create");
            if (!ok) { break; }

            double arg1;
            ok = rubyval_to_number(mrb, argv[1], (double*)&arg1, "CC::SkewBy.create");
            if (!ok) { break; }

            double arg2;
            ok = rubyval_to_number(mrb, argv[2], (double*)&arg2, "CC::SkewBy.create");
            if (!ok) { break; }

            cocos2d::SkewBy* retval = cocos2d::SkewBy::create(arg0, arg1, arg2);
            mrb_value ret;
            RClass* rclass = mrb_class_ptr(self);
            ret = object_to_rubyval<cocos2d::SkewBy>(mrb, "CC::SkewBy", (cocos2d::SkewBy*)retval, rclass);
            if (callbacks.size() > 0) {
                mrb_value hash = mrb_iv_get(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"));
                if (!mrb_hash_p(hash)) {
                    hash = mrb_hash_new(mrb);
                }
                for (auto elm : callbacks) {
                    mrb_hash_set(mrb, hash, mrb_str_new_cstr(mrb, elm.first.c_str()), elm.second);
                    mrb_iv_set(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"), hash);
                }
            }
            g_rubyValue.push_back(ret);
            mrb_funcall(mrb, ret, "initialize", 0);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined static method : cocos2d::SkewBy#create");

    return mrb_nil_value();
}

void ruby_register_cocos2dx_SkewBy(mrb_state* mrb, struct RClass* rmodule)
{
    std::string typeName = typeid(cocos2d::SkewBy).name();
    g_rubyType[typeName] = "CC::SkewBy";
    g_rubyDataType[typeName] = &ruby_cocos2dx_Ref_type;

    struct RClass* p_rmodule = mrb->object_class;
    p_rmodule = mrb_module_get_under(mrb, p_rmodule, "CC");
    struct RClass* p_rclass = mrb_class_get_under(mrb, p_rmodule, "SkewTo");
    struct RClass *rclass = mrb_define_class_under(mrb, rmodule, "SkewBy", p_rclass);
    MRB_SET_INSTANCE_TT(rclass, MRB_TT_DATA);

    mrb_define_class_method(mrb, rclass, "create", ruby_cocos2dx_SkewBy_create_static, ARGS_REQ(3));
}
mrb_value ruby_cocos2dx_JumpBy_create_static(mrb_state* mrb, mrb_value self)
{
    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 4) {
            std::map<std::string, mrb_value> callbacks;
            double arg0;
            ok = rubyval_to_number(mrb, argv[0], (double*)&arg0, "CC::JumpBy.create");
            if (!ok) { break; }

            cocos2d::Vec2* arg1;
            ok = rubyval_to_object<cocos2d::Vec2>(mrb, argv[1], "CC::Vec2", &arg1);
            if (!ok) { break; }

            double arg2;
            ok = rubyval_to_number(mrb, argv[2], (double*)&arg2, "CC::JumpBy.create");
            if (!ok) { break; }

            int arg3;
            ok = rubyval_to_int32(mrb, argv[3], (int*)&arg3, "CC::JumpBy.create");
            if (!ok) { break; }

            cocos2d::JumpBy* retval = cocos2d::JumpBy::create(arg0, *arg1, arg2, arg3);
            mrb_value ret;
            RClass* rclass = mrb_class_ptr(self);
            ret = object_to_rubyval<cocos2d::JumpBy>(mrb, "CC::JumpBy", (cocos2d::JumpBy*)retval, rclass);
            if (callbacks.size() > 0) {
                mrb_value hash = mrb_iv_get(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"));
                if (!mrb_hash_p(hash)) {
                    hash = mrb_hash_new(mrb);
                }
                for (auto elm : callbacks) {
                    mrb_hash_set(mrb, hash, mrb_str_new_cstr(mrb, elm.first.c_str()), elm.second);
                    mrb_iv_set(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"), hash);
                }
            }
            g_rubyValue.push_back(ret);
            mrb_funcall(mrb, ret, "initialize", 0);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined static method : cocos2d::JumpBy#create");

    return mrb_nil_value();
}

void ruby_register_cocos2dx_JumpBy(mrb_state* mrb, struct RClass* rmodule)
{
    std::string typeName = typeid(cocos2d::JumpBy).name();
    g_rubyType[typeName] = "CC::JumpBy";
    g_rubyDataType[typeName] = &ruby_cocos2dx_Ref_type;

    struct RClass* p_rmodule = mrb->object_class;
    p_rmodule = mrb_module_get_under(mrb, p_rmodule, "CC");
    struct RClass* p_rclass = mrb_class_get_under(mrb, p_rmodule, "ActionInterval");
    struct RClass *rclass = mrb_define_class_under(mrb, rmodule, "JumpBy", p_rclass);
    MRB_SET_INSTANCE_TT(rclass, MRB_TT_DATA);

    mrb_define_class_method(mrb, rclass, "create", ruby_cocos2dx_JumpBy_create_static, ARGS_REQ(4));
}
mrb_value ruby_cocos2dx_JumpTo_create_static(mrb_state* mrb, mrb_value self)
{
    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 4) {
            std::map<std::string, mrb_value> callbacks;
            double arg0;
            ok = rubyval_to_number(mrb, argv[0], (double*)&arg0, "CC::JumpTo.create");
            if (!ok) { break; }

            cocos2d::Vec2* arg1;
            ok = rubyval_to_object<cocos2d::Vec2>(mrb, argv[1], "CC::Vec2", &arg1);
            if (!ok) { break; }

            double arg2;
            ok = rubyval_to_number(mrb, argv[2], (double*)&arg2, "CC::JumpTo.create");
            if (!ok) { break; }

            int arg3;
            ok = rubyval_to_int32(mrb, argv[3], (int*)&arg3, "CC::JumpTo.create");
            if (!ok) { break; }

            cocos2d::JumpTo* retval = cocos2d::JumpTo::create(arg0, *arg1, arg2, arg3);
            mrb_value ret;
            RClass* rclass = mrb_class_ptr(self);
            ret = object_to_rubyval<cocos2d::JumpTo>(mrb, "CC::JumpTo", (cocos2d::JumpTo*)retval, rclass);
            if (callbacks.size() > 0) {
                mrb_value hash = mrb_iv_get(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"));
                if (!mrb_hash_p(hash)) {
                    hash = mrb_hash_new(mrb);
                }
                for (auto elm : callbacks) {
                    mrb_hash_set(mrb, hash, mrb_str_new_cstr(mrb, elm.first.c_str()), elm.second);
                    mrb_iv_set(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"), hash);
                }
            }
            g_rubyValue.push_back(ret);
            mrb_funcall(mrb, ret, "initialize", 0);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined static method : cocos2d::JumpTo#create");

    return mrb_nil_value();
}

void ruby_register_cocos2dx_JumpTo(mrb_state* mrb, struct RClass* rmodule)
{
    std::string typeName = typeid(cocos2d::JumpTo).name();
    g_rubyType[typeName] = "CC::JumpTo";
    g_rubyDataType[typeName] = &ruby_cocos2dx_Ref_type;

    struct RClass* p_rmodule = mrb->object_class;
    p_rmodule = mrb_module_get_under(mrb, p_rmodule, "CC");
    struct RClass* p_rclass = mrb_class_get_under(mrb, p_rmodule, "JumpBy");
    struct RClass *rclass = mrb_define_class_under(mrb, rmodule, "JumpTo", p_rclass);
    MRB_SET_INSTANCE_TT(rclass, MRB_TT_DATA);

    mrb_define_class_method(mrb, rclass, "create", ruby_cocos2dx_JumpTo_create_static, ARGS_REQ(4));
}
void ruby_register_cocos2dx_BezierBy(mrb_state* mrb, struct RClass* rmodule)
{
    std::string typeName = typeid(cocos2d::BezierBy).name();
    g_rubyType[typeName] = "CC::BezierBy";
    g_rubyDataType[typeName] = &ruby_cocos2dx_Ref_type;

    struct RClass* p_rmodule = mrb->object_class;
    p_rmodule = mrb_module_get_under(mrb, p_rmodule, "CC");
    struct RClass* p_rclass = mrb_class_get_under(mrb, p_rmodule, "ActionInterval");
    struct RClass *rclass = mrb_define_class_under(mrb, rmodule, "BezierBy", p_rclass);
    MRB_SET_INSTANCE_TT(rclass, MRB_TT_DATA);

}
void ruby_register_cocos2dx_BezierTo(mrb_state* mrb, struct RClass* rmodule)
{
    std::string typeName = typeid(cocos2d::BezierTo).name();
    g_rubyType[typeName] = "CC::BezierTo";
    g_rubyDataType[typeName] = &ruby_cocos2dx_Ref_type;

    struct RClass* p_rmodule = mrb->object_class;
    p_rmodule = mrb_module_get_under(mrb, p_rmodule, "CC");
    struct RClass* p_rclass = mrb_class_get_under(mrb, p_rmodule, "BezierBy");
    struct RClass *rclass = mrb_define_class_under(mrb, rmodule, "BezierTo", p_rclass);
    MRB_SET_INSTANCE_TT(rclass, MRB_TT_DATA);

}
mrb_value ruby_cocos2dx_ScaleTo_create_static(mrb_state* mrb, mrb_value self)
{
    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 3) {
            std::map<std::string, mrb_value> callbacks;
            double arg0;
            ok = rubyval_to_number(mrb, argv[0], (double*)&arg0, "CC::ScaleTo.create");
            if (!ok) { break; }

            double arg1;
            ok = rubyval_to_number(mrb, argv[1], (double*)&arg1, "CC::ScaleTo.create");
            if (!ok) { break; }

            double arg2;
            ok = rubyval_to_number(mrb, argv[2], (double*)&arg2, "CC::ScaleTo.create");
            if (!ok) { break; }

            cocos2d::ScaleTo* retval = cocos2d::ScaleTo::create(arg0, arg1, arg2);
            mrb_value ret;
            RClass* rclass = mrb_class_ptr(self);
            ret = object_to_rubyval<cocos2d::ScaleTo>(mrb, "CC::ScaleTo", (cocos2d::ScaleTo*)retval, rclass);
            if (callbacks.size() > 0) {
                mrb_value hash = mrb_iv_get(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"));
                if (!mrb_hash_p(hash)) {
                    hash = mrb_hash_new(mrb);
                }
                for (auto elm : callbacks) {
                    mrb_hash_set(mrb, hash, mrb_str_new_cstr(mrb, elm.first.c_str()), elm.second);
                    mrb_iv_set(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"), hash);
                }
            }
            g_rubyValue.push_back(ret);
            mrb_funcall(mrb, ret, "initialize", 0);
            return ret;
        }
    } while (0);
    do {
        if (argc == 2) {
            std::map<std::string, mrb_value> callbacks;
            double arg0;
            ok = rubyval_to_number(mrb, argv[0], (double*)&arg0, "CC::ScaleTo.create");
            if (!ok) { break; }

            double arg1;
            ok = rubyval_to_number(mrb, argv[1], (double*)&arg1, "CC::ScaleTo.create");
            if (!ok) { break; }

            cocos2d::ScaleTo* retval = cocos2d::ScaleTo::create(arg0, arg1);
            mrb_value ret;
            RClass* rclass = mrb_class_ptr(self);
            ret = object_to_rubyval<cocos2d::ScaleTo>(mrb, "CC::ScaleTo", (cocos2d::ScaleTo*)retval, rclass);
            if (callbacks.size() > 0) {
                mrb_value hash = mrb_iv_get(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"));
                if (!mrb_hash_p(hash)) {
                    hash = mrb_hash_new(mrb);
                }
                for (auto elm : callbacks) {
                    mrb_hash_set(mrb, hash, mrb_str_new_cstr(mrb, elm.first.c_str()), elm.second);
                    mrb_iv_set(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"), hash);
                }
            }
            g_rubyValue.push_back(ret);
            mrb_funcall(mrb, ret, "initialize", 0);
            return ret;
        }
    } while (0);
    do {
        if (argc == 4) {
            std::map<std::string, mrb_value> callbacks;
            double arg0;
            ok = rubyval_to_number(mrb, argv[0], (double*)&arg0, "CC::ScaleTo.create");
            if (!ok) { break; }

            double arg1;
            ok = rubyval_to_number(mrb, argv[1], (double*)&arg1, "CC::ScaleTo.create");
            if (!ok) { break; }

            double arg2;
            ok = rubyval_to_number(mrb, argv[2], (double*)&arg2, "CC::ScaleTo.create");
            if (!ok) { break; }

            double arg3;
            ok = rubyval_to_number(mrb, argv[3], (double*)&arg3, "CC::ScaleTo.create");
            if (!ok) { break; }

            cocos2d::ScaleTo* retval = cocos2d::ScaleTo::create(arg0, arg1, arg2, arg3);
            mrb_value ret;
            RClass* rclass = mrb_class_ptr(self);
            ret = object_to_rubyval<cocos2d::ScaleTo>(mrb, "CC::ScaleTo", (cocos2d::ScaleTo*)retval, rclass);
            if (callbacks.size() > 0) {
                mrb_value hash = mrb_iv_get(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"));
                if (!mrb_hash_p(hash)) {
                    hash = mrb_hash_new(mrb);
                }
                for (auto elm : callbacks) {
                    mrb_hash_set(mrb, hash, mrb_str_new_cstr(mrb, elm.first.c_str()), elm.second);
                    mrb_iv_set(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"), hash);
                }
            }
            g_rubyValue.push_back(ret);
            mrb_funcall(mrb, ret, "initialize", 0);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined static method : cocos2d::ScaleTo#create");

    return mrb_nil_value();
}

void ruby_register_cocos2dx_ScaleTo(mrb_state* mrb, struct RClass* rmodule)
{
    std::string typeName = typeid(cocos2d::ScaleTo).name();
    g_rubyType[typeName] = "CC::ScaleTo";
    g_rubyDataType[typeName] = &ruby_cocos2dx_Ref_type;

    struct RClass* p_rmodule = mrb->object_class;
    p_rmodule = mrb_module_get_under(mrb, p_rmodule, "CC");
    struct RClass* p_rclass = mrb_class_get_under(mrb, p_rmodule, "ActionInterval");
    struct RClass *rclass = mrb_define_class_under(mrb, rmodule, "ScaleTo", p_rclass);
    MRB_SET_INSTANCE_TT(rclass, MRB_TT_DATA);

    mrb_define_class_method(mrb, rclass, "create", ruby_cocos2dx_ScaleTo_create_static, ARGS_REQ(2)|ARGS_OPT(2));
}
mrb_value ruby_cocos2dx_ScaleBy_create_static(mrb_state* mrb, mrb_value self)
{
    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 3) {
            std::map<std::string, mrb_value> callbacks;
            double arg0;
            ok = rubyval_to_number(mrb, argv[0], (double*)&arg0, "CC::ScaleBy.create");
            if (!ok) { break; }

            double arg1;
            ok = rubyval_to_number(mrb, argv[1], (double*)&arg1, "CC::ScaleBy.create");
            if (!ok) { break; }

            double arg2;
            ok = rubyval_to_number(mrb, argv[2], (double*)&arg2, "CC::ScaleBy.create");
            if (!ok) { break; }

            cocos2d::ScaleBy* retval = cocos2d::ScaleBy::create(arg0, arg1, arg2);
            mrb_value ret;
            RClass* rclass = mrb_class_ptr(self);
            ret = object_to_rubyval<cocos2d::ScaleBy>(mrb, "CC::ScaleBy", (cocos2d::ScaleBy*)retval, rclass);
            if (callbacks.size() > 0) {
                mrb_value hash = mrb_iv_get(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"));
                if (!mrb_hash_p(hash)) {
                    hash = mrb_hash_new(mrb);
                }
                for (auto elm : callbacks) {
                    mrb_hash_set(mrb, hash, mrb_str_new_cstr(mrb, elm.first.c_str()), elm.second);
                    mrb_iv_set(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"), hash);
                }
            }
            g_rubyValue.push_back(ret);
            mrb_funcall(mrb, ret, "initialize", 0);
            return ret;
        }
    } while (0);
    do {
        if (argc == 2) {
            std::map<std::string, mrb_value> callbacks;
            double arg0;
            ok = rubyval_to_number(mrb, argv[0], (double*)&arg0, "CC::ScaleBy.create");
            if (!ok) { break; }

            double arg1;
            ok = rubyval_to_number(mrb, argv[1], (double*)&arg1, "CC::ScaleBy.create");
            if (!ok) { break; }

            cocos2d::ScaleBy* retval = cocos2d::ScaleBy::create(arg0, arg1);
            mrb_value ret;
            RClass* rclass = mrb_class_ptr(self);
            ret = object_to_rubyval<cocos2d::ScaleBy>(mrb, "CC::ScaleBy", (cocos2d::ScaleBy*)retval, rclass);
            if (callbacks.size() > 0) {
                mrb_value hash = mrb_iv_get(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"));
                if (!mrb_hash_p(hash)) {
                    hash = mrb_hash_new(mrb);
                }
                for (auto elm : callbacks) {
                    mrb_hash_set(mrb, hash, mrb_str_new_cstr(mrb, elm.first.c_str()), elm.second);
                    mrb_iv_set(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"), hash);
                }
            }
            g_rubyValue.push_back(ret);
            mrb_funcall(mrb, ret, "initialize", 0);
            return ret;
        }
    } while (0);
    do {
        if (argc == 4) {
            std::map<std::string, mrb_value> callbacks;
            double arg0;
            ok = rubyval_to_number(mrb, argv[0], (double*)&arg0, "CC::ScaleBy.create");
            if (!ok) { break; }

            double arg1;
            ok = rubyval_to_number(mrb, argv[1], (double*)&arg1, "CC::ScaleBy.create");
            if (!ok) { break; }

            double arg2;
            ok = rubyval_to_number(mrb, argv[2], (double*)&arg2, "CC::ScaleBy.create");
            if (!ok) { break; }

            double arg3;
            ok = rubyval_to_number(mrb, argv[3], (double*)&arg3, "CC::ScaleBy.create");
            if (!ok) { break; }

            cocos2d::ScaleBy* retval = cocos2d::ScaleBy::create(arg0, arg1, arg2, arg3);
            mrb_value ret;
            RClass* rclass = mrb_class_ptr(self);
            ret = object_to_rubyval<cocos2d::ScaleBy>(mrb, "CC::ScaleBy", (cocos2d::ScaleBy*)retval, rclass);
            if (callbacks.size() > 0) {
                mrb_value hash = mrb_iv_get(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"));
                if (!mrb_hash_p(hash)) {
                    hash = mrb_hash_new(mrb);
                }
                for (auto elm : callbacks) {
                    mrb_hash_set(mrb, hash, mrb_str_new_cstr(mrb, elm.first.c_str()), elm.second);
                    mrb_iv_set(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"), hash);
                }
            }
            g_rubyValue.push_back(ret);
            mrb_funcall(mrb, ret, "initialize", 0);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined static method : cocos2d::ScaleBy#create");

    return mrb_nil_value();
}

void ruby_register_cocos2dx_ScaleBy(mrb_state* mrb, struct RClass* rmodule)
{
    std::string typeName = typeid(cocos2d::ScaleBy).name();
    g_rubyType[typeName] = "CC::ScaleBy";
    g_rubyDataType[typeName] = &ruby_cocos2dx_Ref_type;

    struct RClass* p_rmodule = mrb->object_class;
    p_rmodule = mrb_module_get_under(mrb, p_rmodule, "CC");
    struct RClass* p_rclass = mrb_class_get_under(mrb, p_rmodule, "ScaleTo");
    struct RClass *rclass = mrb_define_class_under(mrb, rmodule, "ScaleBy", p_rclass);
    MRB_SET_INSTANCE_TT(rclass, MRB_TT_DATA);

    mrb_define_class_method(mrb, rclass, "create", ruby_cocos2dx_ScaleBy_create_static, ARGS_REQ(2)|ARGS_OPT(2));
}
mrb_value ruby_cocos2dx_Blink_create_static(mrb_state* mrb, mrb_value self)
{
    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 2) {
            std::map<std::string, mrb_value> callbacks;
            double arg0;
            ok = rubyval_to_number(mrb, argv[0], (double*)&arg0, "CC::Blink.create");
            if (!ok) { break; }

            int arg1;
            ok = rubyval_to_int32(mrb, argv[1], (int*)&arg1, "CC::Blink.create");
            if (!ok) { break; }

            cocos2d::Blink* retval = cocos2d::Blink::create(arg0, arg1);
            mrb_value ret;
            RClass* rclass = mrb_class_ptr(self);
            ret = object_to_rubyval<cocos2d::Blink>(mrb, "CC::Blink", (cocos2d::Blink*)retval, rclass);
            if (callbacks.size() > 0) {
                mrb_value hash = mrb_iv_get(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"));
                if (!mrb_hash_p(hash)) {
                    hash = mrb_hash_new(mrb);
                }
                for (auto elm : callbacks) {
                    mrb_hash_set(mrb, hash, mrb_str_new_cstr(mrb, elm.first.c_str()), elm.second);
                    mrb_iv_set(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"), hash);
                }
            }
            g_rubyValue.push_back(ret);
            mrb_funcall(mrb, ret, "initialize", 0);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined static method : cocos2d::Blink#create");

    return mrb_nil_value();
}

void ruby_register_cocos2dx_Blink(mrb_state* mrb, struct RClass* rmodule)
{
    std::string typeName = typeid(cocos2d::Blink).name();
    g_rubyType[typeName] = "CC::Blink";
    g_rubyDataType[typeName] = &ruby_cocos2dx_Ref_type;

    struct RClass* p_rmodule = mrb->object_class;
    p_rmodule = mrb_module_get_under(mrb, p_rmodule, "CC");
    struct RClass* p_rclass = mrb_class_get_under(mrb, p_rmodule, "ActionInterval");
    struct RClass *rclass = mrb_define_class_under(mrb, rmodule, "Blink", p_rclass);
    MRB_SET_INSTANCE_TT(rclass, MRB_TT_DATA);

    mrb_define_class_method(mrb, rclass, "create", ruby_cocos2dx_Blink_create_static, ARGS_REQ(2));
}
mrb_value ruby_cocos2dx_FadeTo_create_static(mrb_state* mrb, mrb_value self)
{
    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 2) {
            std::map<std::string, mrb_value> callbacks;
            double arg0;
            ok = rubyval_to_number(mrb, argv[0], (double*)&arg0, "CC::FadeTo.create");
            if (!ok) { break; }

            uint16_t arg1;
            ok = rubyval_to_uint16(mrb, argv[1], &arg1, "CC::FadeTo.create");
            if (!ok) { break; }

            cocos2d::FadeTo* retval = cocos2d::FadeTo::create(arg0, arg1);
            mrb_value ret;
            RClass* rclass = mrb_class_ptr(self);
            ret = object_to_rubyval<cocos2d::FadeTo>(mrb, "CC::FadeTo", (cocos2d::FadeTo*)retval, rclass);
            if (callbacks.size() > 0) {
                mrb_value hash = mrb_iv_get(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"));
                if (!mrb_hash_p(hash)) {
                    hash = mrb_hash_new(mrb);
                }
                for (auto elm : callbacks) {
                    mrb_hash_set(mrb, hash, mrb_str_new_cstr(mrb, elm.first.c_str()), elm.second);
                    mrb_iv_set(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"), hash);
                }
            }
            g_rubyValue.push_back(ret);
            mrb_funcall(mrb, ret, "initialize", 0);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined static method : cocos2d::FadeTo#create");

    return mrb_nil_value();
}

void ruby_register_cocos2dx_FadeTo(mrb_state* mrb, struct RClass* rmodule)
{
    std::string typeName = typeid(cocos2d::FadeTo).name();
    g_rubyType[typeName] = "CC::FadeTo";
    g_rubyDataType[typeName] = &ruby_cocos2dx_Ref_type;

    struct RClass* p_rmodule = mrb->object_class;
    p_rmodule = mrb_module_get_under(mrb, p_rmodule, "CC");
    struct RClass* p_rclass = mrb_class_get_under(mrb, p_rmodule, "ActionInterval");
    struct RClass *rclass = mrb_define_class_under(mrb, rmodule, "FadeTo", p_rclass);
    MRB_SET_INSTANCE_TT(rclass, MRB_TT_DATA);

    mrb_define_class_method(mrb, rclass, "create", ruby_cocos2dx_FadeTo_create_static, ARGS_REQ(2));
}
mrb_value ruby_cocos2dx_FadeIn_setReverseAction(mrb_state* mrb, mrb_value self)
{
    cocos2d::FadeIn* cobj = static_cast<cocos2d::FadeIn*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            cocos2d::FadeTo* arg0;
            ok = rubyval_to_object<cocos2d::FadeTo>(mrb, argv[0], "CC::FadeTo", &arg0);
            if (!ok) { break; }
            cobj->setReverseAction(arg0);
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::FadeIn#setReverseAction");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_FadeIn_create_static(mrb_state* mrb, mrb_value self)
{
    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            std::map<std::string, mrb_value> callbacks;
            double arg0;
            ok = rubyval_to_number(mrb, argv[0], (double*)&arg0, "CC::FadeIn.create");
            if (!ok) { break; }

            cocos2d::FadeIn* retval = cocos2d::FadeIn::create(arg0);
            mrb_value ret;
            RClass* rclass = mrb_class_ptr(self);
            ret = object_to_rubyval<cocos2d::FadeIn>(mrb, "CC::FadeIn", (cocos2d::FadeIn*)retval, rclass);
            if (callbacks.size() > 0) {
                mrb_value hash = mrb_iv_get(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"));
                if (!mrb_hash_p(hash)) {
                    hash = mrb_hash_new(mrb);
                }
                for (auto elm : callbacks) {
                    mrb_hash_set(mrb, hash, mrb_str_new_cstr(mrb, elm.first.c_str()), elm.second);
                    mrb_iv_set(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"), hash);
                }
            }
            g_rubyValue.push_back(ret);
            mrb_funcall(mrb, ret, "initialize", 0);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined static method : cocos2d::FadeIn#create");

    return mrb_nil_value();
}

void ruby_register_cocos2dx_FadeIn(mrb_state* mrb, struct RClass* rmodule)
{
    std::string typeName = typeid(cocos2d::FadeIn).name();
    g_rubyType[typeName] = "CC::FadeIn";
    g_rubyDataType[typeName] = &ruby_cocos2dx_Ref_type;

    struct RClass* p_rmodule = mrb->object_class;
    p_rmodule = mrb_module_get_under(mrb, p_rmodule, "CC");
    struct RClass* p_rclass = mrb_class_get_under(mrb, p_rmodule, "FadeTo");
    struct RClass *rclass = mrb_define_class_under(mrb, rmodule, "FadeIn", p_rclass);
    MRB_SET_INSTANCE_TT(rclass, MRB_TT_DATA);

    mrb_define_method(mrb, rclass, "set_reverse_action", ruby_cocos2dx_FadeIn_setReverseAction, ARGS_REQ(1));
    mrb_define_class_method(mrb, rclass, "create", ruby_cocos2dx_FadeIn_create_static, ARGS_REQ(1));
}
mrb_value ruby_cocos2dx_FadeOut_setReverseAction(mrb_state* mrb, mrb_value self)
{
    cocos2d::FadeOut* cobj = static_cast<cocos2d::FadeOut*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            cocos2d::FadeTo* arg0;
            ok = rubyval_to_object<cocos2d::FadeTo>(mrb, argv[0], "CC::FadeTo", &arg0);
            if (!ok) { break; }
            cobj->setReverseAction(arg0);
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::FadeOut#setReverseAction");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_FadeOut_create_static(mrb_state* mrb, mrb_value self)
{
    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            std::map<std::string, mrb_value> callbacks;
            double arg0;
            ok = rubyval_to_number(mrb, argv[0], (double*)&arg0, "CC::FadeOut.create");
            if (!ok) { break; }

            cocos2d::FadeOut* retval = cocos2d::FadeOut::create(arg0);
            mrb_value ret;
            RClass* rclass = mrb_class_ptr(self);
            ret = object_to_rubyval<cocos2d::FadeOut>(mrb, "CC::FadeOut", (cocos2d::FadeOut*)retval, rclass);
            if (callbacks.size() > 0) {
                mrb_value hash = mrb_iv_get(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"));
                if (!mrb_hash_p(hash)) {
                    hash = mrb_hash_new(mrb);
                }
                for (auto elm : callbacks) {
                    mrb_hash_set(mrb, hash, mrb_str_new_cstr(mrb, elm.first.c_str()), elm.second);
                    mrb_iv_set(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"), hash);
                }
            }
            g_rubyValue.push_back(ret);
            mrb_funcall(mrb, ret, "initialize", 0);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined static method : cocos2d::FadeOut#create");

    return mrb_nil_value();
}

void ruby_register_cocos2dx_FadeOut(mrb_state* mrb, struct RClass* rmodule)
{
    std::string typeName = typeid(cocos2d::FadeOut).name();
    g_rubyType[typeName] = "CC::FadeOut";
    g_rubyDataType[typeName] = &ruby_cocos2dx_Ref_type;

    struct RClass* p_rmodule = mrb->object_class;
    p_rmodule = mrb_module_get_under(mrb, p_rmodule, "CC");
    struct RClass* p_rclass = mrb_class_get_under(mrb, p_rmodule, "FadeTo");
    struct RClass *rclass = mrb_define_class_under(mrb, rmodule, "FadeOut", p_rclass);
    MRB_SET_INSTANCE_TT(rclass, MRB_TT_DATA);

    mrb_define_method(mrb, rclass, "set_reverse_action", ruby_cocos2dx_FadeOut_setReverseAction, ARGS_REQ(1));
    mrb_define_class_method(mrb, rclass, "create", ruby_cocos2dx_FadeOut_create_static, ARGS_REQ(1));
}
mrb_value ruby_cocos2dx_TintTo_create_static(mrb_state* mrb, mrb_value self)
{
    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 2) {
            std::map<std::string, mrb_value> callbacks;
            double arg0;
            ok = rubyval_to_number(mrb, argv[0], (double*)&arg0, "CC::TintTo.create");
            if (!ok) { break; }

            cocos2d::Color3B* arg1;
            ok = rubyval_to_object<cocos2d::Color3B>(mrb, argv[1], "CC::Color3B", &arg1);
            if (!ok) { break; }

            cocos2d::TintTo* retval = cocos2d::TintTo::create(arg0, *arg1);
            mrb_value ret;
            RClass* rclass = mrb_class_ptr(self);
            ret = object_to_rubyval<cocos2d::TintTo>(mrb, "CC::TintTo", (cocos2d::TintTo*)retval, rclass);
            if (callbacks.size() > 0) {
                mrb_value hash = mrb_iv_get(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"));
                if (!mrb_hash_p(hash)) {
                    hash = mrb_hash_new(mrb);
                }
                for (auto elm : callbacks) {
                    mrb_hash_set(mrb, hash, mrb_str_new_cstr(mrb, elm.first.c_str()), elm.second);
                    mrb_iv_set(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"), hash);
                }
            }
            g_rubyValue.push_back(ret);
            mrb_funcall(mrb, ret, "initialize", 0);
            return ret;
        }
    } while (0);
    do {
        if (argc == 4) {
            std::map<std::string, mrb_value> callbacks;
            double arg0;
            ok = rubyval_to_number(mrb, argv[0], (double*)&arg0, "CC::TintTo.create");
            if (!ok) { break; }

            uint16_t arg1;
            ok = rubyval_to_uint16(mrb, argv[1], &arg1, "CC::TintTo.create");
            if (!ok) { break; }

            uint16_t arg2;
            ok = rubyval_to_uint16(mrb, argv[2], &arg2, "CC::TintTo.create");
            if (!ok) { break; }

            uint16_t arg3;
            ok = rubyval_to_uint16(mrb, argv[3], &arg3, "CC::TintTo.create");
            if (!ok) { break; }

            cocos2d::TintTo* retval = cocos2d::TintTo::create(arg0, arg1, arg2, arg3);
            mrb_value ret;
            RClass* rclass = mrb_class_ptr(self);
            ret = object_to_rubyval<cocos2d::TintTo>(mrb, "CC::TintTo", (cocos2d::TintTo*)retval, rclass);
            if (callbacks.size() > 0) {
                mrb_value hash = mrb_iv_get(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"));
                if (!mrb_hash_p(hash)) {
                    hash = mrb_hash_new(mrb);
                }
                for (auto elm : callbacks) {
                    mrb_hash_set(mrb, hash, mrb_str_new_cstr(mrb, elm.first.c_str()), elm.second);
                    mrb_iv_set(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"), hash);
                }
            }
            g_rubyValue.push_back(ret);
            mrb_funcall(mrb, ret, "initialize", 0);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined static method : cocos2d::TintTo#create");

    return mrb_nil_value();
}

void ruby_register_cocos2dx_TintTo(mrb_state* mrb, struct RClass* rmodule)
{
    std::string typeName = typeid(cocos2d::TintTo).name();
    g_rubyType[typeName] = "CC::TintTo";
    g_rubyDataType[typeName] = &ruby_cocos2dx_Ref_type;

    struct RClass* p_rmodule = mrb->object_class;
    p_rmodule = mrb_module_get_under(mrb, p_rmodule, "CC");
    struct RClass* p_rclass = mrb_class_get_under(mrb, p_rmodule, "ActionInterval");
    struct RClass *rclass = mrb_define_class_under(mrb, rmodule, "TintTo", p_rclass);
    MRB_SET_INSTANCE_TT(rclass, MRB_TT_DATA);

    mrb_define_class_method(mrb, rclass, "create", ruby_cocos2dx_TintTo_create_static, ARGS_REQ(2)|ARGS_OPT(2));
}
mrb_value ruby_cocos2dx_TintBy_create_static(mrb_state* mrb, mrb_value self)
{
    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 4) {
            std::map<std::string, mrb_value> callbacks;
            double arg0;
            ok = rubyval_to_number(mrb, argv[0], (double*)&arg0, "CC::TintBy.create");
            if (!ok) { break; }

            int32_t arg1;
            ok = rubyval_to_int32(mrb, argv[1], &arg1, "CC::TintBy.create");
            if (!ok) { break; }

            int32_t arg2;
            ok = rubyval_to_int32(mrb, argv[2], &arg2, "CC::TintBy.create");
            if (!ok) { break; }

            int32_t arg3;
            ok = rubyval_to_int32(mrb, argv[3], &arg3, "CC::TintBy.create");
            if (!ok) { break; }

            cocos2d::TintBy* retval = cocos2d::TintBy::create(arg0, arg1, arg2, arg3);
            mrb_value ret;
            RClass* rclass = mrb_class_ptr(self);
            ret = object_to_rubyval<cocos2d::TintBy>(mrb, "CC::TintBy", (cocos2d::TintBy*)retval, rclass);
            if (callbacks.size() > 0) {
                mrb_value hash = mrb_iv_get(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"));
                if (!mrb_hash_p(hash)) {
                    hash = mrb_hash_new(mrb);
                }
                for (auto elm : callbacks) {
                    mrb_hash_set(mrb, hash, mrb_str_new_cstr(mrb, elm.first.c_str()), elm.second);
                    mrb_iv_set(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"), hash);
                }
            }
            g_rubyValue.push_back(ret);
            mrb_funcall(mrb, ret, "initialize", 0);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined static method : cocos2d::TintBy#create");

    return mrb_nil_value();
}

void ruby_register_cocos2dx_TintBy(mrb_state* mrb, struct RClass* rmodule)
{
    std::string typeName = typeid(cocos2d::TintBy).name();
    g_rubyType[typeName] = "CC::TintBy";
    g_rubyDataType[typeName] = &ruby_cocos2dx_Ref_type;

    struct RClass* p_rmodule = mrb->object_class;
    p_rmodule = mrb_module_get_under(mrb, p_rmodule, "CC");
    struct RClass* p_rclass = mrb_class_get_under(mrb, p_rmodule, "ActionInterval");
    struct RClass *rclass = mrb_define_class_under(mrb, rmodule, "TintBy", p_rclass);
    MRB_SET_INSTANCE_TT(rclass, MRB_TT_DATA);

    mrb_define_class_method(mrb, rclass, "create", ruby_cocos2dx_TintBy_create_static, ARGS_REQ(4));
}
mrb_value ruby_cocos2dx_DelayTime_create_static(mrb_state* mrb, mrb_value self)
{
    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            std::map<std::string, mrb_value> callbacks;
            double arg0;
            ok = rubyval_to_number(mrb, argv[0], (double*)&arg0, "CC::DelayTime.create");
            if (!ok) { break; }

            cocos2d::DelayTime* retval = cocos2d::DelayTime::create(arg0);
            mrb_value ret;
            RClass* rclass = mrb_class_ptr(self);
            ret = object_to_rubyval<cocos2d::DelayTime>(mrb, "CC::DelayTime", (cocos2d::DelayTime*)retval, rclass);
            if (callbacks.size() > 0) {
                mrb_value hash = mrb_iv_get(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"));
                if (!mrb_hash_p(hash)) {
                    hash = mrb_hash_new(mrb);
                }
                for (auto elm : callbacks) {
                    mrb_hash_set(mrb, hash, mrb_str_new_cstr(mrb, elm.first.c_str()), elm.second);
                    mrb_iv_set(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"), hash);
                }
            }
            g_rubyValue.push_back(ret);
            mrb_funcall(mrb, ret, "initialize", 0);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined static method : cocos2d::DelayTime#create");

    return mrb_nil_value();
}

void ruby_register_cocos2dx_DelayTime(mrb_state* mrb, struct RClass* rmodule)
{
    std::string typeName = typeid(cocos2d::DelayTime).name();
    g_rubyType[typeName] = "CC::DelayTime";
    g_rubyDataType[typeName] = &ruby_cocos2dx_Ref_type;

    struct RClass* p_rmodule = mrb->object_class;
    p_rmodule = mrb_module_get_under(mrb, p_rmodule, "CC");
    struct RClass* p_rclass = mrb_class_get_under(mrb, p_rmodule, "ActionInterval");
    struct RClass *rclass = mrb_define_class_under(mrb, rmodule, "DelayTime", p_rclass);
    MRB_SET_INSTANCE_TT(rclass, MRB_TT_DATA);

    mrb_define_class_method(mrb, rclass, "create", ruby_cocos2dx_DelayTime_create_static, ARGS_REQ(1));
}
mrb_value ruby_cocos2dx_Animate_getAnimation(mrb_state* mrb, mrb_value self)
{
    cocos2d::Animate* cobj = static_cast<cocos2d::Animate*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            const cocos2d::Animation* retval = cobj->getAnimation();
            mrb_value ret;
            ret = object_to_rubyval<cocos2d::Animation>(mrb, "CC::Animation", (cocos2d::Animation*)retval, nullptr);
            return ret;
        }
    } while (0);
    do {
        if (argc == 0) {
            cocos2d::Animation* retval = cobj->getAnimation();
            mrb_value ret;
            ret = object_to_rubyval<cocos2d::Animation>(mrb, "CC::Animation", (cocos2d::Animation*)retval, nullptr);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::Animate#getAnimation");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Animate_setAnimation(mrb_state* mrb, mrb_value self)
{
    cocos2d::Animate* cobj = static_cast<cocos2d::Animate*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            cocos2d::Animation* arg0;
            ok = rubyval_to_object<cocos2d::Animation>(mrb, argv[0], "CC::Animation", &arg0);
            if (!ok) { break; }
            cobj->setAnimation(arg0);
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::Animate#setAnimation");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Animate_create_static(mrb_state* mrb, mrb_value self)
{
    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            std::map<std::string, mrb_value> callbacks;
            cocos2d::Animation* arg0;
            ok = rubyval_to_object<cocos2d::Animation>(mrb, argv[0], "CC::Animation", &arg0);
            if (!ok) { break; }

            cocos2d::Animate* retval = cocos2d::Animate::create(arg0);
            mrb_value ret;
            RClass* rclass = mrb_class_ptr(self);
            ret = object_to_rubyval<cocos2d::Animate>(mrb, "CC::Animate", (cocos2d::Animate*)retval, rclass);
            if (callbacks.size() > 0) {
                mrb_value hash = mrb_iv_get(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"));
                if (!mrb_hash_p(hash)) {
                    hash = mrb_hash_new(mrb);
                }
                for (auto elm : callbacks) {
                    mrb_hash_set(mrb, hash, mrb_str_new_cstr(mrb, elm.first.c_str()), elm.second);
                    mrb_iv_set(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"), hash);
                }
            }
            g_rubyValue.push_back(ret);
            mrb_funcall(mrb, ret, "initialize", 0);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined static method : cocos2d::Animate#create");

    return mrb_nil_value();
}

void ruby_register_cocos2dx_Animate(mrb_state* mrb, struct RClass* rmodule)
{
    std::string typeName = typeid(cocos2d::Animate).name();
    g_rubyType[typeName] = "CC::Animate";
    g_rubyDataType[typeName] = &ruby_cocos2dx_Ref_type;

    struct RClass* p_rmodule = mrb->object_class;
    p_rmodule = mrb_module_get_under(mrb, p_rmodule, "CC");
    struct RClass* p_rclass = mrb_class_get_under(mrb, p_rmodule, "ActionInterval");
    struct RClass *rclass = mrb_define_class_under(mrb, rmodule, "Animate", p_rclass);
    MRB_SET_INSTANCE_TT(rclass, MRB_TT_DATA);

    mrb_define_method(mrb, rclass, "get_animation", ruby_cocos2dx_Animate_getAnimation, ARGS_NONE());
    mrb_define_method(mrb, rclass, "set_animation", ruby_cocos2dx_Animate_setAnimation, ARGS_REQ(1));
    mrb_define_class_method(mrb, rclass, "create", ruby_cocos2dx_Animate_create_static, ARGS_REQ(1));
}
mrb_value ruby_cocos2dx_TargetedAction_getForcedTarget(mrb_state* mrb, mrb_value self)
{
    cocos2d::TargetedAction* cobj = static_cast<cocos2d::TargetedAction*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            const cocos2d::Node* retval = cobj->getForcedTarget();
            mrb_value ret;
            ret = object_to_rubyval<cocos2d::Node>(mrb, "CC::Node", (cocos2d::Node*)retval, nullptr);
            return ret;
        }
    } while (0);
    do {
        if (argc == 0) {
            cocos2d::Node* retval = cobj->getForcedTarget();
            mrb_value ret;
            ret = object_to_rubyval<cocos2d::Node>(mrb, "CC::Node", (cocos2d::Node*)retval, nullptr);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::TargetedAction#getForcedTarget");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_TargetedAction_setForcedTarget(mrb_state* mrb, mrb_value self)
{
    cocos2d::TargetedAction* cobj = static_cast<cocos2d::TargetedAction*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            cocos2d::Node* arg0;
            ok = rubyval_to_object<cocos2d::Node>(mrb, argv[0], "CC::Node", &arg0);
            if (!ok) { break; }
            cobj->setForcedTarget(arg0);
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::TargetedAction#setForcedTarget");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_TargetedAction_create_static(mrb_state* mrb, mrb_value self)
{
    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 2) {
            std::map<std::string, mrb_value> callbacks;
            cocos2d::Node* arg0;
            ok = rubyval_to_object<cocos2d::Node>(mrb, argv[0], "CC::Node", &arg0);
            if (!ok) { break; }

            cocos2d::FiniteTimeAction* arg1;
            ok = rubyval_to_object<cocos2d::FiniteTimeAction>(mrb, argv[1], "CC::FiniteTimeAction", &arg1);
            if (!ok) { break; }

            cocos2d::TargetedAction* retval = cocos2d::TargetedAction::create(arg0, arg1);
            mrb_value ret;
            RClass* rclass = mrb_class_ptr(self);
            ret = object_to_rubyval<cocos2d::TargetedAction>(mrb, "CC::TargetedAction", (cocos2d::TargetedAction*)retval, rclass);
            if (callbacks.size() > 0) {
                mrb_value hash = mrb_iv_get(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"));
                if (!mrb_hash_p(hash)) {
                    hash = mrb_hash_new(mrb);
                }
                for (auto elm : callbacks) {
                    mrb_hash_set(mrb, hash, mrb_str_new_cstr(mrb, elm.first.c_str()), elm.second);
                    mrb_iv_set(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"), hash);
                }
            }
            g_rubyValue.push_back(ret);
            mrb_funcall(mrb, ret, "initialize", 0);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined static method : cocos2d::TargetedAction#create");

    return mrb_nil_value();
}

void ruby_register_cocos2dx_TargetedAction(mrb_state* mrb, struct RClass* rmodule)
{
    std::string typeName = typeid(cocos2d::TargetedAction).name();
    g_rubyType[typeName] = "CC::TargetedAction";
    g_rubyDataType[typeName] = &ruby_cocos2dx_Ref_type;

    struct RClass* p_rmodule = mrb->object_class;
    p_rmodule = mrb_module_get_under(mrb, p_rmodule, "CC");
    struct RClass* p_rclass = mrb_class_get_under(mrb, p_rmodule, "ActionInterval");
    struct RClass *rclass = mrb_define_class_under(mrb, rmodule, "TargetedAction", p_rclass);
    MRB_SET_INSTANCE_TT(rclass, MRB_TT_DATA);

    mrb_define_method(mrb, rclass, "get_forced_target", ruby_cocos2dx_TargetedAction_getForcedTarget, ARGS_NONE());
    mrb_define_method(mrb, rclass, "set_forced_target", ruby_cocos2dx_TargetedAction_setForcedTarget, ARGS_REQ(1));
    mrb_define_class_method(mrb, rclass, "create", ruby_cocos2dx_TargetedAction_create_static, ARGS_REQ(2));
}
mrb_value ruby_cocos2dx_ActionCamera_setEye(mrb_state* mrb, mrb_value self)
{
    cocos2d::ActionCamera* cobj = static_cast<cocos2d::ActionCamera*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 3) {
            double arg0;
            ok = rubyval_to_number(mrb, argv[0], (double*)&arg0, "CC::ActionCamera.setEye");
            if (!ok) { break; }
            double arg1;
            ok = rubyval_to_number(mrb, argv[1], (double*)&arg1, "CC::ActionCamera.setEye");
            if (!ok) { break; }
            double arg2;
            ok = rubyval_to_number(mrb, argv[2], (double*)&arg2, "CC::ActionCamera.setEye");
            if (!ok) { break; }
            cobj->setEye(arg0, arg1, arg2);
            return self;
        }
    } while (0);
    do {
        if (argc == 1) {
            cocos2d::Vec3* arg0;
            ok = rubyval_to_object<cocos2d::Vec3>(mrb, argv[0], "CC::Vec3", &arg0);
            if (!ok) { break; }
            cobj->setEye(*arg0);
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::ActionCamera#setEye");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_ActionCamera_getEye(mrb_state* mrb, mrb_value self)
{
    cocos2d::ActionCamera* cobj = static_cast<cocos2d::ActionCamera*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            cocos2d::Vec3 retval = cobj->getEye();
            cocos2d::Vec3* retval_ptr = new cocos2d::Vec3(retval);
            mrb_value ret;
            ret = object_to_rubyval<cocos2d::Vec3>(mrb, "CC::Vec3", (cocos2d::Vec3*)retval_ptr, nullptr);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::ActionCamera#getEye");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_ActionCamera_setUp(mrb_state* mrb, mrb_value self)
{
    cocos2d::ActionCamera* cobj = static_cast<cocos2d::ActionCamera*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            cocos2d::Vec3* arg0;
            ok = rubyval_to_object<cocos2d::Vec3>(mrb, argv[0], "CC::Vec3", &arg0);
            if (!ok) { break; }
            cobj->setUp(*arg0);
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::ActionCamera#setUp");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_ActionCamera_getCenter(mrb_state* mrb, mrb_value self)
{
    cocos2d::ActionCamera* cobj = static_cast<cocos2d::ActionCamera*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            cocos2d::Vec3 retval = cobj->getCenter();
            cocos2d::Vec3* retval_ptr = new cocos2d::Vec3(retval);
            mrb_value ret;
            ret = object_to_rubyval<cocos2d::Vec3>(mrb, "CC::Vec3", (cocos2d::Vec3*)retval_ptr, nullptr);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::ActionCamera#getCenter");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_ActionCamera_setCenter(mrb_state* mrb, mrb_value self)
{
    cocos2d::ActionCamera* cobj = static_cast<cocos2d::ActionCamera*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            cocos2d::Vec3* arg0;
            ok = rubyval_to_object<cocos2d::Vec3>(mrb, argv[0], "CC::Vec3", &arg0);
            if (!ok) { break; }
            cobj->setCenter(*arg0);
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::ActionCamera#setCenter");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_ActionCamera_getUp(mrb_state* mrb, mrb_value self)
{
    cocos2d::ActionCamera* cobj = static_cast<cocos2d::ActionCamera*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            cocos2d::Vec3 retval = cobj->getUp();
            cocos2d::Vec3* retval_ptr = new cocos2d::Vec3(retval);
            mrb_value ret;
            ret = object_to_rubyval<cocos2d::Vec3>(mrb, "CC::Vec3", (cocos2d::Vec3*)retval_ptr, nullptr);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::ActionCamera#getUp");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_ActionCamera_constructor(mrb_state* mrb, mrb_value self)
{

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            cocos2d::ActionCamera* cobj = new cocos2d::ActionCamera();
            DATA_TYPE(self) = &ruby_cocos2dx_Ref_type;
            DATA_PTR(self) = cobj;
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::ActionCamera#ActionCamera");

    return mrb_nil_value();
}


void ruby_register_cocos2dx_ActionCamera(mrb_state* mrb, struct RClass* rmodule)
{
    std::string typeName = typeid(cocos2d::ActionCamera).name();
    g_rubyType[typeName] = "CC::ActionCamera";
    g_rubyDataType[typeName] = &ruby_cocos2dx_Ref_type;

    struct RClass* p_rmodule = mrb->object_class;
    p_rmodule = mrb_module_get_under(mrb, p_rmodule, "CC");
    struct RClass* p_rclass = mrb_class_get_under(mrb, p_rmodule, "ActionInterval");
    struct RClass *rclass = mrb_define_class_under(mrb, rmodule, "ActionCamera", p_rclass);
    MRB_SET_INSTANCE_TT(rclass, MRB_TT_DATA);

    mrb_define_method(mrb, rclass, "initialize", ruby_cocos2dx_ActionCamera_constructor, ARGS_NONE());
    mrb_define_method(mrb, rclass, "set_eye", ruby_cocos2dx_ActionCamera_setEye, ARGS_REQ(1)|ARGS_OPT(2));
    mrb_define_method(mrb, rclass, "get_eye", ruby_cocos2dx_ActionCamera_getEye, ARGS_NONE());
    mrb_define_method(mrb, rclass, "set_up", ruby_cocos2dx_ActionCamera_setUp, ARGS_REQ(1));
    mrb_define_method(mrb, rclass, "get_center", ruby_cocos2dx_ActionCamera_getCenter, ARGS_NONE());
    mrb_define_method(mrb, rclass, "set_center", ruby_cocos2dx_ActionCamera_setCenter, ARGS_REQ(1));
    mrb_define_method(mrb, rclass, "get_up", ruby_cocos2dx_ActionCamera_getUp, ARGS_NONE());
}
mrb_value ruby_cocos2dx_OrbitCamera_create_static(mrb_state* mrb, mrb_value self)
{
    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 7) {
            std::map<std::string, mrb_value> callbacks;
            double arg0;
            ok = rubyval_to_number(mrb, argv[0], (double*)&arg0, "CC::OrbitCamera.create");
            if (!ok) { break; }

            double arg1;
            ok = rubyval_to_number(mrb, argv[1], (double*)&arg1, "CC::OrbitCamera.create");
            if (!ok) { break; }

            double arg2;
            ok = rubyval_to_number(mrb, argv[2], (double*)&arg2, "CC::OrbitCamera.create");
            if (!ok) { break; }

            double arg3;
            ok = rubyval_to_number(mrb, argv[3], (double*)&arg3, "CC::OrbitCamera.create");
            if (!ok) { break; }

            double arg4;
            ok = rubyval_to_number(mrb, argv[4], (double*)&arg4, "CC::OrbitCamera.create");
            if (!ok) { break; }

            double arg5;
            ok = rubyval_to_number(mrb, argv[5], (double*)&arg5, "CC::OrbitCamera.create");
            if (!ok) { break; }

            double arg6;
            ok = rubyval_to_number(mrb, argv[6], (double*)&arg6, "CC::OrbitCamera.create");
            if (!ok) { break; }

            cocos2d::OrbitCamera* retval = cocos2d::OrbitCamera::create(arg0, arg1, arg2, arg3, arg4, arg5, arg6);
            mrb_value ret;
            RClass* rclass = mrb_class_ptr(self);
            ret = object_to_rubyval<cocos2d::OrbitCamera>(mrb, "CC::OrbitCamera", (cocos2d::OrbitCamera*)retval, rclass);
            if (callbacks.size() > 0) {
                mrb_value hash = mrb_iv_get(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"));
                if (!mrb_hash_p(hash)) {
                    hash = mrb_hash_new(mrb);
                }
                for (auto elm : callbacks) {
                    mrb_hash_set(mrb, hash, mrb_str_new_cstr(mrb, elm.first.c_str()), elm.second);
                    mrb_iv_set(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"), hash);
                }
            }
            g_rubyValue.push_back(ret);
            mrb_funcall(mrb, ret, "initialize", 0);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined static method : cocos2d::OrbitCamera#create");

    return mrb_nil_value();
}

void ruby_register_cocos2dx_OrbitCamera(mrb_state* mrb, struct RClass* rmodule)
{
    std::string typeName = typeid(cocos2d::OrbitCamera).name();
    g_rubyType[typeName] = "CC::OrbitCamera";
    g_rubyDataType[typeName] = &ruby_cocos2dx_Ref_type;

    struct RClass* p_rmodule = mrb->object_class;
    p_rmodule = mrb_module_get_under(mrb, p_rmodule, "CC");
    struct RClass* p_rclass = mrb_class_get_under(mrb, p_rmodule, "ActionCamera");
    struct RClass *rclass = mrb_define_class_under(mrb, rmodule, "OrbitCamera", p_rclass);
    MRB_SET_INSTANCE_TT(rclass, MRB_TT_DATA);

    mrb_define_class_method(mrb, rclass, "create", ruby_cocos2dx_OrbitCamera_create_static, ARGS_REQ(7));
}
mrb_value ruby_cocos2dx_ActionManager_getActionByTag(mrb_state* mrb, mrb_value self)
{
    cocos2d::ActionManager* cobj = static_cast<cocos2d::ActionManager*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 2) {
            int arg0;
            ok = rubyval_to_int32(mrb, argv[0], (int*)&arg0, "CC::ActionManager.getActionByTag");
            if (!ok) { break; }
            const cocos2d::Node* arg1;
            ok = rubyval_to_object<const cocos2d::Node>(mrb, argv[1], "CC::Node", &arg1);
            if (!ok) { break; }
            cocos2d::Action* retval = cobj->getActionByTag(arg0, arg1);
            mrb_value ret;
            ret = object_to_rubyval<cocos2d::Action>(mrb, "CC::Action", (cocos2d::Action*)retval, nullptr);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::ActionManager#getActionByTag");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_ActionManager_removeActionByTag(mrb_state* mrb, mrb_value self)
{
    cocos2d::ActionManager* cobj = static_cast<cocos2d::ActionManager*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 2) {
            int arg0;
            ok = rubyval_to_int32(mrb, argv[0], (int*)&arg0, "CC::ActionManager.removeActionByTag");
            if (!ok) { break; }
            cocos2d::Node* arg1;
            ok = rubyval_to_object<cocos2d::Node>(mrb, argv[1], "CC::Node", &arg1);
            if (!ok) { break; }
            cobj->removeActionByTag(arg0, arg1);
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::ActionManager#removeActionByTag");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_ActionManager_removeAllActions(mrb_state* mrb, mrb_value self)
{
    cocos2d::ActionManager* cobj = static_cast<cocos2d::ActionManager*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            cobj->removeAllActions();
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::ActionManager#removeAllActions");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_ActionManager_addAction(mrb_state* mrb, mrb_value self)
{
    cocos2d::ActionManager* cobj = static_cast<cocos2d::ActionManager*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 3) {
            cocos2d::Action* arg0;
            ok = rubyval_to_object<cocos2d::Action>(mrb, argv[0], "CC::Action", &arg0);
            if (!ok) { break; }
            cocos2d::Node* arg1;
            ok = rubyval_to_object<cocos2d::Node>(mrb, argv[1], "CC::Node", &arg1);
            if (!ok) { break; }
            bool arg2;
            ok = rubyval_to_boolean(mrb, argv[2], &arg2, "CC::ActionManager.addAction");
            if (!ok) { break; }
            cobj->addAction(arg0, arg1, arg2);
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::ActionManager#addAction");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_ActionManager_resumeTarget(mrb_state* mrb, mrb_value self)
{
    cocos2d::ActionManager* cobj = static_cast<cocos2d::ActionManager*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            cocos2d::Node* arg0;
            ok = rubyval_to_object<cocos2d::Node>(mrb, argv[0], "CC::Node", &arg0);
            if (!ok) { break; }
            cobj->resumeTarget(arg0);
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::ActionManager#resumeTarget");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_ActionManager_update(mrb_state* mrb, mrb_value self)
{
    cocos2d::ActionManager* cobj = static_cast<cocos2d::ActionManager*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            double arg0;
            ok = rubyval_to_number(mrb, argv[0], (double*)&arg0, "CC::ActionManager.update");
            if (!ok) { break; }
            cobj->update(arg0);
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::ActionManager#update");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_ActionManager_pauseTarget(mrb_state* mrb, mrb_value self)
{
    cocos2d::ActionManager* cobj = static_cast<cocos2d::ActionManager*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            cocos2d::Node* arg0;
            ok = rubyval_to_object<cocos2d::Node>(mrb, argv[0], "CC::Node", &arg0);
            if (!ok) { break; }
            cobj->pauseTarget(arg0);
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::ActionManager#pauseTarget");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_ActionManager_getNumberOfRunningActionsInTarget(mrb_state* mrb, mrb_value self)
{
    cocos2d::ActionManager* cobj = static_cast<cocos2d::ActionManager*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            const cocos2d::Node* arg0;
            ok = rubyval_to_object<const cocos2d::Node>(mrb, argv[0], "CC::Node", &arg0);
            if (!ok) { break; }
            ssize_t retval = cobj->getNumberOfRunningActionsInTarget(arg0);
            mrb_value ret;
            ret = mrb_fixnum_value((mrb_int)retval);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::ActionManager#getNumberOfRunningActionsInTarget");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_ActionManager_removeAllActionsFromTarget(mrb_state* mrb, mrb_value self)
{
    cocos2d::ActionManager* cobj = static_cast<cocos2d::ActionManager*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            cocos2d::Node* arg0;
            ok = rubyval_to_object<cocos2d::Node>(mrb, argv[0], "CC::Node", &arg0);
            if (!ok) { break; }
            cobj->removeAllActionsFromTarget(arg0);
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::ActionManager#removeAllActionsFromTarget");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_ActionManager_resumeTargets(mrb_state* mrb, mrb_value self)
{
    cocos2d::ActionManager* cobj = static_cast<cocos2d::ActionManager*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            cocos2d::Vector<cocos2d::Node *> arg0;
            ok = rubyval_to_ccvector(mrb, argv[0], &arg0, "CC::ActionManager.resumeTargets");
            if (!ok) { break; }
            cobj->resumeTargets(arg0);
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::ActionManager#resumeTargets");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_ActionManager_removeAction(mrb_state* mrb, mrb_value self)
{
    cocos2d::ActionManager* cobj = static_cast<cocos2d::ActionManager*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            cocos2d::Action* arg0;
            ok = rubyval_to_object<cocos2d::Action>(mrb, argv[0], "CC::Action", &arg0);
            if (!ok) { break; }
            cobj->removeAction(arg0);
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::ActionManager#removeAction");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_ActionManager_removeAllActionsByTag(mrb_state* mrb, mrb_value self)
{
    cocos2d::ActionManager* cobj = static_cast<cocos2d::ActionManager*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 2) {
            int arg0;
            ok = rubyval_to_int32(mrb, argv[0], (int*)&arg0, "CC::ActionManager.removeAllActionsByTag");
            if (!ok) { break; }
            cocos2d::Node* arg1;
            ok = rubyval_to_object<cocos2d::Node>(mrb, argv[1], "CC::Node", &arg1);
            if (!ok) { break; }
            cobj->removeAllActionsByTag(arg0, arg1);
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::ActionManager#removeAllActionsByTag");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_ActionManager_pauseAllRunningActions(mrb_state* mrb, mrb_value self)
{
    cocos2d::ActionManager* cobj = static_cast<cocos2d::ActionManager*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            cocos2d::Vector<cocos2d::Node *> retval = cobj->pauseAllRunningActions();
            mrb_value ret;
            ret = ccvector_to_rubyval(mrb, retval);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::ActionManager#pauseAllRunningActions");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_ActionManager_constructor(mrb_state* mrb, mrb_value self)
{

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            cocos2d::ActionManager* cobj = new cocos2d::ActionManager();
            DATA_TYPE(self) = &ruby_cocos2dx_Ref_type;
            DATA_PTR(self) = cobj;
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::ActionManager#ActionManager");

    return mrb_nil_value();
}


void ruby_register_cocos2dx_ActionManager(mrb_state* mrb, struct RClass* rmodule)
{
    std::string typeName = typeid(cocos2d::ActionManager).name();
    g_rubyType[typeName] = "CC::ActionManager";
    g_rubyDataType[typeName] = &ruby_cocos2dx_Ref_type;

    struct RClass* p_rmodule = mrb->object_class;
    p_rmodule = mrb_module_get_under(mrb, p_rmodule, "CC");
    struct RClass* p_rclass = mrb_class_get_under(mrb, p_rmodule, "Ref");
    struct RClass *rclass = mrb_define_class_under(mrb, rmodule, "ActionManager", p_rclass);
    MRB_SET_INSTANCE_TT(rclass, MRB_TT_DATA);

    mrb_define_method(mrb, rclass, "initialize", ruby_cocos2dx_ActionManager_constructor, ARGS_NONE());
    mrb_define_method(mrb, rclass, "get_action_by_tag", ruby_cocos2dx_ActionManager_getActionByTag, ARGS_REQ(2));
    mrb_define_method(mrb, rclass, "remove_action_by_tag", ruby_cocos2dx_ActionManager_removeActionByTag, ARGS_REQ(2));
    mrb_define_method(mrb, rclass, "remove_all_actions", ruby_cocos2dx_ActionManager_removeAllActions, ARGS_NONE());
    mrb_define_method(mrb, rclass, "add_action", ruby_cocos2dx_ActionManager_addAction, ARGS_REQ(3));
    mrb_define_method(mrb, rclass, "resume_target", ruby_cocos2dx_ActionManager_resumeTarget, ARGS_REQ(1));
    mrb_define_method(mrb, rclass, "update", ruby_cocos2dx_ActionManager_update, ARGS_REQ(1));
    mrb_define_method(mrb, rclass, "pause_target", ruby_cocos2dx_ActionManager_pauseTarget, ARGS_REQ(1));
    mrb_define_method(mrb, rclass, "get_number_of_running_actions_in_target", ruby_cocos2dx_ActionManager_getNumberOfRunningActionsInTarget, ARGS_REQ(1));
    mrb_define_method(mrb, rclass, "remove_all_actions_from_target", ruby_cocos2dx_ActionManager_removeAllActionsFromTarget, ARGS_REQ(1));
    mrb_define_method(mrb, rclass, "resume_targets", ruby_cocos2dx_ActionManager_resumeTargets, ARGS_REQ(1));
    mrb_define_method(mrb, rclass, "remove_action", ruby_cocos2dx_ActionManager_removeAction, ARGS_REQ(1));
    mrb_define_method(mrb, rclass, "remove_all_actions_by_tag", ruby_cocos2dx_ActionManager_removeAllActionsByTag, ARGS_REQ(2));
    mrb_define_method(mrb, rclass, "pause_all_running_actions", ruby_cocos2dx_ActionManager_pauseAllRunningActions, ARGS_NONE());
}
mrb_value ruby_cocos2dx_ActionEase_getInnerAction(mrb_state* mrb, mrb_value self)
{
    cocos2d::ActionEase* cobj = static_cast<cocos2d::ActionEase*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            cocos2d::ActionInterval* retval = cobj->getInnerAction();
            mrb_value ret;
            ret = object_to_rubyval<cocos2d::ActionInterval>(mrb, "CC::ActionInterval", (cocos2d::ActionInterval*)retval, nullptr);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::ActionEase#getInnerAction");

    return mrb_nil_value();
}

void ruby_register_cocos2dx_ActionEase(mrb_state* mrb, struct RClass* rmodule)
{
    std::string typeName = typeid(cocos2d::ActionEase).name();
    g_rubyType[typeName] = "CC::ActionEase";
    g_rubyDataType[typeName] = &ruby_cocos2dx_Ref_type;

    struct RClass* p_rmodule = mrb->object_class;
    p_rmodule = mrb_module_get_under(mrb, p_rmodule, "CC");
    struct RClass* p_rclass = mrb_class_get_under(mrb, p_rmodule, "ActionInterval");
    struct RClass *rclass = mrb_define_class_under(mrb, rmodule, "ActionEase", p_rclass);
    MRB_SET_INSTANCE_TT(rclass, MRB_TT_DATA);

    mrb_define_method(mrb, rclass, "get_inner_action", ruby_cocos2dx_ActionEase_getInnerAction, ARGS_NONE());
}
mrb_value ruby_cocos2dx_EaseRateAction_setRate(mrb_state* mrb, mrb_value self)
{
    cocos2d::EaseRateAction* cobj = static_cast<cocos2d::EaseRateAction*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            double arg0;
            ok = rubyval_to_number(mrb, argv[0], (double*)&arg0, "CC::EaseRateAction.setRate");
            if (!ok) { break; }
            cobj->setRate(arg0);
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::EaseRateAction#setRate");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_EaseRateAction_getRate(mrb_state* mrb, mrb_value self)
{
    cocos2d::EaseRateAction* cobj = static_cast<cocos2d::EaseRateAction*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            double retval = cobj->getRate();
            mrb_value ret;
            ret = mrb_float_value(mrb, (mrb_float)retval);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::EaseRateAction#getRate");

    return mrb_nil_value();
}

void ruby_register_cocos2dx_EaseRateAction(mrb_state* mrb, struct RClass* rmodule)
{
    std::string typeName = typeid(cocos2d::EaseRateAction).name();
    g_rubyType[typeName] = "CC::EaseRateAction";
    g_rubyDataType[typeName] = &ruby_cocos2dx_Ref_type;

    struct RClass* p_rmodule = mrb->object_class;
    p_rmodule = mrb_module_get_under(mrb, p_rmodule, "CC");
    struct RClass* p_rclass = mrb_class_get_under(mrb, p_rmodule, "ActionEase");
    struct RClass *rclass = mrb_define_class_under(mrb, rmodule, "EaseRateAction", p_rclass);
    MRB_SET_INSTANCE_TT(rclass, MRB_TT_DATA);

    mrb_define_method(mrb, rclass, "set_rate", ruby_cocos2dx_EaseRateAction_setRate, ARGS_REQ(1));
    mrb_define_method(mrb, rclass, "get_rate", ruby_cocos2dx_EaseRateAction_getRate, ARGS_NONE());
}
mrb_value ruby_cocos2dx_EaseIn_create_static(mrb_state* mrb, mrb_value self)
{
    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 2) {
            std::map<std::string, mrb_value> callbacks;
            cocos2d::ActionInterval* arg0;
            ok = rubyval_to_object<cocos2d::ActionInterval>(mrb, argv[0], "CC::ActionInterval", &arg0);
            if (!ok) { break; }

            double arg1;
            ok = rubyval_to_number(mrb, argv[1], (double*)&arg1, "CC::EaseIn.create");
            if (!ok) { break; }

            cocos2d::EaseIn* retval = cocos2d::EaseIn::create(arg0, arg1);
            mrb_value ret;
            RClass* rclass = mrb_class_ptr(self);
            ret = object_to_rubyval<cocos2d::EaseIn>(mrb, "CC::EaseIn", (cocos2d::EaseIn*)retval, rclass);
            if (callbacks.size() > 0) {
                mrb_value hash = mrb_iv_get(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"));
                if (!mrb_hash_p(hash)) {
                    hash = mrb_hash_new(mrb);
                }
                for (auto elm : callbacks) {
                    mrb_hash_set(mrb, hash, mrb_str_new_cstr(mrb, elm.first.c_str()), elm.second);
                    mrb_iv_set(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"), hash);
                }
            }
            g_rubyValue.push_back(ret);
            mrb_funcall(mrb, ret, "initialize", 0);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined static method : cocos2d::EaseIn#create");

    return mrb_nil_value();
}

void ruby_register_cocos2dx_EaseIn(mrb_state* mrb, struct RClass* rmodule)
{
    std::string typeName = typeid(cocos2d::EaseIn).name();
    g_rubyType[typeName] = "CC::EaseIn";
    g_rubyDataType[typeName] = &ruby_cocos2dx_Ref_type;

    struct RClass* p_rmodule = mrb->object_class;
    p_rmodule = mrb_module_get_under(mrb, p_rmodule, "CC");
    struct RClass* p_rclass = mrb_class_get_under(mrb, p_rmodule, "EaseRateAction");
    struct RClass *rclass = mrb_define_class_under(mrb, rmodule, "EaseIn", p_rclass);
    MRB_SET_INSTANCE_TT(rclass, MRB_TT_DATA);

    mrb_define_class_method(mrb, rclass, "create", ruby_cocos2dx_EaseIn_create_static, ARGS_REQ(2));
}
mrb_value ruby_cocos2dx_EaseOut_create_static(mrb_state* mrb, mrb_value self)
{
    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 2) {
            std::map<std::string, mrb_value> callbacks;
            cocos2d::ActionInterval* arg0;
            ok = rubyval_to_object<cocos2d::ActionInterval>(mrb, argv[0], "CC::ActionInterval", &arg0);
            if (!ok) { break; }

            double arg1;
            ok = rubyval_to_number(mrb, argv[1], (double*)&arg1, "CC::EaseOut.create");
            if (!ok) { break; }

            cocos2d::EaseOut* retval = cocos2d::EaseOut::create(arg0, arg1);
            mrb_value ret;
            RClass* rclass = mrb_class_ptr(self);
            ret = object_to_rubyval<cocos2d::EaseOut>(mrb, "CC::EaseOut", (cocos2d::EaseOut*)retval, rclass);
            if (callbacks.size() > 0) {
                mrb_value hash = mrb_iv_get(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"));
                if (!mrb_hash_p(hash)) {
                    hash = mrb_hash_new(mrb);
                }
                for (auto elm : callbacks) {
                    mrb_hash_set(mrb, hash, mrb_str_new_cstr(mrb, elm.first.c_str()), elm.second);
                    mrb_iv_set(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"), hash);
                }
            }
            g_rubyValue.push_back(ret);
            mrb_funcall(mrb, ret, "initialize", 0);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined static method : cocos2d::EaseOut#create");

    return mrb_nil_value();
}

void ruby_register_cocos2dx_EaseOut(mrb_state* mrb, struct RClass* rmodule)
{
    std::string typeName = typeid(cocos2d::EaseOut).name();
    g_rubyType[typeName] = "CC::EaseOut";
    g_rubyDataType[typeName] = &ruby_cocos2dx_Ref_type;

    struct RClass* p_rmodule = mrb->object_class;
    p_rmodule = mrb_module_get_under(mrb, p_rmodule, "CC");
    struct RClass* p_rclass = mrb_class_get_under(mrb, p_rmodule, "EaseRateAction");
    struct RClass *rclass = mrb_define_class_under(mrb, rmodule, "EaseOut", p_rclass);
    MRB_SET_INSTANCE_TT(rclass, MRB_TT_DATA);

    mrb_define_class_method(mrb, rclass, "create", ruby_cocos2dx_EaseOut_create_static, ARGS_REQ(2));
}
mrb_value ruby_cocos2dx_EaseInOut_create_static(mrb_state* mrb, mrb_value self)
{
    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 2) {
            std::map<std::string, mrb_value> callbacks;
            cocos2d::ActionInterval* arg0;
            ok = rubyval_to_object<cocos2d::ActionInterval>(mrb, argv[0], "CC::ActionInterval", &arg0);
            if (!ok) { break; }

            double arg1;
            ok = rubyval_to_number(mrb, argv[1], (double*)&arg1, "CC::EaseInOut.create");
            if (!ok) { break; }

            cocos2d::EaseInOut* retval = cocos2d::EaseInOut::create(arg0, arg1);
            mrb_value ret;
            RClass* rclass = mrb_class_ptr(self);
            ret = object_to_rubyval<cocos2d::EaseInOut>(mrb, "CC::EaseInOut", (cocos2d::EaseInOut*)retval, rclass);
            if (callbacks.size() > 0) {
                mrb_value hash = mrb_iv_get(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"));
                if (!mrb_hash_p(hash)) {
                    hash = mrb_hash_new(mrb);
                }
                for (auto elm : callbacks) {
                    mrb_hash_set(mrb, hash, mrb_str_new_cstr(mrb, elm.first.c_str()), elm.second);
                    mrb_iv_set(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"), hash);
                }
            }
            g_rubyValue.push_back(ret);
            mrb_funcall(mrb, ret, "initialize", 0);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined static method : cocos2d::EaseInOut#create");

    return mrb_nil_value();
}

void ruby_register_cocos2dx_EaseInOut(mrb_state* mrb, struct RClass* rmodule)
{
    std::string typeName = typeid(cocos2d::EaseInOut).name();
    g_rubyType[typeName] = "CC::EaseInOut";
    g_rubyDataType[typeName] = &ruby_cocos2dx_Ref_type;

    struct RClass* p_rmodule = mrb->object_class;
    p_rmodule = mrb_module_get_under(mrb, p_rmodule, "CC");
    struct RClass* p_rclass = mrb_class_get_under(mrb, p_rmodule, "EaseRateAction");
    struct RClass *rclass = mrb_define_class_under(mrb, rmodule, "EaseInOut", p_rclass);
    MRB_SET_INSTANCE_TT(rclass, MRB_TT_DATA);

    mrb_define_class_method(mrb, rclass, "create", ruby_cocos2dx_EaseInOut_create_static, ARGS_REQ(2));
}
mrb_value ruby_cocos2dx_EaseExponentialIn_create_static(mrb_state* mrb, mrb_value self)
{
    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            std::map<std::string, mrb_value> callbacks;
            cocos2d::ActionInterval* arg0;
            ok = rubyval_to_object<cocos2d::ActionInterval>(mrb, argv[0], "CC::ActionInterval", &arg0);
            if (!ok) { break; }

            cocos2d::EaseExponentialIn* retval = cocos2d::EaseExponentialIn::create(arg0);
            mrb_value ret;
            RClass* rclass = mrb_class_ptr(self);
            ret = object_to_rubyval<cocos2d::EaseExponentialIn>(mrb, "CC::EaseExponentialIn", (cocos2d::EaseExponentialIn*)retval, rclass);
            if (callbacks.size() > 0) {
                mrb_value hash = mrb_iv_get(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"));
                if (!mrb_hash_p(hash)) {
                    hash = mrb_hash_new(mrb);
                }
                for (auto elm : callbacks) {
                    mrb_hash_set(mrb, hash, mrb_str_new_cstr(mrb, elm.first.c_str()), elm.second);
                    mrb_iv_set(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"), hash);
                }
            }
            g_rubyValue.push_back(ret);
            mrb_funcall(mrb, ret, "initialize", 0);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined static method : cocos2d::EaseExponentialIn#create");

    return mrb_nil_value();
}

void ruby_register_cocos2dx_EaseExponentialIn(mrb_state* mrb, struct RClass* rmodule)
{
    std::string typeName = typeid(cocos2d::EaseExponentialIn).name();
    g_rubyType[typeName] = "CC::EaseExponentialIn";
    g_rubyDataType[typeName] = &ruby_cocos2dx_Ref_type;

    struct RClass* p_rmodule = mrb->object_class;
    p_rmodule = mrb_module_get_under(mrb, p_rmodule, "CC");
    struct RClass* p_rclass = mrb_class_get_under(mrb, p_rmodule, "ActionEase");
    struct RClass *rclass = mrb_define_class_under(mrb, rmodule, "EaseExponentialIn", p_rclass);
    MRB_SET_INSTANCE_TT(rclass, MRB_TT_DATA);

    mrb_define_class_method(mrb, rclass, "create", ruby_cocos2dx_EaseExponentialIn_create_static, ARGS_REQ(1));
}
mrb_value ruby_cocos2dx_EaseExponentialOut_create_static(mrb_state* mrb, mrb_value self)
{
    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            std::map<std::string, mrb_value> callbacks;
            cocos2d::ActionInterval* arg0;
            ok = rubyval_to_object<cocos2d::ActionInterval>(mrb, argv[0], "CC::ActionInterval", &arg0);
            if (!ok) { break; }

            cocos2d::EaseExponentialOut* retval = cocos2d::EaseExponentialOut::create(arg0);
            mrb_value ret;
            RClass* rclass = mrb_class_ptr(self);
            ret = object_to_rubyval<cocos2d::EaseExponentialOut>(mrb, "CC::EaseExponentialOut", (cocos2d::EaseExponentialOut*)retval, rclass);
            if (callbacks.size() > 0) {
                mrb_value hash = mrb_iv_get(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"));
                if (!mrb_hash_p(hash)) {
                    hash = mrb_hash_new(mrb);
                }
                for (auto elm : callbacks) {
                    mrb_hash_set(mrb, hash, mrb_str_new_cstr(mrb, elm.first.c_str()), elm.second);
                    mrb_iv_set(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"), hash);
                }
            }
            g_rubyValue.push_back(ret);
            mrb_funcall(mrb, ret, "initialize", 0);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined static method : cocos2d::EaseExponentialOut#create");

    return mrb_nil_value();
}

void ruby_register_cocos2dx_EaseExponentialOut(mrb_state* mrb, struct RClass* rmodule)
{
    std::string typeName = typeid(cocos2d::EaseExponentialOut).name();
    g_rubyType[typeName] = "CC::EaseExponentialOut";
    g_rubyDataType[typeName] = &ruby_cocos2dx_Ref_type;

    struct RClass* p_rmodule = mrb->object_class;
    p_rmodule = mrb_module_get_under(mrb, p_rmodule, "CC");
    struct RClass* p_rclass = mrb_class_get_under(mrb, p_rmodule, "ActionEase");
    struct RClass *rclass = mrb_define_class_under(mrb, rmodule, "EaseExponentialOut", p_rclass);
    MRB_SET_INSTANCE_TT(rclass, MRB_TT_DATA);

    mrb_define_class_method(mrb, rclass, "create", ruby_cocos2dx_EaseExponentialOut_create_static, ARGS_REQ(1));
}
mrb_value ruby_cocos2dx_EaseExponentialInOut_create_static(mrb_state* mrb, mrb_value self)
{
    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            std::map<std::string, mrb_value> callbacks;
            cocos2d::ActionInterval* arg0;
            ok = rubyval_to_object<cocos2d::ActionInterval>(mrb, argv[0], "CC::ActionInterval", &arg0);
            if (!ok) { break; }

            cocos2d::EaseExponentialInOut* retval = cocos2d::EaseExponentialInOut::create(arg0);
            mrb_value ret;
            RClass* rclass = mrb_class_ptr(self);
            ret = object_to_rubyval<cocos2d::EaseExponentialInOut>(mrb, "CC::EaseExponentialInOut", (cocos2d::EaseExponentialInOut*)retval, rclass);
            if (callbacks.size() > 0) {
                mrb_value hash = mrb_iv_get(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"));
                if (!mrb_hash_p(hash)) {
                    hash = mrb_hash_new(mrb);
                }
                for (auto elm : callbacks) {
                    mrb_hash_set(mrb, hash, mrb_str_new_cstr(mrb, elm.first.c_str()), elm.second);
                    mrb_iv_set(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"), hash);
                }
            }
            g_rubyValue.push_back(ret);
            mrb_funcall(mrb, ret, "initialize", 0);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined static method : cocos2d::EaseExponentialInOut#create");

    return mrb_nil_value();
}

void ruby_register_cocos2dx_EaseExponentialInOut(mrb_state* mrb, struct RClass* rmodule)
{
    std::string typeName = typeid(cocos2d::EaseExponentialInOut).name();
    g_rubyType[typeName] = "CC::EaseExponentialInOut";
    g_rubyDataType[typeName] = &ruby_cocos2dx_Ref_type;

    struct RClass* p_rmodule = mrb->object_class;
    p_rmodule = mrb_module_get_under(mrb, p_rmodule, "CC");
    struct RClass* p_rclass = mrb_class_get_under(mrb, p_rmodule, "ActionEase");
    struct RClass *rclass = mrb_define_class_under(mrb, rmodule, "EaseExponentialInOut", p_rclass);
    MRB_SET_INSTANCE_TT(rclass, MRB_TT_DATA);

    mrb_define_class_method(mrb, rclass, "create", ruby_cocos2dx_EaseExponentialInOut_create_static, ARGS_REQ(1));
}
mrb_value ruby_cocos2dx_EaseSineIn_create_static(mrb_state* mrb, mrb_value self)
{
    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            std::map<std::string, mrb_value> callbacks;
            cocos2d::ActionInterval* arg0;
            ok = rubyval_to_object<cocos2d::ActionInterval>(mrb, argv[0], "CC::ActionInterval", &arg0);
            if (!ok) { break; }

            cocos2d::EaseSineIn* retval = cocos2d::EaseSineIn::create(arg0);
            mrb_value ret;
            RClass* rclass = mrb_class_ptr(self);
            ret = object_to_rubyval<cocos2d::EaseSineIn>(mrb, "CC::EaseSineIn", (cocos2d::EaseSineIn*)retval, rclass);
            if (callbacks.size() > 0) {
                mrb_value hash = mrb_iv_get(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"));
                if (!mrb_hash_p(hash)) {
                    hash = mrb_hash_new(mrb);
                }
                for (auto elm : callbacks) {
                    mrb_hash_set(mrb, hash, mrb_str_new_cstr(mrb, elm.first.c_str()), elm.second);
                    mrb_iv_set(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"), hash);
                }
            }
            g_rubyValue.push_back(ret);
            mrb_funcall(mrb, ret, "initialize", 0);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined static method : cocos2d::EaseSineIn#create");

    return mrb_nil_value();
}

void ruby_register_cocos2dx_EaseSineIn(mrb_state* mrb, struct RClass* rmodule)
{
    std::string typeName = typeid(cocos2d::EaseSineIn).name();
    g_rubyType[typeName] = "CC::EaseSineIn";
    g_rubyDataType[typeName] = &ruby_cocos2dx_Ref_type;

    struct RClass* p_rmodule = mrb->object_class;
    p_rmodule = mrb_module_get_under(mrb, p_rmodule, "CC");
    struct RClass* p_rclass = mrb_class_get_under(mrb, p_rmodule, "ActionEase");
    struct RClass *rclass = mrb_define_class_under(mrb, rmodule, "EaseSineIn", p_rclass);
    MRB_SET_INSTANCE_TT(rclass, MRB_TT_DATA);

    mrb_define_class_method(mrb, rclass, "create", ruby_cocos2dx_EaseSineIn_create_static, ARGS_REQ(1));
}
mrb_value ruby_cocos2dx_EaseSineOut_create_static(mrb_state* mrb, mrb_value self)
{
    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            std::map<std::string, mrb_value> callbacks;
            cocos2d::ActionInterval* arg0;
            ok = rubyval_to_object<cocos2d::ActionInterval>(mrb, argv[0], "CC::ActionInterval", &arg0);
            if (!ok) { break; }

            cocos2d::EaseSineOut* retval = cocos2d::EaseSineOut::create(arg0);
            mrb_value ret;
            RClass* rclass = mrb_class_ptr(self);
            ret = object_to_rubyval<cocos2d::EaseSineOut>(mrb, "CC::EaseSineOut", (cocos2d::EaseSineOut*)retval, rclass);
            if (callbacks.size() > 0) {
                mrb_value hash = mrb_iv_get(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"));
                if (!mrb_hash_p(hash)) {
                    hash = mrb_hash_new(mrb);
                }
                for (auto elm : callbacks) {
                    mrb_hash_set(mrb, hash, mrb_str_new_cstr(mrb, elm.first.c_str()), elm.second);
                    mrb_iv_set(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"), hash);
                }
            }
            g_rubyValue.push_back(ret);
            mrb_funcall(mrb, ret, "initialize", 0);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined static method : cocos2d::EaseSineOut#create");

    return mrb_nil_value();
}

void ruby_register_cocos2dx_EaseSineOut(mrb_state* mrb, struct RClass* rmodule)
{
    std::string typeName = typeid(cocos2d::EaseSineOut).name();
    g_rubyType[typeName] = "CC::EaseSineOut";
    g_rubyDataType[typeName] = &ruby_cocos2dx_Ref_type;

    struct RClass* p_rmodule = mrb->object_class;
    p_rmodule = mrb_module_get_under(mrb, p_rmodule, "CC");
    struct RClass* p_rclass = mrb_class_get_under(mrb, p_rmodule, "ActionEase");
    struct RClass *rclass = mrb_define_class_under(mrb, rmodule, "EaseSineOut", p_rclass);
    MRB_SET_INSTANCE_TT(rclass, MRB_TT_DATA);

    mrb_define_class_method(mrb, rclass, "create", ruby_cocos2dx_EaseSineOut_create_static, ARGS_REQ(1));
}
mrb_value ruby_cocos2dx_EaseSineInOut_create_static(mrb_state* mrb, mrb_value self)
{
    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            std::map<std::string, mrb_value> callbacks;
            cocos2d::ActionInterval* arg0;
            ok = rubyval_to_object<cocos2d::ActionInterval>(mrb, argv[0], "CC::ActionInterval", &arg0);
            if (!ok) { break; }

            cocos2d::EaseSineInOut* retval = cocos2d::EaseSineInOut::create(arg0);
            mrb_value ret;
            RClass* rclass = mrb_class_ptr(self);
            ret = object_to_rubyval<cocos2d::EaseSineInOut>(mrb, "CC::EaseSineInOut", (cocos2d::EaseSineInOut*)retval, rclass);
            if (callbacks.size() > 0) {
                mrb_value hash = mrb_iv_get(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"));
                if (!mrb_hash_p(hash)) {
                    hash = mrb_hash_new(mrb);
                }
                for (auto elm : callbacks) {
                    mrb_hash_set(mrb, hash, mrb_str_new_cstr(mrb, elm.first.c_str()), elm.second);
                    mrb_iv_set(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"), hash);
                }
            }
            g_rubyValue.push_back(ret);
            mrb_funcall(mrb, ret, "initialize", 0);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined static method : cocos2d::EaseSineInOut#create");

    return mrb_nil_value();
}

void ruby_register_cocos2dx_EaseSineInOut(mrb_state* mrb, struct RClass* rmodule)
{
    std::string typeName = typeid(cocos2d::EaseSineInOut).name();
    g_rubyType[typeName] = "CC::EaseSineInOut";
    g_rubyDataType[typeName] = &ruby_cocos2dx_Ref_type;

    struct RClass* p_rmodule = mrb->object_class;
    p_rmodule = mrb_module_get_under(mrb, p_rmodule, "CC");
    struct RClass* p_rclass = mrb_class_get_under(mrb, p_rmodule, "ActionEase");
    struct RClass *rclass = mrb_define_class_under(mrb, rmodule, "EaseSineInOut", p_rclass);
    MRB_SET_INSTANCE_TT(rclass, MRB_TT_DATA);

    mrb_define_class_method(mrb, rclass, "create", ruby_cocos2dx_EaseSineInOut_create_static, ARGS_REQ(1));
}
mrb_value ruby_cocos2dx_EaseElastic_setPeriod(mrb_state* mrb, mrb_value self)
{
    cocos2d::EaseElastic* cobj = static_cast<cocos2d::EaseElastic*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            double arg0;
            ok = rubyval_to_number(mrb, argv[0], (double*)&arg0, "CC::EaseElastic.setPeriod");
            if (!ok) { break; }
            cobj->setPeriod(arg0);
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::EaseElastic#setPeriod");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_EaseElastic_getPeriod(mrb_state* mrb, mrb_value self)
{
    cocos2d::EaseElastic* cobj = static_cast<cocos2d::EaseElastic*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            double retval = cobj->getPeriod();
            mrb_value ret;
            ret = mrb_float_value(mrb, (mrb_float)retval);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::EaseElastic#getPeriod");

    return mrb_nil_value();
}

void ruby_register_cocos2dx_EaseElastic(mrb_state* mrb, struct RClass* rmodule)
{
    std::string typeName = typeid(cocos2d::EaseElastic).name();
    g_rubyType[typeName] = "CC::EaseElastic";
    g_rubyDataType[typeName] = &ruby_cocos2dx_Ref_type;

    struct RClass* p_rmodule = mrb->object_class;
    p_rmodule = mrb_module_get_under(mrb, p_rmodule, "CC");
    struct RClass* p_rclass = mrb_class_get_under(mrb, p_rmodule, "ActionEase");
    struct RClass *rclass = mrb_define_class_under(mrb, rmodule, "EaseElastic", p_rclass);
    MRB_SET_INSTANCE_TT(rclass, MRB_TT_DATA);

    mrb_define_method(mrb, rclass, "set_period", ruby_cocos2dx_EaseElastic_setPeriod, ARGS_REQ(1));
    mrb_define_method(mrb, rclass, "get_period", ruby_cocos2dx_EaseElastic_getPeriod, ARGS_NONE());
}
mrb_value ruby_cocos2dx_EaseElasticIn_create_static(mrb_state* mrb, mrb_value self)
{
    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            std::map<std::string, mrb_value> callbacks;
            cocos2d::ActionInterval* arg0;
            ok = rubyval_to_object<cocos2d::ActionInterval>(mrb, argv[0], "CC::ActionInterval", &arg0);
            if (!ok) { break; }

            cocos2d::EaseElasticIn* retval = cocos2d::EaseElasticIn::create(arg0);
            mrb_value ret;
            RClass* rclass = mrb_class_ptr(self);
            ret = object_to_rubyval<cocos2d::EaseElasticIn>(mrb, "CC::EaseElasticIn", (cocos2d::EaseElasticIn*)retval, rclass);
            if (callbacks.size() > 0) {
                mrb_value hash = mrb_iv_get(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"));
                if (!mrb_hash_p(hash)) {
                    hash = mrb_hash_new(mrb);
                }
                for (auto elm : callbacks) {
                    mrb_hash_set(mrb, hash, mrb_str_new_cstr(mrb, elm.first.c_str()), elm.second);
                    mrb_iv_set(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"), hash);
                }
            }
            g_rubyValue.push_back(ret);
            mrb_funcall(mrb, ret, "initialize", 0);
            return ret;
        }
    } while (0);
    do {
        if (argc == 2) {
            std::map<std::string, mrb_value> callbacks;
            cocos2d::ActionInterval* arg0;
            ok = rubyval_to_object<cocos2d::ActionInterval>(mrb, argv[0], "CC::ActionInterval", &arg0);
            if (!ok) { break; }

            double arg1;
            ok = rubyval_to_number(mrb, argv[1], (double*)&arg1, "CC::EaseElasticIn.create");
            if (!ok) { break; }

            cocos2d::EaseElasticIn* retval = cocos2d::EaseElasticIn::create(arg0, arg1);
            mrb_value ret;
            RClass* rclass = mrb_class_ptr(self);
            ret = object_to_rubyval<cocos2d::EaseElasticIn>(mrb, "CC::EaseElasticIn", (cocos2d::EaseElasticIn*)retval, rclass);
            if (callbacks.size() > 0) {
                mrb_value hash = mrb_iv_get(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"));
                if (!mrb_hash_p(hash)) {
                    hash = mrb_hash_new(mrb);
                }
                for (auto elm : callbacks) {
                    mrb_hash_set(mrb, hash, mrb_str_new_cstr(mrb, elm.first.c_str()), elm.second);
                    mrb_iv_set(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"), hash);
                }
            }
            g_rubyValue.push_back(ret);
            mrb_funcall(mrb, ret, "initialize", 0);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined static method : cocos2d::EaseElasticIn#create");

    return mrb_nil_value();
}

void ruby_register_cocos2dx_EaseElasticIn(mrb_state* mrb, struct RClass* rmodule)
{
    std::string typeName = typeid(cocos2d::EaseElasticIn).name();
    g_rubyType[typeName] = "CC::EaseElasticIn";
    g_rubyDataType[typeName] = &ruby_cocos2dx_Ref_type;

    struct RClass* p_rmodule = mrb->object_class;
    p_rmodule = mrb_module_get_under(mrb, p_rmodule, "CC");
    struct RClass* p_rclass = mrb_class_get_under(mrb, p_rmodule, "EaseElastic");
    struct RClass *rclass = mrb_define_class_under(mrb, rmodule, "EaseElasticIn", p_rclass);
    MRB_SET_INSTANCE_TT(rclass, MRB_TT_DATA);

    mrb_define_class_method(mrb, rclass, "create", ruby_cocos2dx_EaseElasticIn_create_static, ARGS_REQ(1)|ARGS_OPT(1));
}
mrb_value ruby_cocos2dx_EaseElasticOut_create_static(mrb_state* mrb, mrb_value self)
{
    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            std::map<std::string, mrb_value> callbacks;
            cocos2d::ActionInterval* arg0;
            ok = rubyval_to_object<cocos2d::ActionInterval>(mrb, argv[0], "CC::ActionInterval", &arg0);
            if (!ok) { break; }

            cocos2d::EaseElasticOut* retval = cocos2d::EaseElasticOut::create(arg0);
            mrb_value ret;
            RClass* rclass = mrb_class_ptr(self);
            ret = object_to_rubyval<cocos2d::EaseElasticOut>(mrb, "CC::EaseElasticOut", (cocos2d::EaseElasticOut*)retval, rclass);
            if (callbacks.size() > 0) {
                mrb_value hash = mrb_iv_get(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"));
                if (!mrb_hash_p(hash)) {
                    hash = mrb_hash_new(mrb);
                }
                for (auto elm : callbacks) {
                    mrb_hash_set(mrb, hash, mrb_str_new_cstr(mrb, elm.first.c_str()), elm.second);
                    mrb_iv_set(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"), hash);
                }
            }
            g_rubyValue.push_back(ret);
            mrb_funcall(mrb, ret, "initialize", 0);
            return ret;
        }
    } while (0);
    do {
        if (argc == 2) {
            std::map<std::string, mrb_value> callbacks;
            cocos2d::ActionInterval* arg0;
            ok = rubyval_to_object<cocos2d::ActionInterval>(mrb, argv[0], "CC::ActionInterval", &arg0);
            if (!ok) { break; }

            double arg1;
            ok = rubyval_to_number(mrb, argv[1], (double*)&arg1, "CC::EaseElasticOut.create");
            if (!ok) { break; }

            cocos2d::EaseElasticOut* retval = cocos2d::EaseElasticOut::create(arg0, arg1);
            mrb_value ret;
            RClass* rclass = mrb_class_ptr(self);
            ret = object_to_rubyval<cocos2d::EaseElasticOut>(mrb, "CC::EaseElasticOut", (cocos2d::EaseElasticOut*)retval, rclass);
            if (callbacks.size() > 0) {
                mrb_value hash = mrb_iv_get(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"));
                if (!mrb_hash_p(hash)) {
                    hash = mrb_hash_new(mrb);
                }
                for (auto elm : callbacks) {
                    mrb_hash_set(mrb, hash, mrb_str_new_cstr(mrb, elm.first.c_str()), elm.second);
                    mrb_iv_set(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"), hash);
                }
            }
            g_rubyValue.push_back(ret);
            mrb_funcall(mrb, ret, "initialize", 0);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined static method : cocos2d::EaseElasticOut#create");

    return mrb_nil_value();
}

void ruby_register_cocos2dx_EaseElasticOut(mrb_state* mrb, struct RClass* rmodule)
{
    std::string typeName = typeid(cocos2d::EaseElasticOut).name();
    g_rubyType[typeName] = "CC::EaseElasticOut";
    g_rubyDataType[typeName] = &ruby_cocos2dx_Ref_type;

    struct RClass* p_rmodule = mrb->object_class;
    p_rmodule = mrb_module_get_under(mrb, p_rmodule, "CC");
    struct RClass* p_rclass = mrb_class_get_under(mrb, p_rmodule, "EaseElastic");
    struct RClass *rclass = mrb_define_class_under(mrb, rmodule, "EaseElasticOut", p_rclass);
    MRB_SET_INSTANCE_TT(rclass, MRB_TT_DATA);

    mrb_define_class_method(mrb, rclass, "create", ruby_cocos2dx_EaseElasticOut_create_static, ARGS_REQ(1)|ARGS_OPT(1));
}
mrb_value ruby_cocos2dx_EaseElasticInOut_create_static(mrb_state* mrb, mrb_value self)
{
    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            std::map<std::string, mrb_value> callbacks;
            cocos2d::ActionInterval* arg0;
            ok = rubyval_to_object<cocos2d::ActionInterval>(mrb, argv[0], "CC::ActionInterval", &arg0);
            if (!ok) { break; }

            cocos2d::EaseElasticInOut* retval = cocos2d::EaseElasticInOut::create(arg0);
            mrb_value ret;
            RClass* rclass = mrb_class_ptr(self);
            ret = object_to_rubyval<cocos2d::EaseElasticInOut>(mrb, "CC::EaseElasticInOut", (cocos2d::EaseElasticInOut*)retval, rclass);
            if (callbacks.size() > 0) {
                mrb_value hash = mrb_iv_get(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"));
                if (!mrb_hash_p(hash)) {
                    hash = mrb_hash_new(mrb);
                }
                for (auto elm : callbacks) {
                    mrb_hash_set(mrb, hash, mrb_str_new_cstr(mrb, elm.first.c_str()), elm.second);
                    mrb_iv_set(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"), hash);
                }
            }
            g_rubyValue.push_back(ret);
            mrb_funcall(mrb, ret, "initialize", 0);
            return ret;
        }
    } while (0);
    do {
        if (argc == 2) {
            std::map<std::string, mrb_value> callbacks;
            cocos2d::ActionInterval* arg0;
            ok = rubyval_to_object<cocos2d::ActionInterval>(mrb, argv[0], "CC::ActionInterval", &arg0);
            if (!ok) { break; }

            double arg1;
            ok = rubyval_to_number(mrb, argv[1], (double*)&arg1, "CC::EaseElasticInOut.create");
            if (!ok) { break; }

            cocos2d::EaseElasticInOut* retval = cocos2d::EaseElasticInOut::create(arg0, arg1);
            mrb_value ret;
            RClass* rclass = mrb_class_ptr(self);
            ret = object_to_rubyval<cocos2d::EaseElasticInOut>(mrb, "CC::EaseElasticInOut", (cocos2d::EaseElasticInOut*)retval, rclass);
            if (callbacks.size() > 0) {
                mrb_value hash = mrb_iv_get(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"));
                if (!mrb_hash_p(hash)) {
                    hash = mrb_hash_new(mrb);
                }
                for (auto elm : callbacks) {
                    mrb_hash_set(mrb, hash, mrb_str_new_cstr(mrb, elm.first.c_str()), elm.second);
                    mrb_iv_set(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"), hash);
                }
            }
            g_rubyValue.push_back(ret);
            mrb_funcall(mrb, ret, "initialize", 0);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined static method : cocos2d::EaseElasticInOut#create");

    return mrb_nil_value();
}

void ruby_register_cocos2dx_EaseElasticInOut(mrb_state* mrb, struct RClass* rmodule)
{
    std::string typeName = typeid(cocos2d::EaseElasticInOut).name();
    g_rubyType[typeName] = "CC::EaseElasticInOut";
    g_rubyDataType[typeName] = &ruby_cocos2dx_Ref_type;

    struct RClass* p_rmodule = mrb->object_class;
    p_rmodule = mrb_module_get_under(mrb, p_rmodule, "CC");
    struct RClass* p_rclass = mrb_class_get_under(mrb, p_rmodule, "EaseElastic");
    struct RClass *rclass = mrb_define_class_under(mrb, rmodule, "EaseElasticInOut", p_rclass);
    MRB_SET_INSTANCE_TT(rclass, MRB_TT_DATA);

    mrb_define_class_method(mrb, rclass, "create", ruby_cocos2dx_EaseElasticInOut_create_static, ARGS_REQ(1)|ARGS_OPT(1));
}
void ruby_register_cocos2dx_EaseBounce(mrb_state* mrb, struct RClass* rmodule)
{
    std::string typeName = typeid(cocos2d::EaseBounce).name();
    g_rubyType[typeName] = "CC::EaseBounce";
    g_rubyDataType[typeName] = &ruby_cocos2dx_Ref_type;

    struct RClass* p_rmodule = mrb->object_class;
    p_rmodule = mrb_module_get_under(mrb, p_rmodule, "CC");
    struct RClass* p_rclass = mrb_class_get_under(mrb, p_rmodule, "ActionEase");
    struct RClass *rclass = mrb_define_class_under(mrb, rmodule, "EaseBounce", p_rclass);
    MRB_SET_INSTANCE_TT(rclass, MRB_TT_DATA);

}
mrb_value ruby_cocos2dx_EaseBounceIn_create_static(mrb_state* mrb, mrb_value self)
{
    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            std::map<std::string, mrb_value> callbacks;
            cocos2d::ActionInterval* arg0;
            ok = rubyval_to_object<cocos2d::ActionInterval>(mrb, argv[0], "CC::ActionInterval", &arg0);
            if (!ok) { break; }

            cocos2d::EaseBounceIn* retval = cocos2d::EaseBounceIn::create(arg0);
            mrb_value ret;
            RClass* rclass = mrb_class_ptr(self);
            ret = object_to_rubyval<cocos2d::EaseBounceIn>(mrb, "CC::EaseBounceIn", (cocos2d::EaseBounceIn*)retval, rclass);
            if (callbacks.size() > 0) {
                mrb_value hash = mrb_iv_get(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"));
                if (!mrb_hash_p(hash)) {
                    hash = mrb_hash_new(mrb);
                }
                for (auto elm : callbacks) {
                    mrb_hash_set(mrb, hash, mrb_str_new_cstr(mrb, elm.first.c_str()), elm.second);
                    mrb_iv_set(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"), hash);
                }
            }
            g_rubyValue.push_back(ret);
            mrb_funcall(mrb, ret, "initialize", 0);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined static method : cocos2d::EaseBounceIn#create");

    return mrb_nil_value();
}

void ruby_register_cocos2dx_EaseBounceIn(mrb_state* mrb, struct RClass* rmodule)
{
    std::string typeName = typeid(cocos2d::EaseBounceIn).name();
    g_rubyType[typeName] = "CC::EaseBounceIn";
    g_rubyDataType[typeName] = &ruby_cocos2dx_Ref_type;

    struct RClass* p_rmodule = mrb->object_class;
    p_rmodule = mrb_module_get_under(mrb, p_rmodule, "CC");
    struct RClass* p_rclass = mrb_class_get_under(mrb, p_rmodule, "EaseBounce");
    struct RClass *rclass = mrb_define_class_under(mrb, rmodule, "EaseBounceIn", p_rclass);
    MRB_SET_INSTANCE_TT(rclass, MRB_TT_DATA);

    mrb_define_class_method(mrb, rclass, "create", ruby_cocos2dx_EaseBounceIn_create_static, ARGS_REQ(1));
}
mrb_value ruby_cocos2dx_EaseBounceOut_create_static(mrb_state* mrb, mrb_value self)
{
    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            std::map<std::string, mrb_value> callbacks;
            cocos2d::ActionInterval* arg0;
            ok = rubyval_to_object<cocos2d::ActionInterval>(mrb, argv[0], "CC::ActionInterval", &arg0);
            if (!ok) { break; }

            cocos2d::EaseBounceOut* retval = cocos2d::EaseBounceOut::create(arg0);
            mrb_value ret;
            RClass* rclass = mrb_class_ptr(self);
            ret = object_to_rubyval<cocos2d::EaseBounceOut>(mrb, "CC::EaseBounceOut", (cocos2d::EaseBounceOut*)retval, rclass);
            if (callbacks.size() > 0) {
                mrb_value hash = mrb_iv_get(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"));
                if (!mrb_hash_p(hash)) {
                    hash = mrb_hash_new(mrb);
                }
                for (auto elm : callbacks) {
                    mrb_hash_set(mrb, hash, mrb_str_new_cstr(mrb, elm.first.c_str()), elm.second);
                    mrb_iv_set(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"), hash);
                }
            }
            g_rubyValue.push_back(ret);
            mrb_funcall(mrb, ret, "initialize", 0);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined static method : cocos2d::EaseBounceOut#create");

    return mrb_nil_value();
}

void ruby_register_cocos2dx_EaseBounceOut(mrb_state* mrb, struct RClass* rmodule)
{
    std::string typeName = typeid(cocos2d::EaseBounceOut).name();
    g_rubyType[typeName] = "CC::EaseBounceOut";
    g_rubyDataType[typeName] = &ruby_cocos2dx_Ref_type;

    struct RClass* p_rmodule = mrb->object_class;
    p_rmodule = mrb_module_get_under(mrb, p_rmodule, "CC");
    struct RClass* p_rclass = mrb_class_get_under(mrb, p_rmodule, "EaseBounce");
    struct RClass *rclass = mrb_define_class_under(mrb, rmodule, "EaseBounceOut", p_rclass);
    MRB_SET_INSTANCE_TT(rclass, MRB_TT_DATA);

    mrb_define_class_method(mrb, rclass, "create", ruby_cocos2dx_EaseBounceOut_create_static, ARGS_REQ(1));
}
mrb_value ruby_cocos2dx_EaseBounceInOut_create_static(mrb_state* mrb, mrb_value self)
{
    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            std::map<std::string, mrb_value> callbacks;
            cocos2d::ActionInterval* arg0;
            ok = rubyval_to_object<cocos2d::ActionInterval>(mrb, argv[0], "CC::ActionInterval", &arg0);
            if (!ok) { break; }

            cocos2d::EaseBounceInOut* retval = cocos2d::EaseBounceInOut::create(arg0);
            mrb_value ret;
            RClass* rclass = mrb_class_ptr(self);
            ret = object_to_rubyval<cocos2d::EaseBounceInOut>(mrb, "CC::EaseBounceInOut", (cocos2d::EaseBounceInOut*)retval, rclass);
            if (callbacks.size() > 0) {
                mrb_value hash = mrb_iv_get(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"));
                if (!mrb_hash_p(hash)) {
                    hash = mrb_hash_new(mrb);
                }
                for (auto elm : callbacks) {
                    mrb_hash_set(mrb, hash, mrb_str_new_cstr(mrb, elm.first.c_str()), elm.second);
                    mrb_iv_set(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"), hash);
                }
            }
            g_rubyValue.push_back(ret);
            mrb_funcall(mrb, ret, "initialize", 0);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined static method : cocos2d::EaseBounceInOut#create");

    return mrb_nil_value();
}

void ruby_register_cocos2dx_EaseBounceInOut(mrb_state* mrb, struct RClass* rmodule)
{
    std::string typeName = typeid(cocos2d::EaseBounceInOut).name();
    g_rubyType[typeName] = "CC::EaseBounceInOut";
    g_rubyDataType[typeName] = &ruby_cocos2dx_Ref_type;

    struct RClass* p_rmodule = mrb->object_class;
    p_rmodule = mrb_module_get_under(mrb, p_rmodule, "CC");
    struct RClass* p_rclass = mrb_class_get_under(mrb, p_rmodule, "EaseBounce");
    struct RClass *rclass = mrb_define_class_under(mrb, rmodule, "EaseBounceInOut", p_rclass);
    MRB_SET_INSTANCE_TT(rclass, MRB_TT_DATA);

    mrb_define_class_method(mrb, rclass, "create", ruby_cocos2dx_EaseBounceInOut_create_static, ARGS_REQ(1));
}
mrb_value ruby_cocos2dx_EaseBackIn_create_static(mrb_state* mrb, mrb_value self)
{
    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            std::map<std::string, mrb_value> callbacks;
            cocos2d::ActionInterval* arg0;
            ok = rubyval_to_object<cocos2d::ActionInterval>(mrb, argv[0], "CC::ActionInterval", &arg0);
            if (!ok) { break; }

            cocos2d::EaseBackIn* retval = cocos2d::EaseBackIn::create(arg0);
            mrb_value ret;
            RClass* rclass = mrb_class_ptr(self);
            ret = object_to_rubyval<cocos2d::EaseBackIn>(mrb, "CC::EaseBackIn", (cocos2d::EaseBackIn*)retval, rclass);
            if (callbacks.size() > 0) {
                mrb_value hash = mrb_iv_get(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"));
                if (!mrb_hash_p(hash)) {
                    hash = mrb_hash_new(mrb);
                }
                for (auto elm : callbacks) {
                    mrb_hash_set(mrb, hash, mrb_str_new_cstr(mrb, elm.first.c_str()), elm.second);
                    mrb_iv_set(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"), hash);
                }
            }
            g_rubyValue.push_back(ret);
            mrb_funcall(mrb, ret, "initialize", 0);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined static method : cocos2d::EaseBackIn#create");

    return mrb_nil_value();
}

void ruby_register_cocos2dx_EaseBackIn(mrb_state* mrb, struct RClass* rmodule)
{
    std::string typeName = typeid(cocos2d::EaseBackIn).name();
    g_rubyType[typeName] = "CC::EaseBackIn";
    g_rubyDataType[typeName] = &ruby_cocos2dx_Ref_type;

    struct RClass* p_rmodule = mrb->object_class;
    p_rmodule = mrb_module_get_under(mrb, p_rmodule, "CC");
    struct RClass* p_rclass = mrb_class_get_under(mrb, p_rmodule, "ActionEase");
    struct RClass *rclass = mrb_define_class_under(mrb, rmodule, "EaseBackIn", p_rclass);
    MRB_SET_INSTANCE_TT(rclass, MRB_TT_DATA);

    mrb_define_class_method(mrb, rclass, "create", ruby_cocos2dx_EaseBackIn_create_static, ARGS_REQ(1));
}
mrb_value ruby_cocos2dx_EaseBackOut_create_static(mrb_state* mrb, mrb_value self)
{
    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            std::map<std::string, mrb_value> callbacks;
            cocos2d::ActionInterval* arg0;
            ok = rubyval_to_object<cocos2d::ActionInterval>(mrb, argv[0], "CC::ActionInterval", &arg0);
            if (!ok) { break; }

            cocos2d::EaseBackOut* retval = cocos2d::EaseBackOut::create(arg0);
            mrb_value ret;
            RClass* rclass = mrb_class_ptr(self);
            ret = object_to_rubyval<cocos2d::EaseBackOut>(mrb, "CC::EaseBackOut", (cocos2d::EaseBackOut*)retval, rclass);
            if (callbacks.size() > 0) {
                mrb_value hash = mrb_iv_get(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"));
                if (!mrb_hash_p(hash)) {
                    hash = mrb_hash_new(mrb);
                }
                for (auto elm : callbacks) {
                    mrb_hash_set(mrb, hash, mrb_str_new_cstr(mrb, elm.first.c_str()), elm.second);
                    mrb_iv_set(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"), hash);
                }
            }
            g_rubyValue.push_back(ret);
            mrb_funcall(mrb, ret, "initialize", 0);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined static method : cocos2d::EaseBackOut#create");

    return mrb_nil_value();
}

void ruby_register_cocos2dx_EaseBackOut(mrb_state* mrb, struct RClass* rmodule)
{
    std::string typeName = typeid(cocos2d::EaseBackOut).name();
    g_rubyType[typeName] = "CC::EaseBackOut";
    g_rubyDataType[typeName] = &ruby_cocos2dx_Ref_type;

    struct RClass* p_rmodule = mrb->object_class;
    p_rmodule = mrb_module_get_under(mrb, p_rmodule, "CC");
    struct RClass* p_rclass = mrb_class_get_under(mrb, p_rmodule, "ActionEase");
    struct RClass *rclass = mrb_define_class_under(mrb, rmodule, "EaseBackOut", p_rclass);
    MRB_SET_INSTANCE_TT(rclass, MRB_TT_DATA);

    mrb_define_class_method(mrb, rclass, "create", ruby_cocos2dx_EaseBackOut_create_static, ARGS_REQ(1));
}
mrb_value ruby_cocos2dx_EaseBackInOut_create_static(mrb_state* mrb, mrb_value self)
{
    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            std::map<std::string, mrb_value> callbacks;
            cocos2d::ActionInterval* arg0;
            ok = rubyval_to_object<cocos2d::ActionInterval>(mrb, argv[0], "CC::ActionInterval", &arg0);
            if (!ok) { break; }

            cocos2d::EaseBackInOut* retval = cocos2d::EaseBackInOut::create(arg0);
            mrb_value ret;
            RClass* rclass = mrb_class_ptr(self);
            ret = object_to_rubyval<cocos2d::EaseBackInOut>(mrb, "CC::EaseBackInOut", (cocos2d::EaseBackInOut*)retval, rclass);
            if (callbacks.size() > 0) {
                mrb_value hash = mrb_iv_get(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"));
                if (!mrb_hash_p(hash)) {
                    hash = mrb_hash_new(mrb);
                }
                for (auto elm : callbacks) {
                    mrb_hash_set(mrb, hash, mrb_str_new_cstr(mrb, elm.first.c_str()), elm.second);
                    mrb_iv_set(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"), hash);
                }
            }
            g_rubyValue.push_back(ret);
            mrb_funcall(mrb, ret, "initialize", 0);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined static method : cocos2d::EaseBackInOut#create");

    return mrb_nil_value();
}

void ruby_register_cocos2dx_EaseBackInOut(mrb_state* mrb, struct RClass* rmodule)
{
    std::string typeName = typeid(cocos2d::EaseBackInOut).name();
    g_rubyType[typeName] = "CC::EaseBackInOut";
    g_rubyDataType[typeName] = &ruby_cocos2dx_Ref_type;

    struct RClass* p_rmodule = mrb->object_class;
    p_rmodule = mrb_module_get_under(mrb, p_rmodule, "CC");
    struct RClass* p_rclass = mrb_class_get_under(mrb, p_rmodule, "ActionEase");
    struct RClass *rclass = mrb_define_class_under(mrb, rmodule, "EaseBackInOut", p_rclass);
    MRB_SET_INSTANCE_TT(rclass, MRB_TT_DATA);

    mrb_define_class_method(mrb, rclass, "create", ruby_cocos2dx_EaseBackInOut_create_static, ARGS_REQ(1));
}
mrb_value ruby_cocos2dx_EaseBezierAction_setBezierParamer(mrb_state* mrb, mrb_value self)
{
    cocos2d::EaseBezierAction* cobj = static_cast<cocos2d::EaseBezierAction*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 4) {
            double arg0;
            ok = rubyval_to_number(mrb, argv[0], (double*)&arg0, "CC::EaseBezierAction.setBezierParamer");
            if (!ok) { break; }
            double arg1;
            ok = rubyval_to_number(mrb, argv[1], (double*)&arg1, "CC::EaseBezierAction.setBezierParamer");
            if (!ok) { break; }
            double arg2;
            ok = rubyval_to_number(mrb, argv[2], (double*)&arg2, "CC::EaseBezierAction.setBezierParamer");
            if (!ok) { break; }
            double arg3;
            ok = rubyval_to_number(mrb, argv[3], (double*)&arg3, "CC::EaseBezierAction.setBezierParamer");
            if (!ok) { break; }
            cobj->setBezierParamer(arg0, arg1, arg2, arg3);
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::EaseBezierAction#setBezierParamer");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_EaseBezierAction_create_static(mrb_state* mrb, mrb_value self)
{
    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            std::map<std::string, mrb_value> callbacks;
            cocos2d::ActionInterval* arg0;
            ok = rubyval_to_object<cocos2d::ActionInterval>(mrb, argv[0], "CC::ActionInterval", &arg0);
            if (!ok) { break; }

            cocos2d::EaseBezierAction* retval = cocos2d::EaseBezierAction::create(arg0);
            mrb_value ret;
            RClass* rclass = mrb_class_ptr(self);
            ret = object_to_rubyval<cocos2d::EaseBezierAction>(mrb, "CC::EaseBezierAction", (cocos2d::EaseBezierAction*)retval, rclass);
            if (callbacks.size() > 0) {
                mrb_value hash = mrb_iv_get(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"));
                if (!mrb_hash_p(hash)) {
                    hash = mrb_hash_new(mrb);
                }
                for (auto elm : callbacks) {
                    mrb_hash_set(mrb, hash, mrb_str_new_cstr(mrb, elm.first.c_str()), elm.second);
                    mrb_iv_set(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"), hash);
                }
            }
            g_rubyValue.push_back(ret);
            mrb_funcall(mrb, ret, "initialize", 0);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined static method : cocos2d::EaseBezierAction#create");

    return mrb_nil_value();
}

void ruby_register_cocos2dx_EaseBezierAction(mrb_state* mrb, struct RClass* rmodule)
{
    std::string typeName = typeid(cocos2d::EaseBezierAction).name();
    g_rubyType[typeName] = "CC::EaseBezierAction";
    g_rubyDataType[typeName] = &ruby_cocos2dx_Ref_type;

    struct RClass* p_rmodule = mrb->object_class;
    p_rmodule = mrb_module_get_under(mrb, p_rmodule, "CC");
    struct RClass* p_rclass = mrb_class_get_under(mrb, p_rmodule, "ActionEase");
    struct RClass *rclass = mrb_define_class_under(mrb, rmodule, "EaseBezierAction", p_rclass);
    MRB_SET_INSTANCE_TT(rclass, MRB_TT_DATA);

    mrb_define_method(mrb, rclass, "set_bezier_paramer", ruby_cocos2dx_EaseBezierAction_setBezierParamer, ARGS_REQ(4));
    mrb_define_class_method(mrb, rclass, "create", ruby_cocos2dx_EaseBezierAction_create_static, ARGS_REQ(1));
}
mrb_value ruby_cocos2dx_EaseQuadraticActionIn_create_static(mrb_state* mrb, mrb_value self)
{
    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            std::map<std::string, mrb_value> callbacks;
            cocos2d::ActionInterval* arg0;
            ok = rubyval_to_object<cocos2d::ActionInterval>(mrb, argv[0], "CC::ActionInterval", &arg0);
            if (!ok) { break; }

            cocos2d::EaseQuadraticActionIn* retval = cocos2d::EaseQuadraticActionIn::create(arg0);
            mrb_value ret;
            RClass* rclass = mrb_class_ptr(self);
            ret = object_to_rubyval<cocos2d::EaseQuadraticActionIn>(mrb, "CC::EaseQuadraticActionIn", (cocos2d::EaseQuadraticActionIn*)retval, rclass);
            if (callbacks.size() > 0) {
                mrb_value hash = mrb_iv_get(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"));
                if (!mrb_hash_p(hash)) {
                    hash = mrb_hash_new(mrb);
                }
                for (auto elm : callbacks) {
                    mrb_hash_set(mrb, hash, mrb_str_new_cstr(mrb, elm.first.c_str()), elm.second);
                    mrb_iv_set(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"), hash);
                }
            }
            g_rubyValue.push_back(ret);
            mrb_funcall(mrb, ret, "initialize", 0);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined static method : cocos2d::EaseQuadraticActionIn#create");

    return mrb_nil_value();
}

void ruby_register_cocos2dx_EaseQuadraticActionIn(mrb_state* mrb, struct RClass* rmodule)
{
    std::string typeName = typeid(cocos2d::EaseQuadraticActionIn).name();
    g_rubyType[typeName] = "CC::EaseQuadraticActionIn";
    g_rubyDataType[typeName] = &ruby_cocos2dx_Ref_type;

    struct RClass* p_rmodule = mrb->object_class;
    p_rmodule = mrb_module_get_under(mrb, p_rmodule, "CC");
    struct RClass* p_rclass = mrb_class_get_under(mrb, p_rmodule, "ActionEase");
    struct RClass *rclass = mrb_define_class_under(mrb, rmodule, "EaseQuadraticActionIn", p_rclass);
    MRB_SET_INSTANCE_TT(rclass, MRB_TT_DATA);

    mrb_define_class_method(mrb, rclass, "create", ruby_cocos2dx_EaseQuadraticActionIn_create_static, ARGS_REQ(1));
}
mrb_value ruby_cocos2dx_EaseQuadraticActionOut_create_static(mrb_state* mrb, mrb_value self)
{
    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            std::map<std::string, mrb_value> callbacks;
            cocos2d::ActionInterval* arg0;
            ok = rubyval_to_object<cocos2d::ActionInterval>(mrb, argv[0], "CC::ActionInterval", &arg0);
            if (!ok) { break; }

            cocos2d::EaseQuadraticActionOut* retval = cocos2d::EaseQuadraticActionOut::create(arg0);
            mrb_value ret;
            RClass* rclass = mrb_class_ptr(self);
            ret = object_to_rubyval<cocos2d::EaseQuadraticActionOut>(mrb, "CC::EaseQuadraticActionOut", (cocos2d::EaseQuadraticActionOut*)retval, rclass);
            if (callbacks.size() > 0) {
                mrb_value hash = mrb_iv_get(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"));
                if (!mrb_hash_p(hash)) {
                    hash = mrb_hash_new(mrb);
                }
                for (auto elm : callbacks) {
                    mrb_hash_set(mrb, hash, mrb_str_new_cstr(mrb, elm.first.c_str()), elm.second);
                    mrb_iv_set(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"), hash);
                }
            }
            g_rubyValue.push_back(ret);
            mrb_funcall(mrb, ret, "initialize", 0);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined static method : cocos2d::EaseQuadraticActionOut#create");

    return mrb_nil_value();
}

void ruby_register_cocos2dx_EaseQuadraticActionOut(mrb_state* mrb, struct RClass* rmodule)
{
    std::string typeName = typeid(cocos2d::EaseQuadraticActionOut).name();
    g_rubyType[typeName] = "CC::EaseQuadraticActionOut";
    g_rubyDataType[typeName] = &ruby_cocos2dx_Ref_type;

    struct RClass* p_rmodule = mrb->object_class;
    p_rmodule = mrb_module_get_under(mrb, p_rmodule, "CC");
    struct RClass* p_rclass = mrb_class_get_under(mrb, p_rmodule, "ActionEase");
    struct RClass *rclass = mrb_define_class_under(mrb, rmodule, "EaseQuadraticActionOut", p_rclass);
    MRB_SET_INSTANCE_TT(rclass, MRB_TT_DATA);

    mrb_define_class_method(mrb, rclass, "create", ruby_cocos2dx_EaseQuadraticActionOut_create_static, ARGS_REQ(1));
}
mrb_value ruby_cocos2dx_EaseQuadraticActionInOut_create_static(mrb_state* mrb, mrb_value self)
{
    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            std::map<std::string, mrb_value> callbacks;
            cocos2d::ActionInterval* arg0;
            ok = rubyval_to_object<cocos2d::ActionInterval>(mrb, argv[0], "CC::ActionInterval", &arg0);
            if (!ok) { break; }

            cocos2d::EaseQuadraticActionInOut* retval = cocos2d::EaseQuadraticActionInOut::create(arg0);
            mrb_value ret;
            RClass* rclass = mrb_class_ptr(self);
            ret = object_to_rubyval<cocos2d::EaseQuadraticActionInOut>(mrb, "CC::EaseQuadraticActionInOut", (cocos2d::EaseQuadraticActionInOut*)retval, rclass);
            if (callbacks.size() > 0) {
                mrb_value hash = mrb_iv_get(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"));
                if (!mrb_hash_p(hash)) {
                    hash = mrb_hash_new(mrb);
                }
                for (auto elm : callbacks) {
                    mrb_hash_set(mrb, hash, mrb_str_new_cstr(mrb, elm.first.c_str()), elm.second);
                    mrb_iv_set(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"), hash);
                }
            }
            g_rubyValue.push_back(ret);
            mrb_funcall(mrb, ret, "initialize", 0);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined static method : cocos2d::EaseQuadraticActionInOut#create");

    return mrb_nil_value();
}

void ruby_register_cocos2dx_EaseQuadraticActionInOut(mrb_state* mrb, struct RClass* rmodule)
{
    std::string typeName = typeid(cocos2d::EaseQuadraticActionInOut).name();
    g_rubyType[typeName] = "CC::EaseQuadraticActionInOut";
    g_rubyDataType[typeName] = &ruby_cocos2dx_Ref_type;

    struct RClass* p_rmodule = mrb->object_class;
    p_rmodule = mrb_module_get_under(mrb, p_rmodule, "CC");
    struct RClass* p_rclass = mrb_class_get_under(mrb, p_rmodule, "ActionEase");
    struct RClass *rclass = mrb_define_class_under(mrb, rmodule, "EaseQuadraticActionInOut", p_rclass);
    MRB_SET_INSTANCE_TT(rclass, MRB_TT_DATA);

    mrb_define_class_method(mrb, rclass, "create", ruby_cocos2dx_EaseQuadraticActionInOut_create_static, ARGS_REQ(1));
}
mrb_value ruby_cocos2dx_EaseQuarticActionIn_create_static(mrb_state* mrb, mrb_value self)
{
    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            std::map<std::string, mrb_value> callbacks;
            cocos2d::ActionInterval* arg0;
            ok = rubyval_to_object<cocos2d::ActionInterval>(mrb, argv[0], "CC::ActionInterval", &arg0);
            if (!ok) { break; }

            cocos2d::EaseQuarticActionIn* retval = cocos2d::EaseQuarticActionIn::create(arg0);
            mrb_value ret;
            RClass* rclass = mrb_class_ptr(self);
            ret = object_to_rubyval<cocos2d::EaseQuarticActionIn>(mrb, "CC::EaseQuarticActionIn", (cocos2d::EaseQuarticActionIn*)retval, rclass);
            if (callbacks.size() > 0) {
                mrb_value hash = mrb_iv_get(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"));
                if (!mrb_hash_p(hash)) {
                    hash = mrb_hash_new(mrb);
                }
                for (auto elm : callbacks) {
                    mrb_hash_set(mrb, hash, mrb_str_new_cstr(mrb, elm.first.c_str()), elm.second);
                    mrb_iv_set(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"), hash);
                }
            }
            g_rubyValue.push_back(ret);
            mrb_funcall(mrb, ret, "initialize", 0);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined static method : cocos2d::EaseQuarticActionIn#create");

    return mrb_nil_value();
}

void ruby_register_cocos2dx_EaseQuarticActionIn(mrb_state* mrb, struct RClass* rmodule)
{
    std::string typeName = typeid(cocos2d::EaseQuarticActionIn).name();
    g_rubyType[typeName] = "CC::EaseQuarticActionIn";
    g_rubyDataType[typeName] = &ruby_cocos2dx_Ref_type;

    struct RClass* p_rmodule = mrb->object_class;
    p_rmodule = mrb_module_get_under(mrb, p_rmodule, "CC");
    struct RClass* p_rclass = mrb_class_get_under(mrb, p_rmodule, "ActionEase");
    struct RClass *rclass = mrb_define_class_under(mrb, rmodule, "EaseQuarticActionIn", p_rclass);
    MRB_SET_INSTANCE_TT(rclass, MRB_TT_DATA);

    mrb_define_class_method(mrb, rclass, "create", ruby_cocos2dx_EaseQuarticActionIn_create_static, ARGS_REQ(1));
}
mrb_value ruby_cocos2dx_EaseQuarticActionOut_create_static(mrb_state* mrb, mrb_value self)
{
    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            std::map<std::string, mrb_value> callbacks;
            cocos2d::ActionInterval* arg0;
            ok = rubyval_to_object<cocos2d::ActionInterval>(mrb, argv[0], "CC::ActionInterval", &arg0);
            if (!ok) { break; }

            cocos2d::EaseQuarticActionOut* retval = cocos2d::EaseQuarticActionOut::create(arg0);
            mrb_value ret;
            RClass* rclass = mrb_class_ptr(self);
            ret = object_to_rubyval<cocos2d::EaseQuarticActionOut>(mrb, "CC::EaseQuarticActionOut", (cocos2d::EaseQuarticActionOut*)retval, rclass);
            if (callbacks.size() > 0) {
                mrb_value hash = mrb_iv_get(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"));
                if (!mrb_hash_p(hash)) {
                    hash = mrb_hash_new(mrb);
                }
                for (auto elm : callbacks) {
                    mrb_hash_set(mrb, hash, mrb_str_new_cstr(mrb, elm.first.c_str()), elm.second);
                    mrb_iv_set(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"), hash);
                }
            }
            g_rubyValue.push_back(ret);
            mrb_funcall(mrb, ret, "initialize", 0);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined static method : cocos2d::EaseQuarticActionOut#create");

    return mrb_nil_value();
}

void ruby_register_cocos2dx_EaseQuarticActionOut(mrb_state* mrb, struct RClass* rmodule)
{
    std::string typeName = typeid(cocos2d::EaseQuarticActionOut).name();
    g_rubyType[typeName] = "CC::EaseQuarticActionOut";
    g_rubyDataType[typeName] = &ruby_cocos2dx_Ref_type;

    struct RClass* p_rmodule = mrb->object_class;
    p_rmodule = mrb_module_get_under(mrb, p_rmodule, "CC");
    struct RClass* p_rclass = mrb_class_get_under(mrb, p_rmodule, "ActionEase");
    struct RClass *rclass = mrb_define_class_under(mrb, rmodule, "EaseQuarticActionOut", p_rclass);
    MRB_SET_INSTANCE_TT(rclass, MRB_TT_DATA);

    mrb_define_class_method(mrb, rclass, "create", ruby_cocos2dx_EaseQuarticActionOut_create_static, ARGS_REQ(1));
}
mrb_value ruby_cocos2dx_EaseQuarticActionInOut_create_static(mrb_state* mrb, mrb_value self)
{
    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            std::map<std::string, mrb_value> callbacks;
            cocos2d::ActionInterval* arg0;
            ok = rubyval_to_object<cocos2d::ActionInterval>(mrb, argv[0], "CC::ActionInterval", &arg0);
            if (!ok) { break; }

            cocos2d::EaseQuarticActionInOut* retval = cocos2d::EaseQuarticActionInOut::create(arg0);
            mrb_value ret;
            RClass* rclass = mrb_class_ptr(self);
            ret = object_to_rubyval<cocos2d::EaseQuarticActionInOut>(mrb, "CC::EaseQuarticActionInOut", (cocos2d::EaseQuarticActionInOut*)retval, rclass);
            if (callbacks.size() > 0) {
                mrb_value hash = mrb_iv_get(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"));
                if (!mrb_hash_p(hash)) {
                    hash = mrb_hash_new(mrb);
                }
                for (auto elm : callbacks) {
                    mrb_hash_set(mrb, hash, mrb_str_new_cstr(mrb, elm.first.c_str()), elm.second);
                    mrb_iv_set(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"), hash);
                }
            }
            g_rubyValue.push_back(ret);
            mrb_funcall(mrb, ret, "initialize", 0);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined static method : cocos2d::EaseQuarticActionInOut#create");

    return mrb_nil_value();
}

void ruby_register_cocos2dx_EaseQuarticActionInOut(mrb_state* mrb, struct RClass* rmodule)
{
    std::string typeName = typeid(cocos2d::EaseQuarticActionInOut).name();
    g_rubyType[typeName] = "CC::EaseQuarticActionInOut";
    g_rubyDataType[typeName] = &ruby_cocos2dx_Ref_type;

    struct RClass* p_rmodule = mrb->object_class;
    p_rmodule = mrb_module_get_under(mrb, p_rmodule, "CC");
    struct RClass* p_rclass = mrb_class_get_under(mrb, p_rmodule, "ActionEase");
    struct RClass *rclass = mrb_define_class_under(mrb, rmodule, "EaseQuarticActionInOut", p_rclass);
    MRB_SET_INSTANCE_TT(rclass, MRB_TT_DATA);

    mrb_define_class_method(mrb, rclass, "create", ruby_cocos2dx_EaseQuarticActionInOut_create_static, ARGS_REQ(1));
}
mrb_value ruby_cocos2dx_EaseQuinticActionIn_create_static(mrb_state* mrb, mrb_value self)
{
    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            std::map<std::string, mrb_value> callbacks;
            cocos2d::ActionInterval* arg0;
            ok = rubyval_to_object<cocos2d::ActionInterval>(mrb, argv[0], "CC::ActionInterval", &arg0);
            if (!ok) { break; }

            cocos2d::EaseQuinticActionIn* retval = cocos2d::EaseQuinticActionIn::create(arg0);
            mrb_value ret;
            RClass* rclass = mrb_class_ptr(self);
            ret = object_to_rubyval<cocos2d::EaseQuinticActionIn>(mrb, "CC::EaseQuinticActionIn", (cocos2d::EaseQuinticActionIn*)retval, rclass);
            if (callbacks.size() > 0) {
                mrb_value hash = mrb_iv_get(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"));
                if (!mrb_hash_p(hash)) {
                    hash = mrb_hash_new(mrb);
                }
                for (auto elm : callbacks) {
                    mrb_hash_set(mrb, hash, mrb_str_new_cstr(mrb, elm.first.c_str()), elm.second);
                    mrb_iv_set(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"), hash);
                }
            }
            g_rubyValue.push_back(ret);
            mrb_funcall(mrb, ret, "initialize", 0);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined static method : cocos2d::EaseQuinticActionIn#create");

    return mrb_nil_value();
}

void ruby_register_cocos2dx_EaseQuinticActionIn(mrb_state* mrb, struct RClass* rmodule)
{
    std::string typeName = typeid(cocos2d::EaseQuinticActionIn).name();
    g_rubyType[typeName] = "CC::EaseQuinticActionIn";
    g_rubyDataType[typeName] = &ruby_cocos2dx_Ref_type;

    struct RClass* p_rmodule = mrb->object_class;
    p_rmodule = mrb_module_get_under(mrb, p_rmodule, "CC");
    struct RClass* p_rclass = mrb_class_get_under(mrb, p_rmodule, "ActionEase");
    struct RClass *rclass = mrb_define_class_under(mrb, rmodule, "EaseQuinticActionIn", p_rclass);
    MRB_SET_INSTANCE_TT(rclass, MRB_TT_DATA);

    mrb_define_class_method(mrb, rclass, "create", ruby_cocos2dx_EaseQuinticActionIn_create_static, ARGS_REQ(1));
}
mrb_value ruby_cocos2dx_EaseQuinticActionOut_create_static(mrb_state* mrb, mrb_value self)
{
    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            std::map<std::string, mrb_value> callbacks;
            cocos2d::ActionInterval* arg0;
            ok = rubyval_to_object<cocos2d::ActionInterval>(mrb, argv[0], "CC::ActionInterval", &arg0);
            if (!ok) { break; }

            cocos2d::EaseQuinticActionOut* retval = cocos2d::EaseQuinticActionOut::create(arg0);
            mrb_value ret;
            RClass* rclass = mrb_class_ptr(self);
            ret = object_to_rubyval<cocos2d::EaseQuinticActionOut>(mrb, "CC::EaseQuinticActionOut", (cocos2d::EaseQuinticActionOut*)retval, rclass);
            if (callbacks.size() > 0) {
                mrb_value hash = mrb_iv_get(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"));
                if (!mrb_hash_p(hash)) {
                    hash = mrb_hash_new(mrb);
                }
                for (auto elm : callbacks) {
                    mrb_hash_set(mrb, hash, mrb_str_new_cstr(mrb, elm.first.c_str()), elm.second);
                    mrb_iv_set(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"), hash);
                }
            }
            g_rubyValue.push_back(ret);
            mrb_funcall(mrb, ret, "initialize", 0);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined static method : cocos2d::EaseQuinticActionOut#create");

    return mrb_nil_value();
}

void ruby_register_cocos2dx_EaseQuinticActionOut(mrb_state* mrb, struct RClass* rmodule)
{
    std::string typeName = typeid(cocos2d::EaseQuinticActionOut).name();
    g_rubyType[typeName] = "CC::EaseQuinticActionOut";
    g_rubyDataType[typeName] = &ruby_cocos2dx_Ref_type;

    struct RClass* p_rmodule = mrb->object_class;
    p_rmodule = mrb_module_get_under(mrb, p_rmodule, "CC");
    struct RClass* p_rclass = mrb_class_get_under(mrb, p_rmodule, "ActionEase");
    struct RClass *rclass = mrb_define_class_under(mrb, rmodule, "EaseQuinticActionOut", p_rclass);
    MRB_SET_INSTANCE_TT(rclass, MRB_TT_DATA);

    mrb_define_class_method(mrb, rclass, "create", ruby_cocos2dx_EaseQuinticActionOut_create_static, ARGS_REQ(1));
}
mrb_value ruby_cocos2dx_EaseQuinticActionInOut_create_static(mrb_state* mrb, mrb_value self)
{
    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            std::map<std::string, mrb_value> callbacks;
            cocos2d::ActionInterval* arg0;
            ok = rubyval_to_object<cocos2d::ActionInterval>(mrb, argv[0], "CC::ActionInterval", &arg0);
            if (!ok) { break; }

            cocos2d::EaseQuinticActionInOut* retval = cocos2d::EaseQuinticActionInOut::create(arg0);
            mrb_value ret;
            RClass* rclass = mrb_class_ptr(self);
            ret = object_to_rubyval<cocos2d::EaseQuinticActionInOut>(mrb, "CC::EaseQuinticActionInOut", (cocos2d::EaseQuinticActionInOut*)retval, rclass);
            if (callbacks.size() > 0) {
                mrb_value hash = mrb_iv_get(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"));
                if (!mrb_hash_p(hash)) {
                    hash = mrb_hash_new(mrb);
                }
                for (auto elm : callbacks) {
                    mrb_hash_set(mrb, hash, mrb_str_new_cstr(mrb, elm.first.c_str()), elm.second);
                    mrb_iv_set(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"), hash);
                }
            }
            g_rubyValue.push_back(ret);
            mrb_funcall(mrb, ret, "initialize", 0);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined static method : cocos2d::EaseQuinticActionInOut#create");

    return mrb_nil_value();
}

void ruby_register_cocos2dx_EaseQuinticActionInOut(mrb_state* mrb, struct RClass* rmodule)
{
    std::string typeName = typeid(cocos2d::EaseQuinticActionInOut).name();
    g_rubyType[typeName] = "CC::EaseQuinticActionInOut";
    g_rubyDataType[typeName] = &ruby_cocos2dx_Ref_type;

    struct RClass* p_rmodule = mrb->object_class;
    p_rmodule = mrb_module_get_under(mrb, p_rmodule, "CC");
    struct RClass* p_rclass = mrb_class_get_under(mrb, p_rmodule, "ActionEase");
    struct RClass *rclass = mrb_define_class_under(mrb, rmodule, "EaseQuinticActionInOut", p_rclass);
    MRB_SET_INSTANCE_TT(rclass, MRB_TT_DATA);

    mrb_define_class_method(mrb, rclass, "create", ruby_cocos2dx_EaseQuinticActionInOut_create_static, ARGS_REQ(1));
}
mrb_value ruby_cocos2dx_EaseCircleActionIn_create_static(mrb_state* mrb, mrb_value self)
{
    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            std::map<std::string, mrb_value> callbacks;
            cocos2d::ActionInterval* arg0;
            ok = rubyval_to_object<cocos2d::ActionInterval>(mrb, argv[0], "CC::ActionInterval", &arg0);
            if (!ok) { break; }

            cocos2d::EaseCircleActionIn* retval = cocos2d::EaseCircleActionIn::create(arg0);
            mrb_value ret;
            RClass* rclass = mrb_class_ptr(self);
            ret = object_to_rubyval<cocos2d::EaseCircleActionIn>(mrb, "CC::EaseCircleActionIn", (cocos2d::EaseCircleActionIn*)retval, rclass);
            if (callbacks.size() > 0) {
                mrb_value hash = mrb_iv_get(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"));
                if (!mrb_hash_p(hash)) {
                    hash = mrb_hash_new(mrb);
                }
                for (auto elm : callbacks) {
                    mrb_hash_set(mrb, hash, mrb_str_new_cstr(mrb, elm.first.c_str()), elm.second);
                    mrb_iv_set(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"), hash);
                }
            }
            g_rubyValue.push_back(ret);
            mrb_funcall(mrb, ret, "initialize", 0);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined static method : cocos2d::EaseCircleActionIn#create");

    return mrb_nil_value();
}

void ruby_register_cocos2dx_EaseCircleActionIn(mrb_state* mrb, struct RClass* rmodule)
{
    std::string typeName = typeid(cocos2d::EaseCircleActionIn).name();
    g_rubyType[typeName] = "CC::EaseCircleActionIn";
    g_rubyDataType[typeName] = &ruby_cocos2dx_Ref_type;

    struct RClass* p_rmodule = mrb->object_class;
    p_rmodule = mrb_module_get_under(mrb, p_rmodule, "CC");
    struct RClass* p_rclass = mrb_class_get_under(mrb, p_rmodule, "ActionEase");
    struct RClass *rclass = mrb_define_class_under(mrb, rmodule, "EaseCircleActionIn", p_rclass);
    MRB_SET_INSTANCE_TT(rclass, MRB_TT_DATA);

    mrb_define_class_method(mrb, rclass, "create", ruby_cocos2dx_EaseCircleActionIn_create_static, ARGS_REQ(1));
}
mrb_value ruby_cocos2dx_EaseCircleActionOut_create_static(mrb_state* mrb, mrb_value self)
{
    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            std::map<std::string, mrb_value> callbacks;
            cocos2d::ActionInterval* arg0;
            ok = rubyval_to_object<cocos2d::ActionInterval>(mrb, argv[0], "CC::ActionInterval", &arg0);
            if (!ok) { break; }

            cocos2d::EaseCircleActionOut* retval = cocos2d::EaseCircleActionOut::create(arg0);
            mrb_value ret;
            RClass* rclass = mrb_class_ptr(self);
            ret = object_to_rubyval<cocos2d::EaseCircleActionOut>(mrb, "CC::EaseCircleActionOut", (cocos2d::EaseCircleActionOut*)retval, rclass);
            if (callbacks.size() > 0) {
                mrb_value hash = mrb_iv_get(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"));
                if (!mrb_hash_p(hash)) {
                    hash = mrb_hash_new(mrb);
                }
                for (auto elm : callbacks) {
                    mrb_hash_set(mrb, hash, mrb_str_new_cstr(mrb, elm.first.c_str()), elm.second);
                    mrb_iv_set(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"), hash);
                }
            }
            g_rubyValue.push_back(ret);
            mrb_funcall(mrb, ret, "initialize", 0);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined static method : cocos2d::EaseCircleActionOut#create");

    return mrb_nil_value();
}

void ruby_register_cocos2dx_EaseCircleActionOut(mrb_state* mrb, struct RClass* rmodule)
{
    std::string typeName = typeid(cocos2d::EaseCircleActionOut).name();
    g_rubyType[typeName] = "CC::EaseCircleActionOut";
    g_rubyDataType[typeName] = &ruby_cocos2dx_Ref_type;

    struct RClass* p_rmodule = mrb->object_class;
    p_rmodule = mrb_module_get_under(mrb, p_rmodule, "CC");
    struct RClass* p_rclass = mrb_class_get_under(mrb, p_rmodule, "ActionEase");
    struct RClass *rclass = mrb_define_class_under(mrb, rmodule, "EaseCircleActionOut", p_rclass);
    MRB_SET_INSTANCE_TT(rclass, MRB_TT_DATA);

    mrb_define_class_method(mrb, rclass, "create", ruby_cocos2dx_EaseCircleActionOut_create_static, ARGS_REQ(1));
}
mrb_value ruby_cocos2dx_EaseCircleActionInOut_create_static(mrb_state* mrb, mrb_value self)
{
    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            std::map<std::string, mrb_value> callbacks;
            cocos2d::ActionInterval* arg0;
            ok = rubyval_to_object<cocos2d::ActionInterval>(mrb, argv[0], "CC::ActionInterval", &arg0);
            if (!ok) { break; }

            cocos2d::EaseCircleActionInOut* retval = cocos2d::EaseCircleActionInOut::create(arg0);
            mrb_value ret;
            RClass* rclass = mrb_class_ptr(self);
            ret = object_to_rubyval<cocos2d::EaseCircleActionInOut>(mrb, "CC::EaseCircleActionInOut", (cocos2d::EaseCircleActionInOut*)retval, rclass);
            if (callbacks.size() > 0) {
                mrb_value hash = mrb_iv_get(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"));
                if (!mrb_hash_p(hash)) {
                    hash = mrb_hash_new(mrb);
                }
                for (auto elm : callbacks) {
                    mrb_hash_set(mrb, hash, mrb_str_new_cstr(mrb, elm.first.c_str()), elm.second);
                    mrb_iv_set(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"), hash);
                }
            }
            g_rubyValue.push_back(ret);
            mrb_funcall(mrb, ret, "initialize", 0);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined static method : cocos2d::EaseCircleActionInOut#create");

    return mrb_nil_value();
}

void ruby_register_cocos2dx_EaseCircleActionInOut(mrb_state* mrb, struct RClass* rmodule)
{
    std::string typeName = typeid(cocos2d::EaseCircleActionInOut).name();
    g_rubyType[typeName] = "CC::EaseCircleActionInOut";
    g_rubyDataType[typeName] = &ruby_cocos2dx_Ref_type;

    struct RClass* p_rmodule = mrb->object_class;
    p_rmodule = mrb_module_get_under(mrb, p_rmodule, "CC");
    struct RClass* p_rclass = mrb_class_get_under(mrb, p_rmodule, "ActionEase");
    struct RClass *rclass = mrb_define_class_under(mrb, rmodule, "EaseCircleActionInOut", p_rclass);
    MRB_SET_INSTANCE_TT(rclass, MRB_TT_DATA);

    mrb_define_class_method(mrb, rclass, "create", ruby_cocos2dx_EaseCircleActionInOut_create_static, ARGS_REQ(1));
}
mrb_value ruby_cocos2dx_EaseCubicActionIn_create_static(mrb_state* mrb, mrb_value self)
{
    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            std::map<std::string, mrb_value> callbacks;
            cocos2d::ActionInterval* arg0;
            ok = rubyval_to_object<cocos2d::ActionInterval>(mrb, argv[0], "CC::ActionInterval", &arg0);
            if (!ok) { break; }

            cocos2d::EaseCubicActionIn* retval = cocos2d::EaseCubicActionIn::create(arg0);
            mrb_value ret;
            RClass* rclass = mrb_class_ptr(self);
            ret = object_to_rubyval<cocos2d::EaseCubicActionIn>(mrb, "CC::EaseCubicActionIn", (cocos2d::EaseCubicActionIn*)retval, rclass);
            if (callbacks.size() > 0) {
                mrb_value hash = mrb_iv_get(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"));
                if (!mrb_hash_p(hash)) {
                    hash = mrb_hash_new(mrb);
                }
                for (auto elm : callbacks) {
                    mrb_hash_set(mrb, hash, mrb_str_new_cstr(mrb, elm.first.c_str()), elm.second);
                    mrb_iv_set(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"), hash);
                }
            }
            g_rubyValue.push_back(ret);
            mrb_funcall(mrb, ret, "initialize", 0);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined static method : cocos2d::EaseCubicActionIn#create");

    return mrb_nil_value();
}

void ruby_register_cocos2dx_EaseCubicActionIn(mrb_state* mrb, struct RClass* rmodule)
{
    std::string typeName = typeid(cocos2d::EaseCubicActionIn).name();
    g_rubyType[typeName] = "CC::EaseCubicActionIn";
    g_rubyDataType[typeName] = &ruby_cocos2dx_Ref_type;

    struct RClass* p_rmodule = mrb->object_class;
    p_rmodule = mrb_module_get_under(mrb, p_rmodule, "CC");
    struct RClass* p_rclass = mrb_class_get_under(mrb, p_rmodule, "ActionEase");
    struct RClass *rclass = mrb_define_class_under(mrb, rmodule, "EaseCubicActionIn", p_rclass);
    MRB_SET_INSTANCE_TT(rclass, MRB_TT_DATA);

    mrb_define_class_method(mrb, rclass, "create", ruby_cocos2dx_EaseCubicActionIn_create_static, ARGS_REQ(1));
}
mrb_value ruby_cocos2dx_EaseCubicActionOut_create_static(mrb_state* mrb, mrb_value self)
{
    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            std::map<std::string, mrb_value> callbacks;
            cocos2d::ActionInterval* arg0;
            ok = rubyval_to_object<cocos2d::ActionInterval>(mrb, argv[0], "CC::ActionInterval", &arg0);
            if (!ok) { break; }

            cocos2d::EaseCubicActionOut* retval = cocos2d::EaseCubicActionOut::create(arg0);
            mrb_value ret;
            RClass* rclass = mrb_class_ptr(self);
            ret = object_to_rubyval<cocos2d::EaseCubicActionOut>(mrb, "CC::EaseCubicActionOut", (cocos2d::EaseCubicActionOut*)retval, rclass);
            if (callbacks.size() > 0) {
                mrb_value hash = mrb_iv_get(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"));
                if (!mrb_hash_p(hash)) {
                    hash = mrb_hash_new(mrb);
                }
                for (auto elm : callbacks) {
                    mrb_hash_set(mrb, hash, mrb_str_new_cstr(mrb, elm.first.c_str()), elm.second);
                    mrb_iv_set(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"), hash);
                }
            }
            g_rubyValue.push_back(ret);
            mrb_funcall(mrb, ret, "initialize", 0);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined static method : cocos2d::EaseCubicActionOut#create");

    return mrb_nil_value();
}

void ruby_register_cocos2dx_EaseCubicActionOut(mrb_state* mrb, struct RClass* rmodule)
{
    std::string typeName = typeid(cocos2d::EaseCubicActionOut).name();
    g_rubyType[typeName] = "CC::EaseCubicActionOut";
    g_rubyDataType[typeName] = &ruby_cocos2dx_Ref_type;

    struct RClass* p_rmodule = mrb->object_class;
    p_rmodule = mrb_module_get_under(mrb, p_rmodule, "CC");
    struct RClass* p_rclass = mrb_class_get_under(mrb, p_rmodule, "ActionEase");
    struct RClass *rclass = mrb_define_class_under(mrb, rmodule, "EaseCubicActionOut", p_rclass);
    MRB_SET_INSTANCE_TT(rclass, MRB_TT_DATA);

    mrb_define_class_method(mrb, rclass, "create", ruby_cocos2dx_EaseCubicActionOut_create_static, ARGS_REQ(1));
}
mrb_value ruby_cocos2dx_EaseCubicActionInOut_create_static(mrb_state* mrb, mrb_value self)
{
    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            std::map<std::string, mrb_value> callbacks;
            cocos2d::ActionInterval* arg0;
            ok = rubyval_to_object<cocos2d::ActionInterval>(mrb, argv[0], "CC::ActionInterval", &arg0);
            if (!ok) { break; }

            cocos2d::EaseCubicActionInOut* retval = cocos2d::EaseCubicActionInOut::create(arg0);
            mrb_value ret;
            RClass* rclass = mrb_class_ptr(self);
            ret = object_to_rubyval<cocos2d::EaseCubicActionInOut>(mrb, "CC::EaseCubicActionInOut", (cocos2d::EaseCubicActionInOut*)retval, rclass);
            if (callbacks.size() > 0) {
                mrb_value hash = mrb_iv_get(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"));
                if (!mrb_hash_p(hash)) {
                    hash = mrb_hash_new(mrb);
                }
                for (auto elm : callbacks) {
                    mrb_hash_set(mrb, hash, mrb_str_new_cstr(mrb, elm.first.c_str()), elm.second);
                    mrb_iv_set(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"), hash);
                }
            }
            g_rubyValue.push_back(ret);
            mrb_funcall(mrb, ret, "initialize", 0);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined static method : cocos2d::EaseCubicActionInOut#create");

    return mrb_nil_value();
}

void ruby_register_cocos2dx_EaseCubicActionInOut(mrb_state* mrb, struct RClass* rmodule)
{
    std::string typeName = typeid(cocos2d::EaseCubicActionInOut).name();
    g_rubyType[typeName] = "CC::EaseCubicActionInOut";
    g_rubyDataType[typeName] = &ruby_cocos2dx_Ref_type;

    struct RClass* p_rmodule = mrb->object_class;
    p_rmodule = mrb_module_get_under(mrb, p_rmodule, "CC");
    struct RClass* p_rclass = mrb_class_get_under(mrb, p_rmodule, "ActionEase");
    struct RClass *rclass = mrb_define_class_under(mrb, rmodule, "EaseCubicActionInOut", p_rclass);
    MRB_SET_INSTANCE_TT(rclass, MRB_TT_DATA);

    mrb_define_class_method(mrb, rclass, "create", ruby_cocos2dx_EaseCubicActionInOut_create_static, ARGS_REQ(1));
}
void ruby_register_cocos2dx_ActionInstant(mrb_state* mrb, struct RClass* rmodule)
{
    std::string typeName = typeid(cocos2d::ActionInstant).name();
    g_rubyType[typeName] = "CC::ActionInstant";
    g_rubyDataType[typeName] = &ruby_cocos2dx_Ref_type;

    struct RClass* p_rmodule = mrb->object_class;
    p_rmodule = mrb_module_get_under(mrb, p_rmodule, "CC");
    struct RClass* p_rclass = mrb_class_get_under(mrb, p_rmodule, "FiniteTimeAction");
    struct RClass *rclass = mrb_define_class_under(mrb, rmodule, "ActionInstant", p_rclass);
    MRB_SET_INSTANCE_TT(rclass, MRB_TT_DATA);

}
mrb_value ruby_cocos2dx_Show_create_static(mrb_state* mrb, mrb_value self)
{
    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            std::map<std::string, mrb_value> callbacks;
            cocos2d::Show* retval = cocos2d::Show::create();
            mrb_value ret;
            RClass* rclass = mrb_class_ptr(self);
            ret = object_to_rubyval<cocos2d::Show>(mrb, "CC::Show", (cocos2d::Show*)retval, rclass);
            if (callbacks.size() > 0) {
                mrb_value hash = mrb_iv_get(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"));
                if (!mrb_hash_p(hash)) {
                    hash = mrb_hash_new(mrb);
                }
                for (auto elm : callbacks) {
                    mrb_hash_set(mrb, hash, mrb_str_new_cstr(mrb, elm.first.c_str()), elm.second);
                    mrb_iv_set(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"), hash);
                }
            }
            g_rubyValue.push_back(ret);
            mrb_funcall(mrb, ret, "initialize", 0);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined static method : cocos2d::Show#create");

    return mrb_nil_value();
}

void ruby_register_cocos2dx_Show(mrb_state* mrb, struct RClass* rmodule)
{
    std::string typeName = typeid(cocos2d::Show).name();
    g_rubyType[typeName] = "CC::Show";
    g_rubyDataType[typeName] = &ruby_cocos2dx_Ref_type;

    struct RClass* p_rmodule = mrb->object_class;
    p_rmodule = mrb_module_get_under(mrb, p_rmodule, "CC");
    struct RClass* p_rclass = mrb_class_get_under(mrb, p_rmodule, "ActionInstant");
    struct RClass *rclass = mrb_define_class_under(mrb, rmodule, "Show", p_rclass);
    MRB_SET_INSTANCE_TT(rclass, MRB_TT_DATA);

    mrb_define_class_method(mrb, rclass, "create", ruby_cocos2dx_Show_create_static, ARGS_NONE());
}
mrb_value ruby_cocos2dx_Hide_create_static(mrb_state* mrb, mrb_value self)
{
    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            std::map<std::string, mrb_value> callbacks;
            cocos2d::Hide* retval = cocos2d::Hide::create();
            mrb_value ret;
            RClass* rclass = mrb_class_ptr(self);
            ret = object_to_rubyval<cocos2d::Hide>(mrb, "CC::Hide", (cocos2d::Hide*)retval, rclass);
            if (callbacks.size() > 0) {
                mrb_value hash = mrb_iv_get(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"));
                if (!mrb_hash_p(hash)) {
                    hash = mrb_hash_new(mrb);
                }
                for (auto elm : callbacks) {
                    mrb_hash_set(mrb, hash, mrb_str_new_cstr(mrb, elm.first.c_str()), elm.second);
                    mrb_iv_set(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"), hash);
                }
            }
            g_rubyValue.push_back(ret);
            mrb_funcall(mrb, ret, "initialize", 0);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined static method : cocos2d::Hide#create");

    return mrb_nil_value();
}

void ruby_register_cocos2dx_Hide(mrb_state* mrb, struct RClass* rmodule)
{
    std::string typeName = typeid(cocos2d::Hide).name();
    g_rubyType[typeName] = "CC::Hide";
    g_rubyDataType[typeName] = &ruby_cocos2dx_Ref_type;

    struct RClass* p_rmodule = mrb->object_class;
    p_rmodule = mrb_module_get_under(mrb, p_rmodule, "CC");
    struct RClass* p_rclass = mrb_class_get_under(mrb, p_rmodule, "ActionInstant");
    struct RClass *rclass = mrb_define_class_under(mrb, rmodule, "Hide", p_rclass);
    MRB_SET_INSTANCE_TT(rclass, MRB_TT_DATA);

    mrb_define_class_method(mrb, rclass, "create", ruby_cocos2dx_Hide_create_static, ARGS_NONE());
}
mrb_value ruby_cocos2dx_ToggleVisibility_create_static(mrb_state* mrb, mrb_value self)
{
    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            std::map<std::string, mrb_value> callbacks;
            cocos2d::ToggleVisibility* retval = cocos2d::ToggleVisibility::create();
            mrb_value ret;
            RClass* rclass = mrb_class_ptr(self);
            ret = object_to_rubyval<cocos2d::ToggleVisibility>(mrb, "CC::ToggleVisibility", (cocos2d::ToggleVisibility*)retval, rclass);
            if (callbacks.size() > 0) {
                mrb_value hash = mrb_iv_get(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"));
                if (!mrb_hash_p(hash)) {
                    hash = mrb_hash_new(mrb);
                }
                for (auto elm : callbacks) {
                    mrb_hash_set(mrb, hash, mrb_str_new_cstr(mrb, elm.first.c_str()), elm.second);
                    mrb_iv_set(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"), hash);
                }
            }
            g_rubyValue.push_back(ret);
            mrb_funcall(mrb, ret, "initialize", 0);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined static method : cocos2d::ToggleVisibility#create");

    return mrb_nil_value();
}

void ruby_register_cocos2dx_ToggleVisibility(mrb_state* mrb, struct RClass* rmodule)
{
    std::string typeName = typeid(cocos2d::ToggleVisibility).name();
    g_rubyType[typeName] = "CC::ToggleVisibility";
    g_rubyDataType[typeName] = &ruby_cocos2dx_Ref_type;

    struct RClass* p_rmodule = mrb->object_class;
    p_rmodule = mrb_module_get_under(mrb, p_rmodule, "CC");
    struct RClass* p_rclass = mrb_class_get_under(mrb, p_rmodule, "ActionInstant");
    struct RClass *rclass = mrb_define_class_under(mrb, rmodule, "ToggleVisibility", p_rclass);
    MRB_SET_INSTANCE_TT(rclass, MRB_TT_DATA);

    mrb_define_class_method(mrb, rclass, "create", ruby_cocos2dx_ToggleVisibility_create_static, ARGS_NONE());
}
mrb_value ruby_cocos2dx_RemoveSelf_create_static(mrb_state* mrb, mrb_value self)
{
    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 0) {
            std::map<std::string, mrb_value> callbacks;
            cocos2d::RemoveSelf* retval = cocos2d::RemoveSelf::create();
            mrb_value ret;
            RClass* rclass = mrb_class_ptr(self);
            ret = object_to_rubyval<cocos2d::RemoveSelf>(mrb, "CC::RemoveSelf", (cocos2d::RemoveSelf*)retval, rclass);
            if (callbacks.size() > 0) {
                mrb_value hash = mrb_iv_get(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"));
                if (!mrb_hash_p(hash)) {
                    hash = mrb_hash_new(mrb);
                }
                for (auto elm : callbacks) {
                    mrb_hash_set(mrb, hash, mrb_str_new_cstr(mrb, elm.first.c_str()), elm.second);
                    mrb_iv_set(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"), hash);
                }
            }
            g_rubyValue.push_back(ret);
            mrb_funcall(mrb, ret, "initialize", 0);
            return ret;
        }
    } while (0);
    do {
        if (argc == 1) {
            std::map<std::string, mrb_value> callbacks;
            bool arg0;
            ok = rubyval_to_boolean(mrb, argv[0], &arg0, "CC::RemoveSelf.create");
            if (!ok) { break; }

            cocos2d::RemoveSelf* retval = cocos2d::RemoveSelf::create(arg0);
            mrb_value ret;
            RClass* rclass = mrb_class_ptr(self);
            ret = object_to_rubyval<cocos2d::RemoveSelf>(mrb, "CC::RemoveSelf", (cocos2d::RemoveSelf*)retval, rclass);
            if (callbacks.size() > 0) {
                mrb_value hash = mrb_iv_get(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"));
                if (!mrb_hash_p(hash)) {
                    hash = mrb_hash_new(mrb);
                }
                for (auto elm : callbacks) {
                    mrb_hash_set(mrb, hash, mrb_str_new_cstr(mrb, elm.first.c_str()), elm.second);
                    mrb_iv_set(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"), hash);
                }
            }
            g_rubyValue.push_back(ret);
            mrb_funcall(mrb, ret, "initialize", 0);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined static method : cocos2d::RemoveSelf#create");

    return mrb_nil_value();
}

void ruby_register_cocos2dx_RemoveSelf(mrb_state* mrb, struct RClass* rmodule)
{
    std::string typeName = typeid(cocos2d::RemoveSelf).name();
    g_rubyType[typeName] = "CC::RemoveSelf";
    g_rubyDataType[typeName] = &ruby_cocos2dx_Ref_type;

    struct RClass* p_rmodule = mrb->object_class;
    p_rmodule = mrb_module_get_under(mrb, p_rmodule, "CC");
    struct RClass* p_rclass = mrb_class_get_under(mrb, p_rmodule, "ActionInstant");
    struct RClass *rclass = mrb_define_class_under(mrb, rmodule, "RemoveSelf", p_rclass);
    MRB_SET_INSTANCE_TT(rclass, MRB_TT_DATA);

    mrb_define_class_method(mrb, rclass, "create", ruby_cocos2dx_RemoveSelf_create_static, ARGS_REQ(1));
}
mrb_value ruby_cocos2dx_FlipX_create_static(mrb_state* mrb, mrb_value self)
{
    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            std::map<std::string, mrb_value> callbacks;
            bool arg0;
            ok = rubyval_to_boolean(mrb, argv[0], &arg0, "CC::FlipX.create");
            if (!ok) { break; }

            cocos2d::FlipX* retval = cocos2d::FlipX::create(arg0);
            mrb_value ret;
            RClass* rclass = mrb_class_ptr(self);
            ret = object_to_rubyval<cocos2d::FlipX>(mrb, "CC::FlipX", (cocos2d::FlipX*)retval, rclass);
            if (callbacks.size() > 0) {
                mrb_value hash = mrb_iv_get(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"));
                if (!mrb_hash_p(hash)) {
                    hash = mrb_hash_new(mrb);
                }
                for (auto elm : callbacks) {
                    mrb_hash_set(mrb, hash, mrb_str_new_cstr(mrb, elm.first.c_str()), elm.second);
                    mrb_iv_set(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"), hash);
                }
            }
            g_rubyValue.push_back(ret);
            mrb_funcall(mrb, ret, "initialize", 0);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined static method : cocos2d::FlipX#create");

    return mrb_nil_value();
}

void ruby_register_cocos2dx_FlipX(mrb_state* mrb, struct RClass* rmodule)
{
    std::string typeName = typeid(cocos2d::FlipX).name();
    g_rubyType[typeName] = "CC::FlipX";
    g_rubyDataType[typeName] = &ruby_cocos2dx_Ref_type;

    struct RClass* p_rmodule = mrb->object_class;
    p_rmodule = mrb_module_get_under(mrb, p_rmodule, "CC");
    struct RClass* p_rclass = mrb_class_get_under(mrb, p_rmodule, "ActionInstant");
    struct RClass *rclass = mrb_define_class_under(mrb, rmodule, "FlipX", p_rclass);
    MRB_SET_INSTANCE_TT(rclass, MRB_TT_DATA);

    mrb_define_class_method(mrb, rclass, "create", ruby_cocos2dx_FlipX_create_static, ARGS_REQ(1));
}
mrb_value ruby_cocos2dx_FlipY_create_static(mrb_state* mrb, mrb_value self)
{
    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            std::map<std::string, mrb_value> callbacks;
            bool arg0;
            ok = rubyval_to_boolean(mrb, argv[0], &arg0, "CC::FlipY.create");
            if (!ok) { break; }

            cocos2d::FlipY* retval = cocos2d::FlipY::create(arg0);
            mrb_value ret;
            RClass* rclass = mrb_class_ptr(self);
            ret = object_to_rubyval<cocos2d::FlipY>(mrb, "CC::FlipY", (cocos2d::FlipY*)retval, rclass);
            if (callbacks.size() > 0) {
                mrb_value hash = mrb_iv_get(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"));
                if (!mrb_hash_p(hash)) {
                    hash = mrb_hash_new(mrb);
                }
                for (auto elm : callbacks) {
                    mrb_hash_set(mrb, hash, mrb_str_new_cstr(mrb, elm.first.c_str()), elm.second);
                    mrb_iv_set(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"), hash);
                }
            }
            g_rubyValue.push_back(ret);
            mrb_funcall(mrb, ret, "initialize", 0);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined static method : cocos2d::FlipY#create");

    return mrb_nil_value();
}

void ruby_register_cocos2dx_FlipY(mrb_state* mrb, struct RClass* rmodule)
{
    std::string typeName = typeid(cocos2d::FlipY).name();
    g_rubyType[typeName] = "CC::FlipY";
    g_rubyDataType[typeName] = &ruby_cocos2dx_Ref_type;

    struct RClass* p_rmodule = mrb->object_class;
    p_rmodule = mrb_module_get_under(mrb, p_rmodule, "CC");
    struct RClass* p_rclass = mrb_class_get_under(mrb, p_rmodule, "ActionInstant");
    struct RClass *rclass = mrb_define_class_under(mrb, rmodule, "FlipY", p_rclass);
    MRB_SET_INSTANCE_TT(rclass, MRB_TT_DATA);

    mrb_define_class_method(mrb, rclass, "create", ruby_cocos2dx_FlipY_create_static, ARGS_REQ(1));
}
mrb_value ruby_cocos2dx_Place_create_static(mrb_state* mrb, mrb_value self)
{
    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            std::map<std::string, mrb_value> callbacks;
            cocos2d::Vec2* arg0;
            ok = rubyval_to_object<cocos2d::Vec2>(mrb, argv[0], "CC::Vec2", &arg0);
            if (!ok) { break; }

            cocos2d::Place* retval = cocos2d::Place::create(*arg0);
            mrb_value ret;
            RClass* rclass = mrb_class_ptr(self);
            ret = object_to_rubyval<cocos2d::Place>(mrb, "CC::Place", (cocos2d::Place*)retval, rclass);
            if (callbacks.size() > 0) {
                mrb_value hash = mrb_iv_get(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"));
                if (!mrb_hash_p(hash)) {
                    hash = mrb_hash_new(mrb);
                }
                for (auto elm : callbacks) {
                    mrb_hash_set(mrb, hash, mrb_str_new_cstr(mrb, elm.first.c_str()), elm.second);
                    mrb_iv_set(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"), hash);
                }
            }
            g_rubyValue.push_back(ret);
            mrb_funcall(mrb, ret, "initialize", 0);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined static method : cocos2d::Place#create");

    return mrb_nil_value();
}

void ruby_register_cocos2dx_Place(mrb_state* mrb, struct RClass* rmodule)
{
    std::string typeName = typeid(cocos2d::Place).name();
    g_rubyType[typeName] = "CC::Place";
    g_rubyDataType[typeName] = &ruby_cocos2dx_Ref_type;

    struct RClass* p_rmodule = mrb->object_class;
    p_rmodule = mrb_module_get_under(mrb, p_rmodule, "CC");
    struct RClass* p_rclass = mrb_class_get_under(mrb, p_rmodule, "ActionInstant");
    struct RClass *rclass = mrb_define_class_under(mrb, rmodule, "Place", p_rclass);
    MRB_SET_INSTANCE_TT(rclass, MRB_TT_DATA);

    mrb_define_class_method(mrb, rclass, "create", ruby_cocos2dx_Place_create_static, ARGS_REQ(1));
}
mrb_value ruby_cocos2dx_CallFunc_execute(mrb_state* mrb, mrb_value self)
{
    cocos2d::CallFunc* cobj = static_cast<cocos2d::CallFunc*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            cobj->execute();
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::CallFunc#execute");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_CallFunc_getTargetCallback(mrb_state* mrb, mrb_value self)
{
    cocos2d::CallFunc* cobj = static_cast<cocos2d::CallFunc*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            cocos2d::Ref* retval = cobj->getTargetCallback();
            mrb_value ret;
            ret = object_to_rubyval<cocos2d::Ref>(mrb, "CC::Ref", (cocos2d::Ref*)retval, nullptr);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::CallFunc#getTargetCallback");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_CallFunc_setTargetCallback(mrb_state* mrb, mrb_value self)
{
    cocos2d::CallFunc* cobj = static_cast<cocos2d::CallFunc*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            cocos2d::Ref* arg0;
            ok = rubyval_to_object<cocos2d::Ref>(mrb, argv[0], "CC::Ref", &arg0);
            if (!ok) { break; }
            cobj->setTargetCallback(arg0);
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::CallFunc#setTargetCallback");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_CallFunc_create_static(mrb_state* mrb, mrb_value self)
{
    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            std::map<std::string, mrb_value> callbacks;
            std::function<void ()> arg0;
            do {
			    // Lambda binding for ruby.
			    unsigned long idx = g_rubyValue.size();
			    arg0 = [mrb, self, idx]() -> void {
			        mrb_value _self = g_rubyValue[idx];
			        mrb_value hash = mrb_iv_get(mrb, _self, mrb_intern_cstr(mrb, "__callback_hash"));
			        mrb_value func = mrb_hash_get(mrb, hash, mrb_str_new_cstr(mrb, "create->arg0"));
			        mrb_value mrb_ret = mrb_funcall(mrb, func, "call", 0);
			        if (mrb_exception_p(mrb_ret)) {
			            mrb_exc_raise(mrb, mrb_ret);
			        }
			    };
			    callbacks["create->arg0"] = argv[0];
			    break;
			} while(0);
            if (!ok) { break; }

            cocos2d::CallFunc* retval = cocos2d::CallFunc::create(arg0);
            mrb_value ret;
            RClass* rclass = mrb_class_ptr(self);
            ret = object_to_rubyval<cocos2d::CallFunc>(mrb, "CC::CallFunc", (cocos2d::CallFunc*)retval, rclass);
            if (callbacks.size() > 0) {
                mrb_value hash = mrb_iv_get(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"));
                if (!mrb_hash_p(hash)) {
                    hash = mrb_hash_new(mrb);
                }
                for (auto elm : callbacks) {
                    mrb_hash_set(mrb, hash, mrb_str_new_cstr(mrb, elm.first.c_str()), elm.second);
                    mrb_iv_set(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"), hash);
                }
            }
            g_rubyValue.push_back(ret);
            mrb_funcall(mrb, ret, "initialize", 0);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined static method : cocos2d::CallFunc#create");

    return mrb_nil_value();
}

void ruby_register_cocos2dx_CallFunc(mrb_state* mrb, struct RClass* rmodule)
{
    std::string typeName = typeid(cocos2d::CallFunc).name();
    g_rubyType[typeName] = "CC::CallFunc";
    g_rubyDataType[typeName] = &ruby_cocos2dx_Ref_type;

    struct RClass* p_rmodule = mrb->object_class;
    p_rmodule = mrb_module_get_under(mrb, p_rmodule, "CC");
    struct RClass* p_rclass = mrb_class_get_under(mrb, p_rmodule, "ActionInstant");
    struct RClass *rclass = mrb_define_class_under(mrb, rmodule, "CallFunc", p_rclass);
    MRB_SET_INSTANCE_TT(rclass, MRB_TT_DATA);

    mrb_define_method(mrb, rclass, "execute", ruby_cocos2dx_CallFunc_execute, ARGS_NONE());
    mrb_define_method(mrb, rclass, "get_target_callback", ruby_cocos2dx_CallFunc_getTargetCallback, ARGS_NONE());
    mrb_define_method(mrb, rclass, "set_target_callback", ruby_cocos2dx_CallFunc_setTargetCallback, ARGS_REQ(1));
    mrb_define_class_method(mrb, rclass, "create", ruby_cocos2dx_CallFunc_create_static, ARGS_REQ(1));
}
mrb_value ruby_cocos2dx_GridAction_getGrid(mrb_state* mrb, mrb_value self)
{
    cocos2d::GridAction* cobj = static_cast<cocos2d::GridAction*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            cocos2d::GridBase* retval = cobj->getGrid();
            mrb_value ret;
            ret = object_to_rubyval<cocos2d::GridBase>(mrb, "CC::GridBase", (cocos2d::GridBase*)retval, nullptr);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::GridAction#getGrid");

    return mrb_nil_value();
}

void ruby_register_cocos2dx_GridAction(mrb_state* mrb, struct RClass* rmodule)
{
    std::string typeName = typeid(cocos2d::GridAction).name();
    g_rubyType[typeName] = "CC::GridAction";
    g_rubyDataType[typeName] = &ruby_cocos2dx_Ref_type;

    struct RClass* p_rmodule = mrb->object_class;
    p_rmodule = mrb_module_get_under(mrb, p_rmodule, "CC");
    struct RClass* p_rclass = mrb_class_get_under(mrb, p_rmodule, "ActionInterval");
    struct RClass *rclass = mrb_define_class_under(mrb, rmodule, "GridAction", p_rclass);
    MRB_SET_INSTANCE_TT(rclass, MRB_TT_DATA);

    mrb_define_method(mrb, rclass, "get_grid", ruby_cocos2dx_GridAction_getGrid, ARGS_NONE());
}
mrb_value ruby_cocos2dx_Grid3DAction_getGrid(mrb_state* mrb, mrb_value self)
{
    cocos2d::Grid3DAction* cobj = static_cast<cocos2d::Grid3DAction*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            cocos2d::GridBase* retval = cobj->getGrid();
            mrb_value ret;
            ret = object_to_rubyval<cocos2d::GridBase>(mrb, "CC::GridBase", (cocos2d::GridBase*)retval, nullptr);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::Grid3DAction#getGrid");

    return mrb_nil_value();
}

void ruby_register_cocos2dx_Grid3DAction(mrb_state* mrb, struct RClass* rmodule)
{
    std::string typeName = typeid(cocos2d::Grid3DAction).name();
    g_rubyType[typeName] = "CC::Grid3DAction";
    g_rubyDataType[typeName] = &ruby_cocos2dx_Ref_type;

    struct RClass* p_rmodule = mrb->object_class;
    p_rmodule = mrb_module_get_under(mrb, p_rmodule, "CC");
    struct RClass* p_rclass = mrb_class_get_under(mrb, p_rmodule, "GridAction");
    struct RClass *rclass = mrb_define_class_under(mrb, rmodule, "Grid3DAction", p_rclass);
    MRB_SET_INSTANCE_TT(rclass, MRB_TT_DATA);

    mrb_define_method(mrb, rclass, "get_grid", ruby_cocos2dx_Grid3DAction_getGrid, ARGS_NONE());
}
mrb_value ruby_cocos2dx_TiledGrid3DAction_getGrid(mrb_state* mrb, mrb_value self)
{
    cocos2d::TiledGrid3DAction* cobj = static_cast<cocos2d::TiledGrid3DAction*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            cocos2d::GridBase* retval = cobj->getGrid();
            mrb_value ret;
            ret = object_to_rubyval<cocos2d::GridBase>(mrb, "CC::GridBase", (cocos2d::GridBase*)retval, nullptr);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::TiledGrid3DAction#getGrid");

    return mrb_nil_value();
}

void ruby_register_cocos2dx_TiledGrid3DAction(mrb_state* mrb, struct RClass* rmodule)
{
    std::string typeName = typeid(cocos2d::TiledGrid3DAction).name();
    g_rubyType[typeName] = "CC::TiledGrid3DAction";
    g_rubyDataType[typeName] = &ruby_cocos2dx_Ref_type;

    struct RClass* p_rmodule = mrb->object_class;
    p_rmodule = mrb_module_get_under(mrb, p_rmodule, "CC");
    struct RClass* p_rclass = mrb_class_get_under(mrb, p_rmodule, "GridAction");
    struct RClass *rclass = mrb_define_class_under(mrb, rmodule, "TiledGrid3DAction", p_rclass);
    MRB_SET_INSTANCE_TT(rclass, MRB_TT_DATA);

    mrb_define_method(mrb, rclass, "get_grid", ruby_cocos2dx_TiledGrid3DAction_getGrid, ARGS_NONE());
}
mrb_value ruby_cocos2dx_StopGrid_create_static(mrb_state* mrb, mrb_value self)
{
    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            std::map<std::string, mrb_value> callbacks;
            cocos2d::StopGrid* retval = cocos2d::StopGrid::create();
            mrb_value ret;
            RClass* rclass = mrb_class_ptr(self);
            ret = object_to_rubyval<cocos2d::StopGrid>(mrb, "CC::StopGrid", (cocos2d::StopGrid*)retval, rclass);
            if (callbacks.size() > 0) {
                mrb_value hash = mrb_iv_get(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"));
                if (!mrb_hash_p(hash)) {
                    hash = mrb_hash_new(mrb);
                }
                for (auto elm : callbacks) {
                    mrb_hash_set(mrb, hash, mrb_str_new_cstr(mrb, elm.first.c_str()), elm.second);
                    mrb_iv_set(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"), hash);
                }
            }
            g_rubyValue.push_back(ret);
            mrb_funcall(mrb, ret, "initialize", 0);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined static method : cocos2d::StopGrid#create");

    return mrb_nil_value();
}

void ruby_register_cocos2dx_StopGrid(mrb_state* mrb, struct RClass* rmodule)
{
    std::string typeName = typeid(cocos2d::StopGrid).name();
    g_rubyType[typeName] = "CC::StopGrid";
    g_rubyDataType[typeName] = &ruby_cocos2dx_Ref_type;

    struct RClass* p_rmodule = mrb->object_class;
    p_rmodule = mrb_module_get_under(mrb, p_rmodule, "CC");
    struct RClass* p_rclass = mrb_class_get_under(mrb, p_rmodule, "ActionInstant");
    struct RClass *rclass = mrb_define_class_under(mrb, rmodule, "StopGrid", p_rclass);
    MRB_SET_INSTANCE_TT(rclass, MRB_TT_DATA);

    mrb_define_class_method(mrb, rclass, "create", ruby_cocos2dx_StopGrid_create_static, ARGS_NONE());
}
mrb_value ruby_cocos2dx_ReuseGrid_create_static(mrb_state* mrb, mrb_value self)
{
    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            std::map<std::string, mrb_value> callbacks;
            int arg0;
            ok = rubyval_to_int32(mrb, argv[0], (int*)&arg0, "CC::ReuseGrid.create");
            if (!ok) { break; }

            cocos2d::ReuseGrid* retval = cocos2d::ReuseGrid::create(arg0);
            mrb_value ret;
            RClass* rclass = mrb_class_ptr(self);
            ret = object_to_rubyval<cocos2d::ReuseGrid>(mrb, "CC::ReuseGrid", (cocos2d::ReuseGrid*)retval, rclass);
            if (callbacks.size() > 0) {
                mrb_value hash = mrb_iv_get(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"));
                if (!mrb_hash_p(hash)) {
                    hash = mrb_hash_new(mrb);
                }
                for (auto elm : callbacks) {
                    mrb_hash_set(mrb, hash, mrb_str_new_cstr(mrb, elm.first.c_str()), elm.second);
                    mrb_iv_set(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"), hash);
                }
            }
            g_rubyValue.push_back(ret);
            mrb_funcall(mrb, ret, "initialize", 0);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined static method : cocos2d::ReuseGrid#create");

    return mrb_nil_value();
}

void ruby_register_cocos2dx_ReuseGrid(mrb_state* mrb, struct RClass* rmodule)
{
    std::string typeName = typeid(cocos2d::ReuseGrid).name();
    g_rubyType[typeName] = "CC::ReuseGrid";
    g_rubyDataType[typeName] = &ruby_cocos2dx_Ref_type;

    struct RClass* p_rmodule = mrb->object_class;
    p_rmodule = mrb_module_get_under(mrb, p_rmodule, "CC");
    struct RClass* p_rclass = mrb_class_get_under(mrb, p_rmodule, "ActionInstant");
    struct RClass *rclass = mrb_define_class_under(mrb, rmodule, "ReuseGrid", p_rclass);
    MRB_SET_INSTANCE_TT(rclass, MRB_TT_DATA);

    mrb_define_class_method(mrb, rclass, "create", ruby_cocos2dx_ReuseGrid_create_static, ARGS_REQ(1));
}
mrb_value ruby_cocos2dx_Waves3D_getAmplitudeRate(mrb_state* mrb, mrb_value self)
{
    cocos2d::Waves3D* cobj = static_cast<cocos2d::Waves3D*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            double retval = cobj->getAmplitudeRate();
            mrb_value ret;
            ret = mrb_float_value(mrb, (mrb_float)retval);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::Waves3D#getAmplitudeRate");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Waves3D_setAmplitude(mrb_state* mrb, mrb_value self)
{
    cocos2d::Waves3D* cobj = static_cast<cocos2d::Waves3D*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            double arg0;
            ok = rubyval_to_number(mrb, argv[0], (double*)&arg0, "CC::Waves3D.setAmplitude");
            if (!ok) { break; }
            cobj->setAmplitude(arg0);
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::Waves3D#setAmplitude");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Waves3D_setAmplitudeRate(mrb_state* mrb, mrb_value self)
{
    cocos2d::Waves3D* cobj = static_cast<cocos2d::Waves3D*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            double arg0;
            ok = rubyval_to_number(mrb, argv[0], (double*)&arg0, "CC::Waves3D.setAmplitudeRate");
            if (!ok) { break; }
            cobj->setAmplitudeRate(arg0);
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::Waves3D#setAmplitudeRate");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Waves3D_getAmplitude(mrb_state* mrb, mrb_value self)
{
    cocos2d::Waves3D* cobj = static_cast<cocos2d::Waves3D*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            double retval = cobj->getAmplitude();
            mrb_value ret;
            ret = mrb_float_value(mrb, (mrb_float)retval);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::Waves3D#getAmplitude");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Waves3D_create_static(mrb_state* mrb, mrb_value self)
{
    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 4) {
            std::map<std::string, mrb_value> callbacks;
            double arg0;
            ok = rubyval_to_number(mrb, argv[0], (double*)&arg0, "CC::Waves3D.create");
            if (!ok) { break; }

            cocos2d::Size* arg1;
            ok = rubyval_to_object<cocos2d::Size>(mrb, argv[1], "CC::Size", &arg1);
            if (!ok) { break; }

            unsigned int arg2;
            ok = rubyval_to_uint32(mrb, argv[2], &arg2, "CC::Waves3D.create");
            if (!ok) { break; }

            double arg3;
            ok = rubyval_to_number(mrb, argv[3], (double*)&arg3, "CC::Waves3D.create");
            if (!ok) { break; }

            cocos2d::Waves3D* retval = cocos2d::Waves3D::create(arg0, *arg1, arg2, arg3);
            mrb_value ret;
            RClass* rclass = mrb_class_ptr(self);
            ret = object_to_rubyval<cocos2d::Waves3D>(mrb, "CC::Waves3D", (cocos2d::Waves3D*)retval, rclass);
            if (callbacks.size() > 0) {
                mrb_value hash = mrb_iv_get(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"));
                if (!mrb_hash_p(hash)) {
                    hash = mrb_hash_new(mrb);
                }
                for (auto elm : callbacks) {
                    mrb_hash_set(mrb, hash, mrb_str_new_cstr(mrb, elm.first.c_str()), elm.second);
                    mrb_iv_set(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"), hash);
                }
            }
            g_rubyValue.push_back(ret);
            mrb_funcall(mrb, ret, "initialize", 0);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined static method : cocos2d::Waves3D#create");

    return mrb_nil_value();
}

void ruby_register_cocos2dx_Waves3D(mrb_state* mrb, struct RClass* rmodule)
{
    std::string typeName = typeid(cocos2d::Waves3D).name();
    g_rubyType[typeName] = "CC::Waves3D";
    g_rubyDataType[typeName] = &ruby_cocos2dx_Ref_type;

    struct RClass* p_rmodule = mrb->object_class;
    p_rmodule = mrb_module_get_under(mrb, p_rmodule, "CC");
    struct RClass* p_rclass = mrb_class_get_under(mrb, p_rmodule, "Grid3DAction");
    struct RClass *rclass = mrb_define_class_under(mrb, rmodule, "Waves3D", p_rclass);
    MRB_SET_INSTANCE_TT(rclass, MRB_TT_DATA);

    mrb_define_method(mrb, rclass, "get_amplitude_rate", ruby_cocos2dx_Waves3D_getAmplitudeRate, ARGS_NONE());
    mrb_define_method(mrb, rclass, "set_amplitude", ruby_cocos2dx_Waves3D_setAmplitude, ARGS_REQ(1));
    mrb_define_method(mrb, rclass, "set_amplitude_rate", ruby_cocos2dx_Waves3D_setAmplitudeRate, ARGS_REQ(1));
    mrb_define_method(mrb, rclass, "get_amplitude", ruby_cocos2dx_Waves3D_getAmplitude, ARGS_NONE());
    mrb_define_class_method(mrb, rclass, "create", ruby_cocos2dx_Waves3D_create_static, ARGS_REQ(4));
}
mrb_value ruby_cocos2dx_FlipX3D_create_static(mrb_state* mrb, mrb_value self)
{
    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            std::map<std::string, mrb_value> callbacks;
            double arg0;
            ok = rubyval_to_number(mrb, argv[0], (double*)&arg0, "CC::FlipX3D.create");
            if (!ok) { break; }

            cocos2d::FlipX3D* retval = cocos2d::FlipX3D::create(arg0);
            mrb_value ret;
            RClass* rclass = mrb_class_ptr(self);
            ret = object_to_rubyval<cocos2d::FlipX3D>(mrb, "CC::FlipX3D", (cocos2d::FlipX3D*)retval, rclass);
            if (callbacks.size() > 0) {
                mrb_value hash = mrb_iv_get(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"));
                if (!mrb_hash_p(hash)) {
                    hash = mrb_hash_new(mrb);
                }
                for (auto elm : callbacks) {
                    mrb_hash_set(mrb, hash, mrb_str_new_cstr(mrb, elm.first.c_str()), elm.second);
                    mrb_iv_set(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"), hash);
                }
            }
            g_rubyValue.push_back(ret);
            mrb_funcall(mrb, ret, "initialize", 0);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined static method : cocos2d::FlipX3D#create");

    return mrb_nil_value();
}

void ruby_register_cocos2dx_FlipX3D(mrb_state* mrb, struct RClass* rmodule)
{
    std::string typeName = typeid(cocos2d::FlipX3D).name();
    g_rubyType[typeName] = "CC::FlipX3D";
    g_rubyDataType[typeName] = &ruby_cocos2dx_Ref_type;

    struct RClass* p_rmodule = mrb->object_class;
    p_rmodule = mrb_module_get_under(mrb, p_rmodule, "CC");
    struct RClass* p_rclass = mrb_class_get_under(mrb, p_rmodule, "Grid3DAction");
    struct RClass *rclass = mrb_define_class_under(mrb, rmodule, "FlipX3D", p_rclass);
    MRB_SET_INSTANCE_TT(rclass, MRB_TT_DATA);

    mrb_define_class_method(mrb, rclass, "create", ruby_cocos2dx_FlipX3D_create_static, ARGS_REQ(1));
}
mrb_value ruby_cocos2dx_FlipY3D_create_static(mrb_state* mrb, mrb_value self)
{
    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            std::map<std::string, mrb_value> callbacks;
            double arg0;
            ok = rubyval_to_number(mrb, argv[0], (double*)&arg0, "CC::FlipY3D.create");
            if (!ok) { break; }

            cocos2d::FlipY3D* retval = cocos2d::FlipY3D::create(arg0);
            mrb_value ret;
            RClass* rclass = mrb_class_ptr(self);
            ret = object_to_rubyval<cocos2d::FlipY3D>(mrb, "CC::FlipY3D", (cocos2d::FlipY3D*)retval, rclass);
            if (callbacks.size() > 0) {
                mrb_value hash = mrb_iv_get(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"));
                if (!mrb_hash_p(hash)) {
                    hash = mrb_hash_new(mrb);
                }
                for (auto elm : callbacks) {
                    mrb_hash_set(mrb, hash, mrb_str_new_cstr(mrb, elm.first.c_str()), elm.second);
                    mrb_iv_set(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"), hash);
                }
            }
            g_rubyValue.push_back(ret);
            mrb_funcall(mrb, ret, "initialize", 0);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined static method : cocos2d::FlipY3D#create");

    return mrb_nil_value();
}

void ruby_register_cocos2dx_FlipY3D(mrb_state* mrb, struct RClass* rmodule)
{
    std::string typeName = typeid(cocos2d::FlipY3D).name();
    g_rubyType[typeName] = "CC::FlipY3D";
    g_rubyDataType[typeName] = &ruby_cocos2dx_Ref_type;

    struct RClass* p_rmodule = mrb->object_class;
    p_rmodule = mrb_module_get_under(mrb, p_rmodule, "CC");
    struct RClass* p_rclass = mrb_class_get_under(mrb, p_rmodule, "FlipX3D");
    struct RClass *rclass = mrb_define_class_under(mrb, rmodule, "FlipY3D", p_rclass);
    MRB_SET_INSTANCE_TT(rclass, MRB_TT_DATA);

    mrb_define_class_method(mrb, rclass, "create", ruby_cocos2dx_FlipY3D_create_static, ARGS_REQ(1));
}
mrb_value ruby_cocos2dx_Lens3D_setPosition(mrb_state* mrb, mrb_value self)
{
    cocos2d::Lens3D* cobj = static_cast<cocos2d::Lens3D*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            cocos2d::Vec2* arg0;
            ok = rubyval_to_object<cocos2d::Vec2>(mrb, argv[0], "CC::Vec2", &arg0);
            if (!ok) { break; }
            cobj->setPosition(*arg0);
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::Lens3D#setPosition");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Lens3D_setConcave(mrb_state* mrb, mrb_value self)
{
    cocos2d::Lens3D* cobj = static_cast<cocos2d::Lens3D*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            bool arg0;
            ok = rubyval_to_boolean(mrb, argv[0], &arg0, "CC::Lens3D.setConcave");
            if (!ok) { break; }
            cobj->setConcave(arg0);
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::Lens3D#setConcave");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Lens3D_setLensEffect(mrb_state* mrb, mrb_value self)
{
    cocos2d::Lens3D* cobj = static_cast<cocos2d::Lens3D*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            double arg0;
            ok = rubyval_to_number(mrb, argv[0], (double*)&arg0, "CC::Lens3D.setLensEffect");
            if (!ok) { break; }
            cobj->setLensEffect(arg0);
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::Lens3D#setLensEffect");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Lens3D_getPosition(mrb_state* mrb, mrb_value self)
{
    cocos2d::Lens3D* cobj = static_cast<cocos2d::Lens3D*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            cocos2d::Vec2 retval = cobj->getPosition();
            cocos2d::Vec2* retval_ptr = new cocos2d::Vec2(retval);
            mrb_value ret;
            ret = object_to_rubyval<cocos2d::Vec2>(mrb, "CC::Vec2", (cocos2d::Vec2*)retval_ptr, nullptr);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::Lens3D#getPosition");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Lens3D_getLensEffect(mrb_state* mrb, mrb_value self)
{
    cocos2d::Lens3D* cobj = static_cast<cocos2d::Lens3D*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            double retval = cobj->getLensEffect();
            mrb_value ret;
            ret = mrb_float_value(mrb, (mrb_float)retval);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::Lens3D#getLensEffect");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Lens3D_create_static(mrb_state* mrb, mrb_value self)
{
    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 4) {
            std::map<std::string, mrb_value> callbacks;
            double arg0;
            ok = rubyval_to_number(mrb, argv[0], (double*)&arg0, "CC::Lens3D.create");
            if (!ok) { break; }

            cocos2d::Size* arg1;
            ok = rubyval_to_object<cocos2d::Size>(mrb, argv[1], "CC::Size", &arg1);
            if (!ok) { break; }

            cocos2d::Vec2* arg2;
            ok = rubyval_to_object<cocos2d::Vec2>(mrb, argv[2], "CC::Vec2", &arg2);
            if (!ok) { break; }

            double arg3;
            ok = rubyval_to_number(mrb, argv[3], (double*)&arg3, "CC::Lens3D.create");
            if (!ok) { break; }

            cocos2d::Lens3D* retval = cocos2d::Lens3D::create(arg0, *arg1, *arg2, arg3);
            mrb_value ret;
            RClass* rclass = mrb_class_ptr(self);
            ret = object_to_rubyval<cocos2d::Lens3D>(mrb, "CC::Lens3D", (cocos2d::Lens3D*)retval, rclass);
            if (callbacks.size() > 0) {
                mrb_value hash = mrb_iv_get(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"));
                if (!mrb_hash_p(hash)) {
                    hash = mrb_hash_new(mrb);
                }
                for (auto elm : callbacks) {
                    mrb_hash_set(mrb, hash, mrb_str_new_cstr(mrb, elm.first.c_str()), elm.second);
                    mrb_iv_set(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"), hash);
                }
            }
            g_rubyValue.push_back(ret);
            mrb_funcall(mrb, ret, "initialize", 0);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined static method : cocos2d::Lens3D#create");

    return mrb_nil_value();
}

void ruby_register_cocos2dx_Lens3D(mrb_state* mrb, struct RClass* rmodule)
{
    std::string typeName = typeid(cocos2d::Lens3D).name();
    g_rubyType[typeName] = "CC::Lens3D";
    g_rubyDataType[typeName] = &ruby_cocos2dx_Ref_type;

    struct RClass* p_rmodule = mrb->object_class;
    p_rmodule = mrb_module_get_under(mrb, p_rmodule, "CC");
    struct RClass* p_rclass = mrb_class_get_under(mrb, p_rmodule, "Grid3DAction");
    struct RClass *rclass = mrb_define_class_under(mrb, rmodule, "Lens3D", p_rclass);
    MRB_SET_INSTANCE_TT(rclass, MRB_TT_DATA);

    mrb_define_method(mrb, rclass, "set_position", ruby_cocos2dx_Lens3D_setPosition, ARGS_REQ(1));
    mrb_define_method(mrb, rclass, "set_concave", ruby_cocos2dx_Lens3D_setConcave, ARGS_REQ(1));
    mrb_define_method(mrb, rclass, "set_lens_effect", ruby_cocos2dx_Lens3D_setLensEffect, ARGS_REQ(1));
    mrb_define_method(mrb, rclass, "get_position", ruby_cocos2dx_Lens3D_getPosition, ARGS_NONE());
    mrb_define_method(mrb, rclass, "get_lens_effect", ruby_cocos2dx_Lens3D_getLensEffect, ARGS_NONE());
    mrb_define_class_method(mrb, rclass, "create", ruby_cocos2dx_Lens3D_create_static, ARGS_REQ(4));
}
mrb_value ruby_cocos2dx_Ripple3D_setAmplitudeRate(mrb_state* mrb, mrb_value self)
{
    cocos2d::Ripple3D* cobj = static_cast<cocos2d::Ripple3D*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            double arg0;
            ok = rubyval_to_number(mrb, argv[0], (double*)&arg0, "CC::Ripple3D.setAmplitudeRate");
            if (!ok) { break; }
            cobj->setAmplitudeRate(arg0);
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::Ripple3D#setAmplitudeRate");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Ripple3D_getAmplitudeRate(mrb_state* mrb, mrb_value self)
{
    cocos2d::Ripple3D* cobj = static_cast<cocos2d::Ripple3D*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            double retval = cobj->getAmplitudeRate();
            mrb_value ret;
            ret = mrb_float_value(mrb, (mrb_float)retval);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::Ripple3D#getAmplitudeRate");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Ripple3D_setAmplitude(mrb_state* mrb, mrb_value self)
{
    cocos2d::Ripple3D* cobj = static_cast<cocos2d::Ripple3D*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            double arg0;
            ok = rubyval_to_number(mrb, argv[0], (double*)&arg0, "CC::Ripple3D.setAmplitude");
            if (!ok) { break; }
            cobj->setAmplitude(arg0);
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::Ripple3D#setAmplitude");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Ripple3D_getAmplitude(mrb_state* mrb, mrb_value self)
{
    cocos2d::Ripple3D* cobj = static_cast<cocos2d::Ripple3D*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            double retval = cobj->getAmplitude();
            mrb_value ret;
            ret = mrb_float_value(mrb, (mrb_float)retval);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::Ripple3D#getAmplitude");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Ripple3D_setPosition(mrb_state* mrb, mrb_value self)
{
    cocos2d::Ripple3D* cobj = static_cast<cocos2d::Ripple3D*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            cocos2d::Vec2* arg0;
            ok = rubyval_to_object<cocos2d::Vec2>(mrb, argv[0], "CC::Vec2", &arg0);
            if (!ok) { break; }
            cobj->setPosition(*arg0);
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::Ripple3D#setPosition");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Ripple3D_getPosition(mrb_state* mrb, mrb_value self)
{
    cocos2d::Ripple3D* cobj = static_cast<cocos2d::Ripple3D*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            cocos2d::Vec2 retval = cobj->getPosition();
            cocos2d::Vec2* retval_ptr = new cocos2d::Vec2(retval);
            mrb_value ret;
            ret = object_to_rubyval<cocos2d::Vec2>(mrb, "CC::Vec2", (cocos2d::Vec2*)retval_ptr, nullptr);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::Ripple3D#getPosition");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Ripple3D_create_static(mrb_state* mrb, mrb_value self)
{
    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 6) {
            std::map<std::string, mrb_value> callbacks;
            double arg0;
            ok = rubyval_to_number(mrb, argv[0], (double*)&arg0, "CC::Ripple3D.create");
            if (!ok) { break; }

            cocos2d::Size* arg1;
            ok = rubyval_to_object<cocos2d::Size>(mrb, argv[1], "CC::Size", &arg1);
            if (!ok) { break; }

            cocos2d::Vec2* arg2;
            ok = rubyval_to_object<cocos2d::Vec2>(mrb, argv[2], "CC::Vec2", &arg2);
            if (!ok) { break; }

            double arg3;
            ok = rubyval_to_number(mrb, argv[3], (double*)&arg3, "CC::Ripple3D.create");
            if (!ok) { break; }

            unsigned int arg4;
            ok = rubyval_to_uint32(mrb, argv[4], &arg4, "CC::Ripple3D.create");
            if (!ok) { break; }

            double arg5;
            ok = rubyval_to_number(mrb, argv[5], (double*)&arg5, "CC::Ripple3D.create");
            if (!ok) { break; }

            cocos2d::Ripple3D* retval = cocos2d::Ripple3D::create(arg0, *arg1, *arg2, arg3, arg4, arg5);
            mrb_value ret;
            RClass* rclass = mrb_class_ptr(self);
            ret = object_to_rubyval<cocos2d::Ripple3D>(mrb, "CC::Ripple3D", (cocos2d::Ripple3D*)retval, rclass);
            if (callbacks.size() > 0) {
                mrb_value hash = mrb_iv_get(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"));
                if (!mrb_hash_p(hash)) {
                    hash = mrb_hash_new(mrb);
                }
                for (auto elm : callbacks) {
                    mrb_hash_set(mrb, hash, mrb_str_new_cstr(mrb, elm.first.c_str()), elm.second);
                    mrb_iv_set(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"), hash);
                }
            }
            g_rubyValue.push_back(ret);
            mrb_funcall(mrb, ret, "initialize", 0);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined static method : cocos2d::Ripple3D#create");

    return mrb_nil_value();
}

void ruby_register_cocos2dx_Ripple3D(mrb_state* mrb, struct RClass* rmodule)
{
    std::string typeName = typeid(cocos2d::Ripple3D).name();
    g_rubyType[typeName] = "CC::Ripple3D";
    g_rubyDataType[typeName] = &ruby_cocos2dx_Ref_type;

    struct RClass* p_rmodule = mrb->object_class;
    p_rmodule = mrb_module_get_under(mrb, p_rmodule, "CC");
    struct RClass* p_rclass = mrb_class_get_under(mrb, p_rmodule, "Grid3DAction");
    struct RClass *rclass = mrb_define_class_under(mrb, rmodule, "Ripple3D", p_rclass);
    MRB_SET_INSTANCE_TT(rclass, MRB_TT_DATA);

    mrb_define_method(mrb, rclass, "set_amplitude_rate", ruby_cocos2dx_Ripple3D_setAmplitudeRate, ARGS_REQ(1));
    mrb_define_method(mrb, rclass, "get_amplitude_rate", ruby_cocos2dx_Ripple3D_getAmplitudeRate, ARGS_NONE());
    mrb_define_method(mrb, rclass, "set_amplitude", ruby_cocos2dx_Ripple3D_setAmplitude, ARGS_REQ(1));
    mrb_define_method(mrb, rclass, "get_amplitude", ruby_cocos2dx_Ripple3D_getAmplitude, ARGS_NONE());
    mrb_define_method(mrb, rclass, "set_position", ruby_cocos2dx_Ripple3D_setPosition, ARGS_REQ(1));
    mrb_define_method(mrb, rclass, "get_position", ruby_cocos2dx_Ripple3D_getPosition, ARGS_NONE());
    mrb_define_class_method(mrb, rclass, "create", ruby_cocos2dx_Ripple3D_create_static, ARGS_REQ(6));
}
mrb_value ruby_cocos2dx_Shaky3D_create_static(mrb_state* mrb, mrb_value self)
{
    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 4) {
            std::map<std::string, mrb_value> callbacks;
            double arg0;
            ok = rubyval_to_number(mrb, argv[0], (double*)&arg0, "CC::Shaky3D.create");
            if (!ok) { break; }

            cocos2d::Size* arg1;
            ok = rubyval_to_object<cocos2d::Size>(mrb, argv[1], "CC::Size", &arg1);
            if (!ok) { break; }

            int arg2;
            ok = rubyval_to_int32(mrb, argv[2], (int*)&arg2, "CC::Shaky3D.create");
            if (!ok) { break; }

            bool arg3;
            ok = rubyval_to_boolean(mrb, argv[3], &arg3, "CC::Shaky3D.create");
            if (!ok) { break; }

            cocos2d::Shaky3D* retval = cocos2d::Shaky3D::create(arg0, *arg1, arg2, arg3);
            mrb_value ret;
            RClass* rclass = mrb_class_ptr(self);
            ret = object_to_rubyval<cocos2d::Shaky3D>(mrb, "CC::Shaky3D", (cocos2d::Shaky3D*)retval, rclass);
            if (callbacks.size() > 0) {
                mrb_value hash = mrb_iv_get(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"));
                if (!mrb_hash_p(hash)) {
                    hash = mrb_hash_new(mrb);
                }
                for (auto elm : callbacks) {
                    mrb_hash_set(mrb, hash, mrb_str_new_cstr(mrb, elm.first.c_str()), elm.second);
                    mrb_iv_set(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"), hash);
                }
            }
            g_rubyValue.push_back(ret);
            mrb_funcall(mrb, ret, "initialize", 0);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined static method : cocos2d::Shaky3D#create");

    return mrb_nil_value();
}

void ruby_register_cocos2dx_Shaky3D(mrb_state* mrb, struct RClass* rmodule)
{
    std::string typeName = typeid(cocos2d::Shaky3D).name();
    g_rubyType[typeName] = "CC::Shaky3D";
    g_rubyDataType[typeName] = &ruby_cocos2dx_Ref_type;

    struct RClass* p_rmodule = mrb->object_class;
    p_rmodule = mrb_module_get_under(mrb, p_rmodule, "CC");
    struct RClass* p_rclass = mrb_class_get_under(mrb, p_rmodule, "Grid3DAction");
    struct RClass *rclass = mrb_define_class_under(mrb, rmodule, "Shaky3D", p_rclass);
    MRB_SET_INSTANCE_TT(rclass, MRB_TT_DATA);

    mrb_define_class_method(mrb, rclass, "create", ruby_cocos2dx_Shaky3D_create_static, ARGS_REQ(4));
}
mrb_value ruby_cocos2dx_Liquid_getAmplitudeRate(mrb_state* mrb, mrb_value self)
{
    cocos2d::Liquid* cobj = static_cast<cocos2d::Liquid*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            double retval = cobj->getAmplitudeRate();
            mrb_value ret;
            ret = mrb_float_value(mrb, (mrb_float)retval);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::Liquid#getAmplitudeRate");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Liquid_setAmplitude(mrb_state* mrb, mrb_value self)
{
    cocos2d::Liquid* cobj = static_cast<cocos2d::Liquid*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            double arg0;
            ok = rubyval_to_number(mrb, argv[0], (double*)&arg0, "CC::Liquid.setAmplitude");
            if (!ok) { break; }
            cobj->setAmplitude(arg0);
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::Liquid#setAmplitude");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Liquid_setAmplitudeRate(mrb_state* mrb, mrb_value self)
{
    cocos2d::Liquid* cobj = static_cast<cocos2d::Liquid*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            double arg0;
            ok = rubyval_to_number(mrb, argv[0], (double*)&arg0, "CC::Liquid.setAmplitudeRate");
            if (!ok) { break; }
            cobj->setAmplitudeRate(arg0);
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::Liquid#setAmplitudeRate");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Liquid_getAmplitude(mrb_state* mrb, mrb_value self)
{
    cocos2d::Liquid* cobj = static_cast<cocos2d::Liquid*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            double retval = cobj->getAmplitude();
            mrb_value ret;
            ret = mrb_float_value(mrb, (mrb_float)retval);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::Liquid#getAmplitude");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Liquid_create_static(mrb_state* mrb, mrb_value self)
{
    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 4) {
            std::map<std::string, mrb_value> callbacks;
            double arg0;
            ok = rubyval_to_number(mrb, argv[0], (double*)&arg0, "CC::Liquid.create");
            if (!ok) { break; }

            cocos2d::Size* arg1;
            ok = rubyval_to_object<cocos2d::Size>(mrb, argv[1], "CC::Size", &arg1);
            if (!ok) { break; }

            unsigned int arg2;
            ok = rubyval_to_uint32(mrb, argv[2], &arg2, "CC::Liquid.create");
            if (!ok) { break; }

            double arg3;
            ok = rubyval_to_number(mrb, argv[3], (double*)&arg3, "CC::Liquid.create");
            if (!ok) { break; }

            cocos2d::Liquid* retval = cocos2d::Liquid::create(arg0, *arg1, arg2, arg3);
            mrb_value ret;
            RClass* rclass = mrb_class_ptr(self);
            ret = object_to_rubyval<cocos2d::Liquid>(mrb, "CC::Liquid", (cocos2d::Liquid*)retval, rclass);
            if (callbacks.size() > 0) {
                mrb_value hash = mrb_iv_get(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"));
                if (!mrb_hash_p(hash)) {
                    hash = mrb_hash_new(mrb);
                }
                for (auto elm : callbacks) {
                    mrb_hash_set(mrb, hash, mrb_str_new_cstr(mrb, elm.first.c_str()), elm.second);
                    mrb_iv_set(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"), hash);
                }
            }
            g_rubyValue.push_back(ret);
            mrb_funcall(mrb, ret, "initialize", 0);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined static method : cocos2d::Liquid#create");

    return mrb_nil_value();
}

void ruby_register_cocos2dx_Liquid(mrb_state* mrb, struct RClass* rmodule)
{
    std::string typeName = typeid(cocos2d::Liquid).name();
    g_rubyType[typeName] = "CC::Liquid";
    g_rubyDataType[typeName] = &ruby_cocos2dx_Ref_type;

    struct RClass* p_rmodule = mrb->object_class;
    p_rmodule = mrb_module_get_under(mrb, p_rmodule, "CC");
    struct RClass* p_rclass = mrb_class_get_under(mrb, p_rmodule, "Grid3DAction");
    struct RClass *rclass = mrb_define_class_under(mrb, rmodule, "Liquid", p_rclass);
    MRB_SET_INSTANCE_TT(rclass, MRB_TT_DATA);

    mrb_define_method(mrb, rclass, "get_amplitude_rate", ruby_cocos2dx_Liquid_getAmplitudeRate, ARGS_NONE());
    mrb_define_method(mrb, rclass, "set_amplitude", ruby_cocos2dx_Liquid_setAmplitude, ARGS_REQ(1));
    mrb_define_method(mrb, rclass, "set_amplitude_rate", ruby_cocos2dx_Liquid_setAmplitudeRate, ARGS_REQ(1));
    mrb_define_method(mrb, rclass, "get_amplitude", ruby_cocos2dx_Liquid_getAmplitude, ARGS_NONE());
    mrb_define_class_method(mrb, rclass, "create", ruby_cocos2dx_Liquid_create_static, ARGS_REQ(4));
}
mrb_value ruby_cocos2dx_Waves_getAmplitudeRate(mrb_state* mrb, mrb_value self)
{
    cocos2d::Waves* cobj = static_cast<cocos2d::Waves*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            double retval = cobj->getAmplitudeRate();
            mrb_value ret;
            ret = mrb_float_value(mrb, (mrb_float)retval);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::Waves#getAmplitudeRate");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Waves_setAmplitude(mrb_state* mrb, mrb_value self)
{
    cocos2d::Waves* cobj = static_cast<cocos2d::Waves*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            double arg0;
            ok = rubyval_to_number(mrb, argv[0], (double*)&arg0, "CC::Waves.setAmplitude");
            if (!ok) { break; }
            cobj->setAmplitude(arg0);
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::Waves#setAmplitude");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Waves_setAmplitudeRate(mrb_state* mrb, mrb_value self)
{
    cocos2d::Waves* cobj = static_cast<cocos2d::Waves*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            double arg0;
            ok = rubyval_to_number(mrb, argv[0], (double*)&arg0, "CC::Waves.setAmplitudeRate");
            if (!ok) { break; }
            cobj->setAmplitudeRate(arg0);
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::Waves#setAmplitudeRate");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Waves_getAmplitude(mrb_state* mrb, mrb_value self)
{
    cocos2d::Waves* cobj = static_cast<cocos2d::Waves*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            double retval = cobj->getAmplitude();
            mrb_value ret;
            ret = mrb_float_value(mrb, (mrb_float)retval);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::Waves#getAmplitude");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Waves_create_static(mrb_state* mrb, mrb_value self)
{
    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 6) {
            std::map<std::string, mrb_value> callbacks;
            double arg0;
            ok = rubyval_to_number(mrb, argv[0], (double*)&arg0, "CC::Waves.create");
            if (!ok) { break; }

            cocos2d::Size* arg1;
            ok = rubyval_to_object<cocos2d::Size>(mrb, argv[1], "CC::Size", &arg1);
            if (!ok) { break; }

            unsigned int arg2;
            ok = rubyval_to_uint32(mrb, argv[2], &arg2, "CC::Waves.create");
            if (!ok) { break; }

            double arg3;
            ok = rubyval_to_number(mrb, argv[3], (double*)&arg3, "CC::Waves.create");
            if (!ok) { break; }

            bool arg4;
            ok = rubyval_to_boolean(mrb, argv[4], &arg4, "CC::Waves.create");
            if (!ok) { break; }

            bool arg5;
            ok = rubyval_to_boolean(mrb, argv[5], &arg5, "CC::Waves.create");
            if (!ok) { break; }

            cocos2d::Waves* retval = cocos2d::Waves::create(arg0, *arg1, arg2, arg3, arg4, arg5);
            mrb_value ret;
            RClass* rclass = mrb_class_ptr(self);
            ret = object_to_rubyval<cocos2d::Waves>(mrb, "CC::Waves", (cocos2d::Waves*)retval, rclass);
            if (callbacks.size() > 0) {
                mrb_value hash = mrb_iv_get(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"));
                if (!mrb_hash_p(hash)) {
                    hash = mrb_hash_new(mrb);
                }
                for (auto elm : callbacks) {
                    mrb_hash_set(mrb, hash, mrb_str_new_cstr(mrb, elm.first.c_str()), elm.second);
                    mrb_iv_set(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"), hash);
                }
            }
            g_rubyValue.push_back(ret);
            mrb_funcall(mrb, ret, "initialize", 0);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined static method : cocos2d::Waves#create");

    return mrb_nil_value();
}

void ruby_register_cocos2dx_Waves(mrb_state* mrb, struct RClass* rmodule)
{
    std::string typeName = typeid(cocos2d::Waves).name();
    g_rubyType[typeName] = "CC::Waves";
    g_rubyDataType[typeName] = &ruby_cocos2dx_Ref_type;

    struct RClass* p_rmodule = mrb->object_class;
    p_rmodule = mrb_module_get_under(mrb, p_rmodule, "CC");
    struct RClass* p_rclass = mrb_class_get_under(mrb, p_rmodule, "Grid3DAction");
    struct RClass *rclass = mrb_define_class_under(mrb, rmodule, "Waves", p_rclass);
    MRB_SET_INSTANCE_TT(rclass, MRB_TT_DATA);

    mrb_define_method(mrb, rclass, "get_amplitude_rate", ruby_cocos2dx_Waves_getAmplitudeRate, ARGS_NONE());
    mrb_define_method(mrb, rclass, "set_amplitude", ruby_cocos2dx_Waves_setAmplitude, ARGS_REQ(1));
    mrb_define_method(mrb, rclass, "set_amplitude_rate", ruby_cocos2dx_Waves_setAmplitudeRate, ARGS_REQ(1));
    mrb_define_method(mrb, rclass, "get_amplitude", ruby_cocos2dx_Waves_getAmplitude, ARGS_NONE());
    mrb_define_class_method(mrb, rclass, "create", ruby_cocos2dx_Waves_create_static, ARGS_REQ(6));
}
mrb_value ruby_cocos2dx_Twirl_setAmplitudeRate(mrb_state* mrb, mrb_value self)
{
    cocos2d::Twirl* cobj = static_cast<cocos2d::Twirl*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            double arg0;
            ok = rubyval_to_number(mrb, argv[0], (double*)&arg0, "CC::Twirl.setAmplitudeRate");
            if (!ok) { break; }
            cobj->setAmplitudeRate(arg0);
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::Twirl#setAmplitudeRate");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Twirl_getAmplitudeRate(mrb_state* mrb, mrb_value self)
{
    cocos2d::Twirl* cobj = static_cast<cocos2d::Twirl*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            double retval = cobj->getAmplitudeRate();
            mrb_value ret;
            ret = mrb_float_value(mrb, (mrb_float)retval);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::Twirl#getAmplitudeRate");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Twirl_setAmplitude(mrb_state* mrb, mrb_value self)
{
    cocos2d::Twirl* cobj = static_cast<cocos2d::Twirl*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            double arg0;
            ok = rubyval_to_number(mrb, argv[0], (double*)&arg0, "CC::Twirl.setAmplitude");
            if (!ok) { break; }
            cobj->setAmplitude(arg0);
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::Twirl#setAmplitude");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Twirl_getAmplitude(mrb_state* mrb, mrb_value self)
{
    cocos2d::Twirl* cobj = static_cast<cocos2d::Twirl*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            double retval = cobj->getAmplitude();
            mrb_value ret;
            ret = mrb_float_value(mrb, (mrb_float)retval);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::Twirl#getAmplitude");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Twirl_setPosition(mrb_state* mrb, mrb_value self)
{
    cocos2d::Twirl* cobj = static_cast<cocos2d::Twirl*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            cocos2d::Vec2* arg0;
            ok = rubyval_to_object<cocos2d::Vec2>(mrb, argv[0], "CC::Vec2", &arg0);
            if (!ok) { break; }
            cobj->setPosition(*arg0);
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::Twirl#setPosition");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Twirl_getPosition(mrb_state* mrb, mrb_value self)
{
    cocos2d::Twirl* cobj = static_cast<cocos2d::Twirl*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            cocos2d::Vec2 retval = cobj->getPosition();
            cocos2d::Vec2* retval_ptr = new cocos2d::Vec2(retval);
            mrb_value ret;
            ret = object_to_rubyval<cocos2d::Vec2>(mrb, "CC::Vec2", (cocos2d::Vec2*)retval_ptr, nullptr);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::Twirl#getPosition");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Twirl_create_static(mrb_state* mrb, mrb_value self)
{
    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 5) {
            std::map<std::string, mrb_value> callbacks;
            double arg0;
            ok = rubyval_to_number(mrb, argv[0], (double*)&arg0, "CC::Twirl.create");
            if (!ok) { break; }

            cocos2d::Size* arg1;
            ok = rubyval_to_object<cocos2d::Size>(mrb, argv[1], "CC::Size", &arg1);
            if (!ok) { break; }

            cocos2d::Vec2* arg2;
            ok = rubyval_to_object<cocos2d::Vec2>(mrb, argv[2], "CC::Vec2", &arg2);
            if (!ok) { break; }

            unsigned int arg3;
            ok = rubyval_to_uint32(mrb, argv[3], &arg3, "CC::Twirl.create");
            if (!ok) { break; }

            double arg4;
            ok = rubyval_to_number(mrb, argv[4], (double*)&arg4, "CC::Twirl.create");
            if (!ok) { break; }

            cocos2d::Twirl* retval = cocos2d::Twirl::create(arg0, *arg1, *arg2, arg3, arg4);
            mrb_value ret;
            RClass* rclass = mrb_class_ptr(self);
            ret = object_to_rubyval<cocos2d::Twirl>(mrb, "CC::Twirl", (cocos2d::Twirl*)retval, rclass);
            if (callbacks.size() > 0) {
                mrb_value hash = mrb_iv_get(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"));
                if (!mrb_hash_p(hash)) {
                    hash = mrb_hash_new(mrb);
                }
                for (auto elm : callbacks) {
                    mrb_hash_set(mrb, hash, mrb_str_new_cstr(mrb, elm.first.c_str()), elm.second);
                    mrb_iv_set(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"), hash);
                }
            }
            g_rubyValue.push_back(ret);
            mrb_funcall(mrb, ret, "initialize", 0);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined static method : cocos2d::Twirl#create");

    return mrb_nil_value();
}

void ruby_register_cocos2dx_Twirl(mrb_state* mrb, struct RClass* rmodule)
{
    std::string typeName = typeid(cocos2d::Twirl).name();
    g_rubyType[typeName] = "CC::Twirl";
    g_rubyDataType[typeName] = &ruby_cocos2dx_Ref_type;

    struct RClass* p_rmodule = mrb->object_class;
    p_rmodule = mrb_module_get_under(mrb, p_rmodule, "CC");
    struct RClass* p_rclass = mrb_class_get_under(mrb, p_rmodule, "Grid3DAction");
    struct RClass *rclass = mrb_define_class_under(mrb, rmodule, "Twirl", p_rclass);
    MRB_SET_INSTANCE_TT(rclass, MRB_TT_DATA);

    mrb_define_method(mrb, rclass, "set_amplitude_rate", ruby_cocos2dx_Twirl_setAmplitudeRate, ARGS_REQ(1));
    mrb_define_method(mrb, rclass, "get_amplitude_rate", ruby_cocos2dx_Twirl_getAmplitudeRate, ARGS_NONE());
    mrb_define_method(mrb, rclass, "set_amplitude", ruby_cocos2dx_Twirl_setAmplitude, ARGS_REQ(1));
    mrb_define_method(mrb, rclass, "get_amplitude", ruby_cocos2dx_Twirl_getAmplitude, ARGS_NONE());
    mrb_define_method(mrb, rclass, "set_position", ruby_cocos2dx_Twirl_setPosition, ARGS_REQ(1));
    mrb_define_method(mrb, rclass, "get_position", ruby_cocos2dx_Twirl_getPosition, ARGS_NONE());
    mrb_define_class_method(mrb, rclass, "create", ruby_cocos2dx_Twirl_create_static, ARGS_REQ(5));
}
mrb_value ruby_cocos2dx_PageTurn3D_getGrid(mrb_state* mrb, mrb_value self)
{
    cocos2d::PageTurn3D* cobj = static_cast<cocos2d::PageTurn3D*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            cocos2d::GridBase* retval = cobj->getGrid();
            mrb_value ret;
            ret = object_to_rubyval<cocos2d::GridBase>(mrb, "CC::GridBase", (cocos2d::GridBase*)retval, nullptr);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::PageTurn3D#getGrid");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_PageTurn3D_create_static(mrb_state* mrb, mrb_value self)
{
    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 2) {
            std::map<std::string, mrb_value> callbacks;
            double arg0;
            ok = rubyval_to_number(mrb, argv[0], (double*)&arg0, "CC::PageTurn3D.create");
            if (!ok) { break; }

            cocos2d::Size* arg1;
            ok = rubyval_to_object<cocos2d::Size>(mrb, argv[1], "CC::Size", &arg1);
            if (!ok) { break; }

            cocos2d::PageTurn3D* retval = cocos2d::PageTurn3D::create(arg0, *arg1);
            mrb_value ret;
            RClass* rclass = mrb_class_ptr(self);
            ret = object_to_rubyval<cocos2d::PageTurn3D>(mrb, "CC::PageTurn3D", (cocos2d::PageTurn3D*)retval, rclass);
            if (callbacks.size() > 0) {
                mrb_value hash = mrb_iv_get(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"));
                if (!mrb_hash_p(hash)) {
                    hash = mrb_hash_new(mrb);
                }
                for (auto elm : callbacks) {
                    mrb_hash_set(mrb, hash, mrb_str_new_cstr(mrb, elm.first.c_str()), elm.second);
                    mrb_iv_set(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"), hash);
                }
            }
            g_rubyValue.push_back(ret);
            mrb_funcall(mrb, ret, "initialize", 0);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined static method : cocos2d::PageTurn3D#create");

    return mrb_nil_value();
}

void ruby_register_cocos2dx_PageTurn3D(mrb_state* mrb, struct RClass* rmodule)
{
    std::string typeName = typeid(cocos2d::PageTurn3D).name();
    g_rubyType[typeName] = "CC::PageTurn3D";
    g_rubyDataType[typeName] = &ruby_cocos2dx_Ref_type;

    struct RClass* p_rmodule = mrb->object_class;
    p_rmodule = mrb_module_get_under(mrb, p_rmodule, "CC");
    struct RClass* p_rclass = mrb_class_get_under(mrb, p_rmodule, "Grid3DAction");
    struct RClass *rclass = mrb_define_class_under(mrb, rmodule, "PageTurn3D", p_rclass);
    MRB_SET_INSTANCE_TT(rclass, MRB_TT_DATA);

    mrb_define_method(mrb, rclass, "get_grid", ruby_cocos2dx_PageTurn3D_getGrid, ARGS_NONE());
    mrb_define_class_method(mrb, rclass, "create", ruby_cocos2dx_PageTurn3D_create_static, ARGS_REQ(2));
}
mrb_value ruby_cocos2dx_ProgressTo_create_static(mrb_state* mrb, mrb_value self)
{
    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 2) {
            std::map<std::string, mrb_value> callbacks;
            double arg0;
            ok = rubyval_to_number(mrb, argv[0], (double*)&arg0, "CC::ProgressTo.create");
            if (!ok) { break; }

            double arg1;
            ok = rubyval_to_number(mrb, argv[1], (double*)&arg1, "CC::ProgressTo.create");
            if (!ok) { break; }

            cocos2d::ProgressTo* retval = cocos2d::ProgressTo::create(arg0, arg1);
            mrb_value ret;
            RClass* rclass = mrb_class_ptr(self);
            ret = object_to_rubyval<cocos2d::ProgressTo>(mrb, "CC::ProgressTo", (cocos2d::ProgressTo*)retval, rclass);
            if (callbacks.size() > 0) {
                mrb_value hash = mrb_iv_get(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"));
                if (!mrb_hash_p(hash)) {
                    hash = mrb_hash_new(mrb);
                }
                for (auto elm : callbacks) {
                    mrb_hash_set(mrb, hash, mrb_str_new_cstr(mrb, elm.first.c_str()), elm.second);
                    mrb_iv_set(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"), hash);
                }
            }
            g_rubyValue.push_back(ret);
            mrb_funcall(mrb, ret, "initialize", 0);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined static method : cocos2d::ProgressTo#create");

    return mrb_nil_value();
}

void ruby_register_cocos2dx_ProgressTo(mrb_state* mrb, struct RClass* rmodule)
{
    std::string typeName = typeid(cocos2d::ProgressTo).name();
    g_rubyType[typeName] = "CC::ProgressTo";
    g_rubyDataType[typeName] = &ruby_cocos2dx_Ref_type;

    struct RClass* p_rmodule = mrb->object_class;
    p_rmodule = mrb_module_get_under(mrb, p_rmodule, "CC");
    struct RClass* p_rclass = mrb_class_get_under(mrb, p_rmodule, "ActionInterval");
    struct RClass *rclass = mrb_define_class_under(mrb, rmodule, "ProgressTo", p_rclass);
    MRB_SET_INSTANCE_TT(rclass, MRB_TT_DATA);

    mrb_define_class_method(mrb, rclass, "create", ruby_cocos2dx_ProgressTo_create_static, ARGS_REQ(2));
}
mrb_value ruby_cocos2dx_ProgressFromTo_create_static(mrb_state* mrb, mrb_value self)
{
    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 3) {
            std::map<std::string, mrb_value> callbacks;
            double arg0;
            ok = rubyval_to_number(mrb, argv[0], (double*)&arg0, "CC::ProgressFromTo.create");
            if (!ok) { break; }

            double arg1;
            ok = rubyval_to_number(mrb, argv[1], (double*)&arg1, "CC::ProgressFromTo.create");
            if (!ok) { break; }

            double arg2;
            ok = rubyval_to_number(mrb, argv[2], (double*)&arg2, "CC::ProgressFromTo.create");
            if (!ok) { break; }

            cocos2d::ProgressFromTo* retval = cocos2d::ProgressFromTo::create(arg0, arg1, arg2);
            mrb_value ret;
            RClass* rclass = mrb_class_ptr(self);
            ret = object_to_rubyval<cocos2d::ProgressFromTo>(mrb, "CC::ProgressFromTo", (cocos2d::ProgressFromTo*)retval, rclass);
            if (callbacks.size() > 0) {
                mrb_value hash = mrb_iv_get(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"));
                if (!mrb_hash_p(hash)) {
                    hash = mrb_hash_new(mrb);
                }
                for (auto elm : callbacks) {
                    mrb_hash_set(mrb, hash, mrb_str_new_cstr(mrb, elm.first.c_str()), elm.second);
                    mrb_iv_set(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"), hash);
                }
            }
            g_rubyValue.push_back(ret);
            mrb_funcall(mrb, ret, "initialize", 0);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined static method : cocos2d::ProgressFromTo#create");

    return mrb_nil_value();
}

void ruby_register_cocos2dx_ProgressFromTo(mrb_state* mrb, struct RClass* rmodule)
{
    std::string typeName = typeid(cocos2d::ProgressFromTo).name();
    g_rubyType[typeName] = "CC::ProgressFromTo";
    g_rubyDataType[typeName] = &ruby_cocos2dx_Ref_type;

    struct RClass* p_rmodule = mrb->object_class;
    p_rmodule = mrb_module_get_under(mrb, p_rmodule, "CC");
    struct RClass* p_rclass = mrb_class_get_under(mrb, p_rmodule, "ActionInterval");
    struct RClass *rclass = mrb_define_class_under(mrb, rmodule, "ProgressFromTo", p_rclass);
    MRB_SET_INSTANCE_TT(rclass, MRB_TT_DATA);

    mrb_define_class_method(mrb, rclass, "create", ruby_cocos2dx_ProgressFromTo_create_static, ARGS_REQ(3));
}
mrb_value ruby_cocos2dx_ShakyTiles3D_create_static(mrb_state* mrb, mrb_value self)
{
    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 4) {
            std::map<std::string, mrb_value> callbacks;
            double arg0;
            ok = rubyval_to_number(mrb, argv[0], (double*)&arg0, "CC::ShakyTiles3D.create");
            if (!ok) { break; }

            cocos2d::Size* arg1;
            ok = rubyval_to_object<cocos2d::Size>(mrb, argv[1], "CC::Size", &arg1);
            if (!ok) { break; }

            int arg2;
            ok = rubyval_to_int32(mrb, argv[2], (int*)&arg2, "CC::ShakyTiles3D.create");
            if (!ok) { break; }

            bool arg3;
            ok = rubyval_to_boolean(mrb, argv[3], &arg3, "CC::ShakyTiles3D.create");
            if (!ok) { break; }

            cocos2d::ShakyTiles3D* retval = cocos2d::ShakyTiles3D::create(arg0, *arg1, arg2, arg3);
            mrb_value ret;
            RClass* rclass = mrb_class_ptr(self);
            ret = object_to_rubyval<cocos2d::ShakyTiles3D>(mrb, "CC::ShakyTiles3D", (cocos2d::ShakyTiles3D*)retval, rclass);
            if (callbacks.size() > 0) {
                mrb_value hash = mrb_iv_get(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"));
                if (!mrb_hash_p(hash)) {
                    hash = mrb_hash_new(mrb);
                }
                for (auto elm : callbacks) {
                    mrb_hash_set(mrb, hash, mrb_str_new_cstr(mrb, elm.first.c_str()), elm.second);
                    mrb_iv_set(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"), hash);
                }
            }
            g_rubyValue.push_back(ret);
            mrb_funcall(mrb, ret, "initialize", 0);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined static method : cocos2d::ShakyTiles3D#create");

    return mrb_nil_value();
}

void ruby_register_cocos2dx_ShakyTiles3D(mrb_state* mrb, struct RClass* rmodule)
{
    std::string typeName = typeid(cocos2d::ShakyTiles3D).name();
    g_rubyType[typeName] = "CC::ShakyTiles3D";
    g_rubyDataType[typeName] = &ruby_cocos2dx_Ref_type;

    struct RClass* p_rmodule = mrb->object_class;
    p_rmodule = mrb_module_get_under(mrb, p_rmodule, "CC");
    struct RClass* p_rclass = mrb_class_get_under(mrb, p_rmodule, "TiledGrid3DAction");
    struct RClass *rclass = mrb_define_class_under(mrb, rmodule, "ShakyTiles3D", p_rclass);
    MRB_SET_INSTANCE_TT(rclass, MRB_TT_DATA);

    mrb_define_class_method(mrb, rclass, "create", ruby_cocos2dx_ShakyTiles3D_create_static, ARGS_REQ(4));
}
mrb_value ruby_cocos2dx_ShatteredTiles3D_create_static(mrb_state* mrb, mrb_value self)
{
    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 4) {
            std::map<std::string, mrb_value> callbacks;
            double arg0;
            ok = rubyval_to_number(mrb, argv[0], (double*)&arg0, "CC::ShatteredTiles3D.create");
            if (!ok) { break; }

            cocos2d::Size* arg1;
            ok = rubyval_to_object<cocos2d::Size>(mrb, argv[1], "CC::Size", &arg1);
            if (!ok) { break; }

            int arg2;
            ok = rubyval_to_int32(mrb, argv[2], (int*)&arg2, "CC::ShatteredTiles3D.create");
            if (!ok) { break; }

            bool arg3;
            ok = rubyval_to_boolean(mrb, argv[3], &arg3, "CC::ShatteredTiles3D.create");
            if (!ok) { break; }

            cocos2d::ShatteredTiles3D* retval = cocos2d::ShatteredTiles3D::create(arg0, *arg1, arg2, arg3);
            mrb_value ret;
            RClass* rclass = mrb_class_ptr(self);
            ret = object_to_rubyval<cocos2d::ShatteredTiles3D>(mrb, "CC::ShatteredTiles3D", (cocos2d::ShatteredTiles3D*)retval, rclass);
            if (callbacks.size() > 0) {
                mrb_value hash = mrb_iv_get(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"));
                if (!mrb_hash_p(hash)) {
                    hash = mrb_hash_new(mrb);
                }
                for (auto elm : callbacks) {
                    mrb_hash_set(mrb, hash, mrb_str_new_cstr(mrb, elm.first.c_str()), elm.second);
                    mrb_iv_set(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"), hash);
                }
            }
            g_rubyValue.push_back(ret);
            mrb_funcall(mrb, ret, "initialize", 0);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined static method : cocos2d::ShatteredTiles3D#create");

    return mrb_nil_value();
}

void ruby_register_cocos2dx_ShatteredTiles3D(mrb_state* mrb, struct RClass* rmodule)
{
    std::string typeName = typeid(cocos2d::ShatteredTiles3D).name();
    g_rubyType[typeName] = "CC::ShatteredTiles3D";
    g_rubyDataType[typeName] = &ruby_cocos2dx_Ref_type;

    struct RClass* p_rmodule = mrb->object_class;
    p_rmodule = mrb_module_get_under(mrb, p_rmodule, "CC");
    struct RClass* p_rclass = mrb_class_get_under(mrb, p_rmodule, "TiledGrid3DAction");
    struct RClass *rclass = mrb_define_class_under(mrb, rmodule, "ShatteredTiles3D", p_rclass);
    MRB_SET_INSTANCE_TT(rclass, MRB_TT_DATA);

    mrb_define_class_method(mrb, rclass, "create", ruby_cocos2dx_ShatteredTiles3D_create_static, ARGS_REQ(4));
}
mrb_value ruby_cocos2dx_ShuffleTiles_getDelta(mrb_state* mrb, mrb_value self)
{
    cocos2d::ShuffleTiles* cobj = static_cast<cocos2d::ShuffleTiles*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            cocos2d::Size* arg0;
            ok = rubyval_to_object<cocos2d::Size>(mrb, argv[0], "CC::Size", &arg0);
            if (!ok) { break; }
            cocos2d::Size retval = cobj->getDelta(*arg0);
            cocos2d::Size* retval_ptr = new cocos2d::Size(retval);
            mrb_value ret;
            ret = object_to_rubyval<cocos2d::Size>(mrb, "CC::Size", (cocos2d::Size*)retval_ptr, nullptr);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::ShuffleTiles#getDelta");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_ShuffleTiles_create_static(mrb_state* mrb, mrb_value self)
{
    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 3) {
            std::map<std::string, mrb_value> callbacks;
            double arg0;
            ok = rubyval_to_number(mrb, argv[0], (double*)&arg0, "CC::ShuffleTiles.create");
            if (!ok) { break; }

            cocos2d::Size* arg1;
            ok = rubyval_to_object<cocos2d::Size>(mrb, argv[1], "CC::Size", &arg1);
            if (!ok) { break; }

            unsigned int arg2;
            ok = rubyval_to_uint32(mrb, argv[2], &arg2, "CC::ShuffleTiles.create");
            if (!ok) { break; }

            cocos2d::ShuffleTiles* retval = cocos2d::ShuffleTiles::create(arg0, *arg1, arg2);
            mrb_value ret;
            RClass* rclass = mrb_class_ptr(self);
            ret = object_to_rubyval<cocos2d::ShuffleTiles>(mrb, "CC::ShuffleTiles", (cocos2d::ShuffleTiles*)retval, rclass);
            if (callbacks.size() > 0) {
                mrb_value hash = mrb_iv_get(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"));
                if (!mrb_hash_p(hash)) {
                    hash = mrb_hash_new(mrb);
                }
                for (auto elm : callbacks) {
                    mrb_hash_set(mrb, hash, mrb_str_new_cstr(mrb, elm.first.c_str()), elm.second);
                    mrb_iv_set(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"), hash);
                }
            }
            g_rubyValue.push_back(ret);
            mrb_funcall(mrb, ret, "initialize", 0);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined static method : cocos2d::ShuffleTiles#create");

    return mrb_nil_value();
}

void ruby_register_cocos2dx_ShuffleTiles(mrb_state* mrb, struct RClass* rmodule)
{
    std::string typeName = typeid(cocos2d::ShuffleTiles).name();
    g_rubyType[typeName] = "CC::ShuffleTiles";
    g_rubyDataType[typeName] = &ruby_cocos2dx_Ref_type;

    struct RClass* p_rmodule = mrb->object_class;
    p_rmodule = mrb_module_get_under(mrb, p_rmodule, "CC");
    struct RClass* p_rclass = mrb_class_get_under(mrb, p_rmodule, "TiledGrid3DAction");
    struct RClass *rclass = mrb_define_class_under(mrb, rmodule, "ShuffleTiles", p_rclass);
    MRB_SET_INSTANCE_TT(rclass, MRB_TT_DATA);

    mrb_define_method(mrb, rclass, "get_delta", ruby_cocos2dx_ShuffleTiles_getDelta, ARGS_REQ(1));
    mrb_define_class_method(mrb, rclass, "create", ruby_cocos2dx_ShuffleTiles_create_static, ARGS_REQ(3));
}
mrb_value ruby_cocos2dx_FadeOutTRTiles_turnOnTile(mrb_state* mrb, mrb_value self)
{
    cocos2d::FadeOutTRTiles* cobj = static_cast<cocos2d::FadeOutTRTiles*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            cocos2d::Vec2* arg0;
            ok = rubyval_to_object<cocos2d::Vec2>(mrb, argv[0], "CC::Vec2", &arg0);
            if (!ok) { break; }
            cobj->turnOnTile(*arg0);
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::FadeOutTRTiles#turnOnTile");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_FadeOutTRTiles_turnOffTile(mrb_state* mrb, mrb_value self)
{
    cocos2d::FadeOutTRTiles* cobj = static_cast<cocos2d::FadeOutTRTiles*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            cocos2d::Vec2* arg0;
            ok = rubyval_to_object<cocos2d::Vec2>(mrb, argv[0], "CC::Vec2", &arg0);
            if (!ok) { break; }
            cobj->turnOffTile(*arg0);
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::FadeOutTRTiles#turnOffTile");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_FadeOutTRTiles_transformTile(mrb_state* mrb, mrb_value self)
{
    cocos2d::FadeOutTRTiles* cobj = static_cast<cocos2d::FadeOutTRTiles*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 2) {
            cocos2d::Vec2* arg0;
            ok = rubyval_to_object<cocos2d::Vec2>(mrb, argv[0], "CC::Vec2", &arg0);
            if (!ok) { break; }
            double arg1;
            ok = rubyval_to_number(mrb, argv[1], (double*)&arg1, "CC::FadeOutTRTiles.transformTile");
            if (!ok) { break; }
            cobj->transformTile(*arg0, arg1);
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::FadeOutTRTiles#transformTile");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_FadeOutTRTiles_testFunc(mrb_state* mrb, mrb_value self)
{
    cocos2d::FadeOutTRTiles* cobj = static_cast<cocos2d::FadeOutTRTiles*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 2) {
            cocos2d::Size* arg0;
            ok = rubyval_to_object<cocos2d::Size>(mrb, argv[0], "CC::Size", &arg0);
            if (!ok) { break; }
            double arg1;
            ok = rubyval_to_number(mrb, argv[1], (double*)&arg1, "CC::FadeOutTRTiles.testFunc");
            if (!ok) { break; }
            double retval = cobj->testFunc(*arg0, arg1);
            mrb_value ret;
            ret = mrb_float_value(mrb, (mrb_float)retval);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::FadeOutTRTiles#testFunc");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_FadeOutTRTiles_create_static(mrb_state* mrb, mrb_value self)
{
    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 2) {
            std::map<std::string, mrb_value> callbacks;
            double arg0;
            ok = rubyval_to_number(mrb, argv[0], (double*)&arg0, "CC::FadeOutTRTiles.create");
            if (!ok) { break; }

            cocos2d::Size* arg1;
            ok = rubyval_to_object<cocos2d::Size>(mrb, argv[1], "CC::Size", &arg1);
            if (!ok) { break; }

            cocos2d::FadeOutTRTiles* retval = cocos2d::FadeOutTRTiles::create(arg0, *arg1);
            mrb_value ret;
            RClass* rclass = mrb_class_ptr(self);
            ret = object_to_rubyval<cocos2d::FadeOutTRTiles>(mrb, "CC::FadeOutTRTiles", (cocos2d::FadeOutTRTiles*)retval, rclass);
            if (callbacks.size() > 0) {
                mrb_value hash = mrb_iv_get(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"));
                if (!mrb_hash_p(hash)) {
                    hash = mrb_hash_new(mrb);
                }
                for (auto elm : callbacks) {
                    mrb_hash_set(mrb, hash, mrb_str_new_cstr(mrb, elm.first.c_str()), elm.second);
                    mrb_iv_set(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"), hash);
                }
            }
            g_rubyValue.push_back(ret);
            mrb_funcall(mrb, ret, "initialize", 0);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined static method : cocos2d::FadeOutTRTiles#create");

    return mrb_nil_value();
}

void ruby_register_cocos2dx_FadeOutTRTiles(mrb_state* mrb, struct RClass* rmodule)
{
    std::string typeName = typeid(cocos2d::FadeOutTRTiles).name();
    g_rubyType[typeName] = "CC::FadeOutTRTiles";
    g_rubyDataType[typeName] = &ruby_cocos2dx_Ref_type;

    struct RClass* p_rmodule = mrb->object_class;
    p_rmodule = mrb_module_get_under(mrb, p_rmodule, "CC");
    struct RClass* p_rclass = mrb_class_get_under(mrb, p_rmodule, "TiledGrid3DAction");
    struct RClass *rclass = mrb_define_class_under(mrb, rmodule, "FadeOutTRTiles", p_rclass);
    MRB_SET_INSTANCE_TT(rclass, MRB_TT_DATA);

    mrb_define_method(mrb, rclass, "turn_on_tile", ruby_cocos2dx_FadeOutTRTiles_turnOnTile, ARGS_REQ(1));
    mrb_define_method(mrb, rclass, "turn_off_tile", ruby_cocos2dx_FadeOutTRTiles_turnOffTile, ARGS_REQ(1));
    mrb_define_method(mrb, rclass, "transform_tile", ruby_cocos2dx_FadeOutTRTiles_transformTile, ARGS_REQ(2));
    mrb_define_method(mrb, rclass, "test_func", ruby_cocos2dx_FadeOutTRTiles_testFunc, ARGS_REQ(2));
    mrb_define_class_method(mrb, rclass, "create", ruby_cocos2dx_FadeOutTRTiles_create_static, ARGS_REQ(2));
}
mrb_value ruby_cocos2dx_FadeOutBLTiles_create_static(mrb_state* mrb, mrb_value self)
{
    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 2) {
            std::map<std::string, mrb_value> callbacks;
            double arg0;
            ok = rubyval_to_number(mrb, argv[0], (double*)&arg0, "CC::FadeOutBLTiles.create");
            if (!ok) { break; }

            cocos2d::Size* arg1;
            ok = rubyval_to_object<cocos2d::Size>(mrb, argv[1], "CC::Size", &arg1);
            if (!ok) { break; }

            cocos2d::FadeOutBLTiles* retval = cocos2d::FadeOutBLTiles::create(arg0, *arg1);
            mrb_value ret;
            RClass* rclass = mrb_class_ptr(self);
            ret = object_to_rubyval<cocos2d::FadeOutBLTiles>(mrb, "CC::FadeOutBLTiles", (cocos2d::FadeOutBLTiles*)retval, rclass);
            if (callbacks.size() > 0) {
                mrb_value hash = mrb_iv_get(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"));
                if (!mrb_hash_p(hash)) {
                    hash = mrb_hash_new(mrb);
                }
                for (auto elm : callbacks) {
                    mrb_hash_set(mrb, hash, mrb_str_new_cstr(mrb, elm.first.c_str()), elm.second);
                    mrb_iv_set(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"), hash);
                }
            }
            g_rubyValue.push_back(ret);
            mrb_funcall(mrb, ret, "initialize", 0);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined static method : cocos2d::FadeOutBLTiles#create");

    return mrb_nil_value();
}

void ruby_register_cocos2dx_FadeOutBLTiles(mrb_state* mrb, struct RClass* rmodule)
{
    std::string typeName = typeid(cocos2d::FadeOutBLTiles).name();
    g_rubyType[typeName] = "CC::FadeOutBLTiles";
    g_rubyDataType[typeName] = &ruby_cocos2dx_Ref_type;

    struct RClass* p_rmodule = mrb->object_class;
    p_rmodule = mrb_module_get_under(mrb, p_rmodule, "CC");
    struct RClass* p_rclass = mrb_class_get_under(mrb, p_rmodule, "FadeOutTRTiles");
    struct RClass *rclass = mrb_define_class_under(mrb, rmodule, "FadeOutBLTiles", p_rclass);
    MRB_SET_INSTANCE_TT(rclass, MRB_TT_DATA);

    mrb_define_class_method(mrb, rclass, "create", ruby_cocos2dx_FadeOutBLTiles_create_static, ARGS_REQ(2));
}
mrb_value ruby_cocos2dx_FadeOutUpTiles_transformTile(mrb_state* mrb, mrb_value self)
{
    cocos2d::FadeOutUpTiles* cobj = static_cast<cocos2d::FadeOutUpTiles*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 2) {
            cocos2d::Vec2* arg0;
            ok = rubyval_to_object<cocos2d::Vec2>(mrb, argv[0], "CC::Vec2", &arg0);
            if (!ok) { break; }
            double arg1;
            ok = rubyval_to_number(mrb, argv[1], (double*)&arg1, "CC::FadeOutUpTiles.transformTile");
            if (!ok) { break; }
            cobj->transformTile(*arg0, arg1);
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::FadeOutUpTiles#transformTile");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_FadeOutUpTiles_create_static(mrb_state* mrb, mrb_value self)
{
    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 2) {
            std::map<std::string, mrb_value> callbacks;
            double arg0;
            ok = rubyval_to_number(mrb, argv[0], (double*)&arg0, "CC::FadeOutUpTiles.create");
            if (!ok) { break; }

            cocos2d::Size* arg1;
            ok = rubyval_to_object<cocos2d::Size>(mrb, argv[1], "CC::Size", &arg1);
            if (!ok) { break; }

            cocos2d::FadeOutUpTiles* retval = cocos2d::FadeOutUpTiles::create(arg0, *arg1);
            mrb_value ret;
            RClass* rclass = mrb_class_ptr(self);
            ret = object_to_rubyval<cocos2d::FadeOutUpTiles>(mrb, "CC::FadeOutUpTiles", (cocos2d::FadeOutUpTiles*)retval, rclass);
            if (callbacks.size() > 0) {
                mrb_value hash = mrb_iv_get(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"));
                if (!mrb_hash_p(hash)) {
                    hash = mrb_hash_new(mrb);
                }
                for (auto elm : callbacks) {
                    mrb_hash_set(mrb, hash, mrb_str_new_cstr(mrb, elm.first.c_str()), elm.second);
                    mrb_iv_set(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"), hash);
                }
            }
            g_rubyValue.push_back(ret);
            mrb_funcall(mrb, ret, "initialize", 0);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined static method : cocos2d::FadeOutUpTiles#create");

    return mrb_nil_value();
}

void ruby_register_cocos2dx_FadeOutUpTiles(mrb_state* mrb, struct RClass* rmodule)
{
    std::string typeName = typeid(cocos2d::FadeOutUpTiles).name();
    g_rubyType[typeName] = "CC::FadeOutUpTiles";
    g_rubyDataType[typeName] = &ruby_cocos2dx_Ref_type;

    struct RClass* p_rmodule = mrb->object_class;
    p_rmodule = mrb_module_get_under(mrb, p_rmodule, "CC");
    struct RClass* p_rclass = mrb_class_get_under(mrb, p_rmodule, "FadeOutTRTiles");
    struct RClass *rclass = mrb_define_class_under(mrb, rmodule, "FadeOutUpTiles", p_rclass);
    MRB_SET_INSTANCE_TT(rclass, MRB_TT_DATA);

    mrb_define_method(mrb, rclass, "transform_tile", ruby_cocos2dx_FadeOutUpTiles_transformTile, ARGS_REQ(2));
    mrb_define_class_method(mrb, rclass, "create", ruby_cocos2dx_FadeOutUpTiles_create_static, ARGS_REQ(2));
}
mrb_value ruby_cocos2dx_FadeOutDownTiles_create_static(mrb_state* mrb, mrb_value self)
{
    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 2) {
            std::map<std::string, mrb_value> callbacks;
            double arg0;
            ok = rubyval_to_number(mrb, argv[0], (double*)&arg0, "CC::FadeOutDownTiles.create");
            if (!ok) { break; }

            cocos2d::Size* arg1;
            ok = rubyval_to_object<cocos2d::Size>(mrb, argv[1], "CC::Size", &arg1);
            if (!ok) { break; }

            cocos2d::FadeOutDownTiles* retval = cocos2d::FadeOutDownTiles::create(arg0, *arg1);
            mrb_value ret;
            RClass* rclass = mrb_class_ptr(self);
            ret = object_to_rubyval<cocos2d::FadeOutDownTiles>(mrb, "CC::FadeOutDownTiles", (cocos2d::FadeOutDownTiles*)retval, rclass);
            if (callbacks.size() > 0) {
                mrb_value hash = mrb_iv_get(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"));
                if (!mrb_hash_p(hash)) {
                    hash = mrb_hash_new(mrb);
                }
                for (auto elm : callbacks) {
                    mrb_hash_set(mrb, hash, mrb_str_new_cstr(mrb, elm.first.c_str()), elm.second);
                    mrb_iv_set(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"), hash);
                }
            }
            g_rubyValue.push_back(ret);
            mrb_funcall(mrb, ret, "initialize", 0);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined static method : cocos2d::FadeOutDownTiles#create");

    return mrb_nil_value();
}

void ruby_register_cocos2dx_FadeOutDownTiles(mrb_state* mrb, struct RClass* rmodule)
{
    std::string typeName = typeid(cocos2d::FadeOutDownTiles).name();
    g_rubyType[typeName] = "CC::FadeOutDownTiles";
    g_rubyDataType[typeName] = &ruby_cocos2dx_Ref_type;

    struct RClass* p_rmodule = mrb->object_class;
    p_rmodule = mrb_module_get_under(mrb, p_rmodule, "CC");
    struct RClass* p_rclass = mrb_class_get_under(mrb, p_rmodule, "FadeOutUpTiles");
    struct RClass *rclass = mrb_define_class_under(mrb, rmodule, "FadeOutDownTiles", p_rclass);
    MRB_SET_INSTANCE_TT(rclass, MRB_TT_DATA);

    mrb_define_class_method(mrb, rclass, "create", ruby_cocos2dx_FadeOutDownTiles_create_static, ARGS_REQ(2));
}
mrb_value ruby_cocos2dx_TurnOffTiles_turnOnTile(mrb_state* mrb, mrb_value self)
{
    cocos2d::TurnOffTiles* cobj = static_cast<cocos2d::TurnOffTiles*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            cocos2d::Vec2* arg0;
            ok = rubyval_to_object<cocos2d::Vec2>(mrb, argv[0], "CC::Vec2", &arg0);
            if (!ok) { break; }
            cobj->turnOnTile(*arg0);
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::TurnOffTiles#turnOnTile");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_TurnOffTiles_turnOffTile(mrb_state* mrb, mrb_value self)
{
    cocos2d::TurnOffTiles* cobj = static_cast<cocos2d::TurnOffTiles*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            cocos2d::Vec2* arg0;
            ok = rubyval_to_object<cocos2d::Vec2>(mrb, argv[0], "CC::Vec2", &arg0);
            if (!ok) { break; }
            cobj->turnOffTile(*arg0);
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::TurnOffTiles#turnOffTile");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_TurnOffTiles_create_static(mrb_state* mrb, mrb_value self)
{
    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 3) {
            std::map<std::string, mrb_value> callbacks;
            double arg0;
            ok = rubyval_to_number(mrb, argv[0], (double*)&arg0, "CC::TurnOffTiles.create");
            if (!ok) { break; }

            cocos2d::Size* arg1;
            ok = rubyval_to_object<cocos2d::Size>(mrb, argv[1], "CC::Size", &arg1);
            if (!ok) { break; }

            unsigned int arg2;
            ok = rubyval_to_uint32(mrb, argv[2], &arg2, "CC::TurnOffTiles.create");
            if (!ok) { break; }

            cocos2d::TurnOffTiles* retval = cocos2d::TurnOffTiles::create(arg0, *arg1, arg2);
            mrb_value ret;
            RClass* rclass = mrb_class_ptr(self);
            ret = object_to_rubyval<cocos2d::TurnOffTiles>(mrb, "CC::TurnOffTiles", (cocos2d::TurnOffTiles*)retval, rclass);
            if (callbacks.size() > 0) {
                mrb_value hash = mrb_iv_get(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"));
                if (!mrb_hash_p(hash)) {
                    hash = mrb_hash_new(mrb);
                }
                for (auto elm : callbacks) {
                    mrb_hash_set(mrb, hash, mrb_str_new_cstr(mrb, elm.first.c_str()), elm.second);
                    mrb_iv_set(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"), hash);
                }
            }
            g_rubyValue.push_back(ret);
            mrb_funcall(mrb, ret, "initialize", 0);
            return ret;
        }
    } while (0);
    do {
        if (argc == 2) {
            std::map<std::string, mrb_value> callbacks;
            double arg0;
            ok = rubyval_to_number(mrb, argv[0], (double*)&arg0, "CC::TurnOffTiles.create");
            if (!ok) { break; }

            cocos2d::Size* arg1;
            ok = rubyval_to_object<cocos2d::Size>(mrb, argv[1], "CC::Size", &arg1);
            if (!ok) { break; }

            cocos2d::TurnOffTiles* retval = cocos2d::TurnOffTiles::create(arg0, *arg1);
            mrb_value ret;
            RClass* rclass = mrb_class_ptr(self);
            ret = object_to_rubyval<cocos2d::TurnOffTiles>(mrb, "CC::TurnOffTiles", (cocos2d::TurnOffTiles*)retval, rclass);
            if (callbacks.size() > 0) {
                mrb_value hash = mrb_iv_get(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"));
                if (!mrb_hash_p(hash)) {
                    hash = mrb_hash_new(mrb);
                }
                for (auto elm : callbacks) {
                    mrb_hash_set(mrb, hash, mrb_str_new_cstr(mrb, elm.first.c_str()), elm.second);
                    mrb_iv_set(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"), hash);
                }
            }
            g_rubyValue.push_back(ret);
            mrb_funcall(mrb, ret, "initialize", 0);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined static method : cocos2d::TurnOffTiles#create");

    return mrb_nil_value();
}

void ruby_register_cocos2dx_TurnOffTiles(mrb_state* mrb, struct RClass* rmodule)
{
    std::string typeName = typeid(cocos2d::TurnOffTiles).name();
    g_rubyType[typeName] = "CC::TurnOffTiles";
    g_rubyDataType[typeName] = &ruby_cocos2dx_Ref_type;

    struct RClass* p_rmodule = mrb->object_class;
    p_rmodule = mrb_module_get_under(mrb, p_rmodule, "CC");
    struct RClass* p_rclass = mrb_class_get_under(mrb, p_rmodule, "TiledGrid3DAction");
    struct RClass *rclass = mrb_define_class_under(mrb, rmodule, "TurnOffTiles", p_rclass);
    MRB_SET_INSTANCE_TT(rclass, MRB_TT_DATA);

    mrb_define_method(mrb, rclass, "turn_on_tile", ruby_cocos2dx_TurnOffTiles_turnOnTile, ARGS_REQ(1));
    mrb_define_method(mrb, rclass, "turn_off_tile", ruby_cocos2dx_TurnOffTiles_turnOffTile, ARGS_REQ(1));
    mrb_define_class_method(mrb, rclass, "create", ruby_cocos2dx_TurnOffTiles_create_static, ARGS_REQ(2)|ARGS_OPT(1));
}
mrb_value ruby_cocos2dx_WavesTiles3D_getAmplitudeRate(mrb_state* mrb, mrb_value self)
{
    cocos2d::WavesTiles3D* cobj = static_cast<cocos2d::WavesTiles3D*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            double retval = cobj->getAmplitudeRate();
            mrb_value ret;
            ret = mrb_float_value(mrb, (mrb_float)retval);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::WavesTiles3D#getAmplitudeRate");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_WavesTiles3D_setAmplitude(mrb_state* mrb, mrb_value self)
{
    cocos2d::WavesTiles3D* cobj = static_cast<cocos2d::WavesTiles3D*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            double arg0;
            ok = rubyval_to_number(mrb, argv[0], (double*)&arg0, "CC::WavesTiles3D.setAmplitude");
            if (!ok) { break; }
            cobj->setAmplitude(arg0);
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::WavesTiles3D#setAmplitude");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_WavesTiles3D_setAmplitudeRate(mrb_state* mrb, mrb_value self)
{
    cocos2d::WavesTiles3D* cobj = static_cast<cocos2d::WavesTiles3D*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            double arg0;
            ok = rubyval_to_number(mrb, argv[0], (double*)&arg0, "CC::WavesTiles3D.setAmplitudeRate");
            if (!ok) { break; }
            cobj->setAmplitudeRate(arg0);
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::WavesTiles3D#setAmplitudeRate");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_WavesTiles3D_getAmplitude(mrb_state* mrb, mrb_value self)
{
    cocos2d::WavesTiles3D* cobj = static_cast<cocos2d::WavesTiles3D*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            double retval = cobj->getAmplitude();
            mrb_value ret;
            ret = mrb_float_value(mrb, (mrb_float)retval);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::WavesTiles3D#getAmplitude");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_WavesTiles3D_create_static(mrb_state* mrb, mrb_value self)
{
    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 4) {
            std::map<std::string, mrb_value> callbacks;
            double arg0;
            ok = rubyval_to_number(mrb, argv[0], (double*)&arg0, "CC::WavesTiles3D.create");
            if (!ok) { break; }

            cocos2d::Size* arg1;
            ok = rubyval_to_object<cocos2d::Size>(mrb, argv[1], "CC::Size", &arg1);
            if (!ok) { break; }

            unsigned int arg2;
            ok = rubyval_to_uint32(mrb, argv[2], &arg2, "CC::WavesTiles3D.create");
            if (!ok) { break; }

            double arg3;
            ok = rubyval_to_number(mrb, argv[3], (double*)&arg3, "CC::WavesTiles3D.create");
            if (!ok) { break; }

            cocos2d::WavesTiles3D* retval = cocos2d::WavesTiles3D::create(arg0, *arg1, arg2, arg3);
            mrb_value ret;
            RClass* rclass = mrb_class_ptr(self);
            ret = object_to_rubyval<cocos2d::WavesTiles3D>(mrb, "CC::WavesTiles3D", (cocos2d::WavesTiles3D*)retval, rclass);
            if (callbacks.size() > 0) {
                mrb_value hash = mrb_iv_get(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"));
                if (!mrb_hash_p(hash)) {
                    hash = mrb_hash_new(mrb);
                }
                for (auto elm : callbacks) {
                    mrb_hash_set(mrb, hash, mrb_str_new_cstr(mrb, elm.first.c_str()), elm.second);
                    mrb_iv_set(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"), hash);
                }
            }
            g_rubyValue.push_back(ret);
            mrb_funcall(mrb, ret, "initialize", 0);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined static method : cocos2d::WavesTiles3D#create");

    return mrb_nil_value();
}

void ruby_register_cocos2dx_WavesTiles3D(mrb_state* mrb, struct RClass* rmodule)
{
    std::string typeName = typeid(cocos2d::WavesTiles3D).name();
    g_rubyType[typeName] = "CC::WavesTiles3D";
    g_rubyDataType[typeName] = &ruby_cocos2dx_Ref_type;

    struct RClass* p_rmodule = mrb->object_class;
    p_rmodule = mrb_module_get_under(mrb, p_rmodule, "CC");
    struct RClass* p_rclass = mrb_class_get_under(mrb, p_rmodule, "TiledGrid3DAction");
    struct RClass *rclass = mrb_define_class_under(mrb, rmodule, "WavesTiles3D", p_rclass);
    MRB_SET_INSTANCE_TT(rclass, MRB_TT_DATA);

    mrb_define_method(mrb, rclass, "get_amplitude_rate", ruby_cocos2dx_WavesTiles3D_getAmplitudeRate, ARGS_NONE());
    mrb_define_method(mrb, rclass, "set_amplitude", ruby_cocos2dx_WavesTiles3D_setAmplitude, ARGS_REQ(1));
    mrb_define_method(mrb, rclass, "set_amplitude_rate", ruby_cocos2dx_WavesTiles3D_setAmplitudeRate, ARGS_REQ(1));
    mrb_define_method(mrb, rclass, "get_amplitude", ruby_cocos2dx_WavesTiles3D_getAmplitude, ARGS_NONE());
    mrb_define_class_method(mrb, rclass, "create", ruby_cocos2dx_WavesTiles3D_create_static, ARGS_REQ(4));
}
mrb_value ruby_cocos2dx_JumpTiles3D_getAmplitudeRate(mrb_state* mrb, mrb_value self)
{
    cocos2d::JumpTiles3D* cobj = static_cast<cocos2d::JumpTiles3D*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            double retval = cobj->getAmplitudeRate();
            mrb_value ret;
            ret = mrb_float_value(mrb, (mrb_float)retval);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::JumpTiles3D#getAmplitudeRate");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_JumpTiles3D_setAmplitude(mrb_state* mrb, mrb_value self)
{
    cocos2d::JumpTiles3D* cobj = static_cast<cocos2d::JumpTiles3D*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            double arg0;
            ok = rubyval_to_number(mrb, argv[0], (double*)&arg0, "CC::JumpTiles3D.setAmplitude");
            if (!ok) { break; }
            cobj->setAmplitude(arg0);
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::JumpTiles3D#setAmplitude");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_JumpTiles3D_setAmplitudeRate(mrb_state* mrb, mrb_value self)
{
    cocos2d::JumpTiles3D* cobj = static_cast<cocos2d::JumpTiles3D*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            double arg0;
            ok = rubyval_to_number(mrb, argv[0], (double*)&arg0, "CC::JumpTiles3D.setAmplitudeRate");
            if (!ok) { break; }
            cobj->setAmplitudeRate(arg0);
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::JumpTiles3D#setAmplitudeRate");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_JumpTiles3D_getAmplitude(mrb_state* mrb, mrb_value self)
{
    cocos2d::JumpTiles3D* cobj = static_cast<cocos2d::JumpTiles3D*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            double retval = cobj->getAmplitude();
            mrb_value ret;
            ret = mrb_float_value(mrb, (mrb_float)retval);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::JumpTiles3D#getAmplitude");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_JumpTiles3D_create_static(mrb_state* mrb, mrb_value self)
{
    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 4) {
            std::map<std::string, mrb_value> callbacks;
            double arg0;
            ok = rubyval_to_number(mrb, argv[0], (double*)&arg0, "CC::JumpTiles3D.create");
            if (!ok) { break; }

            cocos2d::Size* arg1;
            ok = rubyval_to_object<cocos2d::Size>(mrb, argv[1], "CC::Size", &arg1);
            if (!ok) { break; }

            unsigned int arg2;
            ok = rubyval_to_uint32(mrb, argv[2], &arg2, "CC::JumpTiles3D.create");
            if (!ok) { break; }

            double arg3;
            ok = rubyval_to_number(mrb, argv[3], (double*)&arg3, "CC::JumpTiles3D.create");
            if (!ok) { break; }

            cocos2d::JumpTiles3D* retval = cocos2d::JumpTiles3D::create(arg0, *arg1, arg2, arg3);
            mrb_value ret;
            RClass* rclass = mrb_class_ptr(self);
            ret = object_to_rubyval<cocos2d::JumpTiles3D>(mrb, "CC::JumpTiles3D", (cocos2d::JumpTiles3D*)retval, rclass);
            if (callbacks.size() > 0) {
                mrb_value hash = mrb_iv_get(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"));
                if (!mrb_hash_p(hash)) {
                    hash = mrb_hash_new(mrb);
                }
                for (auto elm : callbacks) {
                    mrb_hash_set(mrb, hash, mrb_str_new_cstr(mrb, elm.first.c_str()), elm.second);
                    mrb_iv_set(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"), hash);
                }
            }
            g_rubyValue.push_back(ret);
            mrb_funcall(mrb, ret, "initialize", 0);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined static method : cocos2d::JumpTiles3D#create");

    return mrb_nil_value();
}

void ruby_register_cocos2dx_JumpTiles3D(mrb_state* mrb, struct RClass* rmodule)
{
    std::string typeName = typeid(cocos2d::JumpTiles3D).name();
    g_rubyType[typeName] = "CC::JumpTiles3D";
    g_rubyDataType[typeName] = &ruby_cocos2dx_Ref_type;

    struct RClass* p_rmodule = mrb->object_class;
    p_rmodule = mrb_module_get_under(mrb, p_rmodule, "CC");
    struct RClass* p_rclass = mrb_class_get_under(mrb, p_rmodule, "TiledGrid3DAction");
    struct RClass *rclass = mrb_define_class_under(mrb, rmodule, "JumpTiles3D", p_rclass);
    MRB_SET_INSTANCE_TT(rclass, MRB_TT_DATA);

    mrb_define_method(mrb, rclass, "get_amplitude_rate", ruby_cocos2dx_JumpTiles3D_getAmplitudeRate, ARGS_NONE());
    mrb_define_method(mrb, rclass, "set_amplitude", ruby_cocos2dx_JumpTiles3D_setAmplitude, ARGS_REQ(1));
    mrb_define_method(mrb, rclass, "set_amplitude_rate", ruby_cocos2dx_JumpTiles3D_setAmplitudeRate, ARGS_REQ(1));
    mrb_define_method(mrb, rclass, "get_amplitude", ruby_cocos2dx_JumpTiles3D_getAmplitude, ARGS_NONE());
    mrb_define_class_method(mrb, rclass, "create", ruby_cocos2dx_JumpTiles3D_create_static, ARGS_REQ(4));
}
mrb_value ruby_cocos2dx_SplitRows_create_static(mrb_state* mrb, mrb_value self)
{
    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 2) {
            std::map<std::string, mrb_value> callbacks;
            double arg0;
            ok = rubyval_to_number(mrb, argv[0], (double*)&arg0, "CC::SplitRows.create");
            if (!ok) { break; }

            unsigned int arg1;
            ok = rubyval_to_uint32(mrb, argv[1], &arg1, "CC::SplitRows.create");
            if (!ok) { break; }

            cocos2d::SplitRows* retval = cocos2d::SplitRows::create(arg0, arg1);
            mrb_value ret;
            RClass* rclass = mrb_class_ptr(self);
            ret = object_to_rubyval<cocos2d::SplitRows>(mrb, "CC::SplitRows", (cocos2d::SplitRows*)retval, rclass);
            if (callbacks.size() > 0) {
                mrb_value hash = mrb_iv_get(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"));
                if (!mrb_hash_p(hash)) {
                    hash = mrb_hash_new(mrb);
                }
                for (auto elm : callbacks) {
                    mrb_hash_set(mrb, hash, mrb_str_new_cstr(mrb, elm.first.c_str()), elm.second);
                    mrb_iv_set(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"), hash);
                }
            }
            g_rubyValue.push_back(ret);
            mrb_funcall(mrb, ret, "initialize", 0);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined static method : cocos2d::SplitRows#create");

    return mrb_nil_value();
}

void ruby_register_cocos2dx_SplitRows(mrb_state* mrb, struct RClass* rmodule)
{
    std::string typeName = typeid(cocos2d::SplitRows).name();
    g_rubyType[typeName] = "CC::SplitRows";
    g_rubyDataType[typeName] = &ruby_cocos2dx_Ref_type;

    struct RClass* p_rmodule = mrb->object_class;
    p_rmodule = mrb_module_get_under(mrb, p_rmodule, "CC");
    struct RClass* p_rclass = mrb_class_get_under(mrb, p_rmodule, "TiledGrid3DAction");
    struct RClass *rclass = mrb_define_class_under(mrb, rmodule, "SplitRows", p_rclass);
    MRB_SET_INSTANCE_TT(rclass, MRB_TT_DATA);

    mrb_define_class_method(mrb, rclass, "create", ruby_cocos2dx_SplitRows_create_static, ARGS_REQ(2));
}
mrb_value ruby_cocos2dx_SplitCols_create_static(mrb_state* mrb, mrb_value self)
{
    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 2) {
            std::map<std::string, mrb_value> callbacks;
            double arg0;
            ok = rubyval_to_number(mrb, argv[0], (double*)&arg0, "CC::SplitCols.create");
            if (!ok) { break; }

            unsigned int arg1;
            ok = rubyval_to_uint32(mrb, argv[1], &arg1, "CC::SplitCols.create");
            if (!ok) { break; }

            cocos2d::SplitCols* retval = cocos2d::SplitCols::create(arg0, arg1);
            mrb_value ret;
            RClass* rclass = mrb_class_ptr(self);
            ret = object_to_rubyval<cocos2d::SplitCols>(mrb, "CC::SplitCols", (cocos2d::SplitCols*)retval, rclass);
            if (callbacks.size() > 0) {
                mrb_value hash = mrb_iv_get(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"));
                if (!mrb_hash_p(hash)) {
                    hash = mrb_hash_new(mrb);
                }
                for (auto elm : callbacks) {
                    mrb_hash_set(mrb, hash, mrb_str_new_cstr(mrb, elm.first.c_str()), elm.second);
                    mrb_iv_set(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"), hash);
                }
            }
            g_rubyValue.push_back(ret);
            mrb_funcall(mrb, ret, "initialize", 0);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined static method : cocos2d::SplitCols#create");

    return mrb_nil_value();
}

void ruby_register_cocos2dx_SplitCols(mrb_state* mrb, struct RClass* rmodule)
{
    std::string typeName = typeid(cocos2d::SplitCols).name();
    g_rubyType[typeName] = "CC::SplitCols";
    g_rubyDataType[typeName] = &ruby_cocos2dx_Ref_type;

    struct RClass* p_rmodule = mrb->object_class;
    p_rmodule = mrb_module_get_under(mrb, p_rmodule, "CC");
    struct RClass* p_rclass = mrb_class_get_under(mrb, p_rmodule, "TiledGrid3DAction");
    struct RClass *rclass = mrb_define_class_under(mrb, rmodule, "SplitCols", p_rclass);
    MRB_SET_INSTANCE_TT(rclass, MRB_TT_DATA);

    mrb_define_class_method(mrb, rclass, "create", ruby_cocos2dx_SplitCols_create_static, ARGS_REQ(2));
}
mrb_value ruby_cocos2dx_ActionTween_create_static(mrb_state* mrb, mrb_value self)
{
    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 4) {
            std::map<std::string, mrb_value> callbacks;
            double arg0;
            ok = rubyval_to_number(mrb, argv[0], (double*)&arg0, "CC::ActionTween.create");
            if (!ok) { break; }

            std::string arg1;
            ok = rubyval_to_std_string(mrb, argv[1], &arg1, "CC::ActionTween.create");
            if (!ok) { break; }

            double arg2;
            ok = rubyval_to_number(mrb, argv[2], (double*)&arg2, "CC::ActionTween.create");
            if (!ok) { break; }

            double arg3;
            ok = rubyval_to_number(mrb, argv[3], (double*)&arg3, "CC::ActionTween.create");
            if (!ok) { break; }

            cocos2d::ActionTween* retval = cocos2d::ActionTween::create(arg0, arg1, arg2, arg3);
            mrb_value ret;
            RClass* rclass = mrb_class_ptr(self);
            ret = object_to_rubyval<cocos2d::ActionTween>(mrb, "CC::ActionTween", (cocos2d::ActionTween*)retval, rclass);
            if (callbacks.size() > 0) {
                mrb_value hash = mrb_iv_get(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"));
                if (!mrb_hash_p(hash)) {
                    hash = mrb_hash_new(mrb);
                }
                for (auto elm : callbacks) {
                    mrb_hash_set(mrb, hash, mrb_str_new_cstr(mrb, elm.first.c_str()), elm.second);
                    mrb_iv_set(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"), hash);
                }
            }
            g_rubyValue.push_back(ret);
            mrb_funcall(mrb, ret, "initialize", 0);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined static method : cocos2d::ActionTween#create");

    return mrb_nil_value();
}

void ruby_register_cocos2dx_ActionTween(mrb_state* mrb, struct RClass* rmodule)
{
    std::string typeName = typeid(cocos2d::ActionTween).name();
    g_rubyType[typeName] = "CC::ActionTween";
    g_rubyDataType[typeName] = &ruby_cocos2dx_Ref_type;

    struct RClass* p_rmodule = mrb->object_class;
    p_rmodule = mrb_module_get_under(mrb, p_rmodule, "CC");
    struct RClass* p_rclass = mrb_class_get_under(mrb, p_rmodule, "ActionInterval");
    struct RClass *rclass = mrb_define_class_under(mrb, rmodule, "ActionTween", p_rclass);
    MRB_SET_INSTANCE_TT(rclass, MRB_TT_DATA);

    mrb_define_class_method(mrb, rclass, "create", ruby_cocos2dx_ActionTween_create_static, ARGS_REQ(4));
}
mrb_value ruby_cocos2dx_PointArray_count(mrb_state* mrb, mrb_value self)
{
    cocos2d::PointArray* cobj = static_cast<cocos2d::PointArray*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            ssize_t retval = cobj->count();
            mrb_value ret;
            ret = mrb_fixnum_value((mrb_int)retval);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::PointArray#count");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_PointArray_insertControlPoint(mrb_state* mrb, mrb_value self)
{
    cocos2d::PointArray* cobj = static_cast<cocos2d::PointArray*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 2) {
            cocos2d::Vec2* arg0;
            ok = rubyval_to_object<cocos2d::Vec2>(mrb, argv[0], "CC::Vec2", &arg0);
            if (!ok) { break; }
            ssize_t arg1;
            ok = rubyval_to_ssize(mrb, argv[1], &arg1, "CC::PointArray.insertControlPoint");
            if (!ok) { break; }
            cobj->insertControlPoint(*arg0, arg1);
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::PointArray#insertControlPoint");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_PointArray_reverse(mrb_state* mrb, mrb_value self)
{
    cocos2d::PointArray* cobj = static_cast<cocos2d::PointArray*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            cocos2d::PointArray* retval = cobj->reverse();
            mrb_value ret;
            ret = object_to_rubyval<cocos2d::PointArray>(mrb, "CC::PointArray", (cocos2d::PointArray*)retval, nullptr);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::PointArray#reverse");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_PointArray_initWithCapacity(mrb_state* mrb, mrb_value self)
{
    cocos2d::PointArray* cobj = static_cast<cocos2d::PointArray*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            ssize_t arg0;
            ok = rubyval_to_ssize(mrb, argv[0], &arg0, "CC::PointArray.initWithCapacity");
            if (!ok) { break; }
            bool retval = cobj->initWithCapacity(arg0);
            mrb_value ret;
            ret = mrb_bool_value((mrb_bool)retval);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::PointArray#initWithCapacity");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_PointArray_removeControlPointAtIndex(mrb_state* mrb, mrb_value self)
{
    cocos2d::PointArray* cobj = static_cast<cocos2d::PointArray*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            ssize_t arg0;
            ok = rubyval_to_ssize(mrb, argv[0], &arg0, "CC::PointArray.removeControlPointAtIndex");
            if (!ok) { break; }
            cobj->removeControlPointAtIndex(arg0);
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::PointArray#removeControlPointAtIndex");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_PointArray_clone(mrb_state* mrb, mrb_value self)
{
    cocos2d::PointArray* cobj = static_cast<cocos2d::PointArray*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            cocos2d::PointArray* retval = cobj->clone();
            mrb_value ret;
            ret = object_to_rubyval<cocos2d::PointArray>(mrb, "CC::PointArray", (cocos2d::PointArray*)retval, nullptr);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::PointArray#clone");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_PointArray_setControlPoints(mrb_state* mrb, mrb_value self)
{
    cocos2d::PointArray* cobj = static_cast<cocos2d::PointArray*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            std::vector<cocos2d::Vec2 *>* arg0;
            std::vector<cocos2d::Vec2 *> arg0_tmp; ok = rubyval_to_std_vector_object(mrb, argv[0], &arg0_tmp, "CC::Vec2", "CC::PointArray.setControlPoints"); arg0 = &arg0_tmp;
            if (!ok) { break; }
            cobj->setControlPoints(arg0);
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::PointArray#setControlPoints");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_PointArray_replaceControlPoint(mrb_state* mrb, mrb_value self)
{
    cocos2d::PointArray* cobj = static_cast<cocos2d::PointArray*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 2) {
            cocos2d::Vec2* arg0;
            ok = rubyval_to_object<cocos2d::Vec2>(mrb, argv[0], "CC::Vec2", &arg0);
            if (!ok) { break; }
            ssize_t arg1;
            ok = rubyval_to_ssize(mrb, argv[1], &arg1, "CC::PointArray.replaceControlPoint");
            if (!ok) { break; }
            cobj->replaceControlPoint(*arg0, arg1);
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::PointArray#replaceControlPoint");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_PointArray_addControlPoint(mrb_state* mrb, mrb_value self)
{
    cocos2d::PointArray* cobj = static_cast<cocos2d::PointArray*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            cocos2d::Vec2* arg0;
            ok = rubyval_to_object<cocos2d::Vec2>(mrb, argv[0], "CC::Vec2", &arg0);
            if (!ok) { break; }
            cobj->addControlPoint(*arg0);
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::PointArray#addControlPoint");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_PointArray_getControlPointAtIndex(mrb_state* mrb, mrb_value self)
{
    cocos2d::PointArray* cobj = static_cast<cocos2d::PointArray*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            ssize_t arg0;
            ok = rubyval_to_ssize(mrb, argv[0], &arg0, "CC::PointArray.getControlPointAtIndex");
            if (!ok) { break; }
            cocos2d::Vec2 retval = cobj->getControlPointAtIndex(arg0);
            cocos2d::Vec2* retval_ptr = new cocos2d::Vec2(retval);
            mrb_value ret;
            ret = object_to_rubyval<cocos2d::Vec2>(mrb, "CC::Vec2", (cocos2d::Vec2*)retval_ptr, nullptr);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::PointArray#getControlPointAtIndex");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_PointArray_reverseInline(mrb_state* mrb, mrb_value self)
{
    cocos2d::PointArray* cobj = static_cast<cocos2d::PointArray*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            cobj->reverseInline();
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::PointArray#reverseInline");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_PointArray_getControlPoints(mrb_state* mrb, mrb_value self)
{
    cocos2d::PointArray* cobj = static_cast<cocos2d::PointArray*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            const std::vector<cocos2d::Vec2 *>* retval = cobj->getControlPoints();
            mrb_value ret;
            ret = std_vector_object_to_rubyval(mrb, *retval, "CC::Vec2");
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::PointArray#getControlPoints");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_PointArray_create_static(mrb_state* mrb, mrb_value self)
{
    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            std::map<std::string, mrb_value> callbacks;
            ssize_t arg0;
            ok = rubyval_to_ssize(mrb, argv[0], &arg0, "CC::PointArray.create");
            if (!ok) { break; }

            cocos2d::PointArray* retval = cocos2d::PointArray::create(arg0);
            mrb_value ret;
            RClass* rclass = mrb_class_ptr(self);
            ret = object_to_rubyval<cocos2d::PointArray>(mrb, "CC::PointArray", (cocos2d::PointArray*)retval, rclass);
            if (callbacks.size() > 0) {
                mrb_value hash = mrb_iv_get(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"));
                if (!mrb_hash_p(hash)) {
                    hash = mrb_hash_new(mrb);
                }
                for (auto elm : callbacks) {
                    mrb_hash_set(mrb, hash, mrb_str_new_cstr(mrb, elm.first.c_str()), elm.second);
                    mrb_iv_set(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"), hash);
                }
            }
            g_rubyValue.push_back(ret);
            mrb_funcall(mrb, ret, "initialize", 0);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined static method : cocos2d::PointArray#create");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_PointArray_constructor(mrb_state* mrb, mrb_value self)
{

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            cocos2d::PointArray* cobj = new cocos2d::PointArray();
            DATA_TYPE(self) = &ruby_cocos2dx_Ref_type;
            DATA_PTR(self) = cobj;
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::PointArray#PointArray");

    return mrb_nil_value();
}


void ruby_register_cocos2dx_PointArray(mrb_state* mrb, struct RClass* rmodule)
{
    std::string typeName = typeid(cocos2d::PointArray).name();
    g_rubyType[typeName] = "CC::PointArray";
    g_rubyDataType[typeName] = &ruby_cocos2dx_Ref_type;

    struct RClass* p_rmodule = mrb->object_class;
    p_rmodule = mrb_module_get_under(mrb, p_rmodule, "CC");
    struct RClass* p_rclass = mrb_class_get_under(mrb, p_rmodule, "Ref");
    struct RClass *rclass = mrb_define_class_under(mrb, rmodule, "PointArray", p_rclass);
    MRB_SET_INSTANCE_TT(rclass, MRB_TT_DATA);

    mrb_define_method(mrb, rclass, "initialize", ruby_cocos2dx_PointArray_constructor, ARGS_NONE());
    mrb_define_method(mrb, rclass, "count", ruby_cocos2dx_PointArray_count, ARGS_NONE());
    mrb_define_method(mrb, rclass, "insert_control_point", ruby_cocos2dx_PointArray_insertControlPoint, ARGS_REQ(2));
    mrb_define_method(mrb, rclass, "reverse", ruby_cocos2dx_PointArray_reverse, ARGS_NONE());
    mrb_define_method(mrb, rclass, "init_with_capacity", ruby_cocos2dx_PointArray_initWithCapacity, ARGS_REQ(1));
    mrb_define_method(mrb, rclass, "remove_control_point_at_index", ruby_cocos2dx_PointArray_removeControlPointAtIndex, ARGS_REQ(1));
    mrb_define_method(mrb, rclass, "clone", ruby_cocos2dx_PointArray_clone, ARGS_NONE());
    mrb_define_method(mrb, rclass, "set_control_points", ruby_cocos2dx_PointArray_setControlPoints, ARGS_REQ(1));
    mrb_define_method(mrb, rclass, "replace_control_point", ruby_cocos2dx_PointArray_replaceControlPoint, ARGS_REQ(2));
    mrb_define_method(mrb, rclass, "add_control_point", ruby_cocos2dx_PointArray_addControlPoint, ARGS_REQ(1));
    mrb_define_method(mrb, rclass, "get_control_point_at_index", ruby_cocos2dx_PointArray_getControlPointAtIndex, ARGS_REQ(1));
    mrb_define_method(mrb, rclass, "reverse_inline", ruby_cocos2dx_PointArray_reverseInline, ARGS_NONE());
    mrb_define_method(mrb, rclass, "get_control_points", ruby_cocos2dx_PointArray_getControlPoints, ARGS_NONE());
    mrb_define_class_method(mrb, rclass, "create", ruby_cocos2dx_PointArray_create_static, ARGS_REQ(1));
}
mrb_value ruby_cocos2dx_CardinalSplineTo_getPoints(mrb_state* mrb, mrb_value self)
{
    cocos2d::CardinalSplineTo* cobj = static_cast<cocos2d::CardinalSplineTo*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            cocos2d::PointArray* retval = cobj->getPoints();
            mrb_value ret;
            ret = object_to_rubyval<cocos2d::PointArray>(mrb, "CC::PointArray", (cocos2d::PointArray*)retval, nullptr);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::CardinalSplineTo#getPoints");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_CardinalSplineTo_updatePosition(mrb_state* mrb, mrb_value self)
{
    cocos2d::CardinalSplineTo* cobj = static_cast<cocos2d::CardinalSplineTo*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            cocos2d::Vec2* arg0;
            ok = rubyval_to_object<cocos2d::Vec2>(mrb, argv[0], "CC::Vec2", &arg0);
            if (!ok) { break; }
            cobj->updatePosition(*arg0);
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::CardinalSplineTo#updatePosition");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_CardinalSplineTo_initWithDuration(mrb_state* mrb, mrb_value self)
{
    cocos2d::CardinalSplineTo* cobj = static_cast<cocos2d::CardinalSplineTo*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 3) {
            double arg0;
            ok = rubyval_to_number(mrb, argv[0], (double*)&arg0, "CC::CardinalSplineTo.initWithDuration");
            if (!ok) { break; }
            cocos2d::PointArray* arg1;
            ok = rubyval_to_object<cocos2d::PointArray>(mrb, argv[1], "CC::PointArray", &arg1);
            if (!ok) { break; }
            double arg2;
            ok = rubyval_to_number(mrb, argv[2], (double*)&arg2, "CC::CardinalSplineTo.initWithDuration");
            if (!ok) { break; }
            bool retval = cobj->initWithDuration(arg0, arg1, arg2);
            mrb_value ret;
            ret = mrb_bool_value((mrb_bool)retval);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::CardinalSplineTo#initWithDuration");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_CardinalSplineTo_constructor(mrb_state* mrb, mrb_value self)
{

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            cocos2d::CardinalSplineTo* cobj = new cocos2d::CardinalSplineTo();
            DATA_TYPE(self) = &ruby_cocos2dx_Ref_type;
            DATA_PTR(self) = cobj;
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::CardinalSplineTo#CardinalSplineTo");

    return mrb_nil_value();
}


void ruby_register_cocos2dx_CardinalSplineTo(mrb_state* mrb, struct RClass* rmodule)
{
    std::string typeName = typeid(cocos2d::CardinalSplineTo).name();
    g_rubyType[typeName] = "CC::CardinalSplineTo";
    g_rubyDataType[typeName] = &ruby_cocos2dx_Ref_type;

    struct RClass* p_rmodule = mrb->object_class;
    p_rmodule = mrb_module_get_under(mrb, p_rmodule, "CC");
    struct RClass* p_rclass = mrb_class_get_under(mrb, p_rmodule, "ActionInterval");
    struct RClass *rclass = mrb_define_class_under(mrb, rmodule, "CardinalSplineTo", p_rclass);
    MRB_SET_INSTANCE_TT(rclass, MRB_TT_DATA);

    mrb_define_method(mrb, rclass, "initialize", ruby_cocos2dx_CardinalSplineTo_constructor, ARGS_NONE());
    mrb_define_method(mrb, rclass, "get_points", ruby_cocos2dx_CardinalSplineTo_getPoints, ARGS_NONE());
    mrb_define_method(mrb, rclass, "update_position", ruby_cocos2dx_CardinalSplineTo_updatePosition, ARGS_REQ(1));
    mrb_define_method(mrb, rclass, "init_with_duration", ruby_cocos2dx_CardinalSplineTo_initWithDuration, ARGS_REQ(3));
}
mrb_value ruby_cocos2dx_CardinalSplineBy_constructor(mrb_state* mrb, mrb_value self)
{

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            cocos2d::CardinalSplineBy* cobj = new cocos2d::CardinalSplineBy();
            DATA_TYPE(self) = &ruby_cocos2dx_Ref_type;
            DATA_PTR(self) = cobj;
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::CardinalSplineBy#CardinalSplineBy");

    return mrb_nil_value();
}


void ruby_register_cocos2dx_CardinalSplineBy(mrb_state* mrb, struct RClass* rmodule)
{
    std::string typeName = typeid(cocos2d::CardinalSplineBy).name();
    g_rubyType[typeName] = "CC::CardinalSplineBy";
    g_rubyDataType[typeName] = &ruby_cocos2dx_Ref_type;

    struct RClass* p_rmodule = mrb->object_class;
    p_rmodule = mrb_module_get_under(mrb, p_rmodule, "CC");
    struct RClass* p_rclass = mrb_class_get_under(mrb, p_rmodule, "CardinalSplineTo");
    struct RClass *rclass = mrb_define_class_under(mrb, rmodule, "CardinalSplineBy", p_rclass);
    MRB_SET_INSTANCE_TT(rclass, MRB_TT_DATA);

    mrb_define_method(mrb, rclass, "initialize", ruby_cocos2dx_CardinalSplineBy_constructor, ARGS_NONE());
}
mrb_value ruby_cocos2dx_CatmullRomTo_initWithDuration(mrb_state* mrb, mrb_value self)
{
    cocos2d::CatmullRomTo* cobj = static_cast<cocos2d::CatmullRomTo*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 2) {
            double arg0;
            ok = rubyval_to_number(mrb, argv[0], (double*)&arg0, "CC::CatmullRomTo.initWithDuration");
            if (!ok) { break; }
            cocos2d::PointArray* arg1;
            ok = rubyval_to_object<cocos2d::PointArray>(mrb, argv[1], "CC::PointArray", &arg1);
            if (!ok) { break; }
            bool retval = cobj->initWithDuration(arg0, arg1);
            mrb_value ret;
            ret = mrb_bool_value((mrb_bool)retval);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::CatmullRomTo#initWithDuration");

    return mrb_nil_value();
}

void ruby_register_cocos2dx_CatmullRomTo(mrb_state* mrb, struct RClass* rmodule)
{
    std::string typeName = typeid(cocos2d::CatmullRomTo).name();
    g_rubyType[typeName] = "CC::CatmullRomTo";
    g_rubyDataType[typeName] = &ruby_cocos2dx_Ref_type;

    struct RClass* p_rmodule = mrb->object_class;
    p_rmodule = mrb_module_get_under(mrb, p_rmodule, "CC");
    struct RClass* p_rclass = mrb_class_get_under(mrb, p_rmodule, "CardinalSplineTo");
    struct RClass *rclass = mrb_define_class_under(mrb, rmodule, "CatmullRomTo", p_rclass);
    MRB_SET_INSTANCE_TT(rclass, MRB_TT_DATA);

    mrb_define_method(mrb, rclass, "init_with_duration", ruby_cocos2dx_CatmullRomTo_initWithDuration, ARGS_REQ(2));
}
mrb_value ruby_cocos2dx_CatmullRomBy_initWithDuration(mrb_state* mrb, mrb_value self)
{
    cocos2d::CatmullRomBy* cobj = static_cast<cocos2d::CatmullRomBy*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 2) {
            double arg0;
            ok = rubyval_to_number(mrb, argv[0], (double*)&arg0, "CC::CatmullRomBy.initWithDuration");
            if (!ok) { break; }
            cocos2d::PointArray* arg1;
            ok = rubyval_to_object<cocos2d::PointArray>(mrb, argv[1], "CC::PointArray", &arg1);
            if (!ok) { break; }
            bool retval = cobj->initWithDuration(arg0, arg1);
            mrb_value ret;
            ret = mrb_bool_value((mrb_bool)retval);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::CatmullRomBy#initWithDuration");

    return mrb_nil_value();
}

void ruby_register_cocos2dx_CatmullRomBy(mrb_state* mrb, struct RClass* rmodule)
{
    std::string typeName = typeid(cocos2d::CatmullRomBy).name();
    g_rubyType[typeName] = "CC::CatmullRomBy";
    g_rubyDataType[typeName] = &ruby_cocos2dx_Ref_type;

    struct RClass* p_rmodule = mrb->object_class;
    p_rmodule = mrb_module_get_under(mrb, p_rmodule, "CC");
    struct RClass* p_rclass = mrb_class_get_under(mrb, p_rmodule, "CardinalSplineBy");
    struct RClass *rclass = mrb_define_class_under(mrb, rmodule, "CatmullRomBy", p_rclass);
    MRB_SET_INSTANCE_TT(rclass, MRB_TT_DATA);

    mrb_define_method(mrb, rclass, "init_with_duration", ruby_cocos2dx_CatmullRomBy_initWithDuration, ARGS_REQ(2));
}
mrb_value ruby_cocos2dx_ProtectedNode_addProtectedChild(mrb_state* mrb, mrb_value self)
{
    cocos2d::ProtectedNode* cobj = static_cast<cocos2d::ProtectedNode*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 2) {
            cocos2d::Node* arg0;
            ok = rubyval_to_object<cocos2d::Node>(mrb, argv[0], "CC::Node", &arg0);
            if (!ok) { break; }
            int arg1;
            ok = rubyval_to_int32(mrb, argv[1], (int*)&arg1, "CC::ProtectedNode.addProtectedChild");
            if (!ok) { break; }
            cobj->addProtectedChild(arg0, arg1);
            return self;
        }
    } while (0);
    do {
        if (argc == 1) {
            cocos2d::Node* arg0;
            ok = rubyval_to_object<cocos2d::Node>(mrb, argv[0], "CC::Node", &arg0);
            if (!ok) { break; }
            cobj->addProtectedChild(arg0);
            return self;
        }
    } while (0);
    do {
        if (argc == 3) {
            cocos2d::Node* arg0;
            ok = rubyval_to_object<cocos2d::Node>(mrb, argv[0], "CC::Node", &arg0);
            if (!ok) { break; }
            int arg1;
            ok = rubyval_to_int32(mrb, argv[1], (int*)&arg1, "CC::ProtectedNode.addProtectedChild");
            if (!ok) { break; }
            int arg2;
            ok = rubyval_to_int32(mrb, argv[2], (int*)&arg2, "CC::ProtectedNode.addProtectedChild");
            if (!ok) { break; }
            cobj->addProtectedChild(arg0, arg1, arg2);
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::ProtectedNode#addProtectedChild");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_ProtectedNode_disableCascadeColor(mrb_state* mrb, mrb_value self)
{
    cocos2d::ProtectedNode* cobj = static_cast<cocos2d::ProtectedNode*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            cobj->disableCascadeColor();
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::ProtectedNode#disableCascadeColor");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_ProtectedNode_removeProtectedChildByTag(mrb_state* mrb, mrb_value self)
{
    cocos2d::ProtectedNode* cobj = static_cast<cocos2d::ProtectedNode*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            int arg0;
            ok = rubyval_to_int32(mrb, argv[0], (int*)&arg0, "CC::ProtectedNode.removeProtectedChildByTag");
            if (!ok) { break; }
            cobj->removeProtectedChildByTag(arg0);
            return self;
        }
    } while (0);
    do {
        if (argc == 2) {
            int arg0;
            ok = rubyval_to_int32(mrb, argv[0], (int*)&arg0, "CC::ProtectedNode.removeProtectedChildByTag");
            if (!ok) { break; }
            bool arg1;
            ok = rubyval_to_boolean(mrb, argv[1], &arg1, "CC::ProtectedNode.removeProtectedChildByTag");
            if (!ok) { break; }
            cobj->removeProtectedChildByTag(arg0, arg1);
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::ProtectedNode#removeProtectedChildByTag");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_ProtectedNode_reorderProtectedChild(mrb_state* mrb, mrb_value self)
{
    cocos2d::ProtectedNode* cobj = static_cast<cocos2d::ProtectedNode*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 2) {
            cocos2d::Node* arg0;
            ok = rubyval_to_object<cocos2d::Node>(mrb, argv[0], "CC::Node", &arg0);
            if (!ok) { break; }
            int arg1;
            ok = rubyval_to_int32(mrb, argv[1], (int*)&arg1, "CC::ProtectedNode.reorderProtectedChild");
            if (!ok) { break; }
            cobj->reorderProtectedChild(arg0, arg1);
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::ProtectedNode#reorderProtectedChild");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_ProtectedNode_removeAllProtectedChildrenWithCleanup(mrb_state* mrb, mrb_value self)
{
    cocos2d::ProtectedNode* cobj = static_cast<cocos2d::ProtectedNode*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            bool arg0;
            ok = rubyval_to_boolean(mrb, argv[0], &arg0, "CC::ProtectedNode.removeAllProtectedChildrenWithCleanup");
            if (!ok) { break; }
            cobj->removeAllProtectedChildrenWithCleanup(arg0);
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::ProtectedNode#removeAllProtectedChildrenWithCleanup");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_ProtectedNode_disableCascadeOpacity(mrb_state* mrb, mrb_value self)
{
    cocos2d::ProtectedNode* cobj = static_cast<cocos2d::ProtectedNode*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            cobj->disableCascadeOpacity();
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::ProtectedNode#disableCascadeOpacity");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_ProtectedNode_sortAllProtectedChildren(mrb_state* mrb, mrb_value self)
{
    cocos2d::ProtectedNode* cobj = static_cast<cocos2d::ProtectedNode*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            cobj->sortAllProtectedChildren();
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::ProtectedNode#sortAllProtectedChildren");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_ProtectedNode_getProtectedChildByTag(mrb_state* mrb, mrb_value self)
{
    cocos2d::ProtectedNode* cobj = static_cast<cocos2d::ProtectedNode*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            int arg0;
            ok = rubyval_to_int32(mrb, argv[0], (int*)&arg0, "CC::ProtectedNode.getProtectedChildByTag");
            if (!ok) { break; }
            cocos2d::Node* retval = cobj->getProtectedChildByTag(arg0);
            mrb_value ret;
            ret = object_to_rubyval<cocos2d::Node>(mrb, "CC::Node", (cocos2d::Node*)retval, nullptr);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::ProtectedNode#getProtectedChildByTag");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_ProtectedNode_removeProtectedChild(mrb_state* mrb, mrb_value self)
{
    cocos2d::ProtectedNode* cobj = static_cast<cocos2d::ProtectedNode*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            cocos2d::Node* arg0;
            ok = rubyval_to_object<cocos2d::Node>(mrb, argv[0], "CC::Node", &arg0);
            if (!ok) { break; }
            cobj->removeProtectedChild(arg0);
            return self;
        }
    } while (0);
    do {
        if (argc == 2) {
            cocos2d::Node* arg0;
            ok = rubyval_to_object<cocos2d::Node>(mrb, argv[0], "CC::Node", &arg0);
            if (!ok) { break; }
            bool arg1;
            ok = rubyval_to_boolean(mrb, argv[1], &arg1, "CC::ProtectedNode.removeProtectedChild");
            if (!ok) { break; }
            cobj->removeProtectedChild(arg0, arg1);
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::ProtectedNode#removeProtectedChild");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_ProtectedNode_removeAllProtectedChildren(mrb_state* mrb, mrb_value self)
{
    cocos2d::ProtectedNode* cobj = static_cast<cocos2d::ProtectedNode*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            cobj->removeAllProtectedChildren();
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::ProtectedNode#removeAllProtectedChildren");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_ProtectedNode_create_static(mrb_state* mrb, mrb_value self)
{
    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            std::map<std::string, mrb_value> callbacks;
            cocos2d::ProtectedNode* retval = cocos2d::ProtectedNode::create();
            mrb_value ret;
            RClass* rclass = mrb_class_ptr(self);
            ret = object_to_rubyval<cocos2d::ProtectedNode>(mrb, "CC::ProtectedNode", (cocos2d::ProtectedNode*)retval, rclass);
            if (callbacks.size() > 0) {
                mrb_value hash = mrb_iv_get(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"));
                if (!mrb_hash_p(hash)) {
                    hash = mrb_hash_new(mrb);
                }
                for (auto elm : callbacks) {
                    mrb_hash_set(mrb, hash, mrb_str_new_cstr(mrb, elm.first.c_str()), elm.second);
                    mrb_iv_set(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"), hash);
                }
            }
            g_rubyValue.push_back(ret);
            mrb_funcall(mrb, ret, "initialize", 0);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined static method : cocos2d::ProtectedNode#create");

    return mrb_nil_value();
}

void ruby_register_cocos2dx_ProtectedNode(mrb_state* mrb, struct RClass* rmodule)
{
    std::string typeName = typeid(cocos2d::ProtectedNode).name();
    g_rubyType[typeName] = "CC::ProtectedNode";
    g_rubyDataType[typeName] = &ruby_cocos2dx_Ref_type;

    struct RClass* p_rmodule = mrb->object_class;
    p_rmodule = mrb_module_get_under(mrb, p_rmodule, "CC");
    struct RClass* p_rclass = mrb_class_get_under(mrb, p_rmodule, "Node");
    struct RClass *rclass = mrb_define_class_under(mrb, rmodule, "ProtectedNode", p_rclass);
    MRB_SET_INSTANCE_TT(rclass, MRB_TT_DATA);

    mrb_define_method(mrb, rclass, "add_protected_child", ruby_cocos2dx_ProtectedNode_addProtectedChild, ARGS_REQ(1)|ARGS_OPT(2));
    mrb_define_method(mrb, rclass, "disable_cascade_color", ruby_cocos2dx_ProtectedNode_disableCascadeColor, ARGS_NONE());
    mrb_define_method(mrb, rclass, "remove_protected_child_by_tag", ruby_cocos2dx_ProtectedNode_removeProtectedChildByTag, ARGS_REQ(2));
    mrb_define_method(mrb, rclass, "reorder_protected_child", ruby_cocos2dx_ProtectedNode_reorderProtectedChild, ARGS_REQ(2));
    mrb_define_method(mrb, rclass, "remove_all_protected_children_with_cleanup", ruby_cocos2dx_ProtectedNode_removeAllProtectedChildrenWithCleanup, ARGS_REQ(1));
    mrb_define_method(mrb, rclass, "disable_cascade_opacity", ruby_cocos2dx_ProtectedNode_disableCascadeOpacity, ARGS_NONE());
    mrb_define_method(mrb, rclass, "sort_all_protected_children", ruby_cocos2dx_ProtectedNode_sortAllProtectedChildren, ARGS_NONE());
    mrb_define_method(mrb, rclass, "get_protected_child_by_tag", ruby_cocos2dx_ProtectedNode_getProtectedChildByTag, ARGS_REQ(1));
    mrb_define_method(mrb, rclass, "remove_protected_child", ruby_cocos2dx_ProtectedNode_removeProtectedChild, ARGS_REQ(2));
    mrb_define_method(mrb, rclass, "remove_all_protected_children", ruby_cocos2dx_ProtectedNode_removeAllProtectedChildren, ARGS_NONE());
    mrb_define_class_method(mrb, rclass, "create", ruby_cocos2dx_ProtectedNode_create_static, ARGS_NONE());
}
mrb_value ruby_cocos2dx_GLProgramState_setUniformTexture(mrb_state* mrb, mrb_value self)
{
    cocos2d::GLProgramState* cobj = static_cast<cocos2d::GLProgramState*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 2) {
            std::string arg0;
            ok = rubyval_to_std_string(mrb, argv[0], &arg0, "CC::GLProgramState.setUniformTexture");
            if (!ok) { break; }
            unsigned int arg1;
            ok = rubyval_to_uint32(mrb, argv[1], &arg1, "CC::GLProgramState.setUniformTexture");
            if (!ok) { break; }
            cobj->setUniformTexture(arg0, arg1);
            return self;
        }
    } while (0);
    do {
        if (argc == 2) {
            std::string arg0;
            ok = rubyval_to_std_string(mrb, argv[0], &arg0, "CC::GLProgramState.setUniformTexture");
            if (!ok) { break; }
            cocos2d::Texture2D* arg1;
            ok = rubyval_to_object<cocos2d::Texture2D>(mrb, argv[1], "CC::Texture2D", &arg1);
            if (!ok) { break; }
            cobj->setUniformTexture(arg0, arg1);
            return self;
        }
    } while (0);
    do {
        if (argc == 2) {
            int arg0;
            ok = rubyval_to_int32(mrb, argv[0], (int*)&arg0, "CC::GLProgramState.setUniformTexture");
            if (!ok) { break; }
            cocos2d::Texture2D* arg1;
            ok = rubyval_to_object<cocos2d::Texture2D>(mrb, argv[1], "CC::Texture2D", &arg1);
            if (!ok) { break; }
            cobj->setUniformTexture(arg0, arg1);
            return self;
        }
    } while (0);
    do {
        if (argc == 2) {
            int arg0;
            ok = rubyval_to_int32(mrb, argv[0], (int*)&arg0, "CC::GLProgramState.setUniformTexture");
            if (!ok) { break; }
            unsigned int arg1;
            ok = rubyval_to_uint32(mrb, argv[1], &arg1, "CC::GLProgramState.setUniformTexture");
            if (!ok) { break; }
            cobj->setUniformTexture(arg0, arg1);
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::GLProgramState#setUniformTexture");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_GLProgramState_setUniformMat4(mrb_state* mrb, mrb_value self)
{
    cocos2d::GLProgramState* cobj = static_cast<cocos2d::GLProgramState*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 2) {
            int arg0;
            ok = rubyval_to_int32(mrb, argv[0], (int*)&arg0, "CC::GLProgramState.setUniformMat4");
            if (!ok) { break; }
            cocos2d::Mat4* arg1;
            ok = rubyval_to_object<cocos2d::Mat4>(mrb, argv[1], "CC::Mat4", &arg1);
            if (!ok) { break; }
            cobj->setUniformMat4(arg0, *arg1);
            return self;
        }
    } while (0);
    do {
        if (argc == 2) {
            std::string arg0;
            ok = rubyval_to_std_string(mrb, argv[0], &arg0, "CC::GLProgramState.setUniformMat4");
            if (!ok) { break; }
            cocos2d::Mat4* arg1;
            ok = rubyval_to_object<cocos2d::Mat4>(mrb, argv[1], "CC::Mat4", &arg1);
            if (!ok) { break; }
            cobj->setUniformMat4(arg0, *arg1);
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::GLProgramState#setUniformMat4");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_GLProgramState_applyUniforms(mrb_state* mrb, mrb_value self)
{
    cocos2d::GLProgramState* cobj = static_cast<cocos2d::GLProgramState*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            cobj->applyUniforms();
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::GLProgramState#applyUniforms");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_GLProgramState_applyGLProgram(mrb_state* mrb, mrb_value self)
{
    cocos2d::GLProgramState* cobj = static_cast<cocos2d::GLProgramState*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            cocos2d::Mat4* arg0;
            ok = rubyval_to_object<cocos2d::Mat4>(mrb, argv[0], "CC::Mat4", &arg0);
            if (!ok) { break; }
            cobj->applyGLProgram(*arg0);
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::GLProgramState#applyGLProgram");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_GLProgramState_getUniformCount(mrb_state* mrb, mrb_value self)
{
    cocos2d::GLProgramState* cobj = static_cast<cocos2d::GLProgramState*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            ssize_t retval = cobj->getUniformCount();
            mrb_value ret;
            ret = mrb_fixnum_value((mrb_int)retval);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::GLProgramState#getUniformCount");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_GLProgramState_applyAttributes(mrb_state* mrb, mrb_value self)
{
    cocos2d::GLProgramState* cobj = static_cast<cocos2d::GLProgramState*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 0) {
            cobj->applyAttributes();
            return self;
        }
    } while (0);
    do {
        if (argc == 1) {
            bool arg0;
            ok = rubyval_to_boolean(mrb, argv[0], &arg0, "CC::GLProgramState.applyAttributes");
            if (!ok) { break; }
            cobj->applyAttributes(arg0);
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::GLProgramState#applyAttributes");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_GLProgramState_setUniformFloat(mrb_state* mrb, mrb_value self)
{
    cocos2d::GLProgramState* cobj = static_cast<cocos2d::GLProgramState*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 2) {
            int arg0;
            ok = rubyval_to_int32(mrb, argv[0], (int*)&arg0, "CC::GLProgramState.setUniformFloat");
            if (!ok) { break; }
            double arg1;
            ok = rubyval_to_number(mrb, argv[1], (double*)&arg1, "CC::GLProgramState.setUniformFloat");
            if (!ok) { break; }
            cobj->setUniformFloat(arg0, arg1);
            return self;
        }
    } while (0);
    do {
        if (argc == 2) {
            std::string arg0;
            ok = rubyval_to_std_string(mrb, argv[0], &arg0, "CC::GLProgramState.setUniformFloat");
            if (!ok) { break; }
            double arg1;
            ok = rubyval_to_number(mrb, argv[1], (double*)&arg1, "CC::GLProgramState.setUniformFloat");
            if (!ok) { break; }
            cobj->setUniformFloat(arg0, arg1);
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::GLProgramState#setUniformFloat");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_GLProgramState_setUniformVec3(mrb_state* mrb, mrb_value self)
{
    cocos2d::GLProgramState* cobj = static_cast<cocos2d::GLProgramState*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 2) {
            int arg0;
            ok = rubyval_to_int32(mrb, argv[0], (int*)&arg0, "CC::GLProgramState.setUniformVec3");
            if (!ok) { break; }
            cocos2d::Vec3* arg1;
            ok = rubyval_to_object<cocos2d::Vec3>(mrb, argv[1], "CC::Vec3", &arg1);
            if (!ok) { break; }
            cobj->setUniformVec3(arg0, *arg1);
            return self;
        }
    } while (0);
    do {
        if (argc == 2) {
            std::string arg0;
            ok = rubyval_to_std_string(mrb, argv[0], &arg0, "CC::GLProgramState.setUniformVec3");
            if (!ok) { break; }
            cocos2d::Vec3* arg1;
            ok = rubyval_to_object<cocos2d::Vec3>(mrb, argv[1], "CC::Vec3", &arg1);
            if (!ok) { break; }
            cobj->setUniformVec3(arg0, *arg1);
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::GLProgramState#setUniformVec3");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_GLProgramState_setUniformInt(mrb_state* mrb, mrb_value self)
{
    cocos2d::GLProgramState* cobj = static_cast<cocos2d::GLProgramState*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 2) {
            int arg0;
            ok = rubyval_to_int32(mrb, argv[0], (int*)&arg0, "CC::GLProgramState.setUniformInt");
            if (!ok) { break; }
            int arg1;
            ok = rubyval_to_int32(mrb, argv[1], (int*)&arg1, "CC::GLProgramState.setUniformInt");
            if (!ok) { break; }
            cobj->setUniformInt(arg0, arg1);
            return self;
        }
    } while (0);
    do {
        if (argc == 2) {
            std::string arg0;
            ok = rubyval_to_std_string(mrb, argv[0], &arg0, "CC::GLProgramState.setUniformInt");
            if (!ok) { break; }
            int arg1;
            ok = rubyval_to_int32(mrb, argv[1], (int*)&arg1, "CC::GLProgramState.setUniformInt");
            if (!ok) { break; }
            cobj->setUniformInt(arg0, arg1);
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::GLProgramState#setUniformInt");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_GLProgramState_getVertexAttribCount(mrb_state* mrb, mrb_value self)
{
    cocos2d::GLProgramState* cobj = static_cast<cocos2d::GLProgramState*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            ssize_t retval = cobj->getVertexAttribCount();
            mrb_value ret;
            ret = mrb_fixnum_value((mrb_int)retval);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::GLProgramState#getVertexAttribCount");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_GLProgramState_setUniformVec4(mrb_state* mrb, mrb_value self)
{
    cocos2d::GLProgramState* cobj = static_cast<cocos2d::GLProgramState*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 2) {
            int arg0;
            ok = rubyval_to_int32(mrb, argv[0], (int*)&arg0, "CC::GLProgramState.setUniformVec4");
            if (!ok) { break; }
            cocos2d::Vec4* arg1;
            ok = rubyval_to_object<cocos2d::Vec4>(mrb, argv[1], "CC::Vec4", &arg1);
            if (!ok) { break; }
            cobj->setUniformVec4(arg0, *arg1);
            return self;
        }
    } while (0);
    do {
        if (argc == 2) {
            std::string arg0;
            ok = rubyval_to_std_string(mrb, argv[0], &arg0, "CC::GLProgramState.setUniformVec4");
            if (!ok) { break; }
            cocos2d::Vec4* arg1;
            ok = rubyval_to_object<cocos2d::Vec4>(mrb, argv[1], "CC::Vec4", &arg1);
            if (!ok) { break; }
            cobj->setUniformVec4(arg0, *arg1);
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::GLProgramState#setUniformVec4");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_GLProgramState_setGLProgram(mrb_state* mrb, mrb_value self)
{
    cocos2d::GLProgramState* cobj = static_cast<cocos2d::GLProgramState*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            cocos2d::GLProgram* arg0;
            ok = rubyval_to_object<cocos2d::GLProgram>(mrb, argv[0], "CC::GLProgram", &arg0);
            if (!ok) { break; }
            cobj->setGLProgram(arg0);
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::GLProgramState#setGLProgram");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_GLProgramState_setUniformVec2(mrb_state* mrb, mrb_value self)
{
    cocos2d::GLProgramState* cobj = static_cast<cocos2d::GLProgramState*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 2) {
            int arg0;
            ok = rubyval_to_int32(mrb, argv[0], (int*)&arg0, "CC::GLProgramState.setUniformVec2");
            if (!ok) { break; }
            cocos2d::Vec2* arg1;
            ok = rubyval_to_object<cocos2d::Vec2>(mrb, argv[1], "CC::Vec2", &arg1);
            if (!ok) { break; }
            cobj->setUniformVec2(arg0, *arg1);
            return self;
        }
    } while (0);
    do {
        if (argc == 2) {
            std::string arg0;
            ok = rubyval_to_std_string(mrb, argv[0], &arg0, "CC::GLProgramState.setUniformVec2");
            if (!ok) { break; }
            cocos2d::Vec2* arg1;
            ok = rubyval_to_object<cocos2d::Vec2>(mrb, argv[1], "CC::Vec2", &arg1);
            if (!ok) { break; }
            cobj->setUniformVec2(arg0, *arg1);
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::GLProgramState#setUniformVec2");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_GLProgramState_getVertexAttribsFlags(mrb_state* mrb, mrb_value self)
{
    cocos2d::GLProgramState* cobj = static_cast<cocos2d::GLProgramState*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            unsigned int retval = cobj->getVertexAttribsFlags();
            mrb_value ret;
            ret = mrb_fixnum_value((mrb_int)retval);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::GLProgramState#getVertexAttribsFlags");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_GLProgramState_apply(mrb_state* mrb, mrb_value self)
{
    cocos2d::GLProgramState* cobj = static_cast<cocos2d::GLProgramState*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            cocos2d::Mat4* arg0;
            ok = rubyval_to_object<cocos2d::Mat4>(mrb, argv[0], "CC::Mat4", &arg0);
            if (!ok) { break; }
            cobj->apply(*arg0);
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::GLProgramState#apply");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_GLProgramState_getGLProgram(mrb_state* mrb, mrb_value self)
{
    cocos2d::GLProgramState* cobj = static_cast<cocos2d::GLProgramState*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            cocos2d::GLProgram* retval = cobj->getGLProgram();
            mrb_value ret;
            ret = object_to_rubyval<cocos2d::GLProgram>(mrb, "CC::GLProgram", (cocos2d::GLProgram*)retval, nullptr);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::GLProgramState#getGLProgram");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_GLProgramState_create_static(mrb_state* mrb, mrb_value self)
{
    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            std::map<std::string, mrb_value> callbacks;
            cocos2d::GLProgram* arg0;
            ok = rubyval_to_object<cocos2d::GLProgram>(mrb, argv[0], "CC::GLProgram", &arg0);
            if (!ok) { break; }

            cocos2d::GLProgramState* retval = cocos2d::GLProgramState::create(arg0);
            mrb_value ret;
            RClass* rclass = mrb_class_ptr(self);
            ret = object_to_rubyval<cocos2d::GLProgramState>(mrb, "CC::GLProgramState", (cocos2d::GLProgramState*)retval, rclass);
            if (callbacks.size() > 0) {
                mrb_value hash = mrb_iv_get(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"));
                if (!mrb_hash_p(hash)) {
                    hash = mrb_hash_new(mrb);
                }
                for (auto elm : callbacks) {
                    mrb_hash_set(mrb, hash, mrb_str_new_cstr(mrb, elm.first.c_str()), elm.second);
                    mrb_iv_set(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"), hash);
                }
            }
            g_rubyValue.push_back(ret);
            mrb_funcall(mrb, ret, "initialize", 0);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined static method : cocos2d::GLProgramState#create");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_GLProgramState_getOrCreateWithGLProgramName_static(mrb_state* mrb, mrb_value self)
{
    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            std::string arg0;
            ok = rubyval_to_std_string(mrb, argv[0], &arg0, "CC::GLProgramState.getOrCreateWithGLProgramName");
            if (!ok) { break; }

            cocos2d::GLProgramState* retval = cocos2d::GLProgramState::getOrCreateWithGLProgramName(arg0);
            mrb_value ret;
            ret = object_to_rubyval<cocos2d::GLProgramState>(mrb, "CC::GLProgramState", (cocos2d::GLProgramState*)retval, nullptr);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined static method : cocos2d::GLProgramState#getOrCreateWithGLProgramName");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_GLProgramState_getOrCreateWithGLProgram_static(mrb_state* mrb, mrb_value self)
{
    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            cocos2d::GLProgram* arg0;
            ok = rubyval_to_object<cocos2d::GLProgram>(mrb, argv[0], "CC::GLProgram", &arg0);
            if (!ok) { break; }

            cocos2d::GLProgramState* retval = cocos2d::GLProgramState::getOrCreateWithGLProgram(arg0);
            mrb_value ret;
            ret = object_to_rubyval<cocos2d::GLProgramState>(mrb, "CC::GLProgramState", (cocos2d::GLProgramState*)retval, nullptr);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined static method : cocos2d::GLProgramState#getOrCreateWithGLProgram");

    return mrb_nil_value();
}

void ruby_register_cocos2dx_GLProgramState(mrb_state* mrb, struct RClass* rmodule)
{
    std::string typeName = typeid(cocos2d::GLProgramState).name();
    g_rubyType[typeName] = "CC::GLProgramState";
    g_rubyDataType[typeName] = &ruby_cocos2dx_Ref_type;

    struct RClass* p_rmodule = mrb->object_class;
    p_rmodule = mrb_module_get_under(mrb, p_rmodule, "CC");
    struct RClass* p_rclass = mrb_class_get_under(mrb, p_rmodule, "Ref");
    struct RClass *rclass = mrb_define_class_under(mrb, rmodule, "GLProgramState", p_rclass);
    MRB_SET_INSTANCE_TT(rclass, MRB_TT_DATA);

    mrb_define_method(mrb, rclass, "set_uniform_texture", ruby_cocos2dx_GLProgramState_setUniformTexture, ARGS_REQ(2));
    mrb_define_method(mrb, rclass, "set_uniform_mat4", ruby_cocos2dx_GLProgramState_setUniformMat4, ARGS_REQ(2));
    mrb_define_method(mrb, rclass, "apply_uniforms", ruby_cocos2dx_GLProgramState_applyUniforms, ARGS_NONE());
    mrb_define_method(mrb, rclass, "apply_glprogram", ruby_cocos2dx_GLProgramState_applyGLProgram, ARGS_REQ(1));
    mrb_define_method(mrb, rclass, "get_uniform_count", ruby_cocos2dx_GLProgramState_getUniformCount, ARGS_NONE());
    mrb_define_method(mrb, rclass, "apply_attributes", ruby_cocos2dx_GLProgramState_applyAttributes, ARGS_REQ(1));
    mrb_define_method(mrb, rclass, "set_uniform_float", ruby_cocos2dx_GLProgramState_setUniformFloat, ARGS_REQ(2));
    mrb_define_method(mrb, rclass, "set_uniform_vec3", ruby_cocos2dx_GLProgramState_setUniformVec3, ARGS_REQ(2));
    mrb_define_method(mrb, rclass, "set_uniform_int", ruby_cocos2dx_GLProgramState_setUniformInt, ARGS_REQ(2));
    mrb_define_method(mrb, rclass, "get_vertex_attrib_count", ruby_cocos2dx_GLProgramState_getVertexAttribCount, ARGS_NONE());
    mrb_define_method(mrb, rclass, "set_uniform_vec4", ruby_cocos2dx_GLProgramState_setUniformVec4, ARGS_REQ(2));
    mrb_define_method(mrb, rclass, "set_glprogram", ruby_cocos2dx_GLProgramState_setGLProgram, ARGS_REQ(1));
    mrb_define_method(mrb, rclass, "set_uniform_vec2", ruby_cocos2dx_GLProgramState_setUniformVec2, ARGS_REQ(2));
    mrb_define_method(mrb, rclass, "get_vertex_attribs_flags", ruby_cocos2dx_GLProgramState_getVertexAttribsFlags, ARGS_NONE());
    mrb_define_method(mrb, rclass, "apply", ruby_cocos2dx_GLProgramState_apply, ARGS_REQ(1));
    mrb_define_method(mrb, rclass, "get_glprogram", ruby_cocos2dx_GLProgramState_getGLProgram, ARGS_NONE());
    mrb_define_class_method(mrb, rclass, "create", ruby_cocos2dx_GLProgramState_create_static, ARGS_REQ(1));
    mrb_define_class_method(mrb, rclass, "get_or_create_with_glprogram_name", ruby_cocos2dx_GLProgramState_getOrCreateWithGLProgramName_static, ARGS_REQ(1));
    mrb_define_class_method(mrb, rclass, "get_or_create_with_glprogram", ruby_cocos2dx_GLProgramState_getOrCreateWithGLProgram_static, ARGS_REQ(1));
}
mrb_value ruby_cocos2dx_AtlasNode_updateAtlasValues(mrb_state* mrb, mrb_value self)
{
    cocos2d::AtlasNode* cobj = static_cast<cocos2d::AtlasNode*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            cobj->updateAtlasValues();
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::AtlasNode#updateAtlasValues");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_AtlasNode_getTexture(mrb_state* mrb, mrb_value self)
{
    cocos2d::AtlasNode* cobj = static_cast<cocos2d::AtlasNode*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            cocos2d::Texture2D* retval = cobj->getTexture();
            mrb_value ret;
            ret = object_to_rubyval<cocos2d::Texture2D>(mrb, "CC::Texture2D", (cocos2d::Texture2D*)retval, nullptr);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::AtlasNode#getTexture");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_AtlasNode_setTextureAtlas(mrb_state* mrb, mrb_value self)
{
    cocos2d::AtlasNode* cobj = static_cast<cocos2d::AtlasNode*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            cocos2d::TextureAtlas* arg0;
            ok = rubyval_to_object<cocos2d::TextureAtlas>(mrb, argv[0], "CC::TextureAtlas", &arg0);
            if (!ok) { break; }
            cobj->setTextureAtlas(arg0);
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::AtlasNode#setTextureAtlas");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_AtlasNode_setBlendFunc(mrb_state* mrb, mrb_value self)
{
    cocos2d::AtlasNode* cobj = static_cast<cocos2d::AtlasNode*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            cocos2d::BlendFunc* arg0;
            ok = rubyval_to_object<cocos2d::BlendFunc>(mrb, argv[0], "CC::BlendFunc", &arg0);
            if (!ok) { break; }
            cobj->setBlendFunc(*arg0);
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::AtlasNode#setBlendFunc");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_AtlasNode_getTextureAtlas(mrb_state* mrb, mrb_value self)
{
    cocos2d::AtlasNode* cobj = static_cast<cocos2d::AtlasNode*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            cocos2d::TextureAtlas* retval = cobj->getTextureAtlas();
            mrb_value ret;
            ret = object_to_rubyval<cocos2d::TextureAtlas>(mrb, "CC::TextureAtlas", (cocos2d::TextureAtlas*)retval, nullptr);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::AtlasNode#getTextureAtlas");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_AtlasNode_getBlendFunc(mrb_state* mrb, mrb_value self)
{
    cocos2d::AtlasNode* cobj = static_cast<cocos2d::AtlasNode*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            cocos2d::BlendFunc retval = cobj->getBlendFunc();
            cocos2d::BlendFunc* retval_ptr = new cocos2d::BlendFunc(retval);
            mrb_value ret;
            ret = object_to_rubyval<cocos2d::BlendFunc>(mrb, "CC::BlendFunc", (cocos2d::BlendFunc*)retval_ptr, nullptr);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::AtlasNode#getBlendFunc");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_AtlasNode_getQuadsToDraw(mrb_state* mrb, mrb_value self)
{
    cocos2d::AtlasNode* cobj = static_cast<cocos2d::AtlasNode*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            ssize_t retval = cobj->getQuadsToDraw();
            mrb_value ret;
            ret = mrb_fixnum_value((mrb_int)retval);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::AtlasNode#getQuadsToDraw");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_AtlasNode_setTexture(mrb_state* mrb, mrb_value self)
{
    cocos2d::AtlasNode* cobj = static_cast<cocos2d::AtlasNode*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            cocos2d::Texture2D* arg0;
            ok = rubyval_to_object<cocos2d::Texture2D>(mrb, argv[0], "CC::Texture2D", &arg0);
            if (!ok) { break; }
            cobj->setTexture(arg0);
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::AtlasNode#setTexture");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_AtlasNode_setQuadsToDraw(mrb_state* mrb, mrb_value self)
{
    cocos2d::AtlasNode* cobj = static_cast<cocos2d::AtlasNode*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            ssize_t arg0;
            ok = rubyval_to_ssize(mrb, argv[0], &arg0, "CC::AtlasNode.setQuadsToDraw");
            if (!ok) { break; }
            cobj->setQuadsToDraw(arg0);
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::AtlasNode#setQuadsToDraw");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_AtlasNode_create_static(mrb_state* mrb, mrb_value self)
{
    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 4) {
            std::map<std::string, mrb_value> callbacks;
            std::string arg0;
            ok = rubyval_to_std_string(mrb, argv[0], &arg0, "CC::AtlasNode.create");
            if (!ok) { break; }

            int arg1;
            ok = rubyval_to_int32(mrb, argv[1], (int*)&arg1, "CC::AtlasNode.create");
            if (!ok) { break; }

            int arg2;
            ok = rubyval_to_int32(mrb, argv[2], (int*)&arg2, "CC::AtlasNode.create");
            if (!ok) { break; }

            int arg3;
            ok = rubyval_to_int32(mrb, argv[3], (int*)&arg3, "CC::AtlasNode.create");
            if (!ok) { break; }

            cocos2d::AtlasNode* retval = cocos2d::AtlasNode::create(arg0, arg1, arg2, arg3);
            mrb_value ret;
            RClass* rclass = mrb_class_ptr(self);
            ret = object_to_rubyval<cocos2d::AtlasNode>(mrb, "CC::AtlasNode", (cocos2d::AtlasNode*)retval, rclass);
            if (callbacks.size() > 0) {
                mrb_value hash = mrb_iv_get(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"));
                if (!mrb_hash_p(hash)) {
                    hash = mrb_hash_new(mrb);
                }
                for (auto elm : callbacks) {
                    mrb_hash_set(mrb, hash, mrb_str_new_cstr(mrb, elm.first.c_str()), elm.second);
                    mrb_iv_set(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"), hash);
                }
            }
            g_rubyValue.push_back(ret);
            mrb_funcall(mrb, ret, "initialize", 0);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined static method : cocos2d::AtlasNode#create");

    return mrb_nil_value();
}

void ruby_register_cocos2dx_AtlasNode(mrb_state* mrb, struct RClass* rmodule)
{
    std::string typeName = typeid(cocos2d::AtlasNode).name();
    g_rubyType[typeName] = "CC::AtlasNode";
    g_rubyDataType[typeName] = &ruby_cocos2dx_Ref_type;

    struct RClass* p_rmodule = mrb->object_class;
    p_rmodule = mrb_module_get_under(mrb, p_rmodule, "CC");
    struct RClass* p_rclass = mrb_class_get_under(mrb, p_rmodule, "Node");
    struct RClass *rclass = mrb_define_class_under(mrb, rmodule, "AtlasNode", p_rclass);
    MRB_SET_INSTANCE_TT(rclass, MRB_TT_DATA);

    mrb_define_method(mrb, rclass, "update_atlas_values", ruby_cocos2dx_AtlasNode_updateAtlasValues, ARGS_NONE());
    mrb_define_method(mrb, rclass, "get_texture", ruby_cocos2dx_AtlasNode_getTexture, ARGS_NONE());
    mrb_define_method(mrb, rclass, "set_texture_atlas", ruby_cocos2dx_AtlasNode_setTextureAtlas, ARGS_REQ(1));
    mrb_define_method(mrb, rclass, "set_blend_func", ruby_cocos2dx_AtlasNode_setBlendFunc, ARGS_REQ(1));
    mrb_define_method(mrb, rclass, "get_texture_atlas", ruby_cocos2dx_AtlasNode_getTextureAtlas, ARGS_NONE());
    mrb_define_method(mrb, rclass, "get_blend_func", ruby_cocos2dx_AtlasNode_getBlendFunc, ARGS_NONE());
    mrb_define_method(mrb, rclass, "get_quads_to_draw", ruby_cocos2dx_AtlasNode_getQuadsToDraw, ARGS_NONE());
    mrb_define_method(mrb, rclass, "set_texture", ruby_cocos2dx_AtlasNode_setTexture, ARGS_REQ(1));
    mrb_define_method(mrb, rclass, "set_quads_to_draw", ruby_cocos2dx_AtlasNode_setQuadsToDraw, ARGS_REQ(1));
    mrb_define_class_method(mrb, rclass, "create", ruby_cocos2dx_AtlasNode_create_static, ARGS_REQ(4));
}
mrb_value ruby_cocos2dx_DrawNode_drawLine(mrb_state* mrb, mrb_value self)
{
    cocos2d::DrawNode* cobj = static_cast<cocos2d::DrawNode*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 3) {
            cocos2d::Vec2* arg0;
            ok = rubyval_to_object<cocos2d::Vec2>(mrb, argv[0], "CC::Vec2", &arg0);
            if (!ok) { break; }
            cocos2d::Vec2* arg1;
            ok = rubyval_to_object<cocos2d::Vec2>(mrb, argv[1], "CC::Vec2", &arg1);
            if (!ok) { break; }
            cocos2d::Color4F* arg2;
            ok = rubyval_to_object<cocos2d::Color4F>(mrb, argv[2], "CC::Color4F", &arg2);
            if (!ok) { break; }
            cobj->drawLine(*arg0, *arg1, *arg2);
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::DrawNode#drawLine");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_DrawNode_drawRect(mrb_state* mrb, mrb_value self)
{
    cocos2d::DrawNode* cobj = static_cast<cocos2d::DrawNode*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 5) {
            cocos2d::Vec2* arg0;
            ok = rubyval_to_object<cocos2d::Vec2>(mrb, argv[0], "CC::Vec2", &arg0);
            if (!ok) { break; }
            cocos2d::Vec2* arg1;
            ok = rubyval_to_object<cocos2d::Vec2>(mrb, argv[1], "CC::Vec2", &arg1);
            if (!ok) { break; }
            cocos2d::Vec2* arg2;
            ok = rubyval_to_object<cocos2d::Vec2>(mrb, argv[2], "CC::Vec2", &arg2);
            if (!ok) { break; }
            cocos2d::Vec2* arg3;
            ok = rubyval_to_object<cocos2d::Vec2>(mrb, argv[3], "CC::Vec2", &arg3);
            if (!ok) { break; }
            cocos2d::Color4F* arg4;
            ok = rubyval_to_object<cocos2d::Color4F>(mrb, argv[4], "CC::Color4F", &arg4);
            if (!ok) { break; }
            cobj->drawRect(*arg0, *arg1, *arg2, *arg3, *arg4);
            return self;
        }
    } while (0);
    do {
        if (argc == 3) {
            cocos2d::Vec2* arg0;
            ok = rubyval_to_object<cocos2d::Vec2>(mrb, argv[0], "CC::Vec2", &arg0);
            if (!ok) { break; }
            cocos2d::Vec2* arg1;
            ok = rubyval_to_object<cocos2d::Vec2>(mrb, argv[1], "CC::Vec2", &arg1);
            if (!ok) { break; }
            cocos2d::Color4F* arg2;
            ok = rubyval_to_object<cocos2d::Color4F>(mrb, argv[2], "CC::Color4F", &arg2);
            if (!ok) { break; }
            cobj->drawRect(*arg0, *arg1, *arg2);
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::DrawNode#drawRect");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_DrawNode_drawSolidCircle(mrb_state* mrb, mrb_value self)
{
    cocos2d::DrawNode* cobj = static_cast<cocos2d::DrawNode*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 5) {
            cocos2d::Vec2* arg0;
            ok = rubyval_to_object<cocos2d::Vec2>(mrb, argv[0], "CC::Vec2", &arg0);
            if (!ok) { break; }
            double arg1;
            ok = rubyval_to_number(mrb, argv[1], (double*)&arg1, "CC::DrawNode.drawSolidCircle");
            if (!ok) { break; }
            double arg2;
            ok = rubyval_to_number(mrb, argv[2], (double*)&arg2, "CC::DrawNode.drawSolidCircle");
            if (!ok) { break; }
            unsigned int arg3;
            ok = rubyval_to_uint32(mrb, argv[3], &arg3, "CC::DrawNode.drawSolidCircle");
            if (!ok) { break; }
            cocos2d::Color4F* arg4;
            ok = rubyval_to_object<cocos2d::Color4F>(mrb, argv[4], "CC::Color4F", &arg4);
            if (!ok) { break; }
            cobj->drawSolidCircle(*arg0, arg1, arg2, arg3, *arg4);
            return self;
        }
    } while (0);
    do {
        if (argc == 7) {
            cocos2d::Vec2* arg0;
            ok = rubyval_to_object<cocos2d::Vec2>(mrb, argv[0], "CC::Vec2", &arg0);
            if (!ok) { break; }
            double arg1;
            ok = rubyval_to_number(mrb, argv[1], (double*)&arg1, "CC::DrawNode.drawSolidCircle");
            if (!ok) { break; }
            double arg2;
            ok = rubyval_to_number(mrb, argv[2], (double*)&arg2, "CC::DrawNode.drawSolidCircle");
            if (!ok) { break; }
            unsigned int arg3;
            ok = rubyval_to_uint32(mrb, argv[3], &arg3, "CC::DrawNode.drawSolidCircle");
            if (!ok) { break; }
            double arg4;
            ok = rubyval_to_number(mrb, argv[4], (double*)&arg4, "CC::DrawNode.drawSolidCircle");
            if (!ok) { break; }
            double arg5;
            ok = rubyval_to_number(mrb, argv[5], (double*)&arg5, "CC::DrawNode.drawSolidCircle");
            if (!ok) { break; }
            cocos2d::Color4F* arg6;
            ok = rubyval_to_object<cocos2d::Color4F>(mrb, argv[6], "CC::Color4F", &arg6);
            if (!ok) { break; }
            cobj->drawSolidCircle(*arg0, arg1, arg2, arg3, arg4, arg5, *arg6);
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::DrawNode#drawSolidCircle");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_DrawNode_onDrawGLPoint(mrb_state* mrb, mrb_value self)
{
    cocos2d::DrawNode* cobj = static_cast<cocos2d::DrawNode*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 2) {
            cocos2d::Mat4* arg0;
            ok = rubyval_to_object<cocos2d::Mat4>(mrb, argv[0], "CC::Mat4", &arg0);
            if (!ok) { break; }
            unsigned int arg1;
            ok = rubyval_to_uint32(mrb, argv[1], &arg1, "CC::DrawNode.onDrawGLPoint");
            if (!ok) { break; }
            cobj->onDrawGLPoint(*arg0, arg1);
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::DrawNode#onDrawGLPoint");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_DrawNode_drawDot(mrb_state* mrb, mrb_value self)
{
    cocos2d::DrawNode* cobj = static_cast<cocos2d::DrawNode*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 3) {
            cocos2d::Vec2* arg0;
            ok = rubyval_to_object<cocos2d::Vec2>(mrb, argv[0], "CC::Vec2", &arg0);
            if (!ok) { break; }
            double arg1;
            ok = rubyval_to_number(mrb, argv[1], (double*)&arg1, "CC::DrawNode.drawDot");
            if (!ok) { break; }
            cocos2d::Color4F* arg2;
            ok = rubyval_to_object<cocos2d::Color4F>(mrb, argv[2], "CC::Color4F", &arg2);
            if (!ok) { break; }
            cobj->drawDot(*arg0, arg1, *arg2);
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::DrawNode#drawDot");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_DrawNode_drawSegment(mrb_state* mrb, mrb_value self)
{
    cocos2d::DrawNode* cobj = static_cast<cocos2d::DrawNode*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 4) {
            cocos2d::Vec2* arg0;
            ok = rubyval_to_object<cocos2d::Vec2>(mrb, argv[0], "CC::Vec2", &arg0);
            if (!ok) { break; }
            cocos2d::Vec2* arg1;
            ok = rubyval_to_object<cocos2d::Vec2>(mrb, argv[1], "CC::Vec2", &arg1);
            if (!ok) { break; }
            double arg2;
            ok = rubyval_to_number(mrb, argv[2], (double*)&arg2, "CC::DrawNode.drawSegment");
            if (!ok) { break; }
            cocos2d::Color4F* arg3;
            ok = rubyval_to_object<cocos2d::Color4F>(mrb, argv[3], "CC::Color4F", &arg3);
            if (!ok) { break; }
            cobj->drawSegment(*arg0, *arg1, arg2, *arg3);
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::DrawNode#drawSegment");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_DrawNode_getBlendFunc(mrb_state* mrb, mrb_value self)
{
    cocos2d::DrawNode* cobj = static_cast<cocos2d::DrawNode*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            cocos2d::BlendFunc retval = cobj->getBlendFunc();
            cocos2d::BlendFunc* retval_ptr = new cocos2d::BlendFunc(retval);
            mrb_value ret;
            ret = object_to_rubyval<cocos2d::BlendFunc>(mrb, "CC::BlendFunc", (cocos2d::BlendFunc*)retval_ptr, nullptr);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::DrawNode#getBlendFunc");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_DrawNode_onDraw(mrb_state* mrb, mrb_value self)
{
    cocos2d::DrawNode* cobj = static_cast<cocos2d::DrawNode*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 2) {
            cocos2d::Mat4* arg0;
            ok = rubyval_to_object<cocos2d::Mat4>(mrb, argv[0], "CC::Mat4", &arg0);
            if (!ok) { break; }
            unsigned int arg1;
            ok = rubyval_to_uint32(mrb, argv[1], &arg1, "CC::DrawNode.onDraw");
            if (!ok) { break; }
            cobj->onDraw(*arg0, arg1);
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::DrawNode#onDraw");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_DrawNode_drawCircle(mrb_state* mrb, mrb_value self)
{
    cocos2d::DrawNode* cobj = static_cast<cocos2d::DrawNode*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 6) {
            cocos2d::Vec2* arg0;
            ok = rubyval_to_object<cocos2d::Vec2>(mrb, argv[0], "CC::Vec2", &arg0);
            if (!ok) { break; }
            double arg1;
            ok = rubyval_to_number(mrb, argv[1], (double*)&arg1, "CC::DrawNode.drawCircle");
            if (!ok) { break; }
            double arg2;
            ok = rubyval_to_number(mrb, argv[2], (double*)&arg2, "CC::DrawNode.drawCircle");
            if (!ok) { break; }
            unsigned int arg3;
            ok = rubyval_to_uint32(mrb, argv[3], &arg3, "CC::DrawNode.drawCircle");
            if (!ok) { break; }
            bool arg4;
            ok = rubyval_to_boolean(mrb, argv[4], &arg4, "CC::DrawNode.drawCircle");
            if (!ok) { break; }
            cocos2d::Color4F* arg5;
            ok = rubyval_to_object<cocos2d::Color4F>(mrb, argv[5], "CC::Color4F", &arg5);
            if (!ok) { break; }
            cobj->drawCircle(*arg0, arg1, arg2, arg3, arg4, *arg5);
            return self;
        }
    } while (0);
    do {
        if (argc == 8) {
            cocos2d::Vec2* arg0;
            ok = rubyval_to_object<cocos2d::Vec2>(mrb, argv[0], "CC::Vec2", &arg0);
            if (!ok) { break; }
            double arg1;
            ok = rubyval_to_number(mrb, argv[1], (double*)&arg1, "CC::DrawNode.drawCircle");
            if (!ok) { break; }
            double arg2;
            ok = rubyval_to_number(mrb, argv[2], (double*)&arg2, "CC::DrawNode.drawCircle");
            if (!ok) { break; }
            unsigned int arg3;
            ok = rubyval_to_uint32(mrb, argv[3], &arg3, "CC::DrawNode.drawCircle");
            if (!ok) { break; }
            bool arg4;
            ok = rubyval_to_boolean(mrb, argv[4], &arg4, "CC::DrawNode.drawCircle");
            if (!ok) { break; }
            double arg5;
            ok = rubyval_to_number(mrb, argv[5], (double*)&arg5, "CC::DrawNode.drawCircle");
            if (!ok) { break; }
            double arg6;
            ok = rubyval_to_number(mrb, argv[6], (double*)&arg6, "CC::DrawNode.drawCircle");
            if (!ok) { break; }
            cocos2d::Color4F* arg7;
            ok = rubyval_to_object<cocos2d::Color4F>(mrb, argv[7], "CC::Color4F", &arg7);
            if (!ok) { break; }
            cobj->drawCircle(*arg0, arg1, arg2, arg3, arg4, arg5, arg6, *arg7);
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::DrawNode#drawCircle");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_DrawNode_drawQuadBezier(mrb_state* mrb, mrb_value self)
{
    cocos2d::DrawNode* cobj = static_cast<cocos2d::DrawNode*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 5) {
            cocos2d::Vec2* arg0;
            ok = rubyval_to_object<cocos2d::Vec2>(mrb, argv[0], "CC::Vec2", &arg0);
            if (!ok) { break; }
            cocos2d::Vec2* arg1;
            ok = rubyval_to_object<cocos2d::Vec2>(mrb, argv[1], "CC::Vec2", &arg1);
            if (!ok) { break; }
            cocos2d::Vec2* arg2;
            ok = rubyval_to_object<cocos2d::Vec2>(mrb, argv[2], "CC::Vec2", &arg2);
            if (!ok) { break; }
            unsigned int arg3;
            ok = rubyval_to_uint32(mrb, argv[3], &arg3, "CC::DrawNode.drawQuadBezier");
            if (!ok) { break; }
            cocos2d::Color4F* arg4;
            ok = rubyval_to_object<cocos2d::Color4F>(mrb, argv[4], "CC::Color4F", &arg4);
            if (!ok) { break; }
            cobj->drawQuadBezier(*arg0, *arg1, *arg2, arg3, *arg4);
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::DrawNode#drawQuadBezier");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_DrawNode_onDrawGLLine(mrb_state* mrb, mrb_value self)
{
    cocos2d::DrawNode* cobj = static_cast<cocos2d::DrawNode*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 2) {
            cocos2d::Mat4* arg0;
            ok = rubyval_to_object<cocos2d::Mat4>(mrb, argv[0], "CC::Mat4", &arg0);
            if (!ok) { break; }
            unsigned int arg1;
            ok = rubyval_to_uint32(mrb, argv[1], &arg1, "CC::DrawNode.onDrawGLLine");
            if (!ok) { break; }
            cobj->onDrawGLLine(*arg0, arg1);
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::DrawNode#onDrawGLLine");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_DrawNode_drawTriangle(mrb_state* mrb, mrb_value self)
{
    cocos2d::DrawNode* cobj = static_cast<cocos2d::DrawNode*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 4) {
            cocos2d::Vec2* arg0;
            ok = rubyval_to_object<cocos2d::Vec2>(mrb, argv[0], "CC::Vec2", &arg0);
            if (!ok) { break; }
            cocos2d::Vec2* arg1;
            ok = rubyval_to_object<cocos2d::Vec2>(mrb, argv[1], "CC::Vec2", &arg1);
            if (!ok) { break; }
            cocos2d::Vec2* arg2;
            ok = rubyval_to_object<cocos2d::Vec2>(mrb, argv[2], "CC::Vec2", &arg2);
            if (!ok) { break; }
            cocos2d::Color4F* arg3;
            ok = rubyval_to_object<cocos2d::Color4F>(mrb, argv[3], "CC::Color4F", &arg3);
            if (!ok) { break; }
            cobj->drawTriangle(*arg0, *arg1, *arg2, *arg3);
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::DrawNode#drawTriangle");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_DrawNode_setBlendFunc(mrb_state* mrb, mrb_value self)
{
    cocos2d::DrawNode* cobj = static_cast<cocos2d::DrawNode*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            cocos2d::BlendFunc* arg0;
            ok = rubyval_to_object<cocos2d::BlendFunc>(mrb, argv[0], "CC::BlendFunc", &arg0);
            if (!ok) { break; }
            cobj->setBlendFunc(*arg0);
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::DrawNode#setBlendFunc");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_DrawNode_clear(mrb_state* mrb, mrb_value self)
{
    cocos2d::DrawNode* cobj = static_cast<cocos2d::DrawNode*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            cobj->clear();
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::DrawNode#clear");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_DrawNode_drawSolidRect(mrb_state* mrb, mrb_value self)
{
    cocos2d::DrawNode* cobj = static_cast<cocos2d::DrawNode*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 3) {
            cocos2d::Vec2* arg0;
            ok = rubyval_to_object<cocos2d::Vec2>(mrb, argv[0], "CC::Vec2", &arg0);
            if (!ok) { break; }
            cocos2d::Vec2* arg1;
            ok = rubyval_to_object<cocos2d::Vec2>(mrb, argv[1], "CC::Vec2", &arg1);
            if (!ok) { break; }
            cocos2d::Color4F* arg2;
            ok = rubyval_to_object<cocos2d::Color4F>(mrb, argv[2], "CC::Color4F", &arg2);
            if (!ok) { break; }
            cobj->drawSolidRect(*arg0, *arg1, *arg2);
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::DrawNode#drawSolidRect");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_DrawNode_drawPoint(mrb_state* mrb, mrb_value self)
{
    cocos2d::DrawNode* cobj = static_cast<cocos2d::DrawNode*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 3) {
            cocos2d::Vec2* arg0;
            ok = rubyval_to_object<cocos2d::Vec2>(mrb, argv[0], "CC::Vec2", &arg0);
            if (!ok) { break; }
            float arg1;
            ok = rubyval_to_number(mrb, argv[1], (double*)&arg1, "CC::DrawNode.drawPoint");
            if (!ok) { break; }
            cocos2d::Color4F* arg2;
            ok = rubyval_to_object<cocos2d::Color4F>(mrb, argv[2], "CC::Color4F", &arg2);
            if (!ok) { break; }
            cobj->drawPoint(*arg0, arg1, *arg2);
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::DrawNode#drawPoint");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_DrawNode_drawCubicBezier(mrb_state* mrb, mrb_value self)
{
    cocos2d::DrawNode* cobj = static_cast<cocos2d::DrawNode*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 6) {
            cocos2d::Vec2* arg0;
            ok = rubyval_to_object<cocos2d::Vec2>(mrb, argv[0], "CC::Vec2", &arg0);
            if (!ok) { break; }
            cocos2d::Vec2* arg1;
            ok = rubyval_to_object<cocos2d::Vec2>(mrb, argv[1], "CC::Vec2", &arg1);
            if (!ok) { break; }
            cocos2d::Vec2* arg2;
            ok = rubyval_to_object<cocos2d::Vec2>(mrb, argv[2], "CC::Vec2", &arg2);
            if (!ok) { break; }
            cocos2d::Vec2* arg3;
            ok = rubyval_to_object<cocos2d::Vec2>(mrb, argv[3], "CC::Vec2", &arg3);
            if (!ok) { break; }
            unsigned int arg4;
            ok = rubyval_to_uint32(mrb, argv[4], &arg4, "CC::DrawNode.drawCubicBezier");
            if (!ok) { break; }
            cocos2d::Color4F* arg5;
            ok = rubyval_to_object<cocos2d::Color4F>(mrb, argv[5], "CC::Color4F", &arg5);
            if (!ok) { break; }
            cobj->drawCubicBezier(*arg0, *arg1, *arg2, *arg3, arg4, *arg5);
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::DrawNode#drawCubicBezier");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_DrawNode_create_static(mrb_state* mrb, mrb_value self)
{
    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            std::map<std::string, mrb_value> callbacks;
            cocos2d::DrawNode* retval = cocos2d::DrawNode::create();
            mrb_value ret;
            RClass* rclass = mrb_class_ptr(self);
            ret = object_to_rubyval<cocos2d::DrawNode>(mrb, "CC::DrawNode", (cocos2d::DrawNode*)retval, rclass);
            if (callbacks.size() > 0) {
                mrb_value hash = mrb_iv_get(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"));
                if (!mrb_hash_p(hash)) {
                    hash = mrb_hash_new(mrb);
                }
                for (auto elm : callbacks) {
                    mrb_hash_set(mrb, hash, mrb_str_new_cstr(mrb, elm.first.c_str()), elm.second);
                    mrb_iv_set(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"), hash);
                }
            }
            g_rubyValue.push_back(ret);
            mrb_funcall(mrb, ret, "initialize", 0);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined static method : cocos2d::DrawNode#create");

    return mrb_nil_value();
}

void ruby_register_cocos2dx_DrawNode(mrb_state* mrb, struct RClass* rmodule)
{
    std::string typeName = typeid(cocos2d::DrawNode).name();
    g_rubyType[typeName] = "CC::DrawNode";
    g_rubyDataType[typeName] = &ruby_cocos2dx_Ref_type;

    struct RClass* p_rmodule = mrb->object_class;
    p_rmodule = mrb_module_get_under(mrb, p_rmodule, "CC");
    struct RClass* p_rclass = mrb_class_get_under(mrb, p_rmodule, "Node");
    struct RClass *rclass = mrb_define_class_under(mrb, rmodule, "DrawNode", p_rclass);
    MRB_SET_INSTANCE_TT(rclass, MRB_TT_DATA);

    mrb_define_method(mrb, rclass, "draw_line", ruby_cocos2dx_DrawNode_drawLine, ARGS_REQ(3));
    mrb_define_method(mrb, rclass, "draw_rect", ruby_cocos2dx_DrawNode_drawRect, ARGS_REQ(3)|ARGS_OPT(2));
    mrb_define_method(mrb, rclass, "draw_solid_circle", ruby_cocos2dx_DrawNode_drawSolidCircle, ARGS_REQ(5)|ARGS_OPT(2));
    mrb_define_method(mrb, rclass, "on_draw_glpoint", ruby_cocos2dx_DrawNode_onDrawGLPoint, ARGS_REQ(2));
    mrb_define_method(mrb, rclass, "draw_dot", ruby_cocos2dx_DrawNode_drawDot, ARGS_REQ(3));
    mrb_define_method(mrb, rclass, "draw_segment", ruby_cocos2dx_DrawNode_drawSegment, ARGS_REQ(4));
    mrb_define_method(mrb, rclass, "get_blend_func", ruby_cocos2dx_DrawNode_getBlendFunc, ARGS_NONE());
    mrb_define_method(mrb, rclass, "on_draw", ruby_cocos2dx_DrawNode_onDraw, ARGS_REQ(2));
    mrb_define_method(mrb, rclass, "draw_circle", ruby_cocos2dx_DrawNode_drawCircle, ARGS_REQ(6)|ARGS_OPT(2));
    mrb_define_method(mrb, rclass, "draw_quad_bezier", ruby_cocos2dx_DrawNode_drawQuadBezier, ARGS_REQ(5));
    mrb_define_method(mrb, rclass, "on_draw_glline", ruby_cocos2dx_DrawNode_onDrawGLLine, ARGS_REQ(2));
    mrb_define_method(mrb, rclass, "draw_triangle", ruby_cocos2dx_DrawNode_drawTriangle, ARGS_REQ(4));
    mrb_define_method(mrb, rclass, "set_blend_func", ruby_cocos2dx_DrawNode_setBlendFunc, ARGS_REQ(1));
    mrb_define_method(mrb, rclass, "clear", ruby_cocos2dx_DrawNode_clear, ARGS_NONE());
    mrb_define_method(mrb, rclass, "draw_solid_rect", ruby_cocos2dx_DrawNode_drawSolidRect, ARGS_REQ(3));
    mrb_define_method(mrb, rclass, "draw_point", ruby_cocos2dx_DrawNode_drawPoint, ARGS_REQ(3));
    mrb_define_method(mrb, rclass, "draw_cubic_bezier", ruby_cocos2dx_DrawNode_drawCubicBezier, ARGS_REQ(6));
    mrb_define_class_method(mrb, rclass, "create", ruby_cocos2dx_DrawNode_create_static, ARGS_NONE());
}
mrb_value ruby_cocos2dx_LabelAtlas_setString(mrb_state* mrb, mrb_value self)
{
    cocos2d::LabelAtlas* cobj = static_cast<cocos2d::LabelAtlas*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            std::string arg0;
            ok = rubyval_to_std_string(mrb, argv[0], &arg0, "CC::LabelAtlas.setString");
            if (!ok) { break; }
            cobj->setString(arg0);
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::LabelAtlas#setString");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_LabelAtlas_initWithString(mrb_state* mrb, mrb_value self)
{
    cocos2d::LabelAtlas* cobj = static_cast<cocos2d::LabelAtlas*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 2) {
            std::string arg0;
            ok = rubyval_to_std_string(mrb, argv[0], &arg0, "CC::LabelAtlas.initWithString");
            if (!ok) { break; }
            std::string arg1;
            ok = rubyval_to_std_string(mrb, argv[1], &arg1, "CC::LabelAtlas.initWithString");
            if (!ok) { break; }
            bool retval = cobj->initWithString(arg0, arg1);
            mrb_value ret;
            ret = mrb_bool_value((mrb_bool)retval);
            return ret;
        }
    } while (0);
    do {
        if (argc == 5) {
            std::string arg0;
            ok = rubyval_to_std_string(mrb, argv[0], &arg0, "CC::LabelAtlas.initWithString");
            if (!ok) { break; }
            std::string arg1;
            ok = rubyval_to_std_string(mrb, argv[1], &arg1, "CC::LabelAtlas.initWithString");
            if (!ok) { break; }
            int arg2;
            ok = rubyval_to_int32(mrb, argv[2], (int*)&arg2, "CC::LabelAtlas.initWithString");
            if (!ok) { break; }
            int arg3;
            ok = rubyval_to_int32(mrb, argv[3], (int*)&arg3, "CC::LabelAtlas.initWithString");
            if (!ok) { break; }
            int arg4;
            ok = rubyval_to_int32(mrb, argv[4], (int*)&arg4, "CC::LabelAtlas.initWithString");
            if (!ok) { break; }
            bool retval = cobj->initWithString(arg0, arg1, arg2, arg3, arg4);
            mrb_value ret;
            ret = mrb_bool_value((mrb_bool)retval);
            return ret;
        }
    } while (0);
    do {
        if (argc == 5) {
            std::string arg0;
            ok = rubyval_to_std_string(mrb, argv[0], &arg0, "CC::LabelAtlas.initWithString");
            if (!ok) { break; }
            cocos2d::Texture2D* arg1;
            ok = rubyval_to_object<cocos2d::Texture2D>(mrb, argv[1], "CC::Texture2D", &arg1);
            if (!ok) { break; }
            int arg2;
            ok = rubyval_to_int32(mrb, argv[2], (int*)&arg2, "CC::LabelAtlas.initWithString");
            if (!ok) { break; }
            int arg3;
            ok = rubyval_to_int32(mrb, argv[3], (int*)&arg3, "CC::LabelAtlas.initWithString");
            if (!ok) { break; }
            int arg4;
            ok = rubyval_to_int32(mrb, argv[4], (int*)&arg4, "CC::LabelAtlas.initWithString");
            if (!ok) { break; }
            bool retval = cobj->initWithString(arg0, arg1, arg2, arg3, arg4);
            mrb_value ret;
            ret = mrb_bool_value((mrb_bool)retval);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::LabelAtlas#initWithString");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_LabelAtlas_updateAtlasValues(mrb_state* mrb, mrb_value self)
{
    cocos2d::LabelAtlas* cobj = static_cast<cocos2d::LabelAtlas*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            cobj->updateAtlasValues();
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::LabelAtlas#updateAtlasValues");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_LabelAtlas_getString(mrb_state* mrb, mrb_value self)
{
    cocos2d::LabelAtlas* cobj = static_cast<cocos2d::LabelAtlas*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            std::string retval = cobj->getString();
            mrb_value ret;
            ret = mrb_str_new_cstr(mrb, retval.c_str());
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::LabelAtlas#getString");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_LabelAtlas_create_static(mrb_state* mrb, mrb_value self)
{
    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 5) {
            std::map<std::string, mrb_value> callbacks;
            std::string arg0;
            ok = rubyval_to_std_string(mrb, argv[0], &arg0, "CC::LabelAtlas.create");
            if (!ok) { break; }

            std::string arg1;
            ok = rubyval_to_std_string(mrb, argv[1], &arg1, "CC::LabelAtlas.create");
            if (!ok) { break; }

            int arg2;
            ok = rubyval_to_int32(mrb, argv[2], (int*)&arg2, "CC::LabelAtlas.create");
            if (!ok) { break; }

            int arg3;
            ok = rubyval_to_int32(mrb, argv[3], (int*)&arg3, "CC::LabelAtlas.create");
            if (!ok) { break; }

            int arg4;
            ok = rubyval_to_int32(mrb, argv[4], (int*)&arg4, "CC::LabelAtlas.create");
            if (!ok) { break; }

            cocos2d::LabelAtlas* retval = cocos2d::LabelAtlas::create(arg0, arg1, arg2, arg3, arg4);
            mrb_value ret;
            RClass* rclass = mrb_class_ptr(self);
            ret = object_to_rubyval<cocos2d::LabelAtlas>(mrb, "CC::LabelAtlas", (cocos2d::LabelAtlas*)retval, rclass);
            if (callbacks.size() > 0) {
                mrb_value hash = mrb_iv_get(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"));
                if (!mrb_hash_p(hash)) {
                    hash = mrb_hash_new(mrb);
                }
                for (auto elm : callbacks) {
                    mrb_hash_set(mrb, hash, mrb_str_new_cstr(mrb, elm.first.c_str()), elm.second);
                    mrb_iv_set(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"), hash);
                }
            }
            g_rubyValue.push_back(ret);
            mrb_funcall(mrb, ret, "initialize", 0);
            return ret;
        }
    } while (0);
    do {
        if (argc == 0) {
            std::map<std::string, mrb_value> callbacks;
            cocos2d::LabelAtlas* retval = cocos2d::LabelAtlas::create();
            mrb_value ret;
            RClass* rclass = mrb_class_ptr(self);
            ret = object_to_rubyval<cocos2d::LabelAtlas>(mrb, "CC::LabelAtlas", (cocos2d::LabelAtlas*)retval, rclass);
            if (callbacks.size() > 0) {
                mrb_value hash = mrb_iv_get(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"));
                if (!mrb_hash_p(hash)) {
                    hash = mrb_hash_new(mrb);
                }
                for (auto elm : callbacks) {
                    mrb_hash_set(mrb, hash, mrb_str_new_cstr(mrb, elm.first.c_str()), elm.second);
                    mrb_iv_set(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"), hash);
                }
            }
            g_rubyValue.push_back(ret);
            mrb_funcall(mrb, ret, "initialize", 0);
            return ret;
        }
    } while (0);
    do {
        if (argc == 2) {
            std::map<std::string, mrb_value> callbacks;
            std::string arg0;
            ok = rubyval_to_std_string(mrb, argv[0], &arg0, "CC::LabelAtlas.create");
            if (!ok) { break; }

            std::string arg1;
            ok = rubyval_to_std_string(mrb, argv[1], &arg1, "CC::LabelAtlas.create");
            if (!ok) { break; }

            cocos2d::LabelAtlas* retval = cocos2d::LabelAtlas::create(arg0, arg1);
            mrb_value ret;
            RClass* rclass = mrb_class_ptr(self);
            ret = object_to_rubyval<cocos2d::LabelAtlas>(mrb, "CC::LabelAtlas", (cocos2d::LabelAtlas*)retval, rclass);
            if (callbacks.size() > 0) {
                mrb_value hash = mrb_iv_get(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"));
                if (!mrb_hash_p(hash)) {
                    hash = mrb_hash_new(mrb);
                }
                for (auto elm : callbacks) {
                    mrb_hash_set(mrb, hash, mrb_str_new_cstr(mrb, elm.first.c_str()), elm.second);
                    mrb_iv_set(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"), hash);
                }
            }
            g_rubyValue.push_back(ret);
            mrb_funcall(mrb, ret, "initialize", 0);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined static method : cocos2d::LabelAtlas#create");

    return mrb_nil_value();
}

void ruby_register_cocos2dx_LabelAtlas(mrb_state* mrb, struct RClass* rmodule)
{
    std::string typeName = typeid(cocos2d::LabelAtlas).name();
    g_rubyType[typeName] = "CC::LabelAtlas";
    g_rubyDataType[typeName] = &ruby_cocos2dx_Ref_type;

    struct RClass* p_rmodule = mrb->object_class;
    p_rmodule = mrb_module_get_under(mrb, p_rmodule, "CC");
    struct RClass* p_rclass = mrb_class_get_under(mrb, p_rmodule, "AtlasNode");
    struct RClass *rclass = mrb_define_class_under(mrb, rmodule, "LabelAtlas", p_rclass);
    MRB_SET_INSTANCE_TT(rclass, MRB_TT_DATA);

    mrb_define_method(mrb, rclass, "set_string", ruby_cocos2dx_LabelAtlas_setString, ARGS_REQ(1));
    mrb_define_method(mrb, rclass, "init_with_string", ruby_cocos2dx_LabelAtlas_initWithString, ARGS_REQ(2)|ARGS_OPT(3));
    mrb_define_method(mrb, rclass, "update_atlas_values", ruby_cocos2dx_LabelAtlas_updateAtlasValues, ARGS_NONE());
    mrb_define_method(mrb, rclass, "get_string", ruby_cocos2dx_LabelAtlas_getString, ARGS_NONE());
    mrb_define_class_method(mrb, rclass, "create", ruby_cocos2dx_LabelAtlas_create_static, ARGS_REQ(0)|ARGS_OPT(5));
}
mrb_value ruby_cocos2dx_SpriteBatchNode_appendChild(mrb_state* mrb, mrb_value self)
{
    cocos2d::SpriteBatchNode* cobj = static_cast<cocos2d::SpriteBatchNode*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            cocos2d::Sprite* arg0;
            ok = rubyval_to_object<cocos2d::Sprite>(mrb, argv[0], "CC::Sprite", &arg0);
            if (!ok) { break; }
            cobj->appendChild(arg0);
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::SpriteBatchNode#appendChild");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_SpriteBatchNode_addSpriteWithoutQuad(mrb_state* mrb, mrb_value self)
{
    cocos2d::SpriteBatchNode* cobj = static_cast<cocos2d::SpriteBatchNode*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 3) {
            cocos2d::Sprite* arg0;
            ok = rubyval_to_object<cocos2d::Sprite>(mrb, argv[0], "CC::Sprite", &arg0);
            if (!ok) { break; }
            int arg1;
            ok = rubyval_to_int32(mrb, argv[1], (int*)&arg1, "CC::SpriteBatchNode.addSpriteWithoutQuad");
            if (!ok) { break; }
            int arg2;
            ok = rubyval_to_int32(mrb, argv[2], (int*)&arg2, "CC::SpriteBatchNode.addSpriteWithoutQuad");
            if (!ok) { break; }
            cocos2d::SpriteBatchNode* retval = cobj->addSpriteWithoutQuad(arg0, arg1, arg2);
            mrb_value ret;
            ret = object_to_rubyval<cocos2d::SpriteBatchNode>(mrb, "CC::SpriteBatchNode", (cocos2d::SpriteBatchNode*)retval, nullptr);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::SpriteBatchNode#addSpriteWithoutQuad");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_SpriteBatchNode_reorderBatch(mrb_state* mrb, mrb_value self)
{
    cocos2d::SpriteBatchNode* cobj = static_cast<cocos2d::SpriteBatchNode*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            bool arg0;
            ok = rubyval_to_boolean(mrb, argv[0], &arg0, "CC::SpriteBatchNode.reorderBatch");
            if (!ok) { break; }
            cobj->reorderBatch(arg0);
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::SpriteBatchNode#reorderBatch");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_SpriteBatchNode_removeAllChildrenWithCleanup(mrb_state* mrb, mrb_value self)
{
    cocos2d::SpriteBatchNode* cobj = static_cast<cocos2d::SpriteBatchNode*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            bool arg0;
            ok = rubyval_to_boolean(mrb, argv[0], &arg0, "CC::SpriteBatchNode.removeAllChildrenWithCleanup");
            if (!ok) { break; }
            cobj->removeAllChildrenWithCleanup(arg0);
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::SpriteBatchNode#removeAllChildrenWithCleanup");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_SpriteBatchNode_getBlendFunc(mrb_state* mrb, mrb_value self)
{
    cocos2d::SpriteBatchNode* cobj = static_cast<cocos2d::SpriteBatchNode*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            cocos2d::BlendFunc retval = cobj->getBlendFunc();
            cocos2d::BlendFunc* retval_ptr = new cocos2d::BlendFunc(retval);
            mrb_value ret;
            ret = object_to_rubyval<cocos2d::BlendFunc>(mrb, "CC::BlendFunc", (cocos2d::BlendFunc*)retval_ptr, nullptr);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::SpriteBatchNode#getBlendFunc");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_SpriteBatchNode_lowestAtlasIndexInChild(mrb_state* mrb, mrb_value self)
{
    cocos2d::SpriteBatchNode* cobj = static_cast<cocos2d::SpriteBatchNode*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            cocos2d::Sprite* arg0;
            ok = rubyval_to_object<cocos2d::Sprite>(mrb, argv[0], "CC::Sprite", &arg0);
            if (!ok) { break; }
            ssize_t retval = cobj->lowestAtlasIndexInChild(arg0);
            mrb_value ret;
            ret = mrb_fixnum_value((mrb_int)retval);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::SpriteBatchNode#lowestAtlasIndexInChild");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_SpriteBatchNode_atlasIndexForChild(mrb_state* mrb, mrb_value self)
{
    cocos2d::SpriteBatchNode* cobj = static_cast<cocos2d::SpriteBatchNode*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 2) {
            cocos2d::Sprite* arg0;
            ok = rubyval_to_object<cocos2d::Sprite>(mrb, argv[0], "CC::Sprite", &arg0);
            if (!ok) { break; }
            int arg1;
            ok = rubyval_to_int32(mrb, argv[1], (int*)&arg1, "CC::SpriteBatchNode.atlasIndexForChild");
            if (!ok) { break; }
            ssize_t retval = cobj->atlasIndexForChild(arg0, arg1);
            mrb_value ret;
            ret = mrb_fixnum_value((mrb_int)retval);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::SpriteBatchNode#atlasIndexForChild");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_SpriteBatchNode_setTextureAtlas(mrb_state* mrb, mrb_value self)
{
    cocos2d::SpriteBatchNode* cobj = static_cast<cocos2d::SpriteBatchNode*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            cocos2d::TextureAtlas* arg0;
            ok = rubyval_to_object<cocos2d::TextureAtlas>(mrb, argv[0], "CC::TextureAtlas", &arg0);
            if (!ok) { break; }
            cobj->setTextureAtlas(arg0);
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::SpriteBatchNode#setTextureAtlas");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_SpriteBatchNode_getTexture(mrb_state* mrb, mrb_value self)
{
    cocos2d::SpriteBatchNode* cobj = static_cast<cocos2d::SpriteBatchNode*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            cocos2d::Texture2D* retval = cobj->getTexture();
            mrb_value ret;
            ret = object_to_rubyval<cocos2d::Texture2D>(mrb, "CC::Texture2D", (cocos2d::Texture2D*)retval, nullptr);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::SpriteBatchNode#getTexture");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_SpriteBatchNode_increaseAtlasCapacity(mrb_state* mrb, mrb_value self)
{
    cocos2d::SpriteBatchNode* cobj = static_cast<cocos2d::SpriteBatchNode*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            cobj->increaseAtlasCapacity();
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::SpriteBatchNode#increaseAtlasCapacity");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_SpriteBatchNode_getTextureAtlas(mrb_state* mrb, mrb_value self)
{
    cocos2d::SpriteBatchNode* cobj = static_cast<cocos2d::SpriteBatchNode*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            cocos2d::TextureAtlas* retval = cobj->getTextureAtlas();
            mrb_value ret;
            ret = object_to_rubyval<cocos2d::TextureAtlas>(mrb, "CC::TextureAtlas", (cocos2d::TextureAtlas*)retval, nullptr);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::SpriteBatchNode#getTextureAtlas");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_SpriteBatchNode_insertQuadFromSprite(mrb_state* mrb, mrb_value self)
{
    cocos2d::SpriteBatchNode* cobj = static_cast<cocos2d::SpriteBatchNode*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 2) {
            cocos2d::Sprite* arg0;
            ok = rubyval_to_object<cocos2d::Sprite>(mrb, argv[0], "CC::Sprite", &arg0);
            if (!ok) { break; }
            ssize_t arg1;
            ok = rubyval_to_ssize(mrb, argv[1], &arg1, "CC::SpriteBatchNode.insertQuadFromSprite");
            if (!ok) { break; }
            cobj->insertQuadFromSprite(arg0, arg1);
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::SpriteBatchNode#insertQuadFromSprite");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_SpriteBatchNode_setTexture(mrb_state* mrb, mrb_value self)
{
    cocos2d::SpriteBatchNode* cobj = static_cast<cocos2d::SpriteBatchNode*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            cocos2d::Texture2D* arg0;
            ok = rubyval_to_object<cocos2d::Texture2D>(mrb, argv[0], "CC::Texture2D", &arg0);
            if (!ok) { break; }
            cobj->setTexture(arg0);
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::SpriteBatchNode#setTexture");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_SpriteBatchNode_rebuildIndexInOrder(mrb_state* mrb, mrb_value self)
{
    cocos2d::SpriteBatchNode* cobj = static_cast<cocos2d::SpriteBatchNode*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 2) {
            cocos2d::Sprite* arg0;
            ok = rubyval_to_object<cocos2d::Sprite>(mrb, argv[0], "CC::Sprite", &arg0);
            if (!ok) { break; }
            ssize_t arg1;
            ok = rubyval_to_ssize(mrb, argv[1], &arg1, "CC::SpriteBatchNode.rebuildIndexInOrder");
            if (!ok) { break; }
            ssize_t retval = cobj->rebuildIndexInOrder(arg0, arg1);
            mrb_value ret;
            ret = mrb_fixnum_value((mrb_int)retval);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::SpriteBatchNode#rebuildIndexInOrder");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_SpriteBatchNode_highestAtlasIndexInChild(mrb_state* mrb, mrb_value self)
{
    cocos2d::SpriteBatchNode* cobj = static_cast<cocos2d::SpriteBatchNode*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            cocos2d::Sprite* arg0;
            ok = rubyval_to_object<cocos2d::Sprite>(mrb, argv[0], "CC::Sprite", &arg0);
            if (!ok) { break; }
            ssize_t retval = cobj->highestAtlasIndexInChild(arg0);
            mrb_value ret;
            ret = mrb_fixnum_value((mrb_int)retval);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::SpriteBatchNode#highestAtlasIndexInChild");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_SpriteBatchNode_removeChildAtIndex(mrb_state* mrb, mrb_value self)
{
    cocos2d::SpriteBatchNode* cobj = static_cast<cocos2d::SpriteBatchNode*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 2) {
            ssize_t arg0;
            ok = rubyval_to_ssize(mrb, argv[0], &arg0, "CC::SpriteBatchNode.removeChildAtIndex");
            if (!ok) { break; }
            bool arg1;
            ok = rubyval_to_boolean(mrb, argv[1], &arg1, "CC::SpriteBatchNode.removeChildAtIndex");
            if (!ok) { break; }
            cobj->removeChildAtIndex(arg0, arg1);
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::SpriteBatchNode#removeChildAtIndex");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_SpriteBatchNode_removeSpriteFromAtlas(mrb_state* mrb, mrb_value self)
{
    cocos2d::SpriteBatchNode* cobj = static_cast<cocos2d::SpriteBatchNode*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            cocos2d::Sprite* arg0;
            ok = rubyval_to_object<cocos2d::Sprite>(mrb, argv[0], "CC::Sprite", &arg0);
            if (!ok) { break; }
            cobj->removeSpriteFromAtlas(arg0);
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::SpriteBatchNode#removeSpriteFromAtlas");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_SpriteBatchNode_setBlendFunc(mrb_state* mrb, mrb_value self)
{
    cocos2d::SpriteBatchNode* cobj = static_cast<cocos2d::SpriteBatchNode*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            cocos2d::BlendFunc* arg0;
            ok = rubyval_to_object<cocos2d::BlendFunc>(mrb, argv[0], "CC::BlendFunc", &arg0);
            if (!ok) { break; }
            cobj->setBlendFunc(*arg0);
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::SpriteBatchNode#setBlendFunc");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_SpriteBatchNode_create_static(mrb_state* mrb, mrb_value self)
{
    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            std::map<std::string, mrb_value> callbacks;
            std::string arg0;
            ok = rubyval_to_std_string(mrb, argv[0], &arg0, "CC::SpriteBatchNode.create");
            if (!ok) { break; }

            cocos2d::SpriteBatchNode* retval = cocos2d::SpriteBatchNode::create(arg0);
            mrb_value ret;
            RClass* rclass = mrb_class_ptr(self);
            ret = object_to_rubyval<cocos2d::SpriteBatchNode>(mrb, "CC::SpriteBatchNode", (cocos2d::SpriteBatchNode*)retval, rclass);
            if (callbacks.size() > 0) {
                mrb_value hash = mrb_iv_get(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"));
                if (!mrb_hash_p(hash)) {
                    hash = mrb_hash_new(mrb);
                }
                for (auto elm : callbacks) {
                    mrb_hash_set(mrb, hash, mrb_str_new_cstr(mrb, elm.first.c_str()), elm.second);
                    mrb_iv_set(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"), hash);
                }
            }
            g_rubyValue.push_back(ret);
            mrb_funcall(mrb, ret, "initialize", 0);
            return ret;
        }
    } while (0);
    do {
        if (argc == 2) {
            std::map<std::string, mrb_value> callbacks;
            std::string arg0;
            ok = rubyval_to_std_string(mrb, argv[0], &arg0, "CC::SpriteBatchNode.create");
            if (!ok) { break; }

            ssize_t arg1;
            ok = rubyval_to_ssize(mrb, argv[1], &arg1, "CC::SpriteBatchNode.create");
            if (!ok) { break; }

            cocos2d::SpriteBatchNode* retval = cocos2d::SpriteBatchNode::create(arg0, arg1);
            mrb_value ret;
            RClass* rclass = mrb_class_ptr(self);
            ret = object_to_rubyval<cocos2d::SpriteBatchNode>(mrb, "CC::SpriteBatchNode", (cocos2d::SpriteBatchNode*)retval, rclass);
            if (callbacks.size() > 0) {
                mrb_value hash = mrb_iv_get(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"));
                if (!mrb_hash_p(hash)) {
                    hash = mrb_hash_new(mrb);
                }
                for (auto elm : callbacks) {
                    mrb_hash_set(mrb, hash, mrb_str_new_cstr(mrb, elm.first.c_str()), elm.second);
                    mrb_iv_set(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"), hash);
                }
            }
            g_rubyValue.push_back(ret);
            mrb_funcall(mrb, ret, "initialize", 0);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined static method : cocos2d::SpriteBatchNode#create");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_SpriteBatchNode_createWithTexture_static(mrb_state* mrb, mrb_value self)
{
    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            std::map<std::string, mrb_value> callbacks;
            cocos2d::Texture2D* arg0;
            ok = rubyval_to_object<cocos2d::Texture2D>(mrb, argv[0], "CC::Texture2D", &arg0);
            if (!ok) { break; }

            cocos2d::SpriteBatchNode* retval = cocos2d::SpriteBatchNode::createWithTexture(arg0);
            mrb_value ret;
            RClass* rclass = mrb_class_ptr(self);
            ret = object_to_rubyval<cocos2d::SpriteBatchNode>(mrb, "CC::SpriteBatchNode", (cocos2d::SpriteBatchNode*)retval, rclass);
            if (callbacks.size() > 0) {
                mrb_value hash = mrb_iv_get(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"));
                if (!mrb_hash_p(hash)) {
                    hash = mrb_hash_new(mrb);
                }
                for (auto elm : callbacks) {
                    mrb_hash_set(mrb, hash, mrb_str_new_cstr(mrb, elm.first.c_str()), elm.second);
                    mrb_iv_set(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"), hash);
                }
            }
            g_rubyValue.push_back(ret);
            mrb_funcall(mrb, ret, "initialize", 0);
            return ret;
        }
    } while (0);
    do {
        if (argc == 2) {
            std::map<std::string, mrb_value> callbacks;
            cocos2d::Texture2D* arg0;
            ok = rubyval_to_object<cocos2d::Texture2D>(mrb, argv[0], "CC::Texture2D", &arg0);
            if (!ok) { break; }

            ssize_t arg1;
            ok = rubyval_to_ssize(mrb, argv[1], &arg1, "CC::SpriteBatchNode.createWithTexture");
            if (!ok) { break; }

            cocos2d::SpriteBatchNode* retval = cocos2d::SpriteBatchNode::createWithTexture(arg0, arg1);
            mrb_value ret;
            RClass* rclass = mrb_class_ptr(self);
            ret = object_to_rubyval<cocos2d::SpriteBatchNode>(mrb, "CC::SpriteBatchNode", (cocos2d::SpriteBatchNode*)retval, rclass);
            if (callbacks.size() > 0) {
                mrb_value hash = mrb_iv_get(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"));
                if (!mrb_hash_p(hash)) {
                    hash = mrb_hash_new(mrb);
                }
                for (auto elm : callbacks) {
                    mrb_hash_set(mrb, hash, mrb_str_new_cstr(mrb, elm.first.c_str()), elm.second);
                    mrb_iv_set(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"), hash);
                }
            }
            g_rubyValue.push_back(ret);
            mrb_funcall(mrb, ret, "initialize", 0);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined static method : cocos2d::SpriteBatchNode#createWithTexture");

    return mrb_nil_value();
}

void ruby_register_cocos2dx_SpriteBatchNode(mrb_state* mrb, struct RClass* rmodule)
{
    std::string typeName = typeid(cocos2d::SpriteBatchNode).name();
    g_rubyType[typeName] = "CC::SpriteBatchNode";
    g_rubyDataType[typeName] = &ruby_cocos2dx_Ref_type;

    struct RClass* p_rmodule = mrb->object_class;
    p_rmodule = mrb_module_get_under(mrb, p_rmodule, "CC");
    struct RClass* p_rclass = mrb_class_get_under(mrb, p_rmodule, "Node");
    struct RClass *rclass = mrb_define_class_under(mrb, rmodule, "SpriteBatchNode", p_rclass);
    MRB_SET_INSTANCE_TT(rclass, MRB_TT_DATA);

    mrb_define_method(mrb, rclass, "append_child", ruby_cocos2dx_SpriteBatchNode_appendChild, ARGS_REQ(1));
    mrb_define_method(mrb, rclass, "add_sprite_without_quad", ruby_cocos2dx_SpriteBatchNode_addSpriteWithoutQuad, ARGS_REQ(3));
    mrb_define_method(mrb, rclass, "reorder_batch", ruby_cocos2dx_SpriteBatchNode_reorderBatch, ARGS_REQ(1));
    mrb_define_method(mrb, rclass, "remove_all_children_with_cleanup", ruby_cocos2dx_SpriteBatchNode_removeAllChildrenWithCleanup, ARGS_REQ(1));
    mrb_define_method(mrb, rclass, "get_blend_func", ruby_cocos2dx_SpriteBatchNode_getBlendFunc, ARGS_NONE());
    mrb_define_method(mrb, rclass, "lowest_atlas_index_in_child", ruby_cocos2dx_SpriteBatchNode_lowestAtlasIndexInChild, ARGS_REQ(1));
    mrb_define_method(mrb, rclass, "atlas_index_for_child", ruby_cocos2dx_SpriteBatchNode_atlasIndexForChild, ARGS_REQ(2));
    mrb_define_method(mrb, rclass, "set_texture_atlas", ruby_cocos2dx_SpriteBatchNode_setTextureAtlas, ARGS_REQ(1));
    mrb_define_method(mrb, rclass, "get_texture", ruby_cocos2dx_SpriteBatchNode_getTexture, ARGS_NONE());
    mrb_define_method(mrb, rclass, "increase_atlas_capacity", ruby_cocos2dx_SpriteBatchNode_increaseAtlasCapacity, ARGS_NONE());
    mrb_define_method(mrb, rclass, "get_texture_atlas", ruby_cocos2dx_SpriteBatchNode_getTextureAtlas, ARGS_NONE());
    mrb_define_method(mrb, rclass, "insert_quad_from_sprite", ruby_cocos2dx_SpriteBatchNode_insertQuadFromSprite, ARGS_REQ(2));
    mrb_define_method(mrb, rclass, "set_texture", ruby_cocos2dx_SpriteBatchNode_setTexture, ARGS_REQ(1));
    mrb_define_method(mrb, rclass, "rebuild_index_in_order", ruby_cocos2dx_SpriteBatchNode_rebuildIndexInOrder, ARGS_REQ(2));
    mrb_define_method(mrb, rclass, "highest_atlas_index_in_child", ruby_cocos2dx_SpriteBatchNode_highestAtlasIndexInChild, ARGS_REQ(1));
    mrb_define_method(mrb, rclass, "remove_child_at_index", ruby_cocos2dx_SpriteBatchNode_removeChildAtIndex, ARGS_REQ(2));
    mrb_define_method(mrb, rclass, "remove_sprite_from_atlas", ruby_cocos2dx_SpriteBatchNode_removeSpriteFromAtlas, ARGS_REQ(1));
    mrb_define_method(mrb, rclass, "set_blend_func", ruby_cocos2dx_SpriteBatchNode_setBlendFunc, ARGS_REQ(1));
    mrb_define_class_method(mrb, rclass, "create", ruby_cocos2dx_SpriteBatchNode_create_static, ARGS_REQ(2));
    mrb_define_class_method(mrb, rclass, "create_with_texture", ruby_cocos2dx_SpriteBatchNode_createWithTexture_static, ARGS_REQ(2));
}
void ruby_cocos2dx_global_GlyphCollection_enum_init(mrb_state* mrb)
{
    do {
        mrb_value ev = mrb_fixnum_value((mrb_int)GlyphCollection::DYNAMIC);
        mrb_gv_set(mrb, mrb_intern_cstr(mrb, "DYNAMIC"), ev);
    } while (0);

    do {
        mrb_value ev = mrb_fixnum_value((mrb_int)GlyphCollection::NEHE);
        mrb_gv_set(mrb, mrb_intern_cstr(mrb, "NEHE"), ev);
    } while (0);

    do {
        mrb_value ev = mrb_fixnum_value((mrb_int)GlyphCollection::ASCII);
        mrb_gv_set(mrb, mrb_intern_cstr(mrb, "ASCII"), ev);
    } while (0);

    do {
        mrb_value ev = mrb_fixnum_value((mrb_int)GlyphCollection::CUSTOM);
        mrb_gv_set(mrb, mrb_intern_cstr(mrb, "CUSTOM"), ev);
    } while (0);

}
void ruby_cocos2dx_global_LabelEffect_enum_init(mrb_state* mrb)
{
    do {
        mrb_value ev = mrb_fixnum_value((mrb_int)LabelEffect::NORMAL);
        mrb_gv_set(mrb, mrb_intern_cstr(mrb, "NORMAL"), ev);
    } while (0);

    do {
        mrb_value ev = mrb_fixnum_value((mrb_int)LabelEffect::OUTLINE);
        mrb_gv_set(mrb, mrb_intern_cstr(mrb, "OUTLINE"), ev);
    } while (0);

    do {
        mrb_value ev = mrb_fixnum_value((mrb_int)LabelEffect::SHADOW);
        mrb_gv_set(mrb, mrb_intern_cstr(mrb, "SHADOW"), ev);
    } while (0);

    do {
        mrb_value ev = mrb_fixnum_value((mrb_int)LabelEffect::GLOW);
        mrb_gv_set(mrb, mrb_intern_cstr(mrb, "GLOW"), ev);
    } while (0);

}
mrb_value ruby_cocos2dx_Label_isClipMarginEnabled(mrb_state* mrb, mrb_value self)
{
    cocos2d::Label* cobj = static_cast<cocos2d::Label*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            bool retval = cobj->isClipMarginEnabled();
            mrb_value ret;
            ret = mrb_bool_value((mrb_bool)retval);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::Label#isClipMarginEnabled");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Label_enableShadow(mrb_state* mrb, mrb_value self)
{
    cocos2d::Label* cobj = static_cast<cocos2d::Label*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 0) {
            cobj->enableShadow();
            return self;
        }
    } while (0);
    do {
        if (argc == 1) {
            cocos2d::Color4B* arg0;
            ok = rubyval_to_object<cocos2d::Color4B>(mrb, argv[0], "CC::Color4B", &arg0);
            if (!ok) { break; }
            cobj->enableShadow(*arg0);
            return self;
        }
    } while (0);
    do {
        if (argc == 2) {
            cocos2d::Color4B* arg0;
            ok = rubyval_to_object<cocos2d::Color4B>(mrb, argv[0], "CC::Color4B", &arg0);
            if (!ok) { break; }
            cocos2d::Size* arg1;
            ok = rubyval_to_object<cocos2d::Size>(mrb, argv[1], "CC::Size", &arg1);
            if (!ok) { break; }
            cobj->enableShadow(*arg0, *arg1);
            return self;
        }
    } while (0);
    do {
        if (argc == 3) {
            cocos2d::Color4B* arg0;
            ok = rubyval_to_object<cocos2d::Color4B>(mrb, argv[0], "CC::Color4B", &arg0);
            if (!ok) { break; }
            cocos2d::Size* arg1;
            ok = rubyval_to_object<cocos2d::Size>(mrb, argv[1], "CC::Size", &arg1);
            if (!ok) { break; }
            int arg2;
            ok = rubyval_to_int32(mrb, argv[2], (int*)&arg2, "CC::Label.enableShadow");
            if (!ok) { break; }
            cobj->enableShadow(*arg0, *arg1, arg2);
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::Label#enableShadow");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Label_setDimensions(mrb_state* mrb, mrb_value self)
{
    cocos2d::Label* cobj = static_cast<cocos2d::Label*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 2) {
            double arg0;
            ok = rubyval_to_number(mrb, argv[0], (double*)&arg0, "CC::Label.setDimensions");
            if (!ok) { break; }
            double arg1;
            ok = rubyval_to_number(mrb, argv[1], (double*)&arg1, "CC::Label.setDimensions");
            if (!ok) { break; }
            cobj->setDimensions(arg0, arg1);
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::Label#setDimensions");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Label_getString(mrb_state* mrb, mrb_value self)
{
    cocos2d::Label* cobj = static_cast<cocos2d::Label*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            std::string retval = cobj->getString();
            mrb_value ret;
            ret = mrb_str_new_cstr(mrb, retval.c_str());
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::Label#getString");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Label_getHeight(mrb_state* mrb, mrb_value self)
{
    cocos2d::Label* cobj = static_cast<cocos2d::Label*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            double retval = cobj->getHeight();
            mrb_value ret;
            ret = mrb_float_value(mrb, (mrb_float)retval);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::Label#getHeight");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Label_disableEffect(mrb_state* mrb, mrb_value self)
{
    cocos2d::Label* cobj = static_cast<cocos2d::Label*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            cobj->disableEffect();
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::Label#disableEffect");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Label_setTTFConfig(mrb_state* mrb, mrb_value self)
{
    cocos2d::Label* cobj = static_cast<cocos2d::Label*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            cocos2d::_ttfConfig* arg0;
            ok = rubyval_to_object<cocos2d::_ttfConfig>(mrb, argv[0], "CC::_ttfConfig", &arg0);
            if (!ok) { break; }
            bool retval = cobj->setTTFConfig(*arg0);
            mrb_value ret;
            ret = mrb_bool_value((mrb_bool)retval);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::Label#setTTFConfig");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Label_getTextColor(mrb_state* mrb, mrb_value self)
{
    cocos2d::Label* cobj = static_cast<cocos2d::Label*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            cocos2d::Color4B retval = cobj->getTextColor();
            cocos2d::Color4B* retval_ptr = new cocos2d::Color4B(retval);
            mrb_value ret;
            ret = object_to_rubyval<cocos2d::Color4B>(mrb, "CC::Color4B", (cocos2d::Color4B*)retval_ptr, nullptr);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::Label#getTextColor");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Label_setWidth(mrb_state* mrb, mrb_value self)
{
    cocos2d::Label* cobj = static_cast<cocos2d::Label*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            double arg0;
            ok = rubyval_to_number(mrb, argv[0], (double*)&arg0, "CC::Label.setWidth");
            if (!ok) { break; }
            cobj->setWidth(arg0);
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::Label#setWidth");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Label_getMaxLineWidth(mrb_state* mrb, mrb_value self)
{
    cocos2d::Label* cobj = static_cast<cocos2d::Label*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            double retval = cobj->getMaxLineWidth();
            mrb_value ret;
            ret = mrb_float_value(mrb, (mrb_float)retval);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::Label#getMaxLineWidth");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Label_getHorizontalAlignment(mrb_state* mrb, mrb_value self)
{
    cocos2d::Label* cobj = static_cast<cocos2d::Label*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            int retval = (int)cobj->getHorizontalAlignment();
            mrb_value ret;
            ret = mrb_fixnum_value((mrb_int)retval);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::Label#getHorizontalAlignment");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Label_setClipMarginEnabled(mrb_state* mrb, mrb_value self)
{
    cocos2d::Label* cobj = static_cast<cocos2d::Label*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            bool arg0;
            ok = rubyval_to_boolean(mrb, argv[0], &arg0, "CC::Label.setClipMarginEnabled");
            if (!ok) { break; }
            cobj->setClipMarginEnabled(arg0);
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::Label#setClipMarginEnabled");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Label_setString(mrb_state* mrb, mrb_value self)
{
    cocos2d::Label* cobj = static_cast<cocos2d::Label*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            std::string arg0;
            ok = rubyval_to_std_string(mrb, argv[0], &arg0, "CC::Label.setString");
            if (!ok) { break; }
            cobj->setString(arg0);
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::Label#setString");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Label_setSystemFontName(mrb_state* mrb, mrb_value self)
{
    cocos2d::Label* cobj = static_cast<cocos2d::Label*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            std::string arg0;
            ok = rubyval_to_std_string(mrb, argv[0], &arg0, "CC::Label.setSystemFontName");
            if (!ok) { break; }
            cobj->setSystemFontName(arg0);
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::Label#setSystemFontName");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Label_setBMFontFilePath(mrb_state* mrb, mrb_value self)
{
    cocos2d::Label* cobj = static_cast<cocos2d::Label*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            std::string arg0;
            ok = rubyval_to_std_string(mrb, argv[0], &arg0, "CC::Label.setBMFontFilePath");
            if (!ok) { break; }
            bool retval = cobj->setBMFontFilePath(arg0);
            mrb_value ret;
            ret = mrb_bool_value((mrb_bool)retval);
            return ret;
        }
    } while (0);
    do {
        if (argc == 2) {
            std::string arg0;
            ok = rubyval_to_std_string(mrb, argv[0], &arg0, "CC::Label.setBMFontFilePath");
            if (!ok) { break; }
            cocos2d::Vec2* arg1;
            ok = rubyval_to_object<cocos2d::Vec2>(mrb, argv[1], "CC::Vec2", &arg1);
            if (!ok) { break; }
            bool retval = cobj->setBMFontFilePath(arg0, *arg1);
            mrb_value ret;
            ret = mrb_bool_value((mrb_bool)retval);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::Label#setBMFontFilePath");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Label_getFontAtlas(mrb_state* mrb, mrb_value self)
{
    cocos2d::Label* cobj = static_cast<cocos2d::Label*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            cocos2d::FontAtlas* retval = cobj->getFontAtlas();
            mrb_value ret;
            ret = object_to_rubyval<cocos2d::FontAtlas>(mrb, "CC::FontAtlas", (cocos2d::FontAtlas*)retval, nullptr);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::Label#getFontAtlas");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Label_setLineHeight(mrb_state* mrb, mrb_value self)
{
    cocos2d::Label* cobj = static_cast<cocos2d::Label*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            double arg0;
            ok = rubyval_to_number(mrb, argv[0], (double*)&arg0, "CC::Label.setLineHeight");
            if (!ok) { break; }
            cobj->setLineHeight(arg0);
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::Label#setLineHeight");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Label_setSystemFontSize(mrb_state* mrb, mrb_value self)
{
    cocos2d::Label* cobj = static_cast<cocos2d::Label*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            double arg0;
            ok = rubyval_to_number(mrb, argv[0], (double*)&arg0, "CC::Label.setSystemFontSize");
            if (!ok) { break; }
            cobj->setSystemFontSize(arg0);
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::Label#setSystemFontSize");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Label_updateContent(mrb_state* mrb, mrb_value self)
{
    cocos2d::Label* cobj = static_cast<cocos2d::Label*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            cobj->updateContent();
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::Label#updateContent");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Label_getStringLength(mrb_state* mrb, mrb_value self)
{
    cocos2d::Label* cobj = static_cast<cocos2d::Label*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            int retval = cobj->getStringLength();
            mrb_value ret;
            ret = mrb_fixnum_value((mrb_int)retval);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::Label#getStringLength");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Label_setLineBreakWithoutSpace(mrb_state* mrb, mrb_value self)
{
    cocos2d::Label* cobj = static_cast<cocos2d::Label*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            bool arg0;
            ok = rubyval_to_boolean(mrb, argv[0], &arg0, "CC::Label.setLineBreakWithoutSpace");
            if (!ok) { break; }
            cobj->setLineBreakWithoutSpace(arg0);
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::Label#setLineBreakWithoutSpace");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Label_getStringNumLines(mrb_state* mrb, mrb_value self)
{
    cocos2d::Label* cobj = static_cast<cocos2d::Label*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            int retval = cobj->getStringNumLines();
            mrb_value ret;
            ret = mrb_fixnum_value((mrb_int)retval);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::Label#getStringNumLines");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Label_enableOutline(mrb_state* mrb, mrb_value self)
{
    cocos2d::Label* cobj = static_cast<cocos2d::Label*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            cocos2d::Color4B* arg0;
            ok = rubyval_to_object<cocos2d::Color4B>(mrb, argv[0], "CC::Color4B", &arg0);
            if (!ok) { break; }
            cobj->enableOutline(*arg0);
            return self;
        }
    } while (0);
    do {
        if (argc == 2) {
            cocos2d::Color4B* arg0;
            ok = rubyval_to_object<cocos2d::Color4B>(mrb, argv[0], "CC::Color4B", &arg0);
            if (!ok) { break; }
            int arg1;
            ok = rubyval_to_int32(mrb, argv[1], (int*)&arg1, "CC::Label.enableOutline");
            if (!ok) { break; }
            cobj->enableOutline(*arg0, arg1);
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::Label#enableOutline");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Label_getAdditionalKerning(mrb_state* mrb, mrb_value self)
{
    cocos2d::Label* cobj = static_cast<cocos2d::Label*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            double retval = cobj->getAdditionalKerning();
            mrb_value ret;
            ret = mrb_float_value(mrb, (mrb_float)retval);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::Label#getAdditionalKerning");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Label_setCharMap(mrb_state* mrb, mrb_value self)
{
    cocos2d::Label* cobj = static_cast<cocos2d::Label*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 4) {
            cocos2d::Texture2D* arg0;
            ok = rubyval_to_object<cocos2d::Texture2D>(mrb, argv[0], "CC::Texture2D", &arg0);
            if (!ok) { break; }
            int arg1;
            ok = rubyval_to_int32(mrb, argv[1], (int*)&arg1, "CC::Label.setCharMap");
            if (!ok) { break; }
            int arg2;
            ok = rubyval_to_int32(mrb, argv[2], (int*)&arg2, "CC::Label.setCharMap");
            if (!ok) { break; }
            int arg3;
            ok = rubyval_to_int32(mrb, argv[3], (int*)&arg3, "CC::Label.setCharMap");
            if (!ok) { break; }
            bool retval = cobj->setCharMap(arg0, arg1, arg2, arg3);
            mrb_value ret;
            ret = mrb_bool_value((mrb_bool)retval);
            return ret;
        }
    } while (0);
    do {
        if (argc == 4) {
            std::string arg0;
            ok = rubyval_to_std_string(mrb, argv[0], &arg0, "CC::Label.setCharMap");
            if (!ok) { break; }
            int arg1;
            ok = rubyval_to_int32(mrb, argv[1], (int*)&arg1, "CC::Label.setCharMap");
            if (!ok) { break; }
            int arg2;
            ok = rubyval_to_int32(mrb, argv[2], (int*)&arg2, "CC::Label.setCharMap");
            if (!ok) { break; }
            int arg3;
            ok = rubyval_to_int32(mrb, argv[3], (int*)&arg3, "CC::Label.setCharMap");
            if (!ok) { break; }
            bool retval = cobj->setCharMap(arg0, arg1, arg2, arg3);
            mrb_value ret;
            ret = mrb_bool_value((mrb_bool)retval);
            return ret;
        }
    } while (0);
    do {
        if (argc == 1) {
            std::string arg0;
            ok = rubyval_to_std_string(mrb, argv[0], &arg0, "CC::Label.setCharMap");
            if (!ok) { break; }
            bool retval = cobj->setCharMap(arg0);
            mrb_value ret;
            ret = mrb_bool_value((mrb_bool)retval);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::Label#setCharMap");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Label_getDimensions(mrb_state* mrb, mrb_value self)
{
    cocos2d::Label* cobj = static_cast<cocos2d::Label*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            cocos2d::Size retval = cobj->getDimensions();
            cocos2d::Size* retval_ptr = new cocos2d::Size(retval);
            mrb_value ret;
            ret = object_to_rubyval<cocos2d::Size>(mrb, "CC::Size", (cocos2d::Size*)retval_ptr, nullptr);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::Label#getDimensions");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Label_setMaxLineWidth(mrb_state* mrb, mrb_value self)
{
    cocos2d::Label* cobj = static_cast<cocos2d::Label*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            double arg0;
            ok = rubyval_to_number(mrb, argv[0], (double*)&arg0, "CC::Label.setMaxLineWidth");
            if (!ok) { break; }
            cobj->setMaxLineWidth(arg0);
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::Label#setMaxLineWidth");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Label_getSystemFontName(mrb_state* mrb, mrb_value self)
{
    cocos2d::Label* cobj = static_cast<cocos2d::Label*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            std::string retval = cobj->getSystemFontName();
            mrb_value ret;
            ret = mrb_str_new_cstr(mrb, retval.c_str());
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::Label#getSystemFontName");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Label_setVerticalAlignment(mrb_state* mrb, mrb_value self)
{
    cocos2d::Label* cobj = static_cast<cocos2d::Label*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            cocos2d::TextVAlignment arg0;
            ok = rubyval_to_int32(mrb, argv[0], (int*)&arg0, "CC::Label.setVerticalAlignment");
            if (!ok) { break; }
            cobj->setVerticalAlignment(arg0);
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::Label#setVerticalAlignment");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Label_getLineHeight(mrb_state* mrb, mrb_value self)
{
    cocos2d::Label* cobj = static_cast<cocos2d::Label*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            double retval = cobj->getLineHeight();
            mrb_value ret;
            ret = mrb_float_value(mrb, (mrb_float)retval);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::Label#getLineHeight");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Label_getTTFConfig(mrb_state* mrb, mrb_value self)
{
    cocos2d::Label* cobj = static_cast<cocos2d::Label*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            cocos2d::_ttfConfig retval = cobj->getTTFConfig();
            cocos2d::_ttfConfig* retval_ptr = new cocos2d::_ttfConfig(retval);
            mrb_value ret;
            ret = object_to_rubyval<cocos2d::_ttfConfig>(mrb, "CC::_ttfConfig", (cocos2d::_ttfConfig*)retval_ptr, nullptr);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::Label#getTTFConfig");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Label_getVerticalAlignment(mrb_state* mrb, mrb_value self)
{
    cocos2d::Label* cobj = static_cast<cocos2d::Label*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            int retval = (int)cobj->getVerticalAlignment();
            mrb_value ret;
            ret = mrb_fixnum_value((mrb_int)retval);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::Label#getVerticalAlignment");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Label_setTextColor(mrb_state* mrb, mrb_value self)
{
    cocos2d::Label* cobj = static_cast<cocos2d::Label*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            cocos2d::Color4B* arg0;
            ok = rubyval_to_object<cocos2d::Color4B>(mrb, argv[0], "CC::Color4B", &arg0);
            if (!ok) { break; }
            cobj->setTextColor(*arg0);
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::Label#setTextColor");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Label_setHeight(mrb_state* mrb, mrb_value self)
{
    cocos2d::Label* cobj = static_cast<cocos2d::Label*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            double arg0;
            ok = rubyval_to_number(mrb, argv[0], (double*)&arg0, "CC::Label.setHeight");
            if (!ok) { break; }
            cobj->setHeight(arg0);
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::Label#setHeight");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Label_getWidth(mrb_state* mrb, mrb_value self)
{
    cocos2d::Label* cobj = static_cast<cocos2d::Label*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            double retval = cobj->getWidth();
            mrb_value ret;
            ret = mrb_float_value(mrb, (mrb_float)retval);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::Label#getWidth");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Label_enableGlow(mrb_state* mrb, mrb_value self)
{
    cocos2d::Label* cobj = static_cast<cocos2d::Label*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            cocos2d::Color4B* arg0;
            ok = rubyval_to_object<cocos2d::Color4B>(mrb, argv[0], "CC::Color4B", &arg0);
            if (!ok) { break; }
            cobj->enableGlow(*arg0);
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::Label#enableGlow");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Label_getLetter(mrb_state* mrb, mrb_value self)
{
    cocos2d::Label* cobj = static_cast<cocos2d::Label*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            int arg0;
            ok = rubyval_to_int32(mrb, argv[0], (int*)&arg0, "CC::Label.getLetter");
            if (!ok) { break; }
            cocos2d::Sprite* retval = cobj->getLetter(arg0);
            mrb_value ret;
            ret = object_to_rubyval<cocos2d::Sprite>(mrb, "CC::Sprite", (cocos2d::Sprite*)retval, nullptr);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::Label#getLetter");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Label_setAdditionalKerning(mrb_state* mrb, mrb_value self)
{
    cocos2d::Label* cobj = static_cast<cocos2d::Label*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            double arg0;
            ok = rubyval_to_number(mrb, argv[0], (double*)&arg0, "CC::Label.setAdditionalKerning");
            if (!ok) { break; }
            cobj->setAdditionalKerning(arg0);
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::Label#setAdditionalKerning");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Label_getSystemFontSize(mrb_state* mrb, mrb_value self)
{
    cocos2d::Label* cobj = static_cast<cocos2d::Label*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            double retval = cobj->getSystemFontSize();
            mrb_value ret;
            ret = mrb_float_value(mrb, (mrb_float)retval);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::Label#getSystemFontSize");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Label_getTextAlignment(mrb_state* mrb, mrb_value self)
{
    cocos2d::Label* cobj = static_cast<cocos2d::Label*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            int retval = (int)cobj->getTextAlignment();
            mrb_value ret;
            ret = mrb_fixnum_value((mrb_int)retval);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::Label#getTextAlignment");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Label_getBMFontFilePath(mrb_state* mrb, mrb_value self)
{
    cocos2d::Label* cobj = static_cast<cocos2d::Label*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            std::string retval = cobj->getBMFontFilePath();
            mrb_value ret;
            ret = mrb_str_new_cstr(mrb, retval.c_str());
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::Label#getBMFontFilePath");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Label_setHorizontalAlignment(mrb_state* mrb, mrb_value self)
{
    cocos2d::Label* cobj = static_cast<cocos2d::Label*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            cocos2d::TextHAlignment arg0;
            ok = rubyval_to_int32(mrb, argv[0], (int*)&arg0, "CC::Label.setHorizontalAlignment");
            if (!ok) { break; }
            cobj->setHorizontalAlignment(arg0);
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::Label#setHorizontalAlignment");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Label_setAlignment(mrb_state* mrb, mrb_value self)
{
    cocos2d::Label* cobj = static_cast<cocos2d::Label*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 2) {
            cocos2d::TextHAlignment arg0;
            ok = rubyval_to_int32(mrb, argv[0], (int*)&arg0, "CC::Label.setAlignment");
            if (!ok) { break; }
            cocos2d::TextVAlignment arg1;
            ok = rubyval_to_int32(mrb, argv[1], (int*)&arg1, "CC::Label.setAlignment");
            if (!ok) { break; }
            cobj->setAlignment(arg0, arg1);
            return self;
        }
    } while (0);
    do {
        if (argc == 1) {
            cocos2d::TextHAlignment arg0;
            ok = rubyval_to_int32(mrb, argv[0], (int*)&arg0, "CC::Label.setAlignment");
            if (!ok) { break; }
            cobj->setAlignment(arg0);
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::Label#setAlignment");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Label_requestSystemFontRefresh(mrb_state* mrb, mrb_value self)
{
    cocos2d::Label* cobj = static_cast<cocos2d::Label*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            cobj->requestSystemFontRefresh();
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::Label#requestSystemFontRefresh");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Label_createWithBMFont_static(mrb_state* mrb, mrb_value self)
{
    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 2) {
            std::map<std::string, mrb_value> callbacks;
            std::string arg0;
            ok = rubyval_to_std_string(mrb, argv[0], &arg0, "CC::Label.createWithBMFont");
            if (!ok) { break; }

            std::string arg1;
            ok = rubyval_to_std_string(mrb, argv[1], &arg1, "CC::Label.createWithBMFont");
            if (!ok) { break; }

            cocos2d::Label* retval = cocos2d::Label::createWithBMFont(arg0, arg1);
            mrb_value ret;
            RClass* rclass = mrb_class_ptr(self);
            ret = object_to_rubyval<cocos2d::Label>(mrb, "CC::Label", (cocos2d::Label*)retval, rclass);
            if (callbacks.size() > 0) {
                mrb_value hash = mrb_iv_get(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"));
                if (!mrb_hash_p(hash)) {
                    hash = mrb_hash_new(mrb);
                }
                for (auto elm : callbacks) {
                    mrb_hash_set(mrb, hash, mrb_str_new_cstr(mrb, elm.first.c_str()), elm.second);
                    mrb_iv_set(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"), hash);
                }
            }
            g_rubyValue.push_back(ret);
            mrb_funcall(mrb, ret, "initialize", 0);
            return ret;
        }
    } while (0);
    do {
        if (argc == 3) {
            std::map<std::string, mrb_value> callbacks;
            std::string arg0;
            ok = rubyval_to_std_string(mrb, argv[0], &arg0, "CC::Label.createWithBMFont");
            if (!ok) { break; }

            std::string arg1;
            ok = rubyval_to_std_string(mrb, argv[1], &arg1, "CC::Label.createWithBMFont");
            if (!ok) { break; }

            cocos2d::TextHAlignment arg2;
            ok = rubyval_to_int32(mrb, argv[2], (int*)&arg2, "CC::Label.createWithBMFont");
            if (!ok) { break; }

            cocos2d::Label* retval = cocos2d::Label::createWithBMFont(arg0, arg1, arg2);
            mrb_value ret;
            RClass* rclass = mrb_class_ptr(self);
            ret = object_to_rubyval<cocos2d::Label>(mrb, "CC::Label", (cocos2d::Label*)retval, rclass);
            if (callbacks.size() > 0) {
                mrb_value hash = mrb_iv_get(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"));
                if (!mrb_hash_p(hash)) {
                    hash = mrb_hash_new(mrb);
                }
                for (auto elm : callbacks) {
                    mrb_hash_set(mrb, hash, mrb_str_new_cstr(mrb, elm.first.c_str()), elm.second);
                    mrb_iv_set(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"), hash);
                }
            }
            g_rubyValue.push_back(ret);
            mrb_funcall(mrb, ret, "initialize", 0);
            return ret;
        }
    } while (0);
    do {
        if (argc == 4) {
            std::map<std::string, mrb_value> callbacks;
            std::string arg0;
            ok = rubyval_to_std_string(mrb, argv[0], &arg0, "CC::Label.createWithBMFont");
            if (!ok) { break; }

            std::string arg1;
            ok = rubyval_to_std_string(mrb, argv[1], &arg1, "CC::Label.createWithBMFont");
            if (!ok) { break; }

            cocos2d::TextHAlignment arg2;
            ok = rubyval_to_int32(mrb, argv[2], (int*)&arg2, "CC::Label.createWithBMFont");
            if (!ok) { break; }

            int arg3;
            ok = rubyval_to_int32(mrb, argv[3], (int*)&arg3, "CC::Label.createWithBMFont");
            if (!ok) { break; }

            cocos2d::Label* retval = cocos2d::Label::createWithBMFont(arg0, arg1, arg2, arg3);
            mrb_value ret;
            RClass* rclass = mrb_class_ptr(self);
            ret = object_to_rubyval<cocos2d::Label>(mrb, "CC::Label", (cocos2d::Label*)retval, rclass);
            if (callbacks.size() > 0) {
                mrb_value hash = mrb_iv_get(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"));
                if (!mrb_hash_p(hash)) {
                    hash = mrb_hash_new(mrb);
                }
                for (auto elm : callbacks) {
                    mrb_hash_set(mrb, hash, mrb_str_new_cstr(mrb, elm.first.c_str()), elm.second);
                    mrb_iv_set(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"), hash);
                }
            }
            g_rubyValue.push_back(ret);
            mrb_funcall(mrb, ret, "initialize", 0);
            return ret;
        }
    } while (0);
    do {
        if (argc == 5) {
            std::map<std::string, mrb_value> callbacks;
            std::string arg0;
            ok = rubyval_to_std_string(mrb, argv[0], &arg0, "CC::Label.createWithBMFont");
            if (!ok) { break; }

            std::string arg1;
            ok = rubyval_to_std_string(mrb, argv[1], &arg1, "CC::Label.createWithBMFont");
            if (!ok) { break; }

            cocos2d::TextHAlignment arg2;
            ok = rubyval_to_int32(mrb, argv[2], (int*)&arg2, "CC::Label.createWithBMFont");
            if (!ok) { break; }

            int arg3;
            ok = rubyval_to_int32(mrb, argv[3], (int*)&arg3, "CC::Label.createWithBMFont");
            if (!ok) { break; }

            cocos2d::Vec2* arg4;
            ok = rubyval_to_object<cocos2d::Vec2>(mrb, argv[4], "CC::Vec2", &arg4);
            if (!ok) { break; }

            cocos2d::Label* retval = cocos2d::Label::createWithBMFont(arg0, arg1, arg2, arg3, *arg4);
            mrb_value ret;
            RClass* rclass = mrb_class_ptr(self);
            ret = object_to_rubyval<cocos2d::Label>(mrb, "CC::Label", (cocos2d::Label*)retval, rclass);
            if (callbacks.size() > 0) {
                mrb_value hash = mrb_iv_get(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"));
                if (!mrb_hash_p(hash)) {
                    hash = mrb_hash_new(mrb);
                }
                for (auto elm : callbacks) {
                    mrb_hash_set(mrb, hash, mrb_str_new_cstr(mrb, elm.first.c_str()), elm.second);
                    mrb_iv_set(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"), hash);
                }
            }
            g_rubyValue.push_back(ret);
            mrb_funcall(mrb, ret, "initialize", 0);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined static method : cocos2d::Label#createWithBMFont");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Label_create_static(mrb_state* mrb, mrb_value self)
{
    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            std::map<std::string, mrb_value> callbacks;
            cocos2d::Label* retval = cocos2d::Label::create();
            mrb_value ret;
            RClass* rclass = mrb_class_ptr(self);
            ret = object_to_rubyval<cocos2d::Label>(mrb, "CC::Label", (cocos2d::Label*)retval, rclass);
            if (callbacks.size() > 0) {
                mrb_value hash = mrb_iv_get(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"));
                if (!mrb_hash_p(hash)) {
                    hash = mrb_hash_new(mrb);
                }
                for (auto elm : callbacks) {
                    mrb_hash_set(mrb, hash, mrb_str_new_cstr(mrb, elm.first.c_str()), elm.second);
                    mrb_iv_set(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"), hash);
                }
            }
            g_rubyValue.push_back(ret);
            mrb_funcall(mrb, ret, "initialize", 0);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined static method : cocos2d::Label#create");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Label_createWithCharMap_static(mrb_state* mrb, mrb_value self)
{
    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 4) {
            std::map<std::string, mrb_value> callbacks;
            cocos2d::Texture2D* arg0;
            ok = rubyval_to_object<cocos2d::Texture2D>(mrb, argv[0], "CC::Texture2D", &arg0);
            if (!ok) { break; }

            int arg1;
            ok = rubyval_to_int32(mrb, argv[1], (int*)&arg1, "CC::Label.createWithCharMap");
            if (!ok) { break; }

            int arg2;
            ok = rubyval_to_int32(mrb, argv[2], (int*)&arg2, "CC::Label.createWithCharMap");
            if (!ok) { break; }

            int arg3;
            ok = rubyval_to_int32(mrb, argv[3], (int*)&arg3, "CC::Label.createWithCharMap");
            if (!ok) { break; }

            cocos2d::Label* retval = cocos2d::Label::createWithCharMap(arg0, arg1, arg2, arg3);
            mrb_value ret;
            RClass* rclass = mrb_class_ptr(self);
            ret = object_to_rubyval<cocos2d::Label>(mrb, "CC::Label", (cocos2d::Label*)retval, rclass);
            if (callbacks.size() > 0) {
                mrb_value hash = mrb_iv_get(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"));
                if (!mrb_hash_p(hash)) {
                    hash = mrb_hash_new(mrb);
                }
                for (auto elm : callbacks) {
                    mrb_hash_set(mrb, hash, mrb_str_new_cstr(mrb, elm.first.c_str()), elm.second);
                    mrb_iv_set(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"), hash);
                }
            }
            g_rubyValue.push_back(ret);
            mrb_funcall(mrb, ret, "initialize", 0);
            return ret;
        }
    } while (0);
    do {
        if (argc == 4) {
            std::map<std::string, mrb_value> callbacks;
            std::string arg0;
            ok = rubyval_to_std_string(mrb, argv[0], &arg0, "CC::Label.createWithCharMap");
            if (!ok) { break; }

            int arg1;
            ok = rubyval_to_int32(mrb, argv[1], (int*)&arg1, "CC::Label.createWithCharMap");
            if (!ok) { break; }

            int arg2;
            ok = rubyval_to_int32(mrb, argv[2], (int*)&arg2, "CC::Label.createWithCharMap");
            if (!ok) { break; }

            int arg3;
            ok = rubyval_to_int32(mrb, argv[3], (int*)&arg3, "CC::Label.createWithCharMap");
            if (!ok) { break; }

            cocos2d::Label* retval = cocos2d::Label::createWithCharMap(arg0, arg1, arg2, arg3);
            mrb_value ret;
            RClass* rclass = mrb_class_ptr(self);
            ret = object_to_rubyval<cocos2d::Label>(mrb, "CC::Label", (cocos2d::Label*)retval, rclass);
            if (callbacks.size() > 0) {
                mrb_value hash = mrb_iv_get(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"));
                if (!mrb_hash_p(hash)) {
                    hash = mrb_hash_new(mrb);
                }
                for (auto elm : callbacks) {
                    mrb_hash_set(mrb, hash, mrb_str_new_cstr(mrb, elm.first.c_str()), elm.second);
                    mrb_iv_set(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"), hash);
                }
            }
            g_rubyValue.push_back(ret);
            mrb_funcall(mrb, ret, "initialize", 0);
            return ret;
        }
    } while (0);
    do {
        if (argc == 1) {
            std::map<std::string, mrb_value> callbacks;
            std::string arg0;
            ok = rubyval_to_std_string(mrb, argv[0], &arg0, "CC::Label.createWithCharMap");
            if (!ok) { break; }

            cocos2d::Label* retval = cocos2d::Label::createWithCharMap(arg0);
            mrb_value ret;
            RClass* rclass = mrb_class_ptr(self);
            ret = object_to_rubyval<cocos2d::Label>(mrb, "CC::Label", (cocos2d::Label*)retval, rclass);
            if (callbacks.size() > 0) {
                mrb_value hash = mrb_iv_get(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"));
                if (!mrb_hash_p(hash)) {
                    hash = mrb_hash_new(mrb);
                }
                for (auto elm : callbacks) {
                    mrb_hash_set(mrb, hash, mrb_str_new_cstr(mrb, elm.first.c_str()), elm.second);
                    mrb_iv_set(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"), hash);
                }
            }
            g_rubyValue.push_back(ret);
            mrb_funcall(mrb, ret, "initialize", 0);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined static method : cocos2d::Label#createWithCharMap");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Label_createWithSystemFont_static(mrb_state* mrb, mrb_value self)
{
    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 3) {
            std::map<std::string, mrb_value> callbacks;
            std::string arg0;
            ok = rubyval_to_std_string(mrb, argv[0], &arg0, "CC::Label.createWithSystemFont");
            if (!ok) { break; }

            std::string arg1;
            ok = rubyval_to_std_string(mrb, argv[1], &arg1, "CC::Label.createWithSystemFont");
            if (!ok) { break; }

            double arg2;
            ok = rubyval_to_number(mrb, argv[2], (double*)&arg2, "CC::Label.createWithSystemFont");
            if (!ok) { break; }

            cocos2d::Label* retval = cocos2d::Label::createWithSystemFont(arg0, arg1, arg2);
            mrb_value ret;
            RClass* rclass = mrb_class_ptr(self);
            ret = object_to_rubyval<cocos2d::Label>(mrb, "CC::Label", (cocos2d::Label*)retval, rclass);
            if (callbacks.size() > 0) {
                mrb_value hash = mrb_iv_get(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"));
                if (!mrb_hash_p(hash)) {
                    hash = mrb_hash_new(mrb);
                }
                for (auto elm : callbacks) {
                    mrb_hash_set(mrb, hash, mrb_str_new_cstr(mrb, elm.first.c_str()), elm.second);
                    mrb_iv_set(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"), hash);
                }
            }
            g_rubyValue.push_back(ret);
            mrb_funcall(mrb, ret, "initialize", 0);
            return ret;
        }
    } while (0);
    do {
        if (argc == 4) {
            std::map<std::string, mrb_value> callbacks;
            std::string arg0;
            ok = rubyval_to_std_string(mrb, argv[0], &arg0, "CC::Label.createWithSystemFont");
            if (!ok) { break; }

            std::string arg1;
            ok = rubyval_to_std_string(mrb, argv[1], &arg1, "CC::Label.createWithSystemFont");
            if (!ok) { break; }

            double arg2;
            ok = rubyval_to_number(mrb, argv[2], (double*)&arg2, "CC::Label.createWithSystemFont");
            if (!ok) { break; }

            cocos2d::Size* arg3;
            ok = rubyval_to_object<cocos2d::Size>(mrb, argv[3], "CC::Size", &arg3);
            if (!ok) { break; }

            cocos2d::Label* retval = cocos2d::Label::createWithSystemFont(arg0, arg1, arg2, *arg3);
            mrb_value ret;
            RClass* rclass = mrb_class_ptr(self);
            ret = object_to_rubyval<cocos2d::Label>(mrb, "CC::Label", (cocos2d::Label*)retval, rclass);
            if (callbacks.size() > 0) {
                mrb_value hash = mrb_iv_get(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"));
                if (!mrb_hash_p(hash)) {
                    hash = mrb_hash_new(mrb);
                }
                for (auto elm : callbacks) {
                    mrb_hash_set(mrb, hash, mrb_str_new_cstr(mrb, elm.first.c_str()), elm.second);
                    mrb_iv_set(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"), hash);
                }
            }
            g_rubyValue.push_back(ret);
            mrb_funcall(mrb, ret, "initialize", 0);
            return ret;
        }
    } while (0);
    do {
        if (argc == 5) {
            std::map<std::string, mrb_value> callbacks;
            std::string arg0;
            ok = rubyval_to_std_string(mrb, argv[0], &arg0, "CC::Label.createWithSystemFont");
            if (!ok) { break; }

            std::string arg1;
            ok = rubyval_to_std_string(mrb, argv[1], &arg1, "CC::Label.createWithSystemFont");
            if (!ok) { break; }

            double arg2;
            ok = rubyval_to_number(mrb, argv[2], (double*)&arg2, "CC::Label.createWithSystemFont");
            if (!ok) { break; }

            cocos2d::Size* arg3;
            ok = rubyval_to_object<cocos2d::Size>(mrb, argv[3], "CC::Size", &arg3);
            if (!ok) { break; }

            cocos2d::TextHAlignment arg4;
            ok = rubyval_to_int32(mrb, argv[4], (int*)&arg4, "CC::Label.createWithSystemFont");
            if (!ok) { break; }

            cocos2d::Label* retval = cocos2d::Label::createWithSystemFont(arg0, arg1, arg2, *arg3, arg4);
            mrb_value ret;
            RClass* rclass = mrb_class_ptr(self);
            ret = object_to_rubyval<cocos2d::Label>(mrb, "CC::Label", (cocos2d::Label*)retval, rclass);
            if (callbacks.size() > 0) {
                mrb_value hash = mrb_iv_get(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"));
                if (!mrb_hash_p(hash)) {
                    hash = mrb_hash_new(mrb);
                }
                for (auto elm : callbacks) {
                    mrb_hash_set(mrb, hash, mrb_str_new_cstr(mrb, elm.first.c_str()), elm.second);
                    mrb_iv_set(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"), hash);
                }
            }
            g_rubyValue.push_back(ret);
            mrb_funcall(mrb, ret, "initialize", 0);
            return ret;
        }
    } while (0);
    do {
        if (argc == 6) {
            std::map<std::string, mrb_value> callbacks;
            std::string arg0;
            ok = rubyval_to_std_string(mrb, argv[0], &arg0, "CC::Label.createWithSystemFont");
            if (!ok) { break; }

            std::string arg1;
            ok = rubyval_to_std_string(mrb, argv[1], &arg1, "CC::Label.createWithSystemFont");
            if (!ok) { break; }

            double arg2;
            ok = rubyval_to_number(mrb, argv[2], (double*)&arg2, "CC::Label.createWithSystemFont");
            if (!ok) { break; }

            cocos2d::Size* arg3;
            ok = rubyval_to_object<cocos2d::Size>(mrb, argv[3], "CC::Size", &arg3);
            if (!ok) { break; }

            cocos2d::TextHAlignment arg4;
            ok = rubyval_to_int32(mrb, argv[4], (int*)&arg4, "CC::Label.createWithSystemFont");
            if (!ok) { break; }

            cocos2d::TextVAlignment arg5;
            ok = rubyval_to_int32(mrb, argv[5], (int*)&arg5, "CC::Label.createWithSystemFont");
            if (!ok) { break; }

            cocos2d::Label* retval = cocos2d::Label::createWithSystemFont(arg0, arg1, arg2, *arg3, arg4, arg5);
            mrb_value ret;
            RClass* rclass = mrb_class_ptr(self);
            ret = object_to_rubyval<cocos2d::Label>(mrb, "CC::Label", (cocos2d::Label*)retval, rclass);
            if (callbacks.size() > 0) {
                mrb_value hash = mrb_iv_get(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"));
                if (!mrb_hash_p(hash)) {
                    hash = mrb_hash_new(mrb);
                }
                for (auto elm : callbacks) {
                    mrb_hash_set(mrb, hash, mrb_str_new_cstr(mrb, elm.first.c_str()), elm.second);
                    mrb_iv_set(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"), hash);
                }
            }
            g_rubyValue.push_back(ret);
            mrb_funcall(mrb, ret, "initialize", 0);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined static method : cocos2d::Label#createWithSystemFont");

    return mrb_nil_value();
}

void ruby_cocos2dx_Label_constants_init(mrb_state* mrb, struct RClass* rclass)
{
    do {
        mrb_value ret;
        ret = mrb_fixnum_value((mrb_int)cocos2d::Label::DistanceFieldFontSize);
        mrb_mod_cv_set(mrb, rclass, mrb_intern_cstr(mrb, "DistanceFieldFontSize"), ret);
    } while (0);

}

void ruby_register_cocos2dx_Label(mrb_state* mrb, struct RClass* rmodule)
{
    std::string typeName = typeid(cocos2d::Label).name();
    g_rubyType[typeName] = "CC::Label";
    g_rubyDataType[typeName] = &ruby_cocos2dx_Ref_type;

    struct RClass* p_rmodule = mrb->object_class;
    p_rmodule = mrb_module_get_under(mrb, p_rmodule, "CC");
    struct RClass* p_rclass = mrb_class_get_under(mrb, p_rmodule, "SpriteBatchNode");
    struct RClass *rclass = mrb_define_class_under(mrb, rmodule, "Label", p_rclass);
    MRB_SET_INSTANCE_TT(rclass, MRB_TT_DATA);

    mrb_define_method(mrb, rclass, "clip_margin_enabled?", ruby_cocos2dx_Label_isClipMarginEnabled, ARGS_NONE());
    mrb_define_method(mrb, rclass, "enable_shadow", ruby_cocos2dx_Label_enableShadow, ARGS_REQ(3));
    mrb_define_method(mrb, rclass, "set_dimensions", ruby_cocos2dx_Label_setDimensions, ARGS_REQ(2));
    mrb_define_method(mrb, rclass, "get_string", ruby_cocos2dx_Label_getString, ARGS_NONE());
    mrb_define_method(mrb, rclass, "get_height", ruby_cocos2dx_Label_getHeight, ARGS_NONE());
    mrb_define_method(mrb, rclass, "disable_effect", ruby_cocos2dx_Label_disableEffect, ARGS_NONE());
    mrb_define_method(mrb, rclass, "set_ttfconfig", ruby_cocos2dx_Label_setTTFConfig, ARGS_REQ(1));
    mrb_define_method(mrb, rclass, "get_text_color", ruby_cocos2dx_Label_getTextColor, ARGS_NONE());
    mrb_define_method(mrb, rclass, "set_width", ruby_cocos2dx_Label_setWidth, ARGS_REQ(1));
    mrb_define_method(mrb, rclass, "get_max_line_width", ruby_cocos2dx_Label_getMaxLineWidth, ARGS_NONE());
    mrb_define_method(mrb, rclass, "get_horizontal_alignment", ruby_cocos2dx_Label_getHorizontalAlignment, ARGS_NONE());
    mrb_define_method(mrb, rclass, "set_clip_margin_enabled", ruby_cocos2dx_Label_setClipMarginEnabled, ARGS_REQ(1));
    mrb_define_method(mrb, rclass, "set_string", ruby_cocos2dx_Label_setString, ARGS_REQ(1));
    mrb_define_method(mrb, rclass, "set_system_font_name", ruby_cocos2dx_Label_setSystemFontName, ARGS_REQ(1));
    mrb_define_method(mrb, rclass, "set_bmfont_file_path", ruby_cocos2dx_Label_setBMFontFilePath, ARGS_REQ(2));
    mrb_define_method(mrb, rclass, "get_font_atlas", ruby_cocos2dx_Label_getFontAtlas, ARGS_NONE());
    mrb_define_method(mrb, rclass, "set_line_height", ruby_cocos2dx_Label_setLineHeight, ARGS_REQ(1));
    mrb_define_method(mrb, rclass, "set_system_font_size", ruby_cocos2dx_Label_setSystemFontSize, ARGS_REQ(1));
    mrb_define_method(mrb, rclass, "update_content", ruby_cocos2dx_Label_updateContent, ARGS_NONE());
    mrb_define_method(mrb, rclass, "get_string_length", ruby_cocos2dx_Label_getStringLength, ARGS_NONE());
    mrb_define_method(mrb, rclass, "set_line_break_without_space", ruby_cocos2dx_Label_setLineBreakWithoutSpace, ARGS_REQ(1));
    mrb_define_method(mrb, rclass, "get_string_num_lines", ruby_cocos2dx_Label_getStringNumLines, ARGS_NONE());
    mrb_define_method(mrb, rclass, "enable_outline", ruby_cocos2dx_Label_enableOutline, ARGS_REQ(2));
    mrb_define_method(mrb, rclass, "get_additional_kerning", ruby_cocos2dx_Label_getAdditionalKerning, ARGS_NONE());
    mrb_define_method(mrb, rclass, "set_char_map", ruby_cocos2dx_Label_setCharMap, ARGS_REQ(1)|ARGS_OPT(3));
    mrb_define_method(mrb, rclass, "get_dimensions", ruby_cocos2dx_Label_getDimensions, ARGS_NONE());
    mrb_define_method(mrb, rclass, "set_max_line_width", ruby_cocos2dx_Label_setMaxLineWidth, ARGS_REQ(1));
    mrb_define_method(mrb, rclass, "get_system_font_name", ruby_cocos2dx_Label_getSystemFontName, ARGS_NONE());
    mrb_define_method(mrb, rclass, "set_vertical_alignment", ruby_cocos2dx_Label_setVerticalAlignment, ARGS_REQ(1));
    mrb_define_method(mrb, rclass, "get_line_height", ruby_cocos2dx_Label_getLineHeight, ARGS_NONE());
    mrb_define_method(mrb, rclass, "get_ttfconfig", ruby_cocos2dx_Label_getTTFConfig, ARGS_NONE());
    mrb_define_method(mrb, rclass, "get_vertical_alignment", ruby_cocos2dx_Label_getVerticalAlignment, ARGS_NONE());
    mrb_define_method(mrb, rclass, "set_text_color", ruby_cocos2dx_Label_setTextColor, ARGS_REQ(1));
    mrb_define_method(mrb, rclass, "set_height", ruby_cocos2dx_Label_setHeight, ARGS_REQ(1));
    mrb_define_method(mrb, rclass, "get_width", ruby_cocos2dx_Label_getWidth, ARGS_NONE());
    mrb_define_method(mrb, rclass, "enable_glow", ruby_cocos2dx_Label_enableGlow, ARGS_REQ(1));
    mrb_define_method(mrb, rclass, "get_letter", ruby_cocos2dx_Label_getLetter, ARGS_REQ(1));
    mrb_define_method(mrb, rclass, "set_additional_kerning", ruby_cocos2dx_Label_setAdditionalKerning, ARGS_REQ(1));
    mrb_define_method(mrb, rclass, "get_system_font_size", ruby_cocos2dx_Label_getSystemFontSize, ARGS_NONE());
    mrb_define_method(mrb, rclass, "get_text_alignment", ruby_cocos2dx_Label_getTextAlignment, ARGS_NONE());
    mrb_define_method(mrb, rclass, "get_bmfont_file_path", ruby_cocos2dx_Label_getBMFontFilePath, ARGS_NONE());
    mrb_define_method(mrb, rclass, "set_horizontal_alignment", ruby_cocos2dx_Label_setHorizontalAlignment, ARGS_REQ(1));
    mrb_define_method(mrb, rclass, "set_alignment", ruby_cocos2dx_Label_setAlignment, ARGS_REQ(1)|ARGS_OPT(1));
    mrb_define_method(mrb, rclass, "request_system_font_refresh", ruby_cocos2dx_Label_requestSystemFontRefresh, ARGS_NONE());
    mrb_define_class_method(mrb, rclass, "create_with_bmfont", ruby_cocos2dx_Label_createWithBMFont_static, ARGS_REQ(5));
    mrb_define_class_method(mrb, rclass, "create", ruby_cocos2dx_Label_create_static, ARGS_NONE());
    mrb_define_class_method(mrb, rclass, "create_with_char_map", ruby_cocos2dx_Label_createWithCharMap_static, ARGS_REQ(1)|ARGS_OPT(3));
    mrb_define_class_method(mrb, rclass, "create_with_system_font", ruby_cocos2dx_Label_createWithSystemFont_static, ARGS_REQ(6));
    ruby_cocos2dx_Label_constants_init(mrb, rclass);
    mrb_define_class_method(mrb, rclass, "DistanceFieldFontSize", ruby_cocos2dx_constant_get, ARGS_NONE());
}
mrb_value ruby_cocos2dx_Layer_create_static(mrb_state* mrb, mrb_value self)
{
    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            std::map<std::string, mrb_value> callbacks;
            cocos2d::Layer* retval = cocos2d::Layer::create();
            mrb_value ret;
            RClass* rclass = mrb_class_ptr(self);
            ret = object_to_rubyval<cocos2d::Layer>(mrb, "CC::Layer", (cocos2d::Layer*)retval, rclass);
            if (callbacks.size() > 0) {
                mrb_value hash = mrb_iv_get(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"));
                if (!mrb_hash_p(hash)) {
                    hash = mrb_hash_new(mrb);
                }
                for (auto elm : callbacks) {
                    mrb_hash_set(mrb, hash, mrb_str_new_cstr(mrb, elm.first.c_str()), elm.second);
                    mrb_iv_set(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"), hash);
                }
            }
            g_rubyValue.push_back(ret);
            mrb_funcall(mrb, ret, "initialize", 0);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined static method : cocos2d::Layer#create");

    return mrb_nil_value();
}

void ruby_register_cocos2dx_Layer(mrb_state* mrb, struct RClass* rmodule)
{
    std::string typeName = typeid(cocos2d::Layer).name();
    g_rubyType[typeName] = "CC::Layer";
    g_rubyDataType[typeName] = &ruby_cocos2dx_Ref_type;

    struct RClass* p_rmodule = mrb->object_class;
    p_rmodule = mrb_module_get_under(mrb, p_rmodule, "CC");
    struct RClass* p_rclass = mrb_class_get_under(mrb, p_rmodule, "Node");
    struct RClass *rclass = mrb_define_class_under(mrb, rmodule, "Layer", p_rclass);
    MRB_SET_INSTANCE_TT(rclass, MRB_TT_DATA);

    mrb_define_class_method(mrb, rclass, "create", ruby_cocos2dx_Layer_create_static, ARGS_NONE());
}
mrb_value ruby_cocos2dx_LayerColor_changeWidthAndHeight(mrb_state* mrb, mrb_value self)
{
    cocos2d::LayerColor* cobj = static_cast<cocos2d::LayerColor*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 2) {
            double arg0;
            ok = rubyval_to_number(mrb, argv[0], (double*)&arg0, "CC::LayerColor.changeWidthAndHeight");
            if (!ok) { break; }
            double arg1;
            ok = rubyval_to_number(mrb, argv[1], (double*)&arg1, "CC::LayerColor.changeWidthAndHeight");
            if (!ok) { break; }
            cobj->changeWidthAndHeight(arg0, arg1);
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::LayerColor#changeWidthAndHeight");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_LayerColor_getBlendFunc(mrb_state* mrb, mrb_value self)
{
    cocos2d::LayerColor* cobj = static_cast<cocos2d::LayerColor*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            cocos2d::BlendFunc retval = cobj->getBlendFunc();
            cocos2d::BlendFunc* retval_ptr = new cocos2d::BlendFunc(retval);
            mrb_value ret;
            ret = object_to_rubyval<cocos2d::BlendFunc>(mrb, "CC::BlendFunc", (cocos2d::BlendFunc*)retval_ptr, nullptr);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::LayerColor#getBlendFunc");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_LayerColor_changeHeight(mrb_state* mrb, mrb_value self)
{
    cocos2d::LayerColor* cobj = static_cast<cocos2d::LayerColor*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            double arg0;
            ok = rubyval_to_number(mrb, argv[0], (double*)&arg0, "CC::LayerColor.changeHeight");
            if (!ok) { break; }
            cobj->changeHeight(arg0);
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::LayerColor#changeHeight");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_LayerColor_setBlendFunc(mrb_state* mrb, mrb_value self)
{
    cocos2d::LayerColor* cobj = static_cast<cocos2d::LayerColor*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            cocos2d::BlendFunc* arg0;
            ok = rubyval_to_object<cocos2d::BlendFunc>(mrb, argv[0], "CC::BlendFunc", &arg0);
            if (!ok) { break; }
            cobj->setBlendFunc(*arg0);
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::LayerColor#setBlendFunc");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_LayerColor_changeWidth(mrb_state* mrb, mrb_value self)
{
    cocos2d::LayerColor* cobj = static_cast<cocos2d::LayerColor*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            double arg0;
            ok = rubyval_to_number(mrb, argv[0], (double*)&arg0, "CC::LayerColor.changeWidth");
            if (!ok) { break; }
            cobj->changeWidth(arg0);
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::LayerColor#changeWidth");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_LayerColor_create_static(mrb_state* mrb, mrb_value self)
{
    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 3) {
            std::map<std::string, mrb_value> callbacks;
            cocos2d::Color4B* arg0;
            ok = rubyval_to_object<cocos2d::Color4B>(mrb, argv[0], "CC::Color4B", &arg0);
            if (!ok) { break; }

            double arg1;
            ok = rubyval_to_number(mrb, argv[1], (double*)&arg1, "CC::LayerColor.create");
            if (!ok) { break; }

            double arg2;
            ok = rubyval_to_number(mrb, argv[2], (double*)&arg2, "CC::LayerColor.create");
            if (!ok) { break; }

            cocos2d::LayerColor* retval = cocos2d::LayerColor::create(*arg0, arg1, arg2);
            mrb_value ret;
            RClass* rclass = mrb_class_ptr(self);
            ret = object_to_rubyval<cocos2d::LayerColor>(mrb, "CC::LayerColor", (cocos2d::LayerColor*)retval, rclass);
            if (callbacks.size() > 0) {
                mrb_value hash = mrb_iv_get(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"));
                if (!mrb_hash_p(hash)) {
                    hash = mrb_hash_new(mrb);
                }
                for (auto elm : callbacks) {
                    mrb_hash_set(mrb, hash, mrb_str_new_cstr(mrb, elm.first.c_str()), elm.second);
                    mrb_iv_set(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"), hash);
                }
            }
            g_rubyValue.push_back(ret);
            mrb_funcall(mrb, ret, "initialize", 0);
            return ret;
        }
    } while (0);
    do {
        if (argc == 0) {
            std::map<std::string, mrb_value> callbacks;
            cocos2d::LayerColor* retval = cocos2d::LayerColor::create();
            mrb_value ret;
            RClass* rclass = mrb_class_ptr(self);
            ret = object_to_rubyval<cocos2d::LayerColor>(mrb, "CC::LayerColor", (cocos2d::LayerColor*)retval, rclass);
            if (callbacks.size() > 0) {
                mrb_value hash = mrb_iv_get(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"));
                if (!mrb_hash_p(hash)) {
                    hash = mrb_hash_new(mrb);
                }
                for (auto elm : callbacks) {
                    mrb_hash_set(mrb, hash, mrb_str_new_cstr(mrb, elm.first.c_str()), elm.second);
                    mrb_iv_set(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"), hash);
                }
            }
            g_rubyValue.push_back(ret);
            mrb_funcall(mrb, ret, "initialize", 0);
            return ret;
        }
    } while (0);
    do {
        if (argc == 1) {
            std::map<std::string, mrb_value> callbacks;
            cocos2d::Color4B* arg0;
            ok = rubyval_to_object<cocos2d::Color4B>(mrb, argv[0], "CC::Color4B", &arg0);
            if (!ok) { break; }

            cocos2d::LayerColor* retval = cocos2d::LayerColor::create(*arg0);
            mrb_value ret;
            RClass* rclass = mrb_class_ptr(self);
            ret = object_to_rubyval<cocos2d::LayerColor>(mrb, "CC::LayerColor", (cocos2d::LayerColor*)retval, rclass);
            if (callbacks.size() > 0) {
                mrb_value hash = mrb_iv_get(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"));
                if (!mrb_hash_p(hash)) {
                    hash = mrb_hash_new(mrb);
                }
                for (auto elm : callbacks) {
                    mrb_hash_set(mrb, hash, mrb_str_new_cstr(mrb, elm.first.c_str()), elm.second);
                    mrb_iv_set(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"), hash);
                }
            }
            g_rubyValue.push_back(ret);
            mrb_funcall(mrb, ret, "initialize", 0);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined static method : cocos2d::LayerColor#create");

    return mrb_nil_value();
}

void ruby_register_cocos2dx_LayerColor(mrb_state* mrb, struct RClass* rmodule)
{
    std::string typeName = typeid(cocos2d::LayerColor).name();
    g_rubyType[typeName] = "CC::LayerColor";
    g_rubyDataType[typeName] = &ruby_cocos2dx_Ref_type;

    struct RClass* p_rmodule = mrb->object_class;
    p_rmodule = mrb_module_get_under(mrb, p_rmodule, "CC");
    struct RClass* p_rclass = mrb_class_get_under(mrb, p_rmodule, "Layer");
    struct RClass *rclass = mrb_define_class_under(mrb, rmodule, "LayerColor", p_rclass);
    MRB_SET_INSTANCE_TT(rclass, MRB_TT_DATA);

    mrb_define_method(mrb, rclass, "change_width_and_height", ruby_cocos2dx_LayerColor_changeWidthAndHeight, ARGS_REQ(2));
    mrb_define_method(mrb, rclass, "get_blend_func", ruby_cocos2dx_LayerColor_getBlendFunc, ARGS_NONE());
    mrb_define_method(mrb, rclass, "change_height", ruby_cocos2dx_LayerColor_changeHeight, ARGS_REQ(1));
    mrb_define_method(mrb, rclass, "set_blend_func", ruby_cocos2dx_LayerColor_setBlendFunc, ARGS_REQ(1));
    mrb_define_method(mrb, rclass, "change_width", ruby_cocos2dx_LayerColor_changeWidth, ARGS_REQ(1));
    mrb_define_class_method(mrb, rclass, "create", ruby_cocos2dx_LayerColor_create_static, ARGS_REQ(0)|ARGS_OPT(3));
}
mrb_value ruby_cocos2dx_LayerGradient_getStartColor(mrb_state* mrb, mrb_value self)
{
    cocos2d::LayerGradient* cobj = static_cast<cocos2d::LayerGradient*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            cocos2d::Color3B retval = cobj->getStartColor();
            cocos2d::Color3B* retval_ptr = new cocos2d::Color3B(retval);
            mrb_value ret;
            ret = object_to_rubyval<cocos2d::Color3B>(mrb, "CC::Color3B", (cocos2d::Color3B*)retval_ptr, nullptr);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::LayerGradient#getStartColor");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_LayerGradient_isCompressedInterpolation(mrb_state* mrb, mrb_value self)
{
    cocos2d::LayerGradient* cobj = static_cast<cocos2d::LayerGradient*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            bool retval = cobj->isCompressedInterpolation();
            mrb_value ret;
            ret = mrb_bool_value((mrb_bool)retval);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::LayerGradient#isCompressedInterpolation");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_LayerGradient_getStartOpacity(mrb_state* mrb, mrb_value self)
{
    cocos2d::LayerGradient* cobj = static_cast<cocos2d::LayerGradient*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            uint16_t retval = cobj->getStartOpacity();
            mrb_value ret;
            ret = mrb_fixnum_value((mrb_int)retval);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::LayerGradient#getStartOpacity");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_LayerGradient_setVector(mrb_state* mrb, mrb_value self)
{
    cocos2d::LayerGradient* cobj = static_cast<cocos2d::LayerGradient*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            cocos2d::Vec2* arg0;
            ok = rubyval_to_object<cocos2d::Vec2>(mrb, argv[0], "CC::Vec2", &arg0);
            if (!ok) { break; }
            cobj->setVector(*arg0);
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::LayerGradient#setVector");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_LayerGradient_setStartOpacity(mrb_state* mrb, mrb_value self)
{
    cocos2d::LayerGradient* cobj = static_cast<cocos2d::LayerGradient*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            uint16_t arg0;
            ok = rubyval_to_uint16(mrb, argv[0], &arg0, "CC::LayerGradient.setStartOpacity");
            if (!ok) { break; }
            cobj->setStartOpacity(arg0);
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::LayerGradient#setStartOpacity");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_LayerGradient_setCompressedInterpolation(mrb_state* mrb, mrb_value self)
{
    cocos2d::LayerGradient* cobj = static_cast<cocos2d::LayerGradient*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            bool arg0;
            ok = rubyval_to_boolean(mrb, argv[0], &arg0, "CC::LayerGradient.setCompressedInterpolation");
            if (!ok) { break; }
            cobj->setCompressedInterpolation(arg0);
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::LayerGradient#setCompressedInterpolation");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_LayerGradient_setEndOpacity(mrb_state* mrb, mrb_value self)
{
    cocos2d::LayerGradient* cobj = static_cast<cocos2d::LayerGradient*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            uint16_t arg0;
            ok = rubyval_to_uint16(mrb, argv[0], &arg0, "CC::LayerGradient.setEndOpacity");
            if (!ok) { break; }
            cobj->setEndOpacity(arg0);
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::LayerGradient#setEndOpacity");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_LayerGradient_getVector(mrb_state* mrb, mrb_value self)
{
    cocos2d::LayerGradient* cobj = static_cast<cocos2d::LayerGradient*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            cocos2d::Vec2 retval = cobj->getVector();
            cocos2d::Vec2* retval_ptr = new cocos2d::Vec2(retval);
            mrb_value ret;
            ret = object_to_rubyval<cocos2d::Vec2>(mrb, "CC::Vec2", (cocos2d::Vec2*)retval_ptr, nullptr);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::LayerGradient#getVector");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_LayerGradient_setEndColor(mrb_state* mrb, mrb_value self)
{
    cocos2d::LayerGradient* cobj = static_cast<cocos2d::LayerGradient*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            cocos2d::Color3B* arg0;
            ok = rubyval_to_object<cocos2d::Color3B>(mrb, argv[0], "CC::Color3B", &arg0);
            if (!ok) { break; }
            cobj->setEndColor(*arg0);
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::LayerGradient#setEndColor");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_LayerGradient_getEndColor(mrb_state* mrb, mrb_value self)
{
    cocos2d::LayerGradient* cobj = static_cast<cocos2d::LayerGradient*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            cocos2d::Color3B retval = cobj->getEndColor();
            cocos2d::Color3B* retval_ptr = new cocos2d::Color3B(retval);
            mrb_value ret;
            ret = object_to_rubyval<cocos2d::Color3B>(mrb, "CC::Color3B", (cocos2d::Color3B*)retval_ptr, nullptr);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::LayerGradient#getEndColor");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_LayerGradient_getEndOpacity(mrb_state* mrb, mrb_value self)
{
    cocos2d::LayerGradient* cobj = static_cast<cocos2d::LayerGradient*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            uint16_t retval = cobj->getEndOpacity();
            mrb_value ret;
            ret = mrb_fixnum_value((mrb_int)retval);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::LayerGradient#getEndOpacity");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_LayerGradient_setStartColor(mrb_state* mrb, mrb_value self)
{
    cocos2d::LayerGradient* cobj = static_cast<cocos2d::LayerGradient*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            cocos2d::Color3B* arg0;
            ok = rubyval_to_object<cocos2d::Color3B>(mrb, argv[0], "CC::Color3B", &arg0);
            if (!ok) { break; }
            cobj->setStartColor(*arg0);
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::LayerGradient#setStartColor");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_LayerGradient_create_static(mrb_state* mrb, mrb_value self)
{
    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 2) {
            std::map<std::string, mrb_value> callbacks;
            cocos2d::Color4B* arg0;
            ok = rubyval_to_object<cocos2d::Color4B>(mrb, argv[0], "CC::Color4B", &arg0);
            if (!ok) { break; }

            cocos2d::Color4B* arg1;
            ok = rubyval_to_object<cocos2d::Color4B>(mrb, argv[1], "CC::Color4B", &arg1);
            if (!ok) { break; }

            cocos2d::LayerGradient* retval = cocos2d::LayerGradient::create(*arg0, *arg1);
            mrb_value ret;
            RClass* rclass = mrb_class_ptr(self);
            ret = object_to_rubyval<cocos2d::LayerGradient>(mrb, "CC::LayerGradient", (cocos2d::LayerGradient*)retval, rclass);
            if (callbacks.size() > 0) {
                mrb_value hash = mrb_iv_get(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"));
                if (!mrb_hash_p(hash)) {
                    hash = mrb_hash_new(mrb);
                }
                for (auto elm : callbacks) {
                    mrb_hash_set(mrb, hash, mrb_str_new_cstr(mrb, elm.first.c_str()), elm.second);
                    mrb_iv_set(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"), hash);
                }
            }
            g_rubyValue.push_back(ret);
            mrb_funcall(mrb, ret, "initialize", 0);
            return ret;
        }
    } while (0);
    do {
        if (argc == 0) {
            std::map<std::string, mrb_value> callbacks;
            cocos2d::LayerGradient* retval = cocos2d::LayerGradient::create();
            mrb_value ret;
            RClass* rclass = mrb_class_ptr(self);
            ret = object_to_rubyval<cocos2d::LayerGradient>(mrb, "CC::LayerGradient", (cocos2d::LayerGradient*)retval, rclass);
            if (callbacks.size() > 0) {
                mrb_value hash = mrb_iv_get(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"));
                if (!mrb_hash_p(hash)) {
                    hash = mrb_hash_new(mrb);
                }
                for (auto elm : callbacks) {
                    mrb_hash_set(mrb, hash, mrb_str_new_cstr(mrb, elm.first.c_str()), elm.second);
                    mrb_iv_set(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"), hash);
                }
            }
            g_rubyValue.push_back(ret);
            mrb_funcall(mrb, ret, "initialize", 0);
            return ret;
        }
    } while (0);
    do {
        if (argc == 3) {
            std::map<std::string, mrb_value> callbacks;
            cocos2d::Color4B* arg0;
            ok = rubyval_to_object<cocos2d::Color4B>(mrb, argv[0], "CC::Color4B", &arg0);
            if (!ok) { break; }

            cocos2d::Color4B* arg1;
            ok = rubyval_to_object<cocos2d::Color4B>(mrb, argv[1], "CC::Color4B", &arg1);
            if (!ok) { break; }

            cocos2d::Vec2* arg2;
            ok = rubyval_to_object<cocos2d::Vec2>(mrb, argv[2], "CC::Vec2", &arg2);
            if (!ok) { break; }

            cocos2d::LayerGradient* retval = cocos2d::LayerGradient::create(*arg0, *arg1, *arg2);
            mrb_value ret;
            RClass* rclass = mrb_class_ptr(self);
            ret = object_to_rubyval<cocos2d::LayerGradient>(mrb, "CC::LayerGradient", (cocos2d::LayerGradient*)retval, rclass);
            if (callbacks.size() > 0) {
                mrb_value hash = mrb_iv_get(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"));
                if (!mrb_hash_p(hash)) {
                    hash = mrb_hash_new(mrb);
                }
                for (auto elm : callbacks) {
                    mrb_hash_set(mrb, hash, mrb_str_new_cstr(mrb, elm.first.c_str()), elm.second);
                    mrb_iv_set(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"), hash);
                }
            }
            g_rubyValue.push_back(ret);
            mrb_funcall(mrb, ret, "initialize", 0);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined static method : cocos2d::LayerGradient#create");

    return mrb_nil_value();
}

void ruby_register_cocos2dx_LayerGradient(mrb_state* mrb, struct RClass* rmodule)
{
    std::string typeName = typeid(cocos2d::LayerGradient).name();
    g_rubyType[typeName] = "CC::LayerGradient";
    g_rubyDataType[typeName] = &ruby_cocos2dx_Ref_type;

    struct RClass* p_rmodule = mrb->object_class;
    p_rmodule = mrb_module_get_under(mrb, p_rmodule, "CC");
    struct RClass* p_rclass = mrb_class_get_under(mrb, p_rmodule, "LayerColor");
    struct RClass *rclass = mrb_define_class_under(mrb, rmodule, "LayerGradient", p_rclass);
    MRB_SET_INSTANCE_TT(rclass, MRB_TT_DATA);

    mrb_define_method(mrb, rclass, "get_start_color", ruby_cocos2dx_LayerGradient_getStartColor, ARGS_NONE());
    mrb_define_method(mrb, rclass, "compressed_interpolation?", ruby_cocos2dx_LayerGradient_isCompressedInterpolation, ARGS_NONE());
    mrb_define_method(mrb, rclass, "get_start_opacity", ruby_cocos2dx_LayerGradient_getStartOpacity, ARGS_NONE());
    mrb_define_method(mrb, rclass, "set_vector", ruby_cocos2dx_LayerGradient_setVector, ARGS_REQ(1));
    mrb_define_method(mrb, rclass, "set_start_opacity", ruby_cocos2dx_LayerGradient_setStartOpacity, ARGS_REQ(1));
    mrb_define_method(mrb, rclass, "set_compressed_interpolation", ruby_cocos2dx_LayerGradient_setCompressedInterpolation, ARGS_REQ(1));
    mrb_define_method(mrb, rclass, "set_end_opacity", ruby_cocos2dx_LayerGradient_setEndOpacity, ARGS_REQ(1));
    mrb_define_method(mrb, rclass, "get_vector", ruby_cocos2dx_LayerGradient_getVector, ARGS_NONE());
    mrb_define_method(mrb, rclass, "set_end_color", ruby_cocos2dx_LayerGradient_setEndColor, ARGS_REQ(1));
    mrb_define_method(mrb, rclass, "get_end_color", ruby_cocos2dx_LayerGradient_getEndColor, ARGS_NONE());
    mrb_define_method(mrb, rclass, "get_end_opacity", ruby_cocos2dx_LayerGradient_getEndOpacity, ARGS_NONE());
    mrb_define_method(mrb, rclass, "set_start_color", ruby_cocos2dx_LayerGradient_setStartColor, ARGS_REQ(1));
    mrb_define_class_method(mrb, rclass, "create", ruby_cocos2dx_LayerGradient_create_static, ARGS_REQ(0)|ARGS_OPT(3));
}
mrb_value ruby_cocos2dx_LayerMultiplex_switchToAndReleaseMe(mrb_state* mrb, mrb_value self)
{
    cocos2d::LayerMultiplex* cobj = static_cast<cocos2d::LayerMultiplex*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            int arg0;
            ok = rubyval_to_int32(mrb, argv[0], (int*)&arg0, "CC::LayerMultiplex.switchToAndReleaseMe");
            if (!ok) { break; }
            cobj->switchToAndReleaseMe(arg0);
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::LayerMultiplex#switchToAndReleaseMe");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_LayerMultiplex_addLayer(mrb_state* mrb, mrb_value self)
{
    cocos2d::LayerMultiplex* cobj = static_cast<cocos2d::LayerMultiplex*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            cocos2d::Layer* arg0;
            ok = rubyval_to_object<cocos2d::Layer>(mrb, argv[0], "CC::Layer", &arg0);
            if (!ok) { break; }
            cobj->addLayer(arg0);
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::LayerMultiplex#addLayer");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_LayerMultiplex_switchTo(mrb_state* mrb, mrb_value self)
{
    cocos2d::LayerMultiplex* cobj = static_cast<cocos2d::LayerMultiplex*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            int arg0;
            ok = rubyval_to_int32(mrb, argv[0], (int*)&arg0, "CC::LayerMultiplex.switchTo");
            if (!ok) { break; }
            cobj->switchTo(arg0);
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::LayerMultiplex#switchTo");

    return mrb_nil_value();
}

void ruby_register_cocos2dx_LayerMultiplex(mrb_state* mrb, struct RClass* rmodule)
{
    std::string typeName = typeid(cocos2d::LayerMultiplex).name();
    g_rubyType[typeName] = "CC::LayerMultiplex";
    g_rubyDataType[typeName] = &ruby_cocos2dx_Ref_type;

    struct RClass* p_rmodule = mrb->object_class;
    p_rmodule = mrb_module_get_under(mrb, p_rmodule, "CC");
    struct RClass* p_rclass = mrb_class_get_under(mrb, p_rmodule, "Layer");
    struct RClass *rclass = mrb_define_class_under(mrb, rmodule, "LayerMultiplex", p_rclass);
    MRB_SET_INSTANCE_TT(rclass, MRB_TT_DATA);

    mrb_define_method(mrb, rclass, "switch_to_and_release_me", ruby_cocos2dx_LayerMultiplex_switchToAndReleaseMe, ARGS_REQ(1));
    mrb_define_method(mrb, rclass, "add_layer", ruby_cocos2dx_LayerMultiplex_addLayer, ARGS_REQ(1));
    mrb_define_method(mrb, rclass, "switch_to", ruby_cocos2dx_LayerMultiplex_switchTo, ARGS_REQ(1));
}
mrb_value ruby_cocos2dx_TransitionEaseScene_easeActionWithAction(mrb_state* mrb, mrb_value self)
{
    cocos2d::TransitionEaseScene* cobj = static_cast<cocos2d::TransitionEaseScene*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_TransitionEaseScene_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            cocos2d::ActionInterval* arg0;
            ok = rubyval_to_object<cocos2d::ActionInterval>(mrb, argv[0], "CC::ActionInterval", &arg0);
            if (!ok) { break; }
            cocos2d::ActionInterval* retval = cobj->easeActionWithAction(arg0);
            mrb_value ret;
            ret = object_to_rubyval<cocos2d::ActionInterval>(mrb, "CC::ActionInterval", (cocos2d::ActionInterval*)retval, nullptr);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::TransitionEaseScene#easeActionWithAction");

    return mrb_nil_value();
}

void ruby_register_cocos2dx_TransitionEaseScene(mrb_state* mrb, struct RClass* rmodule)
{
    std::string typeName = typeid(cocos2d::TransitionEaseScene).name();
    g_rubyType[typeName] = "CC::TransitionEaseScene";
    g_rubyDataType[typeName] = &ruby_cocos2dx_TransitionEaseScene_type;

    struct RClass *rclass = mrb_define_class_under(mrb, rmodule, "TransitionEaseScene", mrb->object_class);
    MRB_SET_INSTANCE_TT(rclass, MRB_TT_DATA);

    mrb_define_method(mrb, rclass, "ease_action_with_action", ruby_cocos2dx_TransitionEaseScene_easeActionWithAction, ARGS_REQ(1));
}
mrb_value ruby_cocos2dx_TransitionScene_finish(mrb_state* mrb, mrb_value self)
{
    cocos2d::TransitionScene* cobj = static_cast<cocos2d::TransitionScene*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            cobj->finish();
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::TransitionScene#finish");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_TransitionScene_hideOutShowIn(mrb_state* mrb, mrb_value self)
{
    cocos2d::TransitionScene* cobj = static_cast<cocos2d::TransitionScene*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            cobj->hideOutShowIn();
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::TransitionScene#hideOutShowIn");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_TransitionScene_create_static(mrb_state* mrb, mrb_value self)
{
    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 2) {
            std::map<std::string, mrb_value> callbacks;
            double arg0;
            ok = rubyval_to_number(mrb, argv[0], (double*)&arg0, "CC::TransitionScene.create");
            if (!ok) { break; }

            cocos2d::Scene* arg1;
            ok = rubyval_to_object<cocos2d::Scene>(mrb, argv[1], "CC::Scene", &arg1);
            if (!ok) { break; }

            cocos2d::TransitionScene* retval = cocos2d::TransitionScene::create(arg0, arg1);
            mrb_value ret;
            RClass* rclass = mrb_class_ptr(self);
            ret = object_to_rubyval<cocos2d::TransitionScene>(mrb, "CC::TransitionScene", (cocos2d::TransitionScene*)retval, rclass);
            if (callbacks.size() > 0) {
                mrb_value hash = mrb_iv_get(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"));
                if (!mrb_hash_p(hash)) {
                    hash = mrb_hash_new(mrb);
                }
                for (auto elm : callbacks) {
                    mrb_hash_set(mrb, hash, mrb_str_new_cstr(mrb, elm.first.c_str()), elm.second);
                    mrb_iv_set(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"), hash);
                }
            }
            g_rubyValue.push_back(ret);
            mrb_funcall(mrb, ret, "initialize", 0);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined static method : cocos2d::TransitionScene#create");

    return mrb_nil_value();
}

void ruby_cocos2dx_TransitionScene_Orientation_enum_init(mrb_state* mrb, struct RClass* renum)
{
    do {
        mrb_value ev = mrb_fixnum_value((mrb_int)cocos2d::TransitionScene::Orientation::LEFT_OVER);
        mrb_mod_cv_set(mrb, renum, mrb_intern_cstr(mrb, "LEFT_OVER"), ev);
    } while (0);

    do {
        mrb_value ev = mrb_fixnum_value((mrb_int)cocos2d::TransitionScene::Orientation::RIGHT_OVER);
        mrb_mod_cv_set(mrb, renum, mrb_intern_cstr(mrb, "RIGHT_OVER"), ev);
    } while (0);

    do {
        mrb_value ev = mrb_fixnum_value((mrb_int)cocos2d::TransitionScene::Orientation::UP_OVER);
        mrb_mod_cv_set(mrb, renum, mrb_intern_cstr(mrb, "UP_OVER"), ev);
    } while (0);

    do {
        mrb_value ev = mrb_fixnum_value((mrb_int)cocos2d::TransitionScene::Orientation::DOWN_OVER);
        mrb_mod_cv_set(mrb, renum, mrb_intern_cstr(mrb, "DOWN_OVER"), ev);
    } while (0);

}

void ruby_register_cocos2dx_TransitionScene(mrb_state* mrb, struct RClass* rmodule)
{
    std::string typeName = typeid(cocos2d::TransitionScene).name();
    g_rubyType[typeName] = "CC::TransitionScene";
    g_rubyDataType[typeName] = &ruby_cocos2dx_Ref_type;

    struct RClass* p_rmodule = mrb->object_class;
    p_rmodule = mrb_module_get_under(mrb, p_rmodule, "CC");
    struct RClass* p_rclass = mrb_class_get_under(mrb, p_rmodule, "Scene");
    struct RClass *rclass = mrb_define_class_under(mrb, rmodule, "TransitionScene", p_rclass);
    MRB_SET_INSTANCE_TT(rclass, MRB_TT_DATA);

    mrb_define_method(mrb, rclass, "finish", ruby_cocos2dx_TransitionScene_finish, ARGS_NONE());
    mrb_define_method(mrb, rclass, "hide_out_show_in", ruby_cocos2dx_TransitionScene_hideOutShowIn, ARGS_NONE());
    mrb_define_class_method(mrb, rclass, "create", ruby_cocos2dx_TransitionScene_create_static, ARGS_REQ(2));
    struct RClass* renum_Orientation = mrb_define_module_under(mrb, rclass, "Orientation");
    ruby_cocos2dx_TransitionScene_Orientation_enum_init(mrb, renum_Orientation);
    mrb_define_class_method(mrb, renum_Orientation, "LEFT_OVER", ruby_cocos2dx_constant_get, ARGS_NONE());
    mrb_define_class_method(mrb, renum_Orientation, "RIGHT_OVER", ruby_cocos2dx_constant_get, ARGS_NONE());
    mrb_define_class_method(mrb, renum_Orientation, "UP_OVER", ruby_cocos2dx_constant_get, ARGS_NONE());
    mrb_define_class_method(mrb, renum_Orientation, "DOWN_OVER", ruby_cocos2dx_constant_get, ARGS_NONE());
}
mrb_value ruby_cocos2dx_TransitionSceneOriented_create_static(mrb_state* mrb, mrb_value self)
{
    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 3) {
            std::map<std::string, mrb_value> callbacks;
            double arg0;
            ok = rubyval_to_number(mrb, argv[0], (double*)&arg0, "CC::TransitionSceneOriented.create");
            if (!ok) { break; }

            cocos2d::Scene* arg1;
            ok = rubyval_to_object<cocos2d::Scene>(mrb, argv[1], "CC::Scene", &arg1);
            if (!ok) { break; }

            cocos2d::TransitionScene::Orientation arg2;
            ok = rubyval_to_int32(mrb, argv[2], (int*)&arg2, "CC::TransitionSceneOriented.create");
            if (!ok) { break; }

            cocos2d::TransitionSceneOriented* retval = cocos2d::TransitionSceneOriented::create(arg0, arg1, arg2);
            mrb_value ret;
            RClass* rclass = mrb_class_ptr(self);
            ret = object_to_rubyval<cocos2d::TransitionSceneOriented>(mrb, "CC::TransitionSceneOriented", (cocos2d::TransitionSceneOriented*)retval, rclass);
            if (callbacks.size() > 0) {
                mrb_value hash = mrb_iv_get(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"));
                if (!mrb_hash_p(hash)) {
                    hash = mrb_hash_new(mrb);
                }
                for (auto elm : callbacks) {
                    mrb_hash_set(mrb, hash, mrb_str_new_cstr(mrb, elm.first.c_str()), elm.second);
                    mrb_iv_set(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"), hash);
                }
            }
            g_rubyValue.push_back(ret);
            mrb_funcall(mrb, ret, "initialize", 0);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined static method : cocos2d::TransitionSceneOriented#create");

    return mrb_nil_value();
}

void ruby_register_cocos2dx_TransitionSceneOriented(mrb_state* mrb, struct RClass* rmodule)
{
    std::string typeName = typeid(cocos2d::TransitionSceneOriented).name();
    g_rubyType[typeName] = "CC::TransitionSceneOriented";
    g_rubyDataType[typeName] = &ruby_cocos2dx_Ref_type;

    struct RClass* p_rmodule = mrb->object_class;
    p_rmodule = mrb_module_get_under(mrb, p_rmodule, "CC");
    struct RClass* p_rclass = mrb_class_get_under(mrb, p_rmodule, "TransitionScene");
    struct RClass *rclass = mrb_define_class_under(mrb, rmodule, "TransitionSceneOriented", p_rclass);
    MRB_SET_INSTANCE_TT(rclass, MRB_TT_DATA);

    mrb_define_class_method(mrb, rclass, "create", ruby_cocos2dx_TransitionSceneOriented_create_static, ARGS_REQ(3));
}
mrb_value ruby_cocos2dx_TransitionRotoZoom_create_static(mrb_state* mrb, mrb_value self)
{
    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 2) {
            std::map<std::string, mrb_value> callbacks;
            double arg0;
            ok = rubyval_to_number(mrb, argv[0], (double*)&arg0, "CC::TransitionRotoZoom.create");
            if (!ok) { break; }

            cocos2d::Scene* arg1;
            ok = rubyval_to_object<cocos2d::Scene>(mrb, argv[1], "CC::Scene", &arg1);
            if (!ok) { break; }

            cocos2d::TransitionRotoZoom* retval = cocos2d::TransitionRotoZoom::create(arg0, arg1);
            mrb_value ret;
            RClass* rclass = mrb_class_ptr(self);
            ret = object_to_rubyval<cocos2d::TransitionRotoZoom>(mrb, "CC::TransitionRotoZoom", (cocos2d::TransitionRotoZoom*)retval, rclass);
            if (callbacks.size() > 0) {
                mrb_value hash = mrb_iv_get(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"));
                if (!mrb_hash_p(hash)) {
                    hash = mrb_hash_new(mrb);
                }
                for (auto elm : callbacks) {
                    mrb_hash_set(mrb, hash, mrb_str_new_cstr(mrb, elm.first.c_str()), elm.second);
                    mrb_iv_set(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"), hash);
                }
            }
            g_rubyValue.push_back(ret);
            mrb_funcall(mrb, ret, "initialize", 0);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined static method : cocos2d::TransitionRotoZoom#create");

    return mrb_nil_value();
}

void ruby_register_cocos2dx_TransitionRotoZoom(mrb_state* mrb, struct RClass* rmodule)
{
    std::string typeName = typeid(cocos2d::TransitionRotoZoom).name();
    g_rubyType[typeName] = "CC::TransitionRotoZoom";
    g_rubyDataType[typeName] = &ruby_cocos2dx_Ref_type;

    struct RClass* p_rmodule = mrb->object_class;
    p_rmodule = mrb_module_get_under(mrb, p_rmodule, "CC");
    struct RClass* p_rclass = mrb_class_get_under(mrb, p_rmodule, "TransitionScene");
    struct RClass *rclass = mrb_define_class_under(mrb, rmodule, "TransitionRotoZoom", p_rclass);
    MRB_SET_INSTANCE_TT(rclass, MRB_TT_DATA);

    mrb_define_class_method(mrb, rclass, "create", ruby_cocos2dx_TransitionRotoZoom_create_static, ARGS_REQ(2));
}
mrb_value ruby_cocos2dx_TransitionJumpZoom_create_static(mrb_state* mrb, mrb_value self)
{
    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 2) {
            std::map<std::string, mrb_value> callbacks;
            double arg0;
            ok = rubyval_to_number(mrb, argv[0], (double*)&arg0, "CC::TransitionJumpZoom.create");
            if (!ok) { break; }

            cocos2d::Scene* arg1;
            ok = rubyval_to_object<cocos2d::Scene>(mrb, argv[1], "CC::Scene", &arg1);
            if (!ok) { break; }

            cocos2d::TransitionJumpZoom* retval = cocos2d::TransitionJumpZoom::create(arg0, arg1);
            mrb_value ret;
            RClass* rclass = mrb_class_ptr(self);
            ret = object_to_rubyval<cocos2d::TransitionJumpZoom>(mrb, "CC::TransitionJumpZoom", (cocos2d::TransitionJumpZoom*)retval, rclass);
            if (callbacks.size() > 0) {
                mrb_value hash = mrb_iv_get(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"));
                if (!mrb_hash_p(hash)) {
                    hash = mrb_hash_new(mrb);
                }
                for (auto elm : callbacks) {
                    mrb_hash_set(mrb, hash, mrb_str_new_cstr(mrb, elm.first.c_str()), elm.second);
                    mrb_iv_set(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"), hash);
                }
            }
            g_rubyValue.push_back(ret);
            mrb_funcall(mrb, ret, "initialize", 0);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined static method : cocos2d::TransitionJumpZoom#create");

    return mrb_nil_value();
}

void ruby_register_cocos2dx_TransitionJumpZoom(mrb_state* mrb, struct RClass* rmodule)
{
    std::string typeName = typeid(cocos2d::TransitionJumpZoom).name();
    g_rubyType[typeName] = "CC::TransitionJumpZoom";
    g_rubyDataType[typeName] = &ruby_cocos2dx_Ref_type;

    struct RClass* p_rmodule = mrb->object_class;
    p_rmodule = mrb_module_get_under(mrb, p_rmodule, "CC");
    struct RClass* p_rclass = mrb_class_get_under(mrb, p_rmodule, "TransitionScene");
    struct RClass *rclass = mrb_define_class_under(mrb, rmodule, "TransitionJumpZoom", p_rclass);
    MRB_SET_INSTANCE_TT(rclass, MRB_TT_DATA);

    mrb_define_class_method(mrb, rclass, "create", ruby_cocos2dx_TransitionJumpZoom_create_static, ARGS_REQ(2));
}
mrb_value ruby_cocos2dx_TransitionMoveInL_action(mrb_state* mrb, mrb_value self)
{
    cocos2d::TransitionMoveInL* cobj = static_cast<cocos2d::TransitionMoveInL*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            cocos2d::ActionInterval* retval = cobj->action();
            mrb_value ret;
            ret = object_to_rubyval<cocos2d::ActionInterval>(mrb, "CC::ActionInterval", (cocos2d::ActionInterval*)retval, nullptr);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::TransitionMoveInL#action");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_TransitionMoveInL_easeActionWithAction(mrb_state* mrb, mrb_value self)
{
    cocos2d::TransitionMoveInL* cobj = static_cast<cocos2d::TransitionMoveInL*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            cocos2d::ActionInterval* arg0;
            ok = rubyval_to_object<cocos2d::ActionInterval>(mrb, argv[0], "CC::ActionInterval", &arg0);
            if (!ok) { break; }
            cocos2d::ActionInterval* retval = cobj->easeActionWithAction(arg0);
            mrb_value ret;
            ret = object_to_rubyval<cocos2d::ActionInterval>(mrb, "CC::ActionInterval", (cocos2d::ActionInterval*)retval, nullptr);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::TransitionMoveInL#easeActionWithAction");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_TransitionMoveInL_create_static(mrb_state* mrb, mrb_value self)
{
    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 2) {
            std::map<std::string, mrb_value> callbacks;
            double arg0;
            ok = rubyval_to_number(mrb, argv[0], (double*)&arg0, "CC::TransitionMoveInL.create");
            if (!ok) { break; }

            cocos2d::Scene* arg1;
            ok = rubyval_to_object<cocos2d::Scene>(mrb, argv[1], "CC::Scene", &arg1);
            if (!ok) { break; }

            cocos2d::TransitionMoveInL* retval = cocos2d::TransitionMoveInL::create(arg0, arg1);
            mrb_value ret;
            RClass* rclass = mrb_class_ptr(self);
            ret = object_to_rubyval<cocos2d::TransitionMoveInL>(mrb, "CC::TransitionMoveInL", (cocos2d::TransitionMoveInL*)retval, rclass);
            if (callbacks.size() > 0) {
                mrb_value hash = mrb_iv_get(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"));
                if (!mrb_hash_p(hash)) {
                    hash = mrb_hash_new(mrb);
                }
                for (auto elm : callbacks) {
                    mrb_hash_set(mrb, hash, mrb_str_new_cstr(mrb, elm.first.c_str()), elm.second);
                    mrb_iv_set(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"), hash);
                }
            }
            g_rubyValue.push_back(ret);
            mrb_funcall(mrb, ret, "initialize", 0);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined static method : cocos2d::TransitionMoveInL#create");

    return mrb_nil_value();
}

void ruby_register_cocos2dx_TransitionMoveInL(mrb_state* mrb, struct RClass* rmodule)
{
    std::string typeName = typeid(cocos2d::TransitionMoveInL).name();
    g_rubyType[typeName] = "CC::TransitionMoveInL";
    g_rubyDataType[typeName] = &ruby_cocos2dx_Ref_type;

    struct RClass* p_rmodule = mrb->object_class;
    p_rmodule = mrb_module_get_under(mrb, p_rmodule, "CC");
    struct RClass* p_rclass = mrb_class_get_under(mrb, p_rmodule, "TransitionScene");
    struct RClass *rclass = mrb_define_class_under(mrb, rmodule, "TransitionMoveInL", p_rclass);
    MRB_SET_INSTANCE_TT(rclass, MRB_TT_DATA);

    mrb_define_method(mrb, rclass, "action", ruby_cocos2dx_TransitionMoveInL_action, ARGS_NONE());
    mrb_define_method(mrb, rclass, "ease_action_with_action", ruby_cocos2dx_TransitionMoveInL_easeActionWithAction, ARGS_REQ(1));
    mrb_define_class_method(mrb, rclass, "create", ruby_cocos2dx_TransitionMoveInL_create_static, ARGS_REQ(2));
}
mrb_value ruby_cocos2dx_TransitionMoveInR_create_static(mrb_state* mrb, mrb_value self)
{
    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 2) {
            std::map<std::string, mrb_value> callbacks;
            double arg0;
            ok = rubyval_to_number(mrb, argv[0], (double*)&arg0, "CC::TransitionMoveInR.create");
            if (!ok) { break; }

            cocos2d::Scene* arg1;
            ok = rubyval_to_object<cocos2d::Scene>(mrb, argv[1], "CC::Scene", &arg1);
            if (!ok) { break; }

            cocos2d::TransitionMoveInR* retval = cocos2d::TransitionMoveInR::create(arg0, arg1);
            mrb_value ret;
            RClass* rclass = mrb_class_ptr(self);
            ret = object_to_rubyval<cocos2d::TransitionMoveInR>(mrb, "CC::TransitionMoveInR", (cocos2d::TransitionMoveInR*)retval, rclass);
            if (callbacks.size() > 0) {
                mrb_value hash = mrb_iv_get(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"));
                if (!mrb_hash_p(hash)) {
                    hash = mrb_hash_new(mrb);
                }
                for (auto elm : callbacks) {
                    mrb_hash_set(mrb, hash, mrb_str_new_cstr(mrb, elm.first.c_str()), elm.second);
                    mrb_iv_set(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"), hash);
                }
            }
            g_rubyValue.push_back(ret);
            mrb_funcall(mrb, ret, "initialize", 0);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined static method : cocos2d::TransitionMoveInR#create");

    return mrb_nil_value();
}

void ruby_register_cocos2dx_TransitionMoveInR(mrb_state* mrb, struct RClass* rmodule)
{
    std::string typeName = typeid(cocos2d::TransitionMoveInR).name();
    g_rubyType[typeName] = "CC::TransitionMoveInR";
    g_rubyDataType[typeName] = &ruby_cocos2dx_Ref_type;

    struct RClass* p_rmodule = mrb->object_class;
    p_rmodule = mrb_module_get_under(mrb, p_rmodule, "CC");
    struct RClass* p_rclass = mrb_class_get_under(mrb, p_rmodule, "TransitionMoveInL");
    struct RClass *rclass = mrb_define_class_under(mrb, rmodule, "TransitionMoveInR", p_rclass);
    MRB_SET_INSTANCE_TT(rclass, MRB_TT_DATA);

    mrb_define_class_method(mrb, rclass, "create", ruby_cocos2dx_TransitionMoveInR_create_static, ARGS_REQ(2));
}
mrb_value ruby_cocos2dx_TransitionMoveInT_create_static(mrb_state* mrb, mrb_value self)
{
    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 2) {
            std::map<std::string, mrb_value> callbacks;
            double arg0;
            ok = rubyval_to_number(mrb, argv[0], (double*)&arg0, "CC::TransitionMoveInT.create");
            if (!ok) { break; }

            cocos2d::Scene* arg1;
            ok = rubyval_to_object<cocos2d::Scene>(mrb, argv[1], "CC::Scene", &arg1);
            if (!ok) { break; }

            cocos2d::TransitionMoveInT* retval = cocos2d::TransitionMoveInT::create(arg0, arg1);
            mrb_value ret;
            RClass* rclass = mrb_class_ptr(self);
            ret = object_to_rubyval<cocos2d::TransitionMoveInT>(mrb, "CC::TransitionMoveInT", (cocos2d::TransitionMoveInT*)retval, rclass);
            if (callbacks.size() > 0) {
                mrb_value hash = mrb_iv_get(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"));
                if (!mrb_hash_p(hash)) {
                    hash = mrb_hash_new(mrb);
                }
                for (auto elm : callbacks) {
                    mrb_hash_set(mrb, hash, mrb_str_new_cstr(mrb, elm.first.c_str()), elm.second);
                    mrb_iv_set(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"), hash);
                }
            }
            g_rubyValue.push_back(ret);
            mrb_funcall(mrb, ret, "initialize", 0);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined static method : cocos2d::TransitionMoveInT#create");

    return mrb_nil_value();
}

void ruby_register_cocos2dx_TransitionMoveInT(mrb_state* mrb, struct RClass* rmodule)
{
    std::string typeName = typeid(cocos2d::TransitionMoveInT).name();
    g_rubyType[typeName] = "CC::TransitionMoveInT";
    g_rubyDataType[typeName] = &ruby_cocos2dx_Ref_type;

    struct RClass* p_rmodule = mrb->object_class;
    p_rmodule = mrb_module_get_under(mrb, p_rmodule, "CC");
    struct RClass* p_rclass = mrb_class_get_under(mrb, p_rmodule, "TransitionMoveInL");
    struct RClass *rclass = mrb_define_class_under(mrb, rmodule, "TransitionMoveInT", p_rclass);
    MRB_SET_INSTANCE_TT(rclass, MRB_TT_DATA);

    mrb_define_class_method(mrb, rclass, "create", ruby_cocos2dx_TransitionMoveInT_create_static, ARGS_REQ(2));
}
mrb_value ruby_cocos2dx_TransitionMoveInB_create_static(mrb_state* mrb, mrb_value self)
{
    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 2) {
            std::map<std::string, mrb_value> callbacks;
            double arg0;
            ok = rubyval_to_number(mrb, argv[0], (double*)&arg0, "CC::TransitionMoveInB.create");
            if (!ok) { break; }

            cocos2d::Scene* arg1;
            ok = rubyval_to_object<cocos2d::Scene>(mrb, argv[1], "CC::Scene", &arg1);
            if (!ok) { break; }

            cocos2d::TransitionMoveInB* retval = cocos2d::TransitionMoveInB::create(arg0, arg1);
            mrb_value ret;
            RClass* rclass = mrb_class_ptr(self);
            ret = object_to_rubyval<cocos2d::TransitionMoveInB>(mrb, "CC::TransitionMoveInB", (cocos2d::TransitionMoveInB*)retval, rclass);
            if (callbacks.size() > 0) {
                mrb_value hash = mrb_iv_get(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"));
                if (!mrb_hash_p(hash)) {
                    hash = mrb_hash_new(mrb);
                }
                for (auto elm : callbacks) {
                    mrb_hash_set(mrb, hash, mrb_str_new_cstr(mrb, elm.first.c_str()), elm.second);
                    mrb_iv_set(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"), hash);
                }
            }
            g_rubyValue.push_back(ret);
            mrb_funcall(mrb, ret, "initialize", 0);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined static method : cocos2d::TransitionMoveInB#create");

    return mrb_nil_value();
}

void ruby_register_cocos2dx_TransitionMoveInB(mrb_state* mrb, struct RClass* rmodule)
{
    std::string typeName = typeid(cocos2d::TransitionMoveInB).name();
    g_rubyType[typeName] = "CC::TransitionMoveInB";
    g_rubyDataType[typeName] = &ruby_cocos2dx_Ref_type;

    struct RClass* p_rmodule = mrb->object_class;
    p_rmodule = mrb_module_get_under(mrb, p_rmodule, "CC");
    struct RClass* p_rclass = mrb_class_get_under(mrb, p_rmodule, "TransitionMoveInL");
    struct RClass *rclass = mrb_define_class_under(mrb, rmodule, "TransitionMoveInB", p_rclass);
    MRB_SET_INSTANCE_TT(rclass, MRB_TT_DATA);

    mrb_define_class_method(mrb, rclass, "create", ruby_cocos2dx_TransitionMoveInB_create_static, ARGS_REQ(2));
}
mrb_value ruby_cocos2dx_TransitionSlideInL_action(mrb_state* mrb, mrb_value self)
{
    cocos2d::TransitionSlideInL* cobj = static_cast<cocos2d::TransitionSlideInL*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            cocos2d::ActionInterval* retval = cobj->action();
            mrb_value ret;
            ret = object_to_rubyval<cocos2d::ActionInterval>(mrb, "CC::ActionInterval", (cocos2d::ActionInterval*)retval, nullptr);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::TransitionSlideInL#action");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_TransitionSlideInL_easeActionWithAction(mrb_state* mrb, mrb_value self)
{
    cocos2d::TransitionSlideInL* cobj = static_cast<cocos2d::TransitionSlideInL*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            cocos2d::ActionInterval* arg0;
            ok = rubyval_to_object<cocos2d::ActionInterval>(mrb, argv[0], "CC::ActionInterval", &arg0);
            if (!ok) { break; }
            cocos2d::ActionInterval* retval = cobj->easeActionWithAction(arg0);
            mrb_value ret;
            ret = object_to_rubyval<cocos2d::ActionInterval>(mrb, "CC::ActionInterval", (cocos2d::ActionInterval*)retval, nullptr);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::TransitionSlideInL#easeActionWithAction");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_TransitionSlideInL_create_static(mrb_state* mrb, mrb_value self)
{
    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 2) {
            std::map<std::string, mrb_value> callbacks;
            double arg0;
            ok = rubyval_to_number(mrb, argv[0], (double*)&arg0, "CC::TransitionSlideInL.create");
            if (!ok) { break; }

            cocos2d::Scene* arg1;
            ok = rubyval_to_object<cocos2d::Scene>(mrb, argv[1], "CC::Scene", &arg1);
            if (!ok) { break; }

            cocos2d::TransitionSlideInL* retval = cocos2d::TransitionSlideInL::create(arg0, arg1);
            mrb_value ret;
            RClass* rclass = mrb_class_ptr(self);
            ret = object_to_rubyval<cocos2d::TransitionSlideInL>(mrb, "CC::TransitionSlideInL", (cocos2d::TransitionSlideInL*)retval, rclass);
            if (callbacks.size() > 0) {
                mrb_value hash = mrb_iv_get(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"));
                if (!mrb_hash_p(hash)) {
                    hash = mrb_hash_new(mrb);
                }
                for (auto elm : callbacks) {
                    mrb_hash_set(mrb, hash, mrb_str_new_cstr(mrb, elm.first.c_str()), elm.second);
                    mrb_iv_set(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"), hash);
                }
            }
            g_rubyValue.push_back(ret);
            mrb_funcall(mrb, ret, "initialize", 0);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined static method : cocos2d::TransitionSlideInL#create");

    return mrb_nil_value();
}

void ruby_register_cocos2dx_TransitionSlideInL(mrb_state* mrb, struct RClass* rmodule)
{
    std::string typeName = typeid(cocos2d::TransitionSlideInL).name();
    g_rubyType[typeName] = "CC::TransitionSlideInL";
    g_rubyDataType[typeName] = &ruby_cocos2dx_Ref_type;

    struct RClass* p_rmodule = mrb->object_class;
    p_rmodule = mrb_module_get_under(mrb, p_rmodule, "CC");
    struct RClass* p_rclass = mrb_class_get_under(mrb, p_rmodule, "TransitionScene");
    struct RClass *rclass = mrb_define_class_under(mrb, rmodule, "TransitionSlideInL", p_rclass);
    MRB_SET_INSTANCE_TT(rclass, MRB_TT_DATA);

    mrb_define_method(mrb, rclass, "action", ruby_cocos2dx_TransitionSlideInL_action, ARGS_NONE());
    mrb_define_method(mrb, rclass, "ease_action_with_action", ruby_cocos2dx_TransitionSlideInL_easeActionWithAction, ARGS_REQ(1));
    mrb_define_class_method(mrb, rclass, "create", ruby_cocos2dx_TransitionSlideInL_create_static, ARGS_REQ(2));
}
mrb_value ruby_cocos2dx_TransitionSlideInR_action(mrb_state* mrb, mrb_value self)
{
    cocos2d::TransitionSlideInR* cobj = static_cast<cocos2d::TransitionSlideInR*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            cocos2d::ActionInterval* retval = cobj->action();
            mrb_value ret;
            ret = object_to_rubyval<cocos2d::ActionInterval>(mrb, "CC::ActionInterval", (cocos2d::ActionInterval*)retval, nullptr);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::TransitionSlideInR#action");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_TransitionSlideInR_create_static(mrb_state* mrb, mrb_value self)
{
    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 2) {
            std::map<std::string, mrb_value> callbacks;
            double arg0;
            ok = rubyval_to_number(mrb, argv[0], (double*)&arg0, "CC::TransitionSlideInR.create");
            if (!ok) { break; }

            cocos2d::Scene* arg1;
            ok = rubyval_to_object<cocos2d::Scene>(mrb, argv[1], "CC::Scene", &arg1);
            if (!ok) { break; }

            cocos2d::TransitionSlideInR* retval = cocos2d::TransitionSlideInR::create(arg0, arg1);
            mrb_value ret;
            RClass* rclass = mrb_class_ptr(self);
            ret = object_to_rubyval<cocos2d::TransitionSlideInR>(mrb, "CC::TransitionSlideInR", (cocos2d::TransitionSlideInR*)retval, rclass);
            if (callbacks.size() > 0) {
                mrb_value hash = mrb_iv_get(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"));
                if (!mrb_hash_p(hash)) {
                    hash = mrb_hash_new(mrb);
                }
                for (auto elm : callbacks) {
                    mrb_hash_set(mrb, hash, mrb_str_new_cstr(mrb, elm.first.c_str()), elm.second);
                    mrb_iv_set(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"), hash);
                }
            }
            g_rubyValue.push_back(ret);
            mrb_funcall(mrb, ret, "initialize", 0);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined static method : cocos2d::TransitionSlideInR#create");

    return mrb_nil_value();
}

void ruby_register_cocos2dx_TransitionSlideInR(mrb_state* mrb, struct RClass* rmodule)
{
    std::string typeName = typeid(cocos2d::TransitionSlideInR).name();
    g_rubyType[typeName] = "CC::TransitionSlideInR";
    g_rubyDataType[typeName] = &ruby_cocos2dx_Ref_type;

    struct RClass* p_rmodule = mrb->object_class;
    p_rmodule = mrb_module_get_under(mrb, p_rmodule, "CC");
    struct RClass* p_rclass = mrb_class_get_under(mrb, p_rmodule, "TransitionSlideInL");
    struct RClass *rclass = mrb_define_class_under(mrb, rmodule, "TransitionSlideInR", p_rclass);
    MRB_SET_INSTANCE_TT(rclass, MRB_TT_DATA);

    mrb_define_method(mrb, rclass, "action", ruby_cocos2dx_TransitionSlideInR_action, ARGS_NONE());
    mrb_define_class_method(mrb, rclass, "create", ruby_cocos2dx_TransitionSlideInR_create_static, ARGS_REQ(2));
}
mrb_value ruby_cocos2dx_TransitionSlideInB_action(mrb_state* mrb, mrb_value self)
{
    cocos2d::TransitionSlideInB* cobj = static_cast<cocos2d::TransitionSlideInB*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            cocos2d::ActionInterval* retval = cobj->action();
            mrb_value ret;
            ret = object_to_rubyval<cocos2d::ActionInterval>(mrb, "CC::ActionInterval", (cocos2d::ActionInterval*)retval, nullptr);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::TransitionSlideInB#action");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_TransitionSlideInB_create_static(mrb_state* mrb, mrb_value self)
{
    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 2) {
            std::map<std::string, mrb_value> callbacks;
            double arg0;
            ok = rubyval_to_number(mrb, argv[0], (double*)&arg0, "CC::TransitionSlideInB.create");
            if (!ok) { break; }

            cocos2d::Scene* arg1;
            ok = rubyval_to_object<cocos2d::Scene>(mrb, argv[1], "CC::Scene", &arg1);
            if (!ok) { break; }

            cocos2d::TransitionSlideInB* retval = cocos2d::TransitionSlideInB::create(arg0, arg1);
            mrb_value ret;
            RClass* rclass = mrb_class_ptr(self);
            ret = object_to_rubyval<cocos2d::TransitionSlideInB>(mrb, "CC::TransitionSlideInB", (cocos2d::TransitionSlideInB*)retval, rclass);
            if (callbacks.size() > 0) {
                mrb_value hash = mrb_iv_get(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"));
                if (!mrb_hash_p(hash)) {
                    hash = mrb_hash_new(mrb);
                }
                for (auto elm : callbacks) {
                    mrb_hash_set(mrb, hash, mrb_str_new_cstr(mrb, elm.first.c_str()), elm.second);
                    mrb_iv_set(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"), hash);
                }
            }
            g_rubyValue.push_back(ret);
            mrb_funcall(mrb, ret, "initialize", 0);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined static method : cocos2d::TransitionSlideInB#create");

    return mrb_nil_value();
}

void ruby_register_cocos2dx_TransitionSlideInB(mrb_state* mrb, struct RClass* rmodule)
{
    std::string typeName = typeid(cocos2d::TransitionSlideInB).name();
    g_rubyType[typeName] = "CC::TransitionSlideInB";
    g_rubyDataType[typeName] = &ruby_cocos2dx_Ref_type;

    struct RClass* p_rmodule = mrb->object_class;
    p_rmodule = mrb_module_get_under(mrb, p_rmodule, "CC");
    struct RClass* p_rclass = mrb_class_get_under(mrb, p_rmodule, "TransitionSlideInL");
    struct RClass *rclass = mrb_define_class_under(mrb, rmodule, "TransitionSlideInB", p_rclass);
    MRB_SET_INSTANCE_TT(rclass, MRB_TT_DATA);

    mrb_define_method(mrb, rclass, "action", ruby_cocos2dx_TransitionSlideInB_action, ARGS_NONE());
    mrb_define_class_method(mrb, rclass, "create", ruby_cocos2dx_TransitionSlideInB_create_static, ARGS_REQ(2));
}
mrb_value ruby_cocos2dx_TransitionSlideInT_action(mrb_state* mrb, mrb_value self)
{
    cocos2d::TransitionSlideInT* cobj = static_cast<cocos2d::TransitionSlideInT*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            cocos2d::ActionInterval* retval = cobj->action();
            mrb_value ret;
            ret = object_to_rubyval<cocos2d::ActionInterval>(mrb, "CC::ActionInterval", (cocos2d::ActionInterval*)retval, nullptr);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::TransitionSlideInT#action");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_TransitionSlideInT_create_static(mrb_state* mrb, mrb_value self)
{
    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 2) {
            std::map<std::string, mrb_value> callbacks;
            double arg0;
            ok = rubyval_to_number(mrb, argv[0], (double*)&arg0, "CC::TransitionSlideInT.create");
            if (!ok) { break; }

            cocos2d::Scene* arg1;
            ok = rubyval_to_object<cocos2d::Scene>(mrb, argv[1], "CC::Scene", &arg1);
            if (!ok) { break; }

            cocos2d::TransitionSlideInT* retval = cocos2d::TransitionSlideInT::create(arg0, arg1);
            mrb_value ret;
            RClass* rclass = mrb_class_ptr(self);
            ret = object_to_rubyval<cocos2d::TransitionSlideInT>(mrb, "CC::TransitionSlideInT", (cocos2d::TransitionSlideInT*)retval, rclass);
            if (callbacks.size() > 0) {
                mrb_value hash = mrb_iv_get(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"));
                if (!mrb_hash_p(hash)) {
                    hash = mrb_hash_new(mrb);
                }
                for (auto elm : callbacks) {
                    mrb_hash_set(mrb, hash, mrb_str_new_cstr(mrb, elm.first.c_str()), elm.second);
                    mrb_iv_set(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"), hash);
                }
            }
            g_rubyValue.push_back(ret);
            mrb_funcall(mrb, ret, "initialize", 0);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined static method : cocos2d::TransitionSlideInT#create");

    return mrb_nil_value();
}

void ruby_register_cocos2dx_TransitionSlideInT(mrb_state* mrb, struct RClass* rmodule)
{
    std::string typeName = typeid(cocos2d::TransitionSlideInT).name();
    g_rubyType[typeName] = "CC::TransitionSlideInT";
    g_rubyDataType[typeName] = &ruby_cocos2dx_Ref_type;

    struct RClass* p_rmodule = mrb->object_class;
    p_rmodule = mrb_module_get_under(mrb, p_rmodule, "CC");
    struct RClass* p_rclass = mrb_class_get_under(mrb, p_rmodule, "TransitionSlideInL");
    struct RClass *rclass = mrb_define_class_under(mrb, rmodule, "TransitionSlideInT", p_rclass);
    MRB_SET_INSTANCE_TT(rclass, MRB_TT_DATA);

    mrb_define_method(mrb, rclass, "action", ruby_cocos2dx_TransitionSlideInT_action, ARGS_NONE());
    mrb_define_class_method(mrb, rclass, "create", ruby_cocos2dx_TransitionSlideInT_create_static, ARGS_REQ(2));
}
mrb_value ruby_cocos2dx_TransitionShrinkGrow_easeActionWithAction(mrb_state* mrb, mrb_value self)
{
    cocos2d::TransitionShrinkGrow* cobj = static_cast<cocos2d::TransitionShrinkGrow*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            cocos2d::ActionInterval* arg0;
            ok = rubyval_to_object<cocos2d::ActionInterval>(mrb, argv[0], "CC::ActionInterval", &arg0);
            if (!ok) { break; }
            cocos2d::ActionInterval* retval = cobj->easeActionWithAction(arg0);
            mrb_value ret;
            ret = object_to_rubyval<cocos2d::ActionInterval>(mrb, "CC::ActionInterval", (cocos2d::ActionInterval*)retval, nullptr);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::TransitionShrinkGrow#easeActionWithAction");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_TransitionShrinkGrow_create_static(mrb_state* mrb, mrb_value self)
{
    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 2) {
            std::map<std::string, mrb_value> callbacks;
            double arg0;
            ok = rubyval_to_number(mrb, argv[0], (double*)&arg0, "CC::TransitionShrinkGrow.create");
            if (!ok) { break; }

            cocos2d::Scene* arg1;
            ok = rubyval_to_object<cocos2d::Scene>(mrb, argv[1], "CC::Scene", &arg1);
            if (!ok) { break; }

            cocos2d::TransitionShrinkGrow* retval = cocos2d::TransitionShrinkGrow::create(arg0, arg1);
            mrb_value ret;
            RClass* rclass = mrb_class_ptr(self);
            ret = object_to_rubyval<cocos2d::TransitionShrinkGrow>(mrb, "CC::TransitionShrinkGrow", (cocos2d::TransitionShrinkGrow*)retval, rclass);
            if (callbacks.size() > 0) {
                mrb_value hash = mrb_iv_get(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"));
                if (!mrb_hash_p(hash)) {
                    hash = mrb_hash_new(mrb);
                }
                for (auto elm : callbacks) {
                    mrb_hash_set(mrb, hash, mrb_str_new_cstr(mrb, elm.first.c_str()), elm.second);
                    mrb_iv_set(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"), hash);
                }
            }
            g_rubyValue.push_back(ret);
            mrb_funcall(mrb, ret, "initialize", 0);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined static method : cocos2d::TransitionShrinkGrow#create");

    return mrb_nil_value();
}

void ruby_register_cocos2dx_TransitionShrinkGrow(mrb_state* mrb, struct RClass* rmodule)
{
    std::string typeName = typeid(cocos2d::TransitionShrinkGrow).name();
    g_rubyType[typeName] = "CC::TransitionShrinkGrow";
    g_rubyDataType[typeName] = &ruby_cocos2dx_Ref_type;

    struct RClass* p_rmodule = mrb->object_class;
    p_rmodule = mrb_module_get_under(mrb, p_rmodule, "CC");
    struct RClass* p_rclass = mrb_class_get_under(mrb, p_rmodule, "TransitionScene");
    struct RClass *rclass = mrb_define_class_under(mrb, rmodule, "TransitionShrinkGrow", p_rclass);
    MRB_SET_INSTANCE_TT(rclass, MRB_TT_DATA);

    mrb_define_method(mrb, rclass, "ease_action_with_action", ruby_cocos2dx_TransitionShrinkGrow_easeActionWithAction, ARGS_REQ(1));
    mrb_define_class_method(mrb, rclass, "create", ruby_cocos2dx_TransitionShrinkGrow_create_static, ARGS_REQ(2));
}
mrb_value ruby_cocos2dx_TransitionFlipX_create_static(mrb_state* mrb, mrb_value self)
{
    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 2) {
            std::map<std::string, mrb_value> callbacks;
            double arg0;
            ok = rubyval_to_number(mrb, argv[0], (double*)&arg0, "CC::TransitionFlipX.create");
            if (!ok) { break; }

            cocos2d::Scene* arg1;
            ok = rubyval_to_object<cocos2d::Scene>(mrb, argv[1], "CC::Scene", &arg1);
            if (!ok) { break; }

            cocos2d::TransitionFlipX* retval = cocos2d::TransitionFlipX::create(arg0, arg1);
            mrb_value ret;
            RClass* rclass = mrb_class_ptr(self);
            ret = object_to_rubyval<cocos2d::TransitionFlipX>(mrb, "CC::TransitionFlipX", (cocos2d::TransitionFlipX*)retval, rclass);
            if (callbacks.size() > 0) {
                mrb_value hash = mrb_iv_get(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"));
                if (!mrb_hash_p(hash)) {
                    hash = mrb_hash_new(mrb);
                }
                for (auto elm : callbacks) {
                    mrb_hash_set(mrb, hash, mrb_str_new_cstr(mrb, elm.first.c_str()), elm.second);
                    mrb_iv_set(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"), hash);
                }
            }
            g_rubyValue.push_back(ret);
            mrb_funcall(mrb, ret, "initialize", 0);
            return ret;
        }
    } while (0);
    do {
        if (argc == 3) {
            std::map<std::string, mrb_value> callbacks;
            double arg0;
            ok = rubyval_to_number(mrb, argv[0], (double*)&arg0, "CC::TransitionFlipX.create");
            if (!ok) { break; }

            cocos2d::Scene* arg1;
            ok = rubyval_to_object<cocos2d::Scene>(mrb, argv[1], "CC::Scene", &arg1);
            if (!ok) { break; }

            cocos2d::TransitionScene::Orientation arg2;
            ok = rubyval_to_int32(mrb, argv[2], (int*)&arg2, "CC::TransitionFlipX.create");
            if (!ok) { break; }

            cocos2d::TransitionFlipX* retval = cocos2d::TransitionFlipX::create(arg0, arg1, arg2);
            mrb_value ret;
            RClass* rclass = mrb_class_ptr(self);
            ret = object_to_rubyval<cocos2d::TransitionFlipX>(mrb, "CC::TransitionFlipX", (cocos2d::TransitionFlipX*)retval, rclass);
            if (callbacks.size() > 0) {
                mrb_value hash = mrb_iv_get(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"));
                if (!mrb_hash_p(hash)) {
                    hash = mrb_hash_new(mrb);
                }
                for (auto elm : callbacks) {
                    mrb_hash_set(mrb, hash, mrb_str_new_cstr(mrb, elm.first.c_str()), elm.second);
                    mrb_iv_set(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"), hash);
                }
            }
            g_rubyValue.push_back(ret);
            mrb_funcall(mrb, ret, "initialize", 0);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined static method : cocos2d::TransitionFlipX#create");

    return mrb_nil_value();
}

void ruby_register_cocos2dx_TransitionFlipX(mrb_state* mrb, struct RClass* rmodule)
{
    std::string typeName = typeid(cocos2d::TransitionFlipX).name();
    g_rubyType[typeName] = "CC::TransitionFlipX";
    g_rubyDataType[typeName] = &ruby_cocos2dx_Ref_type;

    struct RClass* p_rmodule = mrb->object_class;
    p_rmodule = mrb_module_get_under(mrb, p_rmodule, "CC");
    struct RClass* p_rclass = mrb_class_get_under(mrb, p_rmodule, "TransitionSceneOriented");
    struct RClass *rclass = mrb_define_class_under(mrb, rmodule, "TransitionFlipX", p_rclass);
    MRB_SET_INSTANCE_TT(rclass, MRB_TT_DATA);

    mrb_define_class_method(mrb, rclass, "create", ruby_cocos2dx_TransitionFlipX_create_static, ARGS_REQ(2)|ARGS_OPT(1));
}
mrb_value ruby_cocos2dx_TransitionFlipY_create_static(mrb_state* mrb, mrb_value self)
{
    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 2) {
            std::map<std::string, mrb_value> callbacks;
            double arg0;
            ok = rubyval_to_number(mrb, argv[0], (double*)&arg0, "CC::TransitionFlipY.create");
            if (!ok) { break; }

            cocos2d::Scene* arg1;
            ok = rubyval_to_object<cocos2d::Scene>(mrb, argv[1], "CC::Scene", &arg1);
            if (!ok) { break; }

            cocos2d::TransitionFlipY* retval = cocos2d::TransitionFlipY::create(arg0, arg1);
            mrb_value ret;
            RClass* rclass = mrb_class_ptr(self);
            ret = object_to_rubyval<cocos2d::TransitionFlipY>(mrb, "CC::TransitionFlipY", (cocos2d::TransitionFlipY*)retval, rclass);
            if (callbacks.size() > 0) {
                mrb_value hash = mrb_iv_get(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"));
                if (!mrb_hash_p(hash)) {
                    hash = mrb_hash_new(mrb);
                }
                for (auto elm : callbacks) {
                    mrb_hash_set(mrb, hash, mrb_str_new_cstr(mrb, elm.first.c_str()), elm.second);
                    mrb_iv_set(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"), hash);
                }
            }
            g_rubyValue.push_back(ret);
            mrb_funcall(mrb, ret, "initialize", 0);
            return ret;
        }
    } while (0);
    do {
        if (argc == 3) {
            std::map<std::string, mrb_value> callbacks;
            double arg0;
            ok = rubyval_to_number(mrb, argv[0], (double*)&arg0, "CC::TransitionFlipY.create");
            if (!ok) { break; }

            cocos2d::Scene* arg1;
            ok = rubyval_to_object<cocos2d::Scene>(mrb, argv[1], "CC::Scene", &arg1);
            if (!ok) { break; }

            cocos2d::TransitionScene::Orientation arg2;
            ok = rubyval_to_int32(mrb, argv[2], (int*)&arg2, "CC::TransitionFlipY.create");
            if (!ok) { break; }

            cocos2d::TransitionFlipY* retval = cocos2d::TransitionFlipY::create(arg0, arg1, arg2);
            mrb_value ret;
            RClass* rclass = mrb_class_ptr(self);
            ret = object_to_rubyval<cocos2d::TransitionFlipY>(mrb, "CC::TransitionFlipY", (cocos2d::TransitionFlipY*)retval, rclass);
            if (callbacks.size() > 0) {
                mrb_value hash = mrb_iv_get(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"));
                if (!mrb_hash_p(hash)) {
                    hash = mrb_hash_new(mrb);
                }
                for (auto elm : callbacks) {
                    mrb_hash_set(mrb, hash, mrb_str_new_cstr(mrb, elm.first.c_str()), elm.second);
                    mrb_iv_set(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"), hash);
                }
            }
            g_rubyValue.push_back(ret);
            mrb_funcall(mrb, ret, "initialize", 0);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined static method : cocos2d::TransitionFlipY#create");

    return mrb_nil_value();
}

void ruby_register_cocos2dx_TransitionFlipY(mrb_state* mrb, struct RClass* rmodule)
{
    std::string typeName = typeid(cocos2d::TransitionFlipY).name();
    g_rubyType[typeName] = "CC::TransitionFlipY";
    g_rubyDataType[typeName] = &ruby_cocos2dx_Ref_type;

    struct RClass* p_rmodule = mrb->object_class;
    p_rmodule = mrb_module_get_under(mrb, p_rmodule, "CC");
    struct RClass* p_rclass = mrb_class_get_under(mrb, p_rmodule, "TransitionSceneOriented");
    struct RClass *rclass = mrb_define_class_under(mrb, rmodule, "TransitionFlipY", p_rclass);
    MRB_SET_INSTANCE_TT(rclass, MRB_TT_DATA);

    mrb_define_class_method(mrb, rclass, "create", ruby_cocos2dx_TransitionFlipY_create_static, ARGS_REQ(2)|ARGS_OPT(1));
}
mrb_value ruby_cocos2dx_TransitionFlipAngular_create_static(mrb_state* mrb, mrb_value self)
{
    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 2) {
            std::map<std::string, mrb_value> callbacks;
            double arg0;
            ok = rubyval_to_number(mrb, argv[0], (double*)&arg0, "CC::TransitionFlipAngular.create");
            if (!ok) { break; }

            cocos2d::Scene* arg1;
            ok = rubyval_to_object<cocos2d::Scene>(mrb, argv[1], "CC::Scene", &arg1);
            if (!ok) { break; }

            cocos2d::TransitionFlipAngular* retval = cocos2d::TransitionFlipAngular::create(arg0, arg1);
            mrb_value ret;
            RClass* rclass = mrb_class_ptr(self);
            ret = object_to_rubyval<cocos2d::TransitionFlipAngular>(mrb, "CC::TransitionFlipAngular", (cocos2d::TransitionFlipAngular*)retval, rclass);
            if (callbacks.size() > 0) {
                mrb_value hash = mrb_iv_get(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"));
                if (!mrb_hash_p(hash)) {
                    hash = mrb_hash_new(mrb);
                }
                for (auto elm : callbacks) {
                    mrb_hash_set(mrb, hash, mrb_str_new_cstr(mrb, elm.first.c_str()), elm.second);
                    mrb_iv_set(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"), hash);
                }
            }
            g_rubyValue.push_back(ret);
            mrb_funcall(mrb, ret, "initialize", 0);
            return ret;
        }
    } while (0);
    do {
        if (argc == 3) {
            std::map<std::string, mrb_value> callbacks;
            double arg0;
            ok = rubyval_to_number(mrb, argv[0], (double*)&arg0, "CC::TransitionFlipAngular.create");
            if (!ok) { break; }

            cocos2d::Scene* arg1;
            ok = rubyval_to_object<cocos2d::Scene>(mrb, argv[1], "CC::Scene", &arg1);
            if (!ok) { break; }

            cocos2d::TransitionScene::Orientation arg2;
            ok = rubyval_to_int32(mrb, argv[2], (int*)&arg2, "CC::TransitionFlipAngular.create");
            if (!ok) { break; }

            cocos2d::TransitionFlipAngular* retval = cocos2d::TransitionFlipAngular::create(arg0, arg1, arg2);
            mrb_value ret;
            RClass* rclass = mrb_class_ptr(self);
            ret = object_to_rubyval<cocos2d::TransitionFlipAngular>(mrb, "CC::TransitionFlipAngular", (cocos2d::TransitionFlipAngular*)retval, rclass);
            if (callbacks.size() > 0) {
                mrb_value hash = mrb_iv_get(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"));
                if (!mrb_hash_p(hash)) {
                    hash = mrb_hash_new(mrb);
                }
                for (auto elm : callbacks) {
                    mrb_hash_set(mrb, hash, mrb_str_new_cstr(mrb, elm.first.c_str()), elm.second);
                    mrb_iv_set(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"), hash);
                }
            }
            g_rubyValue.push_back(ret);
            mrb_funcall(mrb, ret, "initialize", 0);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined static method : cocos2d::TransitionFlipAngular#create");

    return mrb_nil_value();
}

void ruby_register_cocos2dx_TransitionFlipAngular(mrb_state* mrb, struct RClass* rmodule)
{
    std::string typeName = typeid(cocos2d::TransitionFlipAngular).name();
    g_rubyType[typeName] = "CC::TransitionFlipAngular";
    g_rubyDataType[typeName] = &ruby_cocos2dx_Ref_type;

    struct RClass* p_rmodule = mrb->object_class;
    p_rmodule = mrb_module_get_under(mrb, p_rmodule, "CC");
    struct RClass* p_rclass = mrb_class_get_under(mrb, p_rmodule, "TransitionSceneOriented");
    struct RClass *rclass = mrb_define_class_under(mrb, rmodule, "TransitionFlipAngular", p_rclass);
    MRB_SET_INSTANCE_TT(rclass, MRB_TT_DATA);

    mrb_define_class_method(mrb, rclass, "create", ruby_cocos2dx_TransitionFlipAngular_create_static, ARGS_REQ(2)|ARGS_OPT(1));
}
mrb_value ruby_cocos2dx_TransitionZoomFlipX_create_static(mrb_state* mrb, mrb_value self)
{
    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 2) {
            std::map<std::string, mrb_value> callbacks;
            double arg0;
            ok = rubyval_to_number(mrb, argv[0], (double*)&arg0, "CC::TransitionZoomFlipX.create");
            if (!ok) { break; }

            cocos2d::Scene* arg1;
            ok = rubyval_to_object<cocos2d::Scene>(mrb, argv[1], "CC::Scene", &arg1);
            if (!ok) { break; }

            cocos2d::TransitionZoomFlipX* retval = cocos2d::TransitionZoomFlipX::create(arg0, arg1);
            mrb_value ret;
            RClass* rclass = mrb_class_ptr(self);
            ret = object_to_rubyval<cocos2d::TransitionZoomFlipX>(mrb, "CC::TransitionZoomFlipX", (cocos2d::TransitionZoomFlipX*)retval, rclass);
            if (callbacks.size() > 0) {
                mrb_value hash = mrb_iv_get(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"));
                if (!mrb_hash_p(hash)) {
                    hash = mrb_hash_new(mrb);
                }
                for (auto elm : callbacks) {
                    mrb_hash_set(mrb, hash, mrb_str_new_cstr(mrb, elm.first.c_str()), elm.second);
                    mrb_iv_set(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"), hash);
                }
            }
            g_rubyValue.push_back(ret);
            mrb_funcall(mrb, ret, "initialize", 0);
            return ret;
        }
    } while (0);
    do {
        if (argc == 3) {
            std::map<std::string, mrb_value> callbacks;
            double arg0;
            ok = rubyval_to_number(mrb, argv[0], (double*)&arg0, "CC::TransitionZoomFlipX.create");
            if (!ok) { break; }

            cocos2d::Scene* arg1;
            ok = rubyval_to_object<cocos2d::Scene>(mrb, argv[1], "CC::Scene", &arg1);
            if (!ok) { break; }

            cocos2d::TransitionScene::Orientation arg2;
            ok = rubyval_to_int32(mrb, argv[2], (int*)&arg2, "CC::TransitionZoomFlipX.create");
            if (!ok) { break; }

            cocos2d::TransitionZoomFlipX* retval = cocos2d::TransitionZoomFlipX::create(arg0, arg1, arg2);
            mrb_value ret;
            RClass* rclass = mrb_class_ptr(self);
            ret = object_to_rubyval<cocos2d::TransitionZoomFlipX>(mrb, "CC::TransitionZoomFlipX", (cocos2d::TransitionZoomFlipX*)retval, rclass);
            if (callbacks.size() > 0) {
                mrb_value hash = mrb_iv_get(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"));
                if (!mrb_hash_p(hash)) {
                    hash = mrb_hash_new(mrb);
                }
                for (auto elm : callbacks) {
                    mrb_hash_set(mrb, hash, mrb_str_new_cstr(mrb, elm.first.c_str()), elm.second);
                    mrb_iv_set(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"), hash);
                }
            }
            g_rubyValue.push_back(ret);
            mrb_funcall(mrb, ret, "initialize", 0);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined static method : cocos2d::TransitionZoomFlipX#create");

    return mrb_nil_value();
}

void ruby_register_cocos2dx_TransitionZoomFlipX(mrb_state* mrb, struct RClass* rmodule)
{
    std::string typeName = typeid(cocos2d::TransitionZoomFlipX).name();
    g_rubyType[typeName] = "CC::TransitionZoomFlipX";
    g_rubyDataType[typeName] = &ruby_cocos2dx_Ref_type;

    struct RClass* p_rmodule = mrb->object_class;
    p_rmodule = mrb_module_get_under(mrb, p_rmodule, "CC");
    struct RClass* p_rclass = mrb_class_get_under(mrb, p_rmodule, "TransitionSceneOriented");
    struct RClass *rclass = mrb_define_class_under(mrb, rmodule, "TransitionZoomFlipX", p_rclass);
    MRB_SET_INSTANCE_TT(rclass, MRB_TT_DATA);

    mrb_define_class_method(mrb, rclass, "create", ruby_cocos2dx_TransitionZoomFlipX_create_static, ARGS_REQ(2)|ARGS_OPT(1));
}
mrb_value ruby_cocos2dx_TransitionZoomFlipY_create_static(mrb_state* mrb, mrb_value self)
{
    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 2) {
            std::map<std::string, mrb_value> callbacks;
            double arg0;
            ok = rubyval_to_number(mrb, argv[0], (double*)&arg0, "CC::TransitionZoomFlipY.create");
            if (!ok) { break; }

            cocos2d::Scene* arg1;
            ok = rubyval_to_object<cocos2d::Scene>(mrb, argv[1], "CC::Scene", &arg1);
            if (!ok) { break; }

            cocos2d::TransitionZoomFlipY* retval = cocos2d::TransitionZoomFlipY::create(arg0, arg1);
            mrb_value ret;
            RClass* rclass = mrb_class_ptr(self);
            ret = object_to_rubyval<cocos2d::TransitionZoomFlipY>(mrb, "CC::TransitionZoomFlipY", (cocos2d::TransitionZoomFlipY*)retval, rclass);
            if (callbacks.size() > 0) {
                mrb_value hash = mrb_iv_get(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"));
                if (!mrb_hash_p(hash)) {
                    hash = mrb_hash_new(mrb);
                }
                for (auto elm : callbacks) {
                    mrb_hash_set(mrb, hash, mrb_str_new_cstr(mrb, elm.first.c_str()), elm.second);
                    mrb_iv_set(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"), hash);
                }
            }
            g_rubyValue.push_back(ret);
            mrb_funcall(mrb, ret, "initialize", 0);
            return ret;
        }
    } while (0);
    do {
        if (argc == 3) {
            std::map<std::string, mrb_value> callbacks;
            double arg0;
            ok = rubyval_to_number(mrb, argv[0], (double*)&arg0, "CC::TransitionZoomFlipY.create");
            if (!ok) { break; }

            cocos2d::Scene* arg1;
            ok = rubyval_to_object<cocos2d::Scene>(mrb, argv[1], "CC::Scene", &arg1);
            if (!ok) { break; }

            cocos2d::TransitionScene::Orientation arg2;
            ok = rubyval_to_int32(mrb, argv[2], (int*)&arg2, "CC::TransitionZoomFlipY.create");
            if (!ok) { break; }

            cocos2d::TransitionZoomFlipY* retval = cocos2d::TransitionZoomFlipY::create(arg0, arg1, arg2);
            mrb_value ret;
            RClass* rclass = mrb_class_ptr(self);
            ret = object_to_rubyval<cocos2d::TransitionZoomFlipY>(mrb, "CC::TransitionZoomFlipY", (cocos2d::TransitionZoomFlipY*)retval, rclass);
            if (callbacks.size() > 0) {
                mrb_value hash = mrb_iv_get(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"));
                if (!mrb_hash_p(hash)) {
                    hash = mrb_hash_new(mrb);
                }
                for (auto elm : callbacks) {
                    mrb_hash_set(mrb, hash, mrb_str_new_cstr(mrb, elm.first.c_str()), elm.second);
                    mrb_iv_set(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"), hash);
                }
            }
            g_rubyValue.push_back(ret);
            mrb_funcall(mrb, ret, "initialize", 0);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined static method : cocos2d::TransitionZoomFlipY#create");

    return mrb_nil_value();
}

void ruby_register_cocos2dx_TransitionZoomFlipY(mrb_state* mrb, struct RClass* rmodule)
{
    std::string typeName = typeid(cocos2d::TransitionZoomFlipY).name();
    g_rubyType[typeName] = "CC::TransitionZoomFlipY";
    g_rubyDataType[typeName] = &ruby_cocos2dx_Ref_type;

    struct RClass* p_rmodule = mrb->object_class;
    p_rmodule = mrb_module_get_under(mrb, p_rmodule, "CC");
    struct RClass* p_rclass = mrb_class_get_under(mrb, p_rmodule, "TransitionSceneOriented");
    struct RClass *rclass = mrb_define_class_under(mrb, rmodule, "TransitionZoomFlipY", p_rclass);
    MRB_SET_INSTANCE_TT(rclass, MRB_TT_DATA);

    mrb_define_class_method(mrb, rclass, "create", ruby_cocos2dx_TransitionZoomFlipY_create_static, ARGS_REQ(2)|ARGS_OPT(1));
}
mrb_value ruby_cocos2dx_TransitionZoomFlipAngular_create_static(mrb_state* mrb, mrb_value self)
{
    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 2) {
            std::map<std::string, mrb_value> callbacks;
            double arg0;
            ok = rubyval_to_number(mrb, argv[0], (double*)&arg0, "CC::TransitionZoomFlipAngular.create");
            if (!ok) { break; }

            cocos2d::Scene* arg1;
            ok = rubyval_to_object<cocos2d::Scene>(mrb, argv[1], "CC::Scene", &arg1);
            if (!ok) { break; }

            cocos2d::TransitionZoomFlipAngular* retval = cocos2d::TransitionZoomFlipAngular::create(arg0, arg1);
            mrb_value ret;
            RClass* rclass = mrb_class_ptr(self);
            ret = object_to_rubyval<cocos2d::TransitionZoomFlipAngular>(mrb, "CC::TransitionZoomFlipAngular", (cocos2d::TransitionZoomFlipAngular*)retval, rclass);
            if (callbacks.size() > 0) {
                mrb_value hash = mrb_iv_get(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"));
                if (!mrb_hash_p(hash)) {
                    hash = mrb_hash_new(mrb);
                }
                for (auto elm : callbacks) {
                    mrb_hash_set(mrb, hash, mrb_str_new_cstr(mrb, elm.first.c_str()), elm.second);
                    mrb_iv_set(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"), hash);
                }
            }
            g_rubyValue.push_back(ret);
            mrb_funcall(mrb, ret, "initialize", 0);
            return ret;
        }
    } while (0);
    do {
        if (argc == 3) {
            std::map<std::string, mrb_value> callbacks;
            double arg0;
            ok = rubyval_to_number(mrb, argv[0], (double*)&arg0, "CC::TransitionZoomFlipAngular.create");
            if (!ok) { break; }

            cocos2d::Scene* arg1;
            ok = rubyval_to_object<cocos2d::Scene>(mrb, argv[1], "CC::Scene", &arg1);
            if (!ok) { break; }

            cocos2d::TransitionScene::Orientation arg2;
            ok = rubyval_to_int32(mrb, argv[2], (int*)&arg2, "CC::TransitionZoomFlipAngular.create");
            if (!ok) { break; }

            cocos2d::TransitionZoomFlipAngular* retval = cocos2d::TransitionZoomFlipAngular::create(arg0, arg1, arg2);
            mrb_value ret;
            RClass* rclass = mrb_class_ptr(self);
            ret = object_to_rubyval<cocos2d::TransitionZoomFlipAngular>(mrb, "CC::TransitionZoomFlipAngular", (cocos2d::TransitionZoomFlipAngular*)retval, rclass);
            if (callbacks.size() > 0) {
                mrb_value hash = mrb_iv_get(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"));
                if (!mrb_hash_p(hash)) {
                    hash = mrb_hash_new(mrb);
                }
                for (auto elm : callbacks) {
                    mrb_hash_set(mrb, hash, mrb_str_new_cstr(mrb, elm.first.c_str()), elm.second);
                    mrb_iv_set(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"), hash);
                }
            }
            g_rubyValue.push_back(ret);
            mrb_funcall(mrb, ret, "initialize", 0);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined static method : cocos2d::TransitionZoomFlipAngular#create");

    return mrb_nil_value();
}

void ruby_register_cocos2dx_TransitionZoomFlipAngular(mrb_state* mrb, struct RClass* rmodule)
{
    std::string typeName = typeid(cocos2d::TransitionZoomFlipAngular).name();
    g_rubyType[typeName] = "CC::TransitionZoomFlipAngular";
    g_rubyDataType[typeName] = &ruby_cocos2dx_Ref_type;

    struct RClass* p_rmodule = mrb->object_class;
    p_rmodule = mrb_module_get_under(mrb, p_rmodule, "CC");
    struct RClass* p_rclass = mrb_class_get_under(mrb, p_rmodule, "TransitionSceneOriented");
    struct RClass *rclass = mrb_define_class_under(mrb, rmodule, "TransitionZoomFlipAngular", p_rclass);
    MRB_SET_INSTANCE_TT(rclass, MRB_TT_DATA);

    mrb_define_class_method(mrb, rclass, "create", ruby_cocos2dx_TransitionZoomFlipAngular_create_static, ARGS_REQ(2)|ARGS_OPT(1));
}
mrb_value ruby_cocos2dx_TransitionFade_create_static(mrb_state* mrb, mrb_value self)
{
    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 2) {
            std::map<std::string, mrb_value> callbacks;
            double arg0;
            ok = rubyval_to_number(mrb, argv[0], (double*)&arg0, "CC::TransitionFade.create");
            if (!ok) { break; }

            cocos2d::Scene* arg1;
            ok = rubyval_to_object<cocos2d::Scene>(mrb, argv[1], "CC::Scene", &arg1);
            if (!ok) { break; }

            cocos2d::TransitionFade* retval = cocos2d::TransitionFade::create(arg0, arg1);
            mrb_value ret;
            RClass* rclass = mrb_class_ptr(self);
            ret = object_to_rubyval<cocos2d::TransitionFade>(mrb, "CC::TransitionFade", (cocos2d::TransitionFade*)retval, rclass);
            if (callbacks.size() > 0) {
                mrb_value hash = mrb_iv_get(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"));
                if (!mrb_hash_p(hash)) {
                    hash = mrb_hash_new(mrb);
                }
                for (auto elm : callbacks) {
                    mrb_hash_set(mrb, hash, mrb_str_new_cstr(mrb, elm.first.c_str()), elm.second);
                    mrb_iv_set(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"), hash);
                }
            }
            g_rubyValue.push_back(ret);
            mrb_funcall(mrb, ret, "initialize", 0);
            return ret;
        }
    } while (0);
    do {
        if (argc == 3) {
            std::map<std::string, mrb_value> callbacks;
            double arg0;
            ok = rubyval_to_number(mrb, argv[0], (double*)&arg0, "CC::TransitionFade.create");
            if (!ok) { break; }

            cocos2d::Scene* arg1;
            ok = rubyval_to_object<cocos2d::Scene>(mrb, argv[1], "CC::Scene", &arg1);
            if (!ok) { break; }

            cocos2d::Color3B* arg2;
            ok = rubyval_to_object<cocos2d::Color3B>(mrb, argv[2], "CC::Color3B", &arg2);
            if (!ok) { break; }

            cocos2d::TransitionFade* retval = cocos2d::TransitionFade::create(arg0, arg1, *arg2);
            mrb_value ret;
            RClass* rclass = mrb_class_ptr(self);
            ret = object_to_rubyval<cocos2d::TransitionFade>(mrb, "CC::TransitionFade", (cocos2d::TransitionFade*)retval, rclass);
            if (callbacks.size() > 0) {
                mrb_value hash = mrb_iv_get(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"));
                if (!mrb_hash_p(hash)) {
                    hash = mrb_hash_new(mrb);
                }
                for (auto elm : callbacks) {
                    mrb_hash_set(mrb, hash, mrb_str_new_cstr(mrb, elm.first.c_str()), elm.second);
                    mrb_iv_set(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"), hash);
                }
            }
            g_rubyValue.push_back(ret);
            mrb_funcall(mrb, ret, "initialize", 0);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined static method : cocos2d::TransitionFade#create");

    return mrb_nil_value();
}

void ruby_register_cocos2dx_TransitionFade(mrb_state* mrb, struct RClass* rmodule)
{
    std::string typeName = typeid(cocos2d::TransitionFade).name();
    g_rubyType[typeName] = "CC::TransitionFade";
    g_rubyDataType[typeName] = &ruby_cocos2dx_Ref_type;

    struct RClass* p_rmodule = mrb->object_class;
    p_rmodule = mrb_module_get_under(mrb, p_rmodule, "CC");
    struct RClass* p_rclass = mrb_class_get_under(mrb, p_rmodule, "TransitionScene");
    struct RClass *rclass = mrb_define_class_under(mrb, rmodule, "TransitionFade", p_rclass);
    MRB_SET_INSTANCE_TT(rclass, MRB_TT_DATA);

    mrb_define_class_method(mrb, rclass, "create", ruby_cocos2dx_TransitionFade_create_static, ARGS_REQ(2)|ARGS_OPT(1));
}
mrb_value ruby_cocos2dx_TransitionCrossFade_create_static(mrb_state* mrb, mrb_value self)
{
    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 2) {
            std::map<std::string, mrb_value> callbacks;
            double arg0;
            ok = rubyval_to_number(mrb, argv[0], (double*)&arg0, "CC::TransitionCrossFade.create");
            if (!ok) { break; }

            cocos2d::Scene* arg1;
            ok = rubyval_to_object<cocos2d::Scene>(mrb, argv[1], "CC::Scene", &arg1);
            if (!ok) { break; }

            cocos2d::TransitionCrossFade* retval = cocos2d::TransitionCrossFade::create(arg0, arg1);
            mrb_value ret;
            RClass* rclass = mrb_class_ptr(self);
            ret = object_to_rubyval<cocos2d::TransitionCrossFade>(mrb, "CC::TransitionCrossFade", (cocos2d::TransitionCrossFade*)retval, rclass);
            if (callbacks.size() > 0) {
                mrb_value hash = mrb_iv_get(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"));
                if (!mrb_hash_p(hash)) {
                    hash = mrb_hash_new(mrb);
                }
                for (auto elm : callbacks) {
                    mrb_hash_set(mrb, hash, mrb_str_new_cstr(mrb, elm.first.c_str()), elm.second);
                    mrb_iv_set(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"), hash);
                }
            }
            g_rubyValue.push_back(ret);
            mrb_funcall(mrb, ret, "initialize", 0);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined static method : cocos2d::TransitionCrossFade#create");

    return mrb_nil_value();
}

void ruby_register_cocos2dx_TransitionCrossFade(mrb_state* mrb, struct RClass* rmodule)
{
    std::string typeName = typeid(cocos2d::TransitionCrossFade).name();
    g_rubyType[typeName] = "CC::TransitionCrossFade";
    g_rubyDataType[typeName] = &ruby_cocos2dx_Ref_type;

    struct RClass* p_rmodule = mrb->object_class;
    p_rmodule = mrb_module_get_under(mrb, p_rmodule, "CC");
    struct RClass* p_rclass = mrb_class_get_under(mrb, p_rmodule, "TransitionScene");
    struct RClass *rclass = mrb_define_class_under(mrb, rmodule, "TransitionCrossFade", p_rclass);
    MRB_SET_INSTANCE_TT(rclass, MRB_TT_DATA);

    mrb_define_class_method(mrb, rclass, "create", ruby_cocos2dx_TransitionCrossFade_create_static, ARGS_REQ(2));
}
mrb_value ruby_cocos2dx_TransitionTurnOffTiles_easeActionWithAction(mrb_state* mrb, mrb_value self)
{
    cocos2d::TransitionTurnOffTiles* cobj = static_cast<cocos2d::TransitionTurnOffTiles*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            cocos2d::ActionInterval* arg0;
            ok = rubyval_to_object<cocos2d::ActionInterval>(mrb, argv[0], "CC::ActionInterval", &arg0);
            if (!ok) { break; }
            cocos2d::ActionInterval* retval = cobj->easeActionWithAction(arg0);
            mrb_value ret;
            ret = object_to_rubyval<cocos2d::ActionInterval>(mrb, "CC::ActionInterval", (cocos2d::ActionInterval*)retval, nullptr);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::TransitionTurnOffTiles#easeActionWithAction");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_TransitionTurnOffTiles_create_static(mrb_state* mrb, mrb_value self)
{
    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 2) {
            std::map<std::string, mrb_value> callbacks;
            double arg0;
            ok = rubyval_to_number(mrb, argv[0], (double*)&arg0, "CC::TransitionTurnOffTiles.create");
            if (!ok) { break; }

            cocos2d::Scene* arg1;
            ok = rubyval_to_object<cocos2d::Scene>(mrb, argv[1], "CC::Scene", &arg1);
            if (!ok) { break; }

            cocos2d::TransitionTurnOffTiles* retval = cocos2d::TransitionTurnOffTiles::create(arg0, arg1);
            mrb_value ret;
            RClass* rclass = mrb_class_ptr(self);
            ret = object_to_rubyval<cocos2d::TransitionTurnOffTiles>(mrb, "CC::TransitionTurnOffTiles", (cocos2d::TransitionTurnOffTiles*)retval, rclass);
            if (callbacks.size() > 0) {
                mrb_value hash = mrb_iv_get(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"));
                if (!mrb_hash_p(hash)) {
                    hash = mrb_hash_new(mrb);
                }
                for (auto elm : callbacks) {
                    mrb_hash_set(mrb, hash, mrb_str_new_cstr(mrb, elm.first.c_str()), elm.second);
                    mrb_iv_set(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"), hash);
                }
            }
            g_rubyValue.push_back(ret);
            mrb_funcall(mrb, ret, "initialize", 0);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined static method : cocos2d::TransitionTurnOffTiles#create");

    return mrb_nil_value();
}

void ruby_register_cocos2dx_TransitionTurnOffTiles(mrb_state* mrb, struct RClass* rmodule)
{
    std::string typeName = typeid(cocos2d::TransitionTurnOffTiles).name();
    g_rubyType[typeName] = "CC::TransitionTurnOffTiles";
    g_rubyDataType[typeName] = &ruby_cocos2dx_Ref_type;

    struct RClass* p_rmodule = mrb->object_class;
    p_rmodule = mrb_module_get_under(mrb, p_rmodule, "CC");
    struct RClass* p_rclass = mrb_class_get_under(mrb, p_rmodule, "TransitionScene");
    struct RClass *rclass = mrb_define_class_under(mrb, rmodule, "TransitionTurnOffTiles", p_rclass);
    MRB_SET_INSTANCE_TT(rclass, MRB_TT_DATA);

    mrb_define_method(mrb, rclass, "ease_action_with_action", ruby_cocos2dx_TransitionTurnOffTiles_easeActionWithAction, ARGS_REQ(1));
    mrb_define_class_method(mrb, rclass, "create", ruby_cocos2dx_TransitionTurnOffTiles_create_static, ARGS_REQ(2));
}
mrb_value ruby_cocos2dx_TransitionSplitCols_action(mrb_state* mrb, mrb_value self)
{
    cocos2d::TransitionSplitCols* cobj = static_cast<cocos2d::TransitionSplitCols*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            cocos2d::ActionInterval* retval = cobj->action();
            mrb_value ret;
            ret = object_to_rubyval<cocos2d::ActionInterval>(mrb, "CC::ActionInterval", (cocos2d::ActionInterval*)retval, nullptr);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::TransitionSplitCols#action");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_TransitionSplitCols_easeActionWithAction(mrb_state* mrb, mrb_value self)
{
    cocos2d::TransitionSplitCols* cobj = static_cast<cocos2d::TransitionSplitCols*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            cocos2d::ActionInterval* arg0;
            ok = rubyval_to_object<cocos2d::ActionInterval>(mrb, argv[0], "CC::ActionInterval", &arg0);
            if (!ok) { break; }
            cocos2d::ActionInterval* retval = cobj->easeActionWithAction(arg0);
            mrb_value ret;
            ret = object_to_rubyval<cocos2d::ActionInterval>(mrb, "CC::ActionInterval", (cocos2d::ActionInterval*)retval, nullptr);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::TransitionSplitCols#easeActionWithAction");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_TransitionSplitCols_create_static(mrb_state* mrb, mrb_value self)
{
    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 2) {
            std::map<std::string, mrb_value> callbacks;
            double arg0;
            ok = rubyval_to_number(mrb, argv[0], (double*)&arg0, "CC::TransitionSplitCols.create");
            if (!ok) { break; }

            cocos2d::Scene* arg1;
            ok = rubyval_to_object<cocos2d::Scene>(mrb, argv[1], "CC::Scene", &arg1);
            if (!ok) { break; }

            cocos2d::TransitionSplitCols* retval = cocos2d::TransitionSplitCols::create(arg0, arg1);
            mrb_value ret;
            RClass* rclass = mrb_class_ptr(self);
            ret = object_to_rubyval<cocos2d::TransitionSplitCols>(mrb, "CC::TransitionSplitCols", (cocos2d::TransitionSplitCols*)retval, rclass);
            if (callbacks.size() > 0) {
                mrb_value hash = mrb_iv_get(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"));
                if (!mrb_hash_p(hash)) {
                    hash = mrb_hash_new(mrb);
                }
                for (auto elm : callbacks) {
                    mrb_hash_set(mrb, hash, mrb_str_new_cstr(mrb, elm.first.c_str()), elm.second);
                    mrb_iv_set(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"), hash);
                }
            }
            g_rubyValue.push_back(ret);
            mrb_funcall(mrb, ret, "initialize", 0);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined static method : cocos2d::TransitionSplitCols#create");

    return mrb_nil_value();
}

void ruby_register_cocos2dx_TransitionSplitCols(mrb_state* mrb, struct RClass* rmodule)
{
    std::string typeName = typeid(cocos2d::TransitionSplitCols).name();
    g_rubyType[typeName] = "CC::TransitionSplitCols";
    g_rubyDataType[typeName] = &ruby_cocos2dx_Ref_type;

    struct RClass* p_rmodule = mrb->object_class;
    p_rmodule = mrb_module_get_under(mrb, p_rmodule, "CC");
    struct RClass* p_rclass = mrb_class_get_under(mrb, p_rmodule, "TransitionScene");
    struct RClass *rclass = mrb_define_class_under(mrb, rmodule, "TransitionSplitCols", p_rclass);
    MRB_SET_INSTANCE_TT(rclass, MRB_TT_DATA);

    mrb_define_method(mrb, rclass, "action", ruby_cocos2dx_TransitionSplitCols_action, ARGS_NONE());
    mrb_define_method(mrb, rclass, "ease_action_with_action", ruby_cocos2dx_TransitionSplitCols_easeActionWithAction, ARGS_REQ(1));
    mrb_define_class_method(mrb, rclass, "create", ruby_cocos2dx_TransitionSplitCols_create_static, ARGS_REQ(2));
}
mrb_value ruby_cocos2dx_TransitionSplitRows_create_static(mrb_state* mrb, mrb_value self)
{
    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 2) {
            std::map<std::string, mrb_value> callbacks;
            double arg0;
            ok = rubyval_to_number(mrb, argv[0], (double*)&arg0, "CC::TransitionSplitRows.create");
            if (!ok) { break; }

            cocos2d::Scene* arg1;
            ok = rubyval_to_object<cocos2d::Scene>(mrb, argv[1], "CC::Scene", &arg1);
            if (!ok) { break; }

            cocos2d::TransitionSplitRows* retval = cocos2d::TransitionSplitRows::create(arg0, arg1);
            mrb_value ret;
            RClass* rclass = mrb_class_ptr(self);
            ret = object_to_rubyval<cocos2d::TransitionSplitRows>(mrb, "CC::TransitionSplitRows", (cocos2d::TransitionSplitRows*)retval, rclass);
            if (callbacks.size() > 0) {
                mrb_value hash = mrb_iv_get(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"));
                if (!mrb_hash_p(hash)) {
                    hash = mrb_hash_new(mrb);
                }
                for (auto elm : callbacks) {
                    mrb_hash_set(mrb, hash, mrb_str_new_cstr(mrb, elm.first.c_str()), elm.second);
                    mrb_iv_set(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"), hash);
                }
            }
            g_rubyValue.push_back(ret);
            mrb_funcall(mrb, ret, "initialize", 0);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined static method : cocos2d::TransitionSplitRows#create");

    return mrb_nil_value();
}

void ruby_register_cocos2dx_TransitionSplitRows(mrb_state* mrb, struct RClass* rmodule)
{
    std::string typeName = typeid(cocos2d::TransitionSplitRows).name();
    g_rubyType[typeName] = "CC::TransitionSplitRows";
    g_rubyDataType[typeName] = &ruby_cocos2dx_Ref_type;

    struct RClass* p_rmodule = mrb->object_class;
    p_rmodule = mrb_module_get_under(mrb, p_rmodule, "CC");
    struct RClass* p_rclass = mrb_class_get_under(mrb, p_rmodule, "TransitionSplitCols");
    struct RClass *rclass = mrb_define_class_under(mrb, rmodule, "TransitionSplitRows", p_rclass);
    MRB_SET_INSTANCE_TT(rclass, MRB_TT_DATA);

    mrb_define_class_method(mrb, rclass, "create", ruby_cocos2dx_TransitionSplitRows_create_static, ARGS_REQ(2));
}
mrb_value ruby_cocos2dx_TransitionFadeTR_easeActionWithAction(mrb_state* mrb, mrb_value self)
{
    cocos2d::TransitionFadeTR* cobj = static_cast<cocos2d::TransitionFadeTR*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            cocos2d::ActionInterval* arg0;
            ok = rubyval_to_object<cocos2d::ActionInterval>(mrb, argv[0], "CC::ActionInterval", &arg0);
            if (!ok) { break; }
            cocos2d::ActionInterval* retval = cobj->easeActionWithAction(arg0);
            mrb_value ret;
            ret = object_to_rubyval<cocos2d::ActionInterval>(mrb, "CC::ActionInterval", (cocos2d::ActionInterval*)retval, nullptr);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::TransitionFadeTR#easeActionWithAction");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_TransitionFadeTR_actionWithSize(mrb_state* mrb, mrb_value self)
{
    cocos2d::TransitionFadeTR* cobj = static_cast<cocos2d::TransitionFadeTR*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            cocos2d::Size* arg0;
            ok = rubyval_to_object<cocos2d::Size>(mrb, argv[0], "CC::Size", &arg0);
            if (!ok) { break; }
            cocos2d::ActionInterval* retval = cobj->actionWithSize(*arg0);
            mrb_value ret;
            ret = object_to_rubyval<cocos2d::ActionInterval>(mrb, "CC::ActionInterval", (cocos2d::ActionInterval*)retval, nullptr);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::TransitionFadeTR#actionWithSize");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_TransitionFadeTR_create_static(mrb_state* mrb, mrb_value self)
{
    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 2) {
            std::map<std::string, mrb_value> callbacks;
            double arg0;
            ok = rubyval_to_number(mrb, argv[0], (double*)&arg0, "CC::TransitionFadeTR.create");
            if (!ok) { break; }

            cocos2d::Scene* arg1;
            ok = rubyval_to_object<cocos2d::Scene>(mrb, argv[1], "CC::Scene", &arg1);
            if (!ok) { break; }

            cocos2d::TransitionFadeTR* retval = cocos2d::TransitionFadeTR::create(arg0, arg1);
            mrb_value ret;
            RClass* rclass = mrb_class_ptr(self);
            ret = object_to_rubyval<cocos2d::TransitionFadeTR>(mrb, "CC::TransitionFadeTR", (cocos2d::TransitionFadeTR*)retval, rclass);
            if (callbacks.size() > 0) {
                mrb_value hash = mrb_iv_get(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"));
                if (!mrb_hash_p(hash)) {
                    hash = mrb_hash_new(mrb);
                }
                for (auto elm : callbacks) {
                    mrb_hash_set(mrb, hash, mrb_str_new_cstr(mrb, elm.first.c_str()), elm.second);
                    mrb_iv_set(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"), hash);
                }
            }
            g_rubyValue.push_back(ret);
            mrb_funcall(mrb, ret, "initialize", 0);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined static method : cocos2d::TransitionFadeTR#create");

    return mrb_nil_value();
}

void ruby_register_cocos2dx_TransitionFadeTR(mrb_state* mrb, struct RClass* rmodule)
{
    std::string typeName = typeid(cocos2d::TransitionFadeTR).name();
    g_rubyType[typeName] = "CC::TransitionFadeTR";
    g_rubyDataType[typeName] = &ruby_cocos2dx_Ref_type;

    struct RClass* p_rmodule = mrb->object_class;
    p_rmodule = mrb_module_get_under(mrb, p_rmodule, "CC");
    struct RClass* p_rclass = mrb_class_get_under(mrb, p_rmodule, "TransitionScene");
    struct RClass *rclass = mrb_define_class_under(mrb, rmodule, "TransitionFadeTR", p_rclass);
    MRB_SET_INSTANCE_TT(rclass, MRB_TT_DATA);

    mrb_define_method(mrb, rclass, "ease_action_with_action", ruby_cocos2dx_TransitionFadeTR_easeActionWithAction, ARGS_REQ(1));
    mrb_define_method(mrb, rclass, "action_with_size", ruby_cocos2dx_TransitionFadeTR_actionWithSize, ARGS_REQ(1));
    mrb_define_class_method(mrb, rclass, "create", ruby_cocos2dx_TransitionFadeTR_create_static, ARGS_REQ(2));
}
mrb_value ruby_cocos2dx_TransitionFadeBL_create_static(mrb_state* mrb, mrb_value self)
{
    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 2) {
            std::map<std::string, mrb_value> callbacks;
            double arg0;
            ok = rubyval_to_number(mrb, argv[0], (double*)&arg0, "CC::TransitionFadeBL.create");
            if (!ok) { break; }

            cocos2d::Scene* arg1;
            ok = rubyval_to_object<cocos2d::Scene>(mrb, argv[1], "CC::Scene", &arg1);
            if (!ok) { break; }

            cocos2d::TransitionFadeBL* retval = cocos2d::TransitionFadeBL::create(arg0, arg1);
            mrb_value ret;
            RClass* rclass = mrb_class_ptr(self);
            ret = object_to_rubyval<cocos2d::TransitionFadeBL>(mrb, "CC::TransitionFadeBL", (cocos2d::TransitionFadeBL*)retval, rclass);
            if (callbacks.size() > 0) {
                mrb_value hash = mrb_iv_get(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"));
                if (!mrb_hash_p(hash)) {
                    hash = mrb_hash_new(mrb);
                }
                for (auto elm : callbacks) {
                    mrb_hash_set(mrb, hash, mrb_str_new_cstr(mrb, elm.first.c_str()), elm.second);
                    mrb_iv_set(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"), hash);
                }
            }
            g_rubyValue.push_back(ret);
            mrb_funcall(mrb, ret, "initialize", 0);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined static method : cocos2d::TransitionFadeBL#create");

    return mrb_nil_value();
}

void ruby_register_cocos2dx_TransitionFadeBL(mrb_state* mrb, struct RClass* rmodule)
{
    std::string typeName = typeid(cocos2d::TransitionFadeBL).name();
    g_rubyType[typeName] = "CC::TransitionFadeBL";
    g_rubyDataType[typeName] = &ruby_cocos2dx_Ref_type;

    struct RClass* p_rmodule = mrb->object_class;
    p_rmodule = mrb_module_get_under(mrb, p_rmodule, "CC");
    struct RClass* p_rclass = mrb_class_get_under(mrb, p_rmodule, "TransitionFadeTR");
    struct RClass *rclass = mrb_define_class_under(mrb, rmodule, "TransitionFadeBL", p_rclass);
    MRB_SET_INSTANCE_TT(rclass, MRB_TT_DATA);

    mrb_define_class_method(mrb, rclass, "create", ruby_cocos2dx_TransitionFadeBL_create_static, ARGS_REQ(2));
}
mrb_value ruby_cocos2dx_TransitionFadeUp_create_static(mrb_state* mrb, mrb_value self)
{
    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 2) {
            std::map<std::string, mrb_value> callbacks;
            double arg0;
            ok = rubyval_to_number(mrb, argv[0], (double*)&arg0, "CC::TransitionFadeUp.create");
            if (!ok) { break; }

            cocos2d::Scene* arg1;
            ok = rubyval_to_object<cocos2d::Scene>(mrb, argv[1], "CC::Scene", &arg1);
            if (!ok) { break; }

            cocos2d::TransitionFadeUp* retval = cocos2d::TransitionFadeUp::create(arg0, arg1);
            mrb_value ret;
            RClass* rclass = mrb_class_ptr(self);
            ret = object_to_rubyval<cocos2d::TransitionFadeUp>(mrb, "CC::TransitionFadeUp", (cocos2d::TransitionFadeUp*)retval, rclass);
            if (callbacks.size() > 0) {
                mrb_value hash = mrb_iv_get(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"));
                if (!mrb_hash_p(hash)) {
                    hash = mrb_hash_new(mrb);
                }
                for (auto elm : callbacks) {
                    mrb_hash_set(mrb, hash, mrb_str_new_cstr(mrb, elm.first.c_str()), elm.second);
                    mrb_iv_set(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"), hash);
                }
            }
            g_rubyValue.push_back(ret);
            mrb_funcall(mrb, ret, "initialize", 0);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined static method : cocos2d::TransitionFadeUp#create");

    return mrb_nil_value();
}

void ruby_register_cocos2dx_TransitionFadeUp(mrb_state* mrb, struct RClass* rmodule)
{
    std::string typeName = typeid(cocos2d::TransitionFadeUp).name();
    g_rubyType[typeName] = "CC::TransitionFadeUp";
    g_rubyDataType[typeName] = &ruby_cocos2dx_Ref_type;

    struct RClass* p_rmodule = mrb->object_class;
    p_rmodule = mrb_module_get_under(mrb, p_rmodule, "CC");
    struct RClass* p_rclass = mrb_class_get_under(mrb, p_rmodule, "TransitionFadeTR");
    struct RClass *rclass = mrb_define_class_under(mrb, rmodule, "TransitionFadeUp", p_rclass);
    MRB_SET_INSTANCE_TT(rclass, MRB_TT_DATA);

    mrb_define_class_method(mrb, rclass, "create", ruby_cocos2dx_TransitionFadeUp_create_static, ARGS_REQ(2));
}
mrb_value ruby_cocos2dx_TransitionFadeDown_create_static(mrb_state* mrb, mrb_value self)
{
    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 2) {
            std::map<std::string, mrb_value> callbacks;
            double arg0;
            ok = rubyval_to_number(mrb, argv[0], (double*)&arg0, "CC::TransitionFadeDown.create");
            if (!ok) { break; }

            cocos2d::Scene* arg1;
            ok = rubyval_to_object<cocos2d::Scene>(mrb, argv[1], "CC::Scene", &arg1);
            if (!ok) { break; }

            cocos2d::TransitionFadeDown* retval = cocos2d::TransitionFadeDown::create(arg0, arg1);
            mrb_value ret;
            RClass* rclass = mrb_class_ptr(self);
            ret = object_to_rubyval<cocos2d::TransitionFadeDown>(mrb, "CC::TransitionFadeDown", (cocos2d::TransitionFadeDown*)retval, rclass);
            if (callbacks.size() > 0) {
                mrb_value hash = mrb_iv_get(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"));
                if (!mrb_hash_p(hash)) {
                    hash = mrb_hash_new(mrb);
                }
                for (auto elm : callbacks) {
                    mrb_hash_set(mrb, hash, mrb_str_new_cstr(mrb, elm.first.c_str()), elm.second);
                    mrb_iv_set(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"), hash);
                }
            }
            g_rubyValue.push_back(ret);
            mrb_funcall(mrb, ret, "initialize", 0);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined static method : cocos2d::TransitionFadeDown#create");

    return mrb_nil_value();
}

void ruby_register_cocos2dx_TransitionFadeDown(mrb_state* mrb, struct RClass* rmodule)
{
    std::string typeName = typeid(cocos2d::TransitionFadeDown).name();
    g_rubyType[typeName] = "CC::TransitionFadeDown";
    g_rubyDataType[typeName] = &ruby_cocos2dx_Ref_type;

    struct RClass* p_rmodule = mrb->object_class;
    p_rmodule = mrb_module_get_under(mrb, p_rmodule, "CC");
    struct RClass* p_rclass = mrb_class_get_under(mrb, p_rmodule, "TransitionFadeTR");
    struct RClass *rclass = mrb_define_class_under(mrb, rmodule, "TransitionFadeDown", p_rclass);
    MRB_SET_INSTANCE_TT(rclass, MRB_TT_DATA);

    mrb_define_class_method(mrb, rclass, "create", ruby_cocos2dx_TransitionFadeDown_create_static, ARGS_REQ(2));
}
mrb_value ruby_cocos2dx_TransitionPageTurn_actionWithSize(mrb_state* mrb, mrb_value self)
{
    cocos2d::TransitionPageTurn* cobj = static_cast<cocos2d::TransitionPageTurn*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            cocos2d::Size* arg0;
            ok = rubyval_to_object<cocos2d::Size>(mrb, argv[0], "CC::Size", &arg0);
            if (!ok) { break; }
            cocos2d::ActionInterval* retval = cobj->actionWithSize(*arg0);
            mrb_value ret;
            ret = object_to_rubyval<cocos2d::ActionInterval>(mrb, "CC::ActionInterval", (cocos2d::ActionInterval*)retval, nullptr);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::TransitionPageTurn#actionWithSize");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_TransitionPageTurn_initWithDuration(mrb_state* mrb, mrb_value self)
{
    cocos2d::TransitionPageTurn* cobj = static_cast<cocos2d::TransitionPageTurn*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 3) {
            double arg0;
            ok = rubyval_to_number(mrb, argv[0], (double*)&arg0, "CC::TransitionPageTurn.initWithDuration");
            if (!ok) { break; }
            cocos2d::Scene* arg1;
            ok = rubyval_to_object<cocos2d::Scene>(mrb, argv[1], "CC::Scene", &arg1);
            if (!ok) { break; }
            bool arg2;
            ok = rubyval_to_boolean(mrb, argv[2], &arg2, "CC::TransitionPageTurn.initWithDuration");
            if (!ok) { break; }
            bool retval = cobj->initWithDuration(arg0, arg1, arg2);
            mrb_value ret;
            ret = mrb_bool_value((mrb_bool)retval);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::TransitionPageTurn#initWithDuration");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_TransitionPageTurn_create_static(mrb_state* mrb, mrb_value self)
{
    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 3) {
            std::map<std::string, mrb_value> callbacks;
            double arg0;
            ok = rubyval_to_number(mrb, argv[0], (double*)&arg0, "CC::TransitionPageTurn.create");
            if (!ok) { break; }

            cocos2d::Scene* arg1;
            ok = rubyval_to_object<cocos2d::Scene>(mrb, argv[1], "CC::Scene", &arg1);
            if (!ok) { break; }

            bool arg2;
            ok = rubyval_to_boolean(mrb, argv[2], &arg2, "CC::TransitionPageTurn.create");
            if (!ok) { break; }

            cocos2d::TransitionPageTurn* retval = cocos2d::TransitionPageTurn::create(arg0, arg1, arg2);
            mrb_value ret;
            RClass* rclass = mrb_class_ptr(self);
            ret = object_to_rubyval<cocos2d::TransitionPageTurn>(mrb, "CC::TransitionPageTurn", (cocos2d::TransitionPageTurn*)retval, rclass);
            if (callbacks.size() > 0) {
                mrb_value hash = mrb_iv_get(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"));
                if (!mrb_hash_p(hash)) {
                    hash = mrb_hash_new(mrb);
                }
                for (auto elm : callbacks) {
                    mrb_hash_set(mrb, hash, mrb_str_new_cstr(mrb, elm.first.c_str()), elm.second);
                    mrb_iv_set(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"), hash);
                }
            }
            g_rubyValue.push_back(ret);
            mrb_funcall(mrb, ret, "initialize", 0);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined static method : cocos2d::TransitionPageTurn#create");

    return mrb_nil_value();
}

void ruby_register_cocos2dx_TransitionPageTurn(mrb_state* mrb, struct RClass* rmodule)
{
    std::string typeName = typeid(cocos2d::TransitionPageTurn).name();
    g_rubyType[typeName] = "CC::TransitionPageTurn";
    g_rubyDataType[typeName] = &ruby_cocos2dx_Ref_type;

    struct RClass* p_rmodule = mrb->object_class;
    p_rmodule = mrb_module_get_under(mrb, p_rmodule, "CC");
    struct RClass* p_rclass = mrb_class_get_under(mrb, p_rmodule, "TransitionScene");
    struct RClass *rclass = mrb_define_class_under(mrb, rmodule, "TransitionPageTurn", p_rclass);
    MRB_SET_INSTANCE_TT(rclass, MRB_TT_DATA);

    mrb_define_method(mrb, rclass, "action_with_size", ruby_cocos2dx_TransitionPageTurn_actionWithSize, ARGS_REQ(1));
    mrb_define_method(mrb, rclass, "init_with_duration", ruby_cocos2dx_TransitionPageTurn_initWithDuration, ARGS_REQ(3));
    mrb_define_class_method(mrb, rclass, "create", ruby_cocos2dx_TransitionPageTurn_create_static, ARGS_REQ(3));
}
mrb_value ruby_cocos2dx_TransitionProgress_create_static(mrb_state* mrb, mrb_value self)
{
    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 2) {
            std::map<std::string, mrb_value> callbacks;
            double arg0;
            ok = rubyval_to_number(mrb, argv[0], (double*)&arg0, "CC::TransitionProgress.create");
            if (!ok) { break; }

            cocos2d::Scene* arg1;
            ok = rubyval_to_object<cocos2d::Scene>(mrb, argv[1], "CC::Scene", &arg1);
            if (!ok) { break; }

            cocos2d::TransitionProgress* retval = cocos2d::TransitionProgress::create(arg0, arg1);
            mrb_value ret;
            RClass* rclass = mrb_class_ptr(self);
            ret = object_to_rubyval<cocos2d::TransitionProgress>(mrb, "CC::TransitionProgress", (cocos2d::TransitionProgress*)retval, rclass);
            if (callbacks.size() > 0) {
                mrb_value hash = mrb_iv_get(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"));
                if (!mrb_hash_p(hash)) {
                    hash = mrb_hash_new(mrb);
                }
                for (auto elm : callbacks) {
                    mrb_hash_set(mrb, hash, mrb_str_new_cstr(mrb, elm.first.c_str()), elm.second);
                    mrb_iv_set(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"), hash);
                }
            }
            g_rubyValue.push_back(ret);
            mrb_funcall(mrb, ret, "initialize", 0);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined static method : cocos2d::TransitionProgress#create");

    return mrb_nil_value();
}

void ruby_register_cocos2dx_TransitionProgress(mrb_state* mrb, struct RClass* rmodule)
{
    std::string typeName = typeid(cocos2d::TransitionProgress).name();
    g_rubyType[typeName] = "CC::TransitionProgress";
    g_rubyDataType[typeName] = &ruby_cocos2dx_Ref_type;

    struct RClass* p_rmodule = mrb->object_class;
    p_rmodule = mrb_module_get_under(mrb, p_rmodule, "CC");
    struct RClass* p_rclass = mrb_class_get_under(mrb, p_rmodule, "TransitionScene");
    struct RClass *rclass = mrb_define_class_under(mrb, rmodule, "TransitionProgress", p_rclass);
    MRB_SET_INSTANCE_TT(rclass, MRB_TT_DATA);

    mrb_define_class_method(mrb, rclass, "create", ruby_cocos2dx_TransitionProgress_create_static, ARGS_REQ(2));
}
mrb_value ruby_cocos2dx_TransitionProgressRadialCCW_create_static(mrb_state* mrb, mrb_value self)
{
    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 2) {
            std::map<std::string, mrb_value> callbacks;
            double arg0;
            ok = rubyval_to_number(mrb, argv[0], (double*)&arg0, "CC::TransitionProgressRadialCCW.create");
            if (!ok) { break; }

            cocos2d::Scene* arg1;
            ok = rubyval_to_object<cocos2d::Scene>(mrb, argv[1], "CC::Scene", &arg1);
            if (!ok) { break; }

            cocos2d::TransitionProgressRadialCCW* retval = cocos2d::TransitionProgressRadialCCW::create(arg0, arg1);
            mrb_value ret;
            RClass* rclass = mrb_class_ptr(self);
            ret = object_to_rubyval<cocos2d::TransitionProgressRadialCCW>(mrb, "CC::TransitionProgressRadialCCW", (cocos2d::TransitionProgressRadialCCW*)retval, rclass);
            if (callbacks.size() > 0) {
                mrb_value hash = mrb_iv_get(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"));
                if (!mrb_hash_p(hash)) {
                    hash = mrb_hash_new(mrb);
                }
                for (auto elm : callbacks) {
                    mrb_hash_set(mrb, hash, mrb_str_new_cstr(mrb, elm.first.c_str()), elm.second);
                    mrb_iv_set(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"), hash);
                }
            }
            g_rubyValue.push_back(ret);
            mrb_funcall(mrb, ret, "initialize", 0);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined static method : cocos2d::TransitionProgressRadialCCW#create");

    return mrb_nil_value();
}

void ruby_register_cocos2dx_TransitionProgressRadialCCW(mrb_state* mrb, struct RClass* rmodule)
{
    std::string typeName = typeid(cocos2d::TransitionProgressRadialCCW).name();
    g_rubyType[typeName] = "CC::TransitionProgressRadialCCW";
    g_rubyDataType[typeName] = &ruby_cocos2dx_Ref_type;

    struct RClass* p_rmodule = mrb->object_class;
    p_rmodule = mrb_module_get_under(mrb, p_rmodule, "CC");
    struct RClass* p_rclass = mrb_class_get_under(mrb, p_rmodule, "TransitionProgress");
    struct RClass *rclass = mrb_define_class_under(mrb, rmodule, "TransitionProgressRadialCCW", p_rclass);
    MRB_SET_INSTANCE_TT(rclass, MRB_TT_DATA);

    mrb_define_class_method(mrb, rclass, "create", ruby_cocos2dx_TransitionProgressRadialCCW_create_static, ARGS_REQ(2));
}
mrb_value ruby_cocos2dx_TransitionProgressRadialCW_create_static(mrb_state* mrb, mrb_value self)
{
    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 2) {
            std::map<std::string, mrb_value> callbacks;
            double arg0;
            ok = rubyval_to_number(mrb, argv[0], (double*)&arg0, "CC::TransitionProgressRadialCW.create");
            if (!ok) { break; }

            cocos2d::Scene* arg1;
            ok = rubyval_to_object<cocos2d::Scene>(mrb, argv[1], "CC::Scene", &arg1);
            if (!ok) { break; }

            cocos2d::TransitionProgressRadialCW* retval = cocos2d::TransitionProgressRadialCW::create(arg0, arg1);
            mrb_value ret;
            RClass* rclass = mrb_class_ptr(self);
            ret = object_to_rubyval<cocos2d::TransitionProgressRadialCW>(mrb, "CC::TransitionProgressRadialCW", (cocos2d::TransitionProgressRadialCW*)retval, rclass);
            if (callbacks.size() > 0) {
                mrb_value hash = mrb_iv_get(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"));
                if (!mrb_hash_p(hash)) {
                    hash = mrb_hash_new(mrb);
                }
                for (auto elm : callbacks) {
                    mrb_hash_set(mrb, hash, mrb_str_new_cstr(mrb, elm.first.c_str()), elm.second);
                    mrb_iv_set(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"), hash);
                }
            }
            g_rubyValue.push_back(ret);
            mrb_funcall(mrb, ret, "initialize", 0);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined static method : cocos2d::TransitionProgressRadialCW#create");

    return mrb_nil_value();
}

void ruby_register_cocos2dx_TransitionProgressRadialCW(mrb_state* mrb, struct RClass* rmodule)
{
    std::string typeName = typeid(cocos2d::TransitionProgressRadialCW).name();
    g_rubyType[typeName] = "CC::TransitionProgressRadialCW";
    g_rubyDataType[typeName] = &ruby_cocos2dx_Ref_type;

    struct RClass* p_rmodule = mrb->object_class;
    p_rmodule = mrb_module_get_under(mrb, p_rmodule, "CC");
    struct RClass* p_rclass = mrb_class_get_under(mrb, p_rmodule, "TransitionProgress");
    struct RClass *rclass = mrb_define_class_under(mrb, rmodule, "TransitionProgressRadialCW", p_rclass);
    MRB_SET_INSTANCE_TT(rclass, MRB_TT_DATA);

    mrb_define_class_method(mrb, rclass, "create", ruby_cocos2dx_TransitionProgressRadialCW_create_static, ARGS_REQ(2));
}
mrb_value ruby_cocos2dx_TransitionProgressHorizontal_create_static(mrb_state* mrb, mrb_value self)
{
    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 2) {
            std::map<std::string, mrb_value> callbacks;
            double arg0;
            ok = rubyval_to_number(mrb, argv[0], (double*)&arg0, "CC::TransitionProgressHorizontal.create");
            if (!ok) { break; }

            cocos2d::Scene* arg1;
            ok = rubyval_to_object<cocos2d::Scene>(mrb, argv[1], "CC::Scene", &arg1);
            if (!ok) { break; }

            cocos2d::TransitionProgressHorizontal* retval = cocos2d::TransitionProgressHorizontal::create(arg0, arg1);
            mrb_value ret;
            RClass* rclass = mrb_class_ptr(self);
            ret = object_to_rubyval<cocos2d::TransitionProgressHorizontal>(mrb, "CC::TransitionProgressHorizontal", (cocos2d::TransitionProgressHorizontal*)retval, rclass);
            if (callbacks.size() > 0) {
                mrb_value hash = mrb_iv_get(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"));
                if (!mrb_hash_p(hash)) {
                    hash = mrb_hash_new(mrb);
                }
                for (auto elm : callbacks) {
                    mrb_hash_set(mrb, hash, mrb_str_new_cstr(mrb, elm.first.c_str()), elm.second);
                    mrb_iv_set(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"), hash);
                }
            }
            g_rubyValue.push_back(ret);
            mrb_funcall(mrb, ret, "initialize", 0);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined static method : cocos2d::TransitionProgressHorizontal#create");

    return mrb_nil_value();
}

void ruby_register_cocos2dx_TransitionProgressHorizontal(mrb_state* mrb, struct RClass* rmodule)
{
    std::string typeName = typeid(cocos2d::TransitionProgressHorizontal).name();
    g_rubyType[typeName] = "CC::TransitionProgressHorizontal";
    g_rubyDataType[typeName] = &ruby_cocos2dx_Ref_type;

    struct RClass* p_rmodule = mrb->object_class;
    p_rmodule = mrb_module_get_under(mrb, p_rmodule, "CC");
    struct RClass* p_rclass = mrb_class_get_under(mrb, p_rmodule, "TransitionProgress");
    struct RClass *rclass = mrb_define_class_under(mrb, rmodule, "TransitionProgressHorizontal", p_rclass);
    MRB_SET_INSTANCE_TT(rclass, MRB_TT_DATA);

    mrb_define_class_method(mrb, rclass, "create", ruby_cocos2dx_TransitionProgressHorizontal_create_static, ARGS_REQ(2));
}
mrb_value ruby_cocos2dx_TransitionProgressVertical_create_static(mrb_state* mrb, mrb_value self)
{
    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 2) {
            std::map<std::string, mrb_value> callbacks;
            double arg0;
            ok = rubyval_to_number(mrb, argv[0], (double*)&arg0, "CC::TransitionProgressVertical.create");
            if (!ok) { break; }

            cocos2d::Scene* arg1;
            ok = rubyval_to_object<cocos2d::Scene>(mrb, argv[1], "CC::Scene", &arg1);
            if (!ok) { break; }

            cocos2d::TransitionProgressVertical* retval = cocos2d::TransitionProgressVertical::create(arg0, arg1);
            mrb_value ret;
            RClass* rclass = mrb_class_ptr(self);
            ret = object_to_rubyval<cocos2d::TransitionProgressVertical>(mrb, "CC::TransitionProgressVertical", (cocos2d::TransitionProgressVertical*)retval, rclass);
            if (callbacks.size() > 0) {
                mrb_value hash = mrb_iv_get(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"));
                if (!mrb_hash_p(hash)) {
                    hash = mrb_hash_new(mrb);
                }
                for (auto elm : callbacks) {
                    mrb_hash_set(mrb, hash, mrb_str_new_cstr(mrb, elm.first.c_str()), elm.second);
                    mrb_iv_set(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"), hash);
                }
            }
            g_rubyValue.push_back(ret);
            mrb_funcall(mrb, ret, "initialize", 0);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined static method : cocos2d::TransitionProgressVertical#create");

    return mrb_nil_value();
}

void ruby_register_cocos2dx_TransitionProgressVertical(mrb_state* mrb, struct RClass* rmodule)
{
    std::string typeName = typeid(cocos2d::TransitionProgressVertical).name();
    g_rubyType[typeName] = "CC::TransitionProgressVertical";
    g_rubyDataType[typeName] = &ruby_cocos2dx_Ref_type;

    struct RClass* p_rmodule = mrb->object_class;
    p_rmodule = mrb_module_get_under(mrb, p_rmodule, "CC");
    struct RClass* p_rclass = mrb_class_get_under(mrb, p_rmodule, "TransitionProgress");
    struct RClass *rclass = mrb_define_class_under(mrb, rmodule, "TransitionProgressVertical", p_rclass);
    MRB_SET_INSTANCE_TT(rclass, MRB_TT_DATA);

    mrb_define_class_method(mrb, rclass, "create", ruby_cocos2dx_TransitionProgressVertical_create_static, ARGS_REQ(2));
}
mrb_value ruby_cocos2dx_TransitionProgressInOut_create_static(mrb_state* mrb, mrb_value self)
{
    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 2) {
            std::map<std::string, mrb_value> callbacks;
            double arg0;
            ok = rubyval_to_number(mrb, argv[0], (double*)&arg0, "CC::TransitionProgressInOut.create");
            if (!ok) { break; }

            cocos2d::Scene* arg1;
            ok = rubyval_to_object<cocos2d::Scene>(mrb, argv[1], "CC::Scene", &arg1);
            if (!ok) { break; }

            cocos2d::TransitionProgressInOut* retval = cocos2d::TransitionProgressInOut::create(arg0, arg1);
            mrb_value ret;
            RClass* rclass = mrb_class_ptr(self);
            ret = object_to_rubyval<cocos2d::TransitionProgressInOut>(mrb, "CC::TransitionProgressInOut", (cocos2d::TransitionProgressInOut*)retval, rclass);
            if (callbacks.size() > 0) {
                mrb_value hash = mrb_iv_get(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"));
                if (!mrb_hash_p(hash)) {
                    hash = mrb_hash_new(mrb);
                }
                for (auto elm : callbacks) {
                    mrb_hash_set(mrb, hash, mrb_str_new_cstr(mrb, elm.first.c_str()), elm.second);
                    mrb_iv_set(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"), hash);
                }
            }
            g_rubyValue.push_back(ret);
            mrb_funcall(mrb, ret, "initialize", 0);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined static method : cocos2d::TransitionProgressInOut#create");

    return mrb_nil_value();
}

void ruby_register_cocos2dx_TransitionProgressInOut(mrb_state* mrb, struct RClass* rmodule)
{
    std::string typeName = typeid(cocos2d::TransitionProgressInOut).name();
    g_rubyType[typeName] = "CC::TransitionProgressInOut";
    g_rubyDataType[typeName] = &ruby_cocos2dx_Ref_type;

    struct RClass* p_rmodule = mrb->object_class;
    p_rmodule = mrb_module_get_under(mrb, p_rmodule, "CC");
    struct RClass* p_rclass = mrb_class_get_under(mrb, p_rmodule, "TransitionProgress");
    struct RClass *rclass = mrb_define_class_under(mrb, rmodule, "TransitionProgressInOut", p_rclass);
    MRB_SET_INSTANCE_TT(rclass, MRB_TT_DATA);

    mrb_define_class_method(mrb, rclass, "create", ruby_cocos2dx_TransitionProgressInOut_create_static, ARGS_REQ(2));
}
mrb_value ruby_cocos2dx_TransitionProgressOutIn_create_static(mrb_state* mrb, mrb_value self)
{
    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 2) {
            std::map<std::string, mrb_value> callbacks;
            double arg0;
            ok = rubyval_to_number(mrb, argv[0], (double*)&arg0, "CC::TransitionProgressOutIn.create");
            if (!ok) { break; }

            cocos2d::Scene* arg1;
            ok = rubyval_to_object<cocos2d::Scene>(mrb, argv[1], "CC::Scene", &arg1);
            if (!ok) { break; }

            cocos2d::TransitionProgressOutIn* retval = cocos2d::TransitionProgressOutIn::create(arg0, arg1);
            mrb_value ret;
            RClass* rclass = mrb_class_ptr(self);
            ret = object_to_rubyval<cocos2d::TransitionProgressOutIn>(mrb, "CC::TransitionProgressOutIn", (cocos2d::TransitionProgressOutIn*)retval, rclass);
            if (callbacks.size() > 0) {
                mrb_value hash = mrb_iv_get(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"));
                if (!mrb_hash_p(hash)) {
                    hash = mrb_hash_new(mrb);
                }
                for (auto elm : callbacks) {
                    mrb_hash_set(mrb, hash, mrb_str_new_cstr(mrb, elm.first.c_str()), elm.second);
                    mrb_iv_set(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"), hash);
                }
            }
            g_rubyValue.push_back(ret);
            mrb_funcall(mrb, ret, "initialize", 0);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined static method : cocos2d::TransitionProgressOutIn#create");

    return mrb_nil_value();
}

void ruby_register_cocos2dx_TransitionProgressOutIn(mrb_state* mrb, struct RClass* rmodule)
{
    std::string typeName = typeid(cocos2d::TransitionProgressOutIn).name();
    g_rubyType[typeName] = "CC::TransitionProgressOutIn";
    g_rubyDataType[typeName] = &ruby_cocos2dx_Ref_type;

    struct RClass* p_rmodule = mrb->object_class;
    p_rmodule = mrb_module_get_under(mrb, p_rmodule, "CC");
    struct RClass* p_rclass = mrb_class_get_under(mrb, p_rmodule, "TransitionProgress");
    struct RClass *rclass = mrb_define_class_under(mrb, rmodule, "TransitionProgressOutIn", p_rclass);
    MRB_SET_INSTANCE_TT(rclass, MRB_TT_DATA);

    mrb_define_class_method(mrb, rclass, "create", ruby_cocos2dx_TransitionProgressOutIn_create_static, ARGS_REQ(2));
}
mrb_value ruby_cocos2dx_MenuItem_setEnabled(mrb_state* mrb, mrb_value self)
{
    cocos2d::MenuItem* cobj = static_cast<cocos2d::MenuItem*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            bool arg0;
            ok = rubyval_to_boolean(mrb, argv[0], &arg0, "CC::MenuItem.setEnabled");
            if (!ok) { break; }
            cobj->setEnabled(arg0);
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::MenuItem#setEnabled");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_MenuItem_activate(mrb_state* mrb, mrb_value self)
{
    cocos2d::MenuItem* cobj = static_cast<cocos2d::MenuItem*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            cobj->activate();
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::MenuItem#activate");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_MenuItem_isEnabled(mrb_state* mrb, mrb_value self)
{
    cocos2d::MenuItem* cobj = static_cast<cocos2d::MenuItem*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            bool retval = cobj->isEnabled();
            mrb_value ret;
            ret = mrb_bool_value((mrb_bool)retval);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::MenuItem#isEnabled");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_MenuItem_selected(mrb_state* mrb, mrb_value self)
{
    cocos2d::MenuItem* cobj = static_cast<cocos2d::MenuItem*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            cobj->selected();
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::MenuItem#selected");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_MenuItem_isSelected(mrb_state* mrb, mrb_value self)
{
    cocos2d::MenuItem* cobj = static_cast<cocos2d::MenuItem*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            bool retval = cobj->isSelected();
            mrb_value ret;
            ret = mrb_bool_value((mrb_bool)retval);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::MenuItem#isSelected");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_MenuItem_setCallback(mrb_state* mrb, mrb_value self)
{
    cocos2d::MenuItem* cobj = static_cast<cocos2d::MenuItem*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            std::function<void (cocos2d::Ref *)> arg0;
            do {
			    // Lambda binding for ruby.
			    unsigned long idx = -1;
			    arg0 = [mrb, self, idx](cocos2d::Ref* larg0) -> void {
			        mrb_value ruby_arg0;
			        ruby_arg0 = object_to_rubyval<cocos2d::Ref>(mrb, "CC::Ref", (cocos2d::Ref*)larg0, nullptr);
			        mrb_value hash = mrb_iv_get(mrb, self, mrb_intern_cstr(mrb, "__callback_hash"));
			        mrb_value func = mrb_hash_get(mrb, hash, mrb_str_new_cstr(mrb, "setCallback->arg0"));
			        mrb_value mrb_ret = mrb_funcall(mrb, func, "call", 1, ruby_arg0);
			        if (mrb_exception_p(mrb_ret)) {
			            mrb_exc_raise(mrb, mrb_ret);
			        }
			    };
			    mrb_value hash = mrb_iv_get(mrb, self, mrb_intern_cstr(mrb, "__callback_hash"));
			    if (!mrb_hash_p(hash)) {
			        hash = mrb_hash_new(mrb);
			    }
			    mrb_hash_set(mrb, hash, mrb_str_new_cstr(mrb, "setCallback->arg0"), argv[0]);
			    mrb_iv_set(mrb, self, mrb_intern_cstr(mrb, "__callback_hash"), hash);
			    break;
			} while(0);
            cobj->setCallback(arg0);
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::MenuItem#setCallback");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_MenuItem_unselected(mrb_state* mrb, mrb_value self)
{
    cocos2d::MenuItem* cobj = static_cast<cocos2d::MenuItem*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            cobj->unselected();
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::MenuItem#unselected");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_MenuItem_rect(mrb_state* mrb, mrb_value self)
{
    cocos2d::MenuItem* cobj = static_cast<cocos2d::MenuItem*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            cocos2d::Rect retval = cobj->rect();
            cocos2d::Rect* retval_ptr = new cocos2d::Rect(retval);
            mrb_value ret;
            ret = object_to_rubyval<cocos2d::Rect>(mrb, "CC::Rect", (cocos2d::Rect*)retval_ptr, nullptr);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::MenuItem#rect");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_MenuItem_create_static(mrb_state* mrb, mrb_value self)
{
    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            std::map<std::string, mrb_value> callbacks;
            std::function<void (cocos2d::Ref *)> arg0;
            do {
			    // Lambda binding for ruby.
			    unsigned long idx = g_rubyValue.size();
			    arg0 = [mrb, self, idx](cocos2d::Ref* larg0) -> void {
			        mrb_value ruby_arg0;
			        ruby_arg0 = object_to_rubyval<cocos2d::Ref>(mrb, "CC::Ref", (cocos2d::Ref*)larg0, nullptr);
			        mrb_value _self = g_rubyValue[idx];
			        mrb_value hash = mrb_iv_get(mrb, _self, mrb_intern_cstr(mrb, "__callback_hash"));
			        mrb_value func = mrb_hash_get(mrb, hash, mrb_str_new_cstr(mrb, "create->arg0"));
			        mrb_value mrb_ret = mrb_funcall(mrb, func, "call", 1, ruby_arg0);
			        if (mrb_exception_p(mrb_ret)) {
			            mrb_exc_raise(mrb, mrb_ret);
			        }
			    };
			    callbacks["create->arg0"] = argv[0];
			    break;
			} while(0);
            if (!ok) { break; }

            cocos2d::MenuItem* retval = cocos2d::MenuItem::create(arg0);
            mrb_value ret;
            RClass* rclass = mrb_class_ptr(self);
            ret = object_to_rubyval<cocos2d::MenuItem>(mrb, "CC::MenuItem", (cocos2d::MenuItem*)retval, rclass);
            if (callbacks.size() > 0) {
                mrb_value hash = mrb_iv_get(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"));
                if (!mrb_hash_p(hash)) {
                    hash = mrb_hash_new(mrb);
                }
                for (auto elm : callbacks) {
                    mrb_hash_set(mrb, hash, mrb_str_new_cstr(mrb, elm.first.c_str()), elm.second);
                    mrb_iv_set(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"), hash);
                }
            }
            g_rubyValue.push_back(ret);
            mrb_funcall(mrb, ret, "initialize", 0);
            return ret;
        }
    } while (0);
    do {
        if (argc == 0) {
            std::map<std::string, mrb_value> callbacks;
            cocos2d::MenuItem* retval = cocos2d::MenuItem::create();
            mrb_value ret;
            RClass* rclass = mrb_class_ptr(self);
            ret = object_to_rubyval<cocos2d::MenuItem>(mrb, "CC::MenuItem", (cocos2d::MenuItem*)retval, rclass);
            if (callbacks.size() > 0) {
                mrb_value hash = mrb_iv_get(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"));
                if (!mrb_hash_p(hash)) {
                    hash = mrb_hash_new(mrb);
                }
                for (auto elm : callbacks) {
                    mrb_hash_set(mrb, hash, mrb_str_new_cstr(mrb, elm.first.c_str()), elm.second);
                    mrb_iv_set(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"), hash);
                }
            }
            g_rubyValue.push_back(ret);
            mrb_funcall(mrb, ret, "initialize", 0);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined static method : cocos2d::MenuItem#create");

    return mrb_nil_value();
}

void ruby_register_cocos2dx_MenuItem(mrb_state* mrb, struct RClass* rmodule)
{
    std::string typeName = typeid(cocos2d::MenuItem).name();
    g_rubyType[typeName] = "CC::MenuItem";
    g_rubyDataType[typeName] = &ruby_cocos2dx_Ref_type;

    struct RClass* p_rmodule = mrb->object_class;
    p_rmodule = mrb_module_get_under(mrb, p_rmodule, "CC");
    struct RClass* p_rclass = mrb_class_get_under(mrb, p_rmodule, "Node");
    struct RClass *rclass = mrb_define_class_under(mrb, rmodule, "MenuItem", p_rclass);
    MRB_SET_INSTANCE_TT(rclass, MRB_TT_DATA);

    mrb_define_method(mrb, rclass, "set_enabled", ruby_cocos2dx_MenuItem_setEnabled, ARGS_REQ(1));
    mrb_define_method(mrb, rclass, "activate", ruby_cocos2dx_MenuItem_activate, ARGS_NONE());
    mrb_define_method(mrb, rclass, "enabled?", ruby_cocos2dx_MenuItem_isEnabled, ARGS_NONE());
    mrb_define_method(mrb, rclass, "selected", ruby_cocos2dx_MenuItem_selected, ARGS_NONE());
    mrb_define_method(mrb, rclass, "selected?", ruby_cocos2dx_MenuItem_isSelected, ARGS_NONE());
    mrb_define_method(mrb, rclass, "set_callback", ruby_cocos2dx_MenuItem_setCallback, ARGS_REQ(1));
    mrb_define_method(mrb, rclass, "unselected", ruby_cocos2dx_MenuItem_unselected, ARGS_NONE());
    mrb_define_method(mrb, rclass, "rect", ruby_cocos2dx_MenuItem_rect, ARGS_NONE());
    mrb_define_class_method(mrb, rclass, "create", ruby_cocos2dx_MenuItem_create_static, ARGS_REQ(0)|ARGS_OPT(1));
}
mrb_value ruby_cocos2dx_MenuItemLabel_getDisabledColor(mrb_state* mrb, mrb_value self)
{
    cocos2d::MenuItemLabel* cobj = static_cast<cocos2d::MenuItemLabel*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            cocos2d::Color3B retval = cobj->getDisabledColor();
            cocos2d::Color3B* retval_ptr = new cocos2d::Color3B(retval);
            mrb_value ret;
            ret = object_to_rubyval<cocos2d::Color3B>(mrb, "CC::Color3B", (cocos2d::Color3B*)retval_ptr, nullptr);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::MenuItemLabel#getDisabledColor");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_MenuItemLabel_setString(mrb_state* mrb, mrb_value self)
{
    cocos2d::MenuItemLabel* cobj = static_cast<cocos2d::MenuItemLabel*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            std::string arg0;
            ok = rubyval_to_std_string(mrb, argv[0], &arg0, "CC::MenuItemLabel.setString");
            if (!ok) { break; }
            cobj->setString(arg0);
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::MenuItemLabel#setString");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_MenuItemLabel_setLabel(mrb_state* mrb, mrb_value self)
{
    cocos2d::MenuItemLabel* cobj = static_cast<cocos2d::MenuItemLabel*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            cocos2d::Node* arg0;
            ok = rubyval_to_object<cocos2d::Node>(mrb, argv[0], "CC::Node", &arg0);
            if (!ok) { break; }
            cobj->setLabel(arg0);
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::MenuItemLabel#setLabel");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_MenuItemLabel_setDisabledColor(mrb_state* mrb, mrb_value self)
{
    cocos2d::MenuItemLabel* cobj = static_cast<cocos2d::MenuItemLabel*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            cocos2d::Color3B* arg0;
            ok = rubyval_to_object<cocos2d::Color3B>(mrb, argv[0], "CC::Color3B", &arg0);
            if (!ok) { break; }
            cobj->setDisabledColor(*arg0);
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::MenuItemLabel#setDisabledColor");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_MenuItemLabel_getLabel(mrb_state* mrb, mrb_value self)
{
    cocos2d::MenuItemLabel* cobj = static_cast<cocos2d::MenuItemLabel*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            cocos2d::Node* retval = cobj->getLabel();
            mrb_value ret;
            ret = object_to_rubyval<cocos2d::Node>(mrb, "CC::Node", (cocos2d::Node*)retval, nullptr);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::MenuItemLabel#getLabel");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_MenuItemLabel_create_static(mrb_state* mrb, mrb_value self)
{
    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            std::map<std::string, mrb_value> callbacks;
            cocos2d::Node* arg0;
            ok = rubyval_to_object<cocos2d::Node>(mrb, argv[0], "CC::Node", &arg0);
            if (!ok) { break; }

            cocos2d::MenuItemLabel* retval = cocos2d::MenuItemLabel::create(arg0);
            mrb_value ret;
            RClass* rclass = mrb_class_ptr(self);
            ret = object_to_rubyval<cocos2d::MenuItemLabel>(mrb, "CC::MenuItemLabel", (cocos2d::MenuItemLabel*)retval, rclass);
            if (callbacks.size() > 0) {
                mrb_value hash = mrb_iv_get(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"));
                if (!mrb_hash_p(hash)) {
                    hash = mrb_hash_new(mrb);
                }
                for (auto elm : callbacks) {
                    mrb_hash_set(mrb, hash, mrb_str_new_cstr(mrb, elm.first.c_str()), elm.second);
                    mrb_iv_set(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"), hash);
                }
            }
            g_rubyValue.push_back(ret);
            mrb_funcall(mrb, ret, "initialize", 0);
            return ret;
        }
    } while (0);
    do {
        if (argc == 2) {
            std::map<std::string, mrb_value> callbacks;
            cocos2d::Node* arg0;
            ok = rubyval_to_object<cocos2d::Node>(mrb, argv[0], "CC::Node", &arg0);
            if (!ok) { break; }

            std::function<void (cocos2d::Ref *)> arg1;
            do {
			    // Lambda binding for ruby.
			    unsigned long idx = g_rubyValue.size();
			    arg1 = [mrb, self, idx](cocos2d::Ref* larg0) -> void {
			        mrb_value ruby_arg0;
			        ruby_arg0 = object_to_rubyval<cocos2d::Ref>(mrb, "CC::Ref", (cocos2d::Ref*)larg0, nullptr);
			        mrb_value _self = g_rubyValue[idx];
			        mrb_value hash = mrb_iv_get(mrb, _self, mrb_intern_cstr(mrb, "__callback_hash"));
			        mrb_value func = mrb_hash_get(mrb, hash, mrb_str_new_cstr(mrb, "create->arg1"));
			        mrb_value mrb_ret = mrb_funcall(mrb, func, "call", 1, ruby_arg0);
			        if (mrb_exception_p(mrb_ret)) {
			            mrb_exc_raise(mrb, mrb_ret);
			        }
			    };
			    callbacks["create->arg1"] = argv[1];
			    break;
			} while(0);
            if (!ok) { break; }

            cocos2d::MenuItemLabel* retval = cocos2d::MenuItemLabel::create(arg0, arg1);
            mrb_value ret;
            RClass* rclass = mrb_class_ptr(self);
            ret = object_to_rubyval<cocos2d::MenuItemLabel>(mrb, "CC::MenuItemLabel", (cocos2d::MenuItemLabel*)retval, rclass);
            if (callbacks.size() > 0) {
                mrb_value hash = mrb_iv_get(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"));
                if (!mrb_hash_p(hash)) {
                    hash = mrb_hash_new(mrb);
                }
                for (auto elm : callbacks) {
                    mrb_hash_set(mrb, hash, mrb_str_new_cstr(mrb, elm.first.c_str()), elm.second);
                    mrb_iv_set(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"), hash);
                }
            }
            g_rubyValue.push_back(ret);
            mrb_funcall(mrb, ret, "initialize", 0);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined static method : cocos2d::MenuItemLabel#create");

    return mrb_nil_value();
}

void ruby_register_cocos2dx_MenuItemLabel(mrb_state* mrb, struct RClass* rmodule)
{
    std::string typeName = typeid(cocos2d::MenuItemLabel).name();
    g_rubyType[typeName] = "CC::MenuItemLabel";
    g_rubyDataType[typeName] = &ruby_cocos2dx_Ref_type;

    struct RClass* p_rmodule = mrb->object_class;
    p_rmodule = mrb_module_get_under(mrb, p_rmodule, "CC");
    struct RClass* p_rclass = mrb_class_get_under(mrb, p_rmodule, "MenuItem");
    struct RClass *rclass = mrb_define_class_under(mrb, rmodule, "MenuItemLabel", p_rclass);
    MRB_SET_INSTANCE_TT(rclass, MRB_TT_DATA);

    mrb_define_method(mrb, rclass, "get_disabled_color", ruby_cocos2dx_MenuItemLabel_getDisabledColor, ARGS_NONE());
    mrb_define_method(mrb, rclass, "set_string", ruby_cocos2dx_MenuItemLabel_setString, ARGS_REQ(1));
    mrb_define_method(mrb, rclass, "set_label", ruby_cocos2dx_MenuItemLabel_setLabel, ARGS_REQ(1));
    mrb_define_method(mrb, rclass, "set_disabled_color", ruby_cocos2dx_MenuItemLabel_setDisabledColor, ARGS_REQ(1));
    mrb_define_method(mrb, rclass, "get_label", ruby_cocos2dx_MenuItemLabel_getLabel, ARGS_NONE());
    mrb_define_class_method(mrb, rclass, "create", ruby_cocos2dx_MenuItemLabel_create_static, ARGS_REQ(1)|ARGS_OPT(1));
}
mrb_value ruby_cocos2dx_MenuItemAtlasFont_create_static(mrb_state* mrb, mrb_value self)
{
    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 6) {
            std::map<std::string, mrb_value> callbacks;
            std::string arg0;
            ok = rubyval_to_std_string(mrb, argv[0], &arg0, "CC::MenuItemAtlasFont.create");
            if (!ok) { break; }

            std::string arg1;
            ok = rubyval_to_std_string(mrb, argv[1], &arg1, "CC::MenuItemAtlasFont.create");
            if (!ok) { break; }

            int arg2;
            ok = rubyval_to_int32(mrb, argv[2], (int*)&arg2, "CC::MenuItemAtlasFont.create");
            if (!ok) { break; }

            int arg3;
            ok = rubyval_to_int32(mrb, argv[3], (int*)&arg3, "CC::MenuItemAtlasFont.create");
            if (!ok) { break; }

            int32_t arg4;
            ok = rubyval_to_int32(mrb, argv[4], &arg4, "CC::MenuItemAtlasFont.create");
            if (!ok) { break; }

            std::function<void (cocos2d::Ref *)> arg5;
            do {
			    // Lambda binding for ruby.
			    unsigned long idx = g_rubyValue.size();
			    arg5 = [mrb, self, idx](cocos2d::Ref* larg0) -> void {
			        mrb_value ruby_arg0;
			        ruby_arg0 = object_to_rubyval<cocos2d::Ref>(mrb, "CC::Ref", (cocos2d::Ref*)larg0, nullptr);
			        mrb_value _self = g_rubyValue[idx];
			        mrb_value hash = mrb_iv_get(mrb, _self, mrb_intern_cstr(mrb, "__callback_hash"));
			        mrb_value func = mrb_hash_get(mrb, hash, mrb_str_new_cstr(mrb, "create->arg5"));
			        mrb_value mrb_ret = mrb_funcall(mrb, func, "call", 1, ruby_arg0);
			        if (mrb_exception_p(mrb_ret)) {
			            mrb_exc_raise(mrb, mrb_ret);
			        }
			    };
			    callbacks["create->arg5"] = argv[5];
			    break;
			} while(0);
            if (!ok) { break; }

            cocos2d::MenuItemAtlasFont* retval = cocos2d::MenuItemAtlasFont::create(arg0, arg1, arg2, arg3, arg4, arg5);
            mrb_value ret;
            RClass* rclass = mrb_class_ptr(self);
            ret = object_to_rubyval<cocos2d::MenuItemAtlasFont>(mrb, "CC::MenuItemAtlasFont", (cocos2d::MenuItemAtlasFont*)retval, rclass);
            if (callbacks.size() > 0) {
                mrb_value hash = mrb_iv_get(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"));
                if (!mrb_hash_p(hash)) {
                    hash = mrb_hash_new(mrb);
                }
                for (auto elm : callbacks) {
                    mrb_hash_set(mrb, hash, mrb_str_new_cstr(mrb, elm.first.c_str()), elm.second);
                    mrb_iv_set(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"), hash);
                }
            }
            g_rubyValue.push_back(ret);
            mrb_funcall(mrb, ret, "initialize", 0);
            return ret;
        }
    } while (0);
    do {
        if (argc == 5) {
            std::map<std::string, mrb_value> callbacks;
            std::string arg0;
            ok = rubyval_to_std_string(mrb, argv[0], &arg0, "CC::MenuItemAtlasFont.create");
            if (!ok) { break; }

            std::string arg1;
            ok = rubyval_to_std_string(mrb, argv[1], &arg1, "CC::MenuItemAtlasFont.create");
            if (!ok) { break; }

            int arg2;
            ok = rubyval_to_int32(mrb, argv[2], (int*)&arg2, "CC::MenuItemAtlasFont.create");
            if (!ok) { break; }

            int arg3;
            ok = rubyval_to_int32(mrb, argv[3], (int*)&arg3, "CC::MenuItemAtlasFont.create");
            if (!ok) { break; }

            int32_t arg4;
            ok = rubyval_to_int32(mrb, argv[4], &arg4, "CC::MenuItemAtlasFont.create");
            if (!ok) { break; }

            cocos2d::MenuItemAtlasFont* retval = cocos2d::MenuItemAtlasFont::create(arg0, arg1, arg2, arg3, arg4);
            mrb_value ret;
            RClass* rclass = mrb_class_ptr(self);
            ret = object_to_rubyval<cocos2d::MenuItemAtlasFont>(mrb, "CC::MenuItemAtlasFont", (cocos2d::MenuItemAtlasFont*)retval, rclass);
            if (callbacks.size() > 0) {
                mrb_value hash = mrb_iv_get(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"));
                if (!mrb_hash_p(hash)) {
                    hash = mrb_hash_new(mrb);
                }
                for (auto elm : callbacks) {
                    mrb_hash_set(mrb, hash, mrb_str_new_cstr(mrb, elm.first.c_str()), elm.second);
                    mrb_iv_set(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"), hash);
                }
            }
            g_rubyValue.push_back(ret);
            mrb_funcall(mrb, ret, "initialize", 0);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined static method : cocos2d::MenuItemAtlasFont#create");

    return mrb_nil_value();
}

void ruby_register_cocos2dx_MenuItemAtlasFont(mrb_state* mrb, struct RClass* rmodule)
{
    std::string typeName = typeid(cocos2d::MenuItemAtlasFont).name();
    g_rubyType[typeName] = "CC::MenuItemAtlasFont";
    g_rubyDataType[typeName] = &ruby_cocos2dx_Ref_type;

    struct RClass* p_rmodule = mrb->object_class;
    p_rmodule = mrb_module_get_under(mrb, p_rmodule, "CC");
    struct RClass* p_rclass = mrb_class_get_under(mrb, p_rmodule, "MenuItemLabel");
    struct RClass *rclass = mrb_define_class_under(mrb, rmodule, "MenuItemAtlasFont", p_rclass);
    MRB_SET_INSTANCE_TT(rclass, MRB_TT_DATA);

    mrb_define_class_method(mrb, rclass, "create", ruby_cocos2dx_MenuItemAtlasFont_create_static, ARGS_REQ(5)|ARGS_OPT(1));
}
mrb_value ruby_cocos2dx_MenuItemFont_getFontSizeObj(mrb_state* mrb, mrb_value self)
{
    cocos2d::MenuItemFont* cobj = static_cast<cocos2d::MenuItemFont*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            int retval = cobj->getFontSizeObj();
            mrb_value ret;
            ret = mrb_fixnum_value((mrb_int)retval);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::MenuItemFont#getFontSizeObj");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_MenuItemFont_getFontNameObj(mrb_state* mrb, mrb_value self)
{
    cocos2d::MenuItemFont* cobj = static_cast<cocos2d::MenuItemFont*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            std::string retval = cobj->getFontNameObj();
            mrb_value ret;
            ret = mrb_str_new_cstr(mrb, retval.c_str());
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::MenuItemFont#getFontNameObj");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_MenuItemFont_setFontSizeObj(mrb_state* mrb, mrb_value self)
{
    cocos2d::MenuItemFont* cobj = static_cast<cocos2d::MenuItemFont*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            int arg0;
            ok = rubyval_to_int32(mrb, argv[0], (int*)&arg0, "CC::MenuItemFont.setFontSizeObj");
            if (!ok) { break; }
            cobj->setFontSizeObj(arg0);
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::MenuItemFont#setFontSizeObj");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_MenuItemFont_setFontNameObj(mrb_state* mrb, mrb_value self)
{
    cocos2d::MenuItemFont* cobj = static_cast<cocos2d::MenuItemFont*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            std::string arg0;
            ok = rubyval_to_std_string(mrb, argv[0], &arg0, "CC::MenuItemFont.setFontNameObj");
            if (!ok) { break; }
            cobj->setFontNameObj(arg0);
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::MenuItemFont#setFontNameObj");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_MenuItemFont_setFontName_static(mrb_state* mrb, mrb_value self)
{
    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            std::string arg0;
            ok = rubyval_to_std_string(mrb, argv[0], &arg0, "CC::MenuItemFont.setFontName");
            if (!ok) { break; }

            cocos2d::MenuItemFont::setFontName(arg0);
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined static method : cocos2d::MenuItemFont#setFontName");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_MenuItemFont_create_static(mrb_state* mrb, mrb_value self)
{
    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 2) {
            std::map<std::string, mrb_value> callbacks;
            std::string arg0;
            ok = rubyval_to_std_string(mrb, argv[0], &arg0, "CC::MenuItemFont.create");
            if (!ok) { break; }

            std::function<void (cocos2d::Ref *)> arg1;
            do {
			    // Lambda binding for ruby.
			    unsigned long idx = g_rubyValue.size();
			    arg1 = [mrb, self, idx](cocos2d::Ref* larg0) -> void {
			        mrb_value ruby_arg0;
			        ruby_arg0 = object_to_rubyval<cocos2d::Ref>(mrb, "CC::Ref", (cocos2d::Ref*)larg0, nullptr);
			        mrb_value _self = g_rubyValue[idx];
			        mrb_value hash = mrb_iv_get(mrb, _self, mrb_intern_cstr(mrb, "__callback_hash"));
			        mrb_value func = mrb_hash_get(mrb, hash, mrb_str_new_cstr(mrb, "create->arg1"));
			        mrb_value mrb_ret = mrb_funcall(mrb, func, "call", 1, ruby_arg0);
			        if (mrb_exception_p(mrb_ret)) {
			            mrb_exc_raise(mrb, mrb_ret);
			        }
			    };
			    callbacks["create->arg1"] = argv[1];
			    break;
			} while(0);
            if (!ok) { break; }

            cocos2d::MenuItemFont* retval = cocos2d::MenuItemFont::create(arg0, arg1);
            mrb_value ret;
            RClass* rclass = mrb_class_ptr(self);
            ret = object_to_rubyval<cocos2d::MenuItemFont>(mrb, "CC::MenuItemFont", (cocos2d::MenuItemFont*)retval, rclass);
            if (callbacks.size() > 0) {
                mrb_value hash = mrb_iv_get(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"));
                if (!mrb_hash_p(hash)) {
                    hash = mrb_hash_new(mrb);
                }
                for (auto elm : callbacks) {
                    mrb_hash_set(mrb, hash, mrb_str_new_cstr(mrb, elm.first.c_str()), elm.second);
                    mrb_iv_set(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"), hash);
                }
            }
            g_rubyValue.push_back(ret);
            mrb_funcall(mrb, ret, "initialize", 0);
            return ret;
        }
    } while (0);
    do {
        if (argc == 0) {
            std::map<std::string, mrb_value> callbacks;
            cocos2d::MenuItemFont* retval = cocos2d::MenuItemFont::create();
            mrb_value ret;
            RClass* rclass = mrb_class_ptr(self);
            ret = object_to_rubyval<cocos2d::MenuItemFont>(mrb, "CC::MenuItemFont", (cocos2d::MenuItemFont*)retval, rclass);
            if (callbacks.size() > 0) {
                mrb_value hash = mrb_iv_get(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"));
                if (!mrb_hash_p(hash)) {
                    hash = mrb_hash_new(mrb);
                }
                for (auto elm : callbacks) {
                    mrb_hash_set(mrb, hash, mrb_str_new_cstr(mrb, elm.first.c_str()), elm.second);
                    mrb_iv_set(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"), hash);
                }
            }
            g_rubyValue.push_back(ret);
            mrb_funcall(mrb, ret, "initialize", 0);
            return ret;
        }
    } while (0);
    do {
        if (argc == 1) {
            std::map<std::string, mrb_value> callbacks;
            std::string arg0;
            ok = rubyval_to_std_string(mrb, argv[0], &arg0, "CC::MenuItemFont.create");
            if (!ok) { break; }

            cocos2d::MenuItemFont* retval = cocos2d::MenuItemFont::create(arg0);
            mrb_value ret;
            RClass* rclass = mrb_class_ptr(self);
            ret = object_to_rubyval<cocos2d::MenuItemFont>(mrb, "CC::MenuItemFont", (cocos2d::MenuItemFont*)retval, rclass);
            if (callbacks.size() > 0) {
                mrb_value hash = mrb_iv_get(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"));
                if (!mrb_hash_p(hash)) {
                    hash = mrb_hash_new(mrb);
                }
                for (auto elm : callbacks) {
                    mrb_hash_set(mrb, hash, mrb_str_new_cstr(mrb, elm.first.c_str()), elm.second);
                    mrb_iv_set(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"), hash);
                }
            }
            g_rubyValue.push_back(ret);
            mrb_funcall(mrb, ret, "initialize", 0);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined static method : cocos2d::MenuItemFont#create");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_MenuItemFont_getFontSize_static(mrb_state* mrb, mrb_value self)
{
    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            int retval = cocos2d::MenuItemFont::getFontSize();
            mrb_value ret;
            ret = mrb_fixnum_value((mrb_int)retval);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined static method : cocos2d::MenuItemFont#getFontSize");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_MenuItemFont_getFontName_static(mrb_state* mrb, mrb_value self)
{
    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            std::string retval = cocos2d::MenuItemFont::getFontName();
            mrb_value ret;
            ret = mrb_str_new_cstr(mrb, retval.c_str());
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined static method : cocos2d::MenuItemFont#getFontName");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_MenuItemFont_setFontSize_static(mrb_state* mrb, mrb_value self)
{
    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            int arg0;
            ok = rubyval_to_int32(mrb, argv[0], (int*)&arg0, "CC::MenuItemFont.setFontSize");
            if (!ok) { break; }

            cocos2d::MenuItemFont::setFontSize(arg0);
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined static method : cocos2d::MenuItemFont#setFontSize");

    return mrb_nil_value();
}

void ruby_register_cocos2dx_MenuItemFont(mrb_state* mrb, struct RClass* rmodule)
{
    std::string typeName = typeid(cocos2d::MenuItemFont).name();
    g_rubyType[typeName] = "CC::MenuItemFont";
    g_rubyDataType[typeName] = &ruby_cocos2dx_Ref_type;

    struct RClass* p_rmodule = mrb->object_class;
    p_rmodule = mrb_module_get_under(mrb, p_rmodule, "CC");
    struct RClass* p_rclass = mrb_class_get_under(mrb, p_rmodule, "MenuItemLabel");
    struct RClass *rclass = mrb_define_class_under(mrb, rmodule, "MenuItemFont", p_rclass);
    MRB_SET_INSTANCE_TT(rclass, MRB_TT_DATA);

    mrb_define_method(mrb, rclass, "get_font_size_obj", ruby_cocos2dx_MenuItemFont_getFontSizeObj, ARGS_NONE());
    mrb_define_method(mrb, rclass, "get_font_name_obj", ruby_cocos2dx_MenuItemFont_getFontNameObj, ARGS_NONE());
    mrb_define_method(mrb, rclass, "set_font_size_obj", ruby_cocos2dx_MenuItemFont_setFontSizeObj, ARGS_REQ(1));
    mrb_define_method(mrb, rclass, "set_font_name_obj", ruby_cocos2dx_MenuItemFont_setFontNameObj, ARGS_REQ(1));
    mrb_define_class_method(mrb, rclass, "set_font_name", ruby_cocos2dx_MenuItemFont_setFontName_static, ARGS_REQ(1));
    mrb_define_class_method(mrb, rclass, "create", ruby_cocos2dx_MenuItemFont_create_static, ARGS_REQ(0)|ARGS_OPT(2));
    mrb_define_class_method(mrb, rclass, "get_font_size", ruby_cocos2dx_MenuItemFont_getFontSize_static, ARGS_NONE());
    mrb_define_class_method(mrb, rclass, "get_font_name", ruby_cocos2dx_MenuItemFont_getFontName_static, ARGS_NONE());
    mrb_define_class_method(mrb, rclass, "set_font_size", ruby_cocos2dx_MenuItemFont_setFontSize_static, ARGS_REQ(1));
}
mrb_value ruby_cocos2dx_MenuItemSprite_setEnabled(mrb_state* mrb, mrb_value self)
{
    cocos2d::MenuItemSprite* cobj = static_cast<cocos2d::MenuItemSprite*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            bool arg0;
            ok = rubyval_to_boolean(mrb, argv[0], &arg0, "CC::MenuItemSprite.setEnabled");
            if (!ok) { break; }
            cobj->setEnabled(arg0);
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::MenuItemSprite#setEnabled");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_MenuItemSprite_selected(mrb_state* mrb, mrb_value self)
{
    cocos2d::MenuItemSprite* cobj = static_cast<cocos2d::MenuItemSprite*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            cobj->selected();
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::MenuItemSprite#selected");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_MenuItemSprite_setNormalImage(mrb_state* mrb, mrb_value self)
{
    cocos2d::MenuItemSprite* cobj = static_cast<cocos2d::MenuItemSprite*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            cocos2d::Node* arg0;
            ok = rubyval_to_object<cocos2d::Node>(mrb, argv[0], "CC::Node", &arg0);
            if (!ok) { break; }
            cobj->setNormalImage(arg0);
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::MenuItemSprite#setNormalImage");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_MenuItemSprite_setDisabledImage(mrb_state* mrb, mrb_value self)
{
    cocos2d::MenuItemSprite* cobj = static_cast<cocos2d::MenuItemSprite*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            cocos2d::Node* arg0;
            ok = rubyval_to_object<cocos2d::Node>(mrb, argv[0], "CC::Node", &arg0);
            if (!ok) { break; }
            cobj->setDisabledImage(arg0);
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::MenuItemSprite#setDisabledImage");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_MenuItemSprite_setSelectedImage(mrb_state* mrb, mrb_value self)
{
    cocos2d::MenuItemSprite* cobj = static_cast<cocos2d::MenuItemSprite*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            cocos2d::Node* arg0;
            ok = rubyval_to_object<cocos2d::Node>(mrb, argv[0], "CC::Node", &arg0);
            if (!ok) { break; }
            cobj->setSelectedImage(arg0);
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::MenuItemSprite#setSelectedImage");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_MenuItemSprite_getDisabledImage(mrb_state* mrb, mrb_value self)
{
    cocos2d::MenuItemSprite* cobj = static_cast<cocos2d::MenuItemSprite*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            cocos2d::Node* retval = cobj->getDisabledImage();
            mrb_value ret;
            ret = object_to_rubyval<cocos2d::Node>(mrb, "CC::Node", (cocos2d::Node*)retval, nullptr);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::MenuItemSprite#getDisabledImage");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_MenuItemSprite_getSelectedImage(mrb_state* mrb, mrb_value self)
{
    cocos2d::MenuItemSprite* cobj = static_cast<cocos2d::MenuItemSprite*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            cocos2d::Node* retval = cobj->getSelectedImage();
            mrb_value ret;
            ret = object_to_rubyval<cocos2d::Node>(mrb, "CC::Node", (cocos2d::Node*)retval, nullptr);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::MenuItemSprite#getSelectedImage");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_MenuItemSprite_getNormalImage(mrb_state* mrb, mrb_value self)
{
    cocos2d::MenuItemSprite* cobj = static_cast<cocos2d::MenuItemSprite*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            cocos2d::Node* retval = cobj->getNormalImage();
            mrb_value ret;
            ret = object_to_rubyval<cocos2d::Node>(mrb, "CC::Node", (cocos2d::Node*)retval, nullptr);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::MenuItemSprite#getNormalImage");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_MenuItemSprite_unselected(mrb_state* mrb, mrb_value self)
{
    cocos2d::MenuItemSprite* cobj = static_cast<cocos2d::MenuItemSprite*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            cobj->unselected();
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::MenuItemSprite#unselected");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_MenuItemSprite_create_static(mrb_state* mrb, mrb_value self)
{
    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 3) {
            std::map<std::string, mrb_value> callbacks;
            cocos2d::Node* arg0;
            ok = rubyval_to_object<cocos2d::Node>(mrb, argv[0], "CC::Node", &arg0);
            if (!ok) { break; }

            cocos2d::Node* arg1;
            ok = rubyval_to_object<cocos2d::Node>(mrb, argv[1], "CC::Node", &arg1);
            if (!ok) { break; }

            std::function<void (cocos2d::Ref *)> arg2;
            do {
			    // Lambda binding for ruby.
			    unsigned long idx = g_rubyValue.size();
			    arg2 = [mrb, self, idx](cocos2d::Ref* larg0) -> void {
			        mrb_value ruby_arg0;
			        ruby_arg0 = object_to_rubyval<cocos2d::Ref>(mrb, "CC::Ref", (cocos2d::Ref*)larg0, nullptr);
			        mrb_value _self = g_rubyValue[idx];
			        mrb_value hash = mrb_iv_get(mrb, _self, mrb_intern_cstr(mrb, "__callback_hash"));
			        mrb_value func = mrb_hash_get(mrb, hash, mrb_str_new_cstr(mrb, "create->arg2"));
			        mrb_value mrb_ret = mrb_funcall(mrb, func, "call", 1, ruby_arg0);
			        if (mrb_exception_p(mrb_ret)) {
			            mrb_exc_raise(mrb, mrb_ret);
			        }
			    };
			    callbacks["create->arg2"] = argv[2];
			    break;
			} while(0);
            if (!ok) { break; }

            cocos2d::MenuItemSprite* retval = cocos2d::MenuItemSprite::create(arg0, arg1, arg2);
            mrb_value ret;
            RClass* rclass = mrb_class_ptr(self);
            ret = object_to_rubyval<cocos2d::MenuItemSprite>(mrb, "CC::MenuItemSprite", (cocos2d::MenuItemSprite*)retval, rclass);
            if (callbacks.size() > 0) {
                mrb_value hash = mrb_iv_get(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"));
                if (!mrb_hash_p(hash)) {
                    hash = mrb_hash_new(mrb);
                }
                for (auto elm : callbacks) {
                    mrb_hash_set(mrb, hash, mrb_str_new_cstr(mrb, elm.first.c_str()), elm.second);
                    mrb_iv_set(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"), hash);
                }
            }
            g_rubyValue.push_back(ret);
            mrb_funcall(mrb, ret, "initialize", 0);
            return ret;
        }
    } while (0);
    do {
        if (argc == 2) {
            std::map<std::string, mrb_value> callbacks;
            cocos2d::Node* arg0;
            ok = rubyval_to_object<cocos2d::Node>(mrb, argv[0], "CC::Node", &arg0);
            if (!ok) { break; }

            cocos2d::Node* arg1;
            ok = rubyval_to_object<cocos2d::Node>(mrb, argv[1], "CC::Node", &arg1);
            if (!ok) { break; }

            cocos2d::MenuItemSprite* retval = cocos2d::MenuItemSprite::create(arg0, arg1);
            mrb_value ret;
            RClass* rclass = mrb_class_ptr(self);
            ret = object_to_rubyval<cocos2d::MenuItemSprite>(mrb, "CC::MenuItemSprite", (cocos2d::MenuItemSprite*)retval, rclass);
            if (callbacks.size() > 0) {
                mrb_value hash = mrb_iv_get(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"));
                if (!mrb_hash_p(hash)) {
                    hash = mrb_hash_new(mrb);
                }
                for (auto elm : callbacks) {
                    mrb_hash_set(mrb, hash, mrb_str_new_cstr(mrb, elm.first.c_str()), elm.second);
                    mrb_iv_set(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"), hash);
                }
            }
            g_rubyValue.push_back(ret);
            mrb_funcall(mrb, ret, "initialize", 0);
            return ret;
        }
    } while (0);
    do {
        if (argc == 3) {
            std::map<std::string, mrb_value> callbacks;
            cocos2d::Node* arg0;
            ok = rubyval_to_object<cocos2d::Node>(mrb, argv[0], "CC::Node", &arg0);
            if (!ok) { break; }

            cocos2d::Node* arg1;
            ok = rubyval_to_object<cocos2d::Node>(mrb, argv[1], "CC::Node", &arg1);
            if (!ok) { break; }

            cocos2d::Node* arg2;
            ok = rubyval_to_object<cocos2d::Node>(mrb, argv[2], "CC::Node", &arg2);
            if (!ok) { break; }

            cocos2d::MenuItemSprite* retval = cocos2d::MenuItemSprite::create(arg0, arg1, arg2);
            mrb_value ret;
            RClass* rclass = mrb_class_ptr(self);
            ret = object_to_rubyval<cocos2d::MenuItemSprite>(mrb, "CC::MenuItemSprite", (cocos2d::MenuItemSprite*)retval, rclass);
            if (callbacks.size() > 0) {
                mrb_value hash = mrb_iv_get(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"));
                if (!mrb_hash_p(hash)) {
                    hash = mrb_hash_new(mrb);
                }
                for (auto elm : callbacks) {
                    mrb_hash_set(mrb, hash, mrb_str_new_cstr(mrb, elm.first.c_str()), elm.second);
                    mrb_iv_set(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"), hash);
                }
            }
            g_rubyValue.push_back(ret);
            mrb_funcall(mrb, ret, "initialize", 0);
            return ret;
        }
    } while (0);
    do {
        if (argc == 4) {
            std::map<std::string, mrb_value> callbacks;
            cocos2d::Node* arg0;
            ok = rubyval_to_object<cocos2d::Node>(mrb, argv[0], "CC::Node", &arg0);
            if (!ok) { break; }

            cocos2d::Node* arg1;
            ok = rubyval_to_object<cocos2d::Node>(mrb, argv[1], "CC::Node", &arg1);
            if (!ok) { break; }

            cocos2d::Node* arg2;
            ok = rubyval_to_object<cocos2d::Node>(mrb, argv[2], "CC::Node", &arg2);
            if (!ok) { break; }

            std::function<void (cocos2d::Ref *)> arg3;
            do {
			    // Lambda binding for ruby.
			    unsigned long idx = g_rubyValue.size();
			    arg3 = [mrb, self, idx](cocos2d::Ref* larg0) -> void {
			        mrb_value ruby_arg0;
			        ruby_arg0 = object_to_rubyval<cocos2d::Ref>(mrb, "CC::Ref", (cocos2d::Ref*)larg0, nullptr);
			        mrb_value _self = g_rubyValue[idx];
			        mrb_value hash = mrb_iv_get(mrb, _self, mrb_intern_cstr(mrb, "__callback_hash"));
			        mrb_value func = mrb_hash_get(mrb, hash, mrb_str_new_cstr(mrb, "create->arg3"));
			        mrb_value mrb_ret = mrb_funcall(mrb, func, "call", 1, ruby_arg0);
			        if (mrb_exception_p(mrb_ret)) {
			            mrb_exc_raise(mrb, mrb_ret);
			        }
			    };
			    callbacks["create->arg3"] = argv[3];
			    break;
			} while(0);
            if (!ok) { break; }

            cocos2d::MenuItemSprite* retval = cocos2d::MenuItemSprite::create(arg0, arg1, arg2, arg3);
            mrb_value ret;
            RClass* rclass = mrb_class_ptr(self);
            ret = object_to_rubyval<cocos2d::MenuItemSprite>(mrb, "CC::MenuItemSprite", (cocos2d::MenuItemSprite*)retval, rclass);
            if (callbacks.size() > 0) {
                mrb_value hash = mrb_iv_get(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"));
                if (!mrb_hash_p(hash)) {
                    hash = mrb_hash_new(mrb);
                }
                for (auto elm : callbacks) {
                    mrb_hash_set(mrb, hash, mrb_str_new_cstr(mrb, elm.first.c_str()), elm.second);
                    mrb_iv_set(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"), hash);
                }
            }
            g_rubyValue.push_back(ret);
            mrb_funcall(mrb, ret, "initialize", 0);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined static method : cocos2d::MenuItemSprite#create");

    return mrb_nil_value();
}

void ruby_register_cocos2dx_MenuItemSprite(mrb_state* mrb, struct RClass* rmodule)
{
    std::string typeName = typeid(cocos2d::MenuItemSprite).name();
    g_rubyType[typeName] = "CC::MenuItemSprite";
    g_rubyDataType[typeName] = &ruby_cocos2dx_Ref_type;

    struct RClass* p_rmodule = mrb->object_class;
    p_rmodule = mrb_module_get_under(mrb, p_rmodule, "CC");
    struct RClass* p_rclass = mrb_class_get_under(mrb, p_rmodule, "MenuItem");
    struct RClass *rclass = mrb_define_class_under(mrb, rmodule, "MenuItemSprite", p_rclass);
    MRB_SET_INSTANCE_TT(rclass, MRB_TT_DATA);

    mrb_define_method(mrb, rclass, "set_enabled", ruby_cocos2dx_MenuItemSprite_setEnabled, ARGS_REQ(1));
    mrb_define_method(mrb, rclass, "selected", ruby_cocos2dx_MenuItemSprite_selected, ARGS_NONE());
    mrb_define_method(mrb, rclass, "set_normal_image", ruby_cocos2dx_MenuItemSprite_setNormalImage, ARGS_REQ(1));
    mrb_define_method(mrb, rclass, "set_disabled_image", ruby_cocos2dx_MenuItemSprite_setDisabledImage, ARGS_REQ(1));
    mrb_define_method(mrb, rclass, "set_selected_image", ruby_cocos2dx_MenuItemSprite_setSelectedImage, ARGS_REQ(1));
    mrb_define_method(mrb, rclass, "get_disabled_image", ruby_cocos2dx_MenuItemSprite_getDisabledImage, ARGS_NONE());
    mrb_define_method(mrb, rclass, "get_selected_image", ruby_cocos2dx_MenuItemSprite_getSelectedImage, ARGS_NONE());
    mrb_define_method(mrb, rclass, "get_normal_image", ruby_cocos2dx_MenuItemSprite_getNormalImage, ARGS_NONE());
    mrb_define_method(mrb, rclass, "unselected", ruby_cocos2dx_MenuItemSprite_unselected, ARGS_NONE());
    mrb_define_class_method(mrb, rclass, "create", ruby_cocos2dx_MenuItemSprite_create_static, ARGS_REQ(2)|ARGS_OPT(2));
}
mrb_value ruby_cocos2dx_MenuItemImage_setDisabledSpriteFrame(mrb_state* mrb, mrb_value self)
{
    cocos2d::MenuItemImage* cobj = static_cast<cocos2d::MenuItemImage*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            cocos2d::SpriteFrame* arg0;
            ok = rubyval_to_object<cocos2d::SpriteFrame>(mrb, argv[0], "CC::SpriteFrame", &arg0);
            if (!ok) { break; }
            cobj->setDisabledSpriteFrame(arg0);
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::MenuItemImage#setDisabledSpriteFrame");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_MenuItemImage_setSelectedSpriteFrame(mrb_state* mrb, mrb_value self)
{
    cocos2d::MenuItemImage* cobj = static_cast<cocos2d::MenuItemImage*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            cocos2d::SpriteFrame* arg0;
            ok = rubyval_to_object<cocos2d::SpriteFrame>(mrb, argv[0], "CC::SpriteFrame", &arg0);
            if (!ok) { break; }
            cobj->setSelectedSpriteFrame(arg0);
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::MenuItemImage#setSelectedSpriteFrame");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_MenuItemImage_setNormalSpriteFrame(mrb_state* mrb, mrb_value self)
{
    cocos2d::MenuItemImage* cobj = static_cast<cocos2d::MenuItemImage*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            cocos2d::SpriteFrame* arg0;
            ok = rubyval_to_object<cocos2d::SpriteFrame>(mrb, argv[0], "CC::SpriteFrame", &arg0);
            if (!ok) { break; }
            cobj->setNormalSpriteFrame(arg0);
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::MenuItemImage#setNormalSpriteFrame");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_MenuItemImage_create_static(mrb_state* mrb, mrb_value self)
{
    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 2) {
            std::map<std::string, mrb_value> callbacks;
            std::string arg0;
            ok = rubyval_to_std_string(mrb, argv[0], &arg0, "CC::MenuItemImage.create");
            if (!ok) { break; }

            std::string arg1;
            ok = rubyval_to_std_string(mrb, argv[1], &arg1, "CC::MenuItemImage.create");
            if (!ok) { break; }

            cocos2d::MenuItemImage* retval = cocos2d::MenuItemImage::create(arg0, arg1);
            mrb_value ret;
            RClass* rclass = mrb_class_ptr(self);
            ret = object_to_rubyval<cocos2d::MenuItemImage>(mrb, "CC::MenuItemImage", (cocos2d::MenuItemImage*)retval, rclass);
            if (callbacks.size() > 0) {
                mrb_value hash = mrb_iv_get(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"));
                if (!mrb_hash_p(hash)) {
                    hash = mrb_hash_new(mrb);
                }
                for (auto elm : callbacks) {
                    mrb_hash_set(mrb, hash, mrb_str_new_cstr(mrb, elm.first.c_str()), elm.second);
                    mrb_iv_set(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"), hash);
                }
            }
            g_rubyValue.push_back(ret);
            mrb_funcall(mrb, ret, "initialize", 0);
            return ret;
        }
    } while (0);
    do {
        if (argc == 0) {
            std::map<std::string, mrb_value> callbacks;
            cocos2d::MenuItemImage* retval = cocos2d::MenuItemImage::create();
            mrb_value ret;
            RClass* rclass = mrb_class_ptr(self);
            ret = object_to_rubyval<cocos2d::MenuItemImage>(mrb, "CC::MenuItemImage", (cocos2d::MenuItemImage*)retval, rclass);
            if (callbacks.size() > 0) {
                mrb_value hash = mrb_iv_get(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"));
                if (!mrb_hash_p(hash)) {
                    hash = mrb_hash_new(mrb);
                }
                for (auto elm : callbacks) {
                    mrb_hash_set(mrb, hash, mrb_str_new_cstr(mrb, elm.first.c_str()), elm.second);
                    mrb_iv_set(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"), hash);
                }
            }
            g_rubyValue.push_back(ret);
            mrb_funcall(mrb, ret, "initialize", 0);
            return ret;
        }
    } while (0);
    do {
        if (argc == 3) {
            std::map<std::string, mrb_value> callbacks;
            std::string arg0;
            ok = rubyval_to_std_string(mrb, argv[0], &arg0, "CC::MenuItemImage.create");
            if (!ok) { break; }

            std::string arg1;
            ok = rubyval_to_std_string(mrb, argv[1], &arg1, "CC::MenuItemImage.create");
            if (!ok) { break; }

            std::string arg2;
            ok = rubyval_to_std_string(mrb, argv[2], &arg2, "CC::MenuItemImage.create");
            if (!ok) { break; }

            cocos2d::MenuItemImage* retval = cocos2d::MenuItemImage::create(arg0, arg1, arg2);
            mrb_value ret;
            RClass* rclass = mrb_class_ptr(self);
            ret = object_to_rubyval<cocos2d::MenuItemImage>(mrb, "CC::MenuItemImage", (cocos2d::MenuItemImage*)retval, rclass);
            if (callbacks.size() > 0) {
                mrb_value hash = mrb_iv_get(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"));
                if (!mrb_hash_p(hash)) {
                    hash = mrb_hash_new(mrb);
                }
                for (auto elm : callbacks) {
                    mrb_hash_set(mrb, hash, mrb_str_new_cstr(mrb, elm.first.c_str()), elm.second);
                    mrb_iv_set(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"), hash);
                }
            }
            g_rubyValue.push_back(ret);
            mrb_funcall(mrb, ret, "initialize", 0);
            return ret;
        }
    } while (0);
    do {
        if (argc == 3) {
            std::map<std::string, mrb_value> callbacks;
            std::string arg0;
            ok = rubyval_to_std_string(mrb, argv[0], &arg0, "CC::MenuItemImage.create");
            if (!ok) { break; }

            std::string arg1;
            ok = rubyval_to_std_string(mrb, argv[1], &arg1, "CC::MenuItemImage.create");
            if (!ok) { break; }

            std::function<void (cocos2d::Ref *)> arg2;
            do {
			    // Lambda binding for ruby.
			    unsigned long idx = g_rubyValue.size();
			    arg2 = [mrb, self, idx](cocos2d::Ref* larg0) -> void {
			        mrb_value ruby_arg0;
			        ruby_arg0 = object_to_rubyval<cocos2d::Ref>(mrb, "CC::Ref", (cocos2d::Ref*)larg0, nullptr);
			        mrb_value _self = g_rubyValue[idx];
			        mrb_value hash = mrb_iv_get(mrb, _self, mrb_intern_cstr(mrb, "__callback_hash"));
			        mrb_value func = mrb_hash_get(mrb, hash, mrb_str_new_cstr(mrb, "create->arg2"));
			        mrb_value mrb_ret = mrb_funcall(mrb, func, "call", 1, ruby_arg0);
			        if (mrb_exception_p(mrb_ret)) {
			            mrb_exc_raise(mrb, mrb_ret);
			        }
			    };
			    callbacks["create->arg2"] = argv[2];
			    break;
			} while(0);
            if (!ok) { break; }

            cocos2d::MenuItemImage* retval = cocos2d::MenuItemImage::create(arg0, arg1, arg2);
            mrb_value ret;
            RClass* rclass = mrb_class_ptr(self);
            ret = object_to_rubyval<cocos2d::MenuItemImage>(mrb, "CC::MenuItemImage", (cocos2d::MenuItemImage*)retval, rclass);
            if (callbacks.size() > 0) {
                mrb_value hash = mrb_iv_get(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"));
                if (!mrb_hash_p(hash)) {
                    hash = mrb_hash_new(mrb);
                }
                for (auto elm : callbacks) {
                    mrb_hash_set(mrb, hash, mrb_str_new_cstr(mrb, elm.first.c_str()), elm.second);
                    mrb_iv_set(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"), hash);
                }
            }
            g_rubyValue.push_back(ret);
            mrb_funcall(mrb, ret, "initialize", 0);
            return ret;
        }
    } while (0);
    do {
        if (argc == 4) {
            std::map<std::string, mrb_value> callbacks;
            std::string arg0;
            ok = rubyval_to_std_string(mrb, argv[0], &arg0, "CC::MenuItemImage.create");
            if (!ok) { break; }

            std::string arg1;
            ok = rubyval_to_std_string(mrb, argv[1], &arg1, "CC::MenuItemImage.create");
            if (!ok) { break; }

            std::string arg2;
            ok = rubyval_to_std_string(mrb, argv[2], &arg2, "CC::MenuItemImage.create");
            if (!ok) { break; }

            std::function<void (cocos2d::Ref *)> arg3;
            do {
			    // Lambda binding for ruby.
			    unsigned long idx = g_rubyValue.size();
			    arg3 = [mrb, self, idx](cocos2d::Ref* larg0) -> void {
			        mrb_value ruby_arg0;
			        ruby_arg0 = object_to_rubyval<cocos2d::Ref>(mrb, "CC::Ref", (cocos2d::Ref*)larg0, nullptr);
			        mrb_value _self = g_rubyValue[idx];
			        mrb_value hash = mrb_iv_get(mrb, _self, mrb_intern_cstr(mrb, "__callback_hash"));
			        mrb_value func = mrb_hash_get(mrb, hash, mrb_str_new_cstr(mrb, "create->arg3"));
			        mrb_value mrb_ret = mrb_funcall(mrb, func, "call", 1, ruby_arg0);
			        if (mrb_exception_p(mrb_ret)) {
			            mrb_exc_raise(mrb, mrb_ret);
			        }
			    };
			    callbacks["create->arg3"] = argv[3];
			    break;
			} while(0);
            if (!ok) { break; }

            cocos2d::MenuItemImage* retval = cocos2d::MenuItemImage::create(arg0, arg1, arg2, arg3);
            mrb_value ret;
            RClass* rclass = mrb_class_ptr(self);
            ret = object_to_rubyval<cocos2d::MenuItemImage>(mrb, "CC::MenuItemImage", (cocos2d::MenuItemImage*)retval, rclass);
            if (callbacks.size() > 0) {
                mrb_value hash = mrb_iv_get(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"));
                if (!mrb_hash_p(hash)) {
                    hash = mrb_hash_new(mrb);
                }
                for (auto elm : callbacks) {
                    mrb_hash_set(mrb, hash, mrb_str_new_cstr(mrb, elm.first.c_str()), elm.second);
                    mrb_iv_set(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"), hash);
                }
            }
            g_rubyValue.push_back(ret);
            mrb_funcall(mrb, ret, "initialize", 0);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined static method : cocos2d::MenuItemImage#create");

    return mrb_nil_value();
}

void ruby_register_cocos2dx_MenuItemImage(mrb_state* mrb, struct RClass* rmodule)
{
    std::string typeName = typeid(cocos2d::MenuItemImage).name();
    g_rubyType[typeName] = "CC::MenuItemImage";
    g_rubyDataType[typeName] = &ruby_cocos2dx_Ref_type;

    struct RClass* p_rmodule = mrb->object_class;
    p_rmodule = mrb_module_get_under(mrb, p_rmodule, "CC");
    struct RClass* p_rclass = mrb_class_get_under(mrb, p_rmodule, "MenuItemSprite");
    struct RClass *rclass = mrb_define_class_under(mrb, rmodule, "MenuItemImage", p_rclass);
    MRB_SET_INSTANCE_TT(rclass, MRB_TT_DATA);

    mrb_define_method(mrb, rclass, "set_disabled_sprite_frame", ruby_cocos2dx_MenuItemImage_setDisabledSpriteFrame, ARGS_REQ(1));
    mrb_define_method(mrb, rclass, "set_selected_sprite_frame", ruby_cocos2dx_MenuItemImage_setSelectedSpriteFrame, ARGS_REQ(1));
    mrb_define_method(mrb, rclass, "set_normal_sprite_frame", ruby_cocos2dx_MenuItemImage_setNormalSpriteFrame, ARGS_REQ(1));
    mrb_define_class_method(mrb, rclass, "create", ruby_cocos2dx_MenuItemImage_create_static, ARGS_REQ(0)|ARGS_OPT(4));
}
mrb_value ruby_cocos2dx_MenuItemToggle_setSubItems(mrb_state* mrb, mrb_value self)
{
    cocos2d::MenuItemToggle* cobj = static_cast<cocos2d::MenuItemToggle*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            cocos2d::Vector<cocos2d::MenuItem *> arg0;
            ok = rubyval_to_ccvector(mrb, argv[0], &arg0, "CC::MenuItemToggle.setSubItems");
            if (!ok) { break; }
            cobj->setSubItems(arg0);
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::MenuItemToggle#setSubItems");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_MenuItemToggle_getSubItems(mrb_state* mrb, mrb_value self)
{
    cocos2d::MenuItemToggle* cobj = static_cast<cocos2d::MenuItemToggle*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            cocos2d::Vector<cocos2d::MenuItem *> retval = cobj->getSubItems();
            mrb_value ret;
            ret = ccvector_to_rubyval(mrb, retval);
            return ret;
        }
    } while (0);
    do {
        if (argc == 0) {
            cocos2d::Vector<cocos2d::MenuItem *> retval = cobj->getSubItems();
            mrb_value ret;
            ret = ccvector_to_rubyval(mrb, retval);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::MenuItemToggle#getSubItems");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_MenuItemToggle_getSelectedIndex(mrb_state* mrb, mrb_value self)
{
    cocos2d::MenuItemToggle* cobj = static_cast<cocos2d::MenuItemToggle*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            unsigned int retval = cobj->getSelectedIndex();
            mrb_value ret;
            ret = mrb_fixnum_value((mrb_int)retval);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::MenuItemToggle#getSelectedIndex");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_MenuItemToggle_addSubItem(mrb_state* mrb, mrb_value self)
{
    cocos2d::MenuItemToggle* cobj = static_cast<cocos2d::MenuItemToggle*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            cocos2d::MenuItem* arg0;
            ok = rubyval_to_object<cocos2d::MenuItem>(mrb, argv[0], "CC::MenuItem", &arg0);
            if (!ok) { break; }
            cobj->addSubItem(arg0);
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::MenuItemToggle#addSubItem");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_MenuItemToggle_getSelectedItem(mrb_state* mrb, mrb_value self)
{
    cocos2d::MenuItemToggle* cobj = static_cast<cocos2d::MenuItemToggle*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            cocos2d::MenuItem* retval = cobj->getSelectedItem();
            mrb_value ret;
            ret = object_to_rubyval<cocos2d::MenuItem>(mrb, "CC::MenuItem", (cocos2d::MenuItem*)retval, nullptr);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::MenuItemToggle#getSelectedItem");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_MenuItemToggle_setSelectedIndex(mrb_state* mrb, mrb_value self)
{
    cocos2d::MenuItemToggle* cobj = static_cast<cocos2d::MenuItemToggle*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            unsigned int arg0;
            ok = rubyval_to_uint32(mrb, argv[0], &arg0, "CC::MenuItemToggle.setSelectedIndex");
            if (!ok) { break; }
            cobj->setSelectedIndex(arg0);
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::MenuItemToggle#setSelectedIndex");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_MenuItemToggle_create_static(mrb_state* mrb, mrb_value self)
{
    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            std::map<std::string, mrb_value> callbacks;
            cocos2d::MenuItem* arg0;
            ok = rubyval_to_object<cocos2d::MenuItem>(mrb, argv[0], "CC::MenuItem", &arg0);
            if (!ok) { break; }

            cocos2d::MenuItemToggle* retval = cocos2d::MenuItemToggle::create(arg0);
            mrb_value ret;
            RClass* rclass = mrb_class_ptr(self);
            ret = object_to_rubyval<cocos2d::MenuItemToggle>(mrb, "CC::MenuItemToggle", (cocos2d::MenuItemToggle*)retval, rclass);
            if (callbacks.size() > 0) {
                mrb_value hash = mrb_iv_get(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"));
                if (!mrb_hash_p(hash)) {
                    hash = mrb_hash_new(mrb);
                }
                for (auto elm : callbacks) {
                    mrb_hash_set(mrb, hash, mrb_str_new_cstr(mrb, elm.first.c_str()), elm.second);
                    mrb_iv_set(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"), hash);
                }
            }
            g_rubyValue.push_back(ret);
            mrb_funcall(mrb, ret, "initialize", 0);
            return ret;
        }
    } while (0);
    do {
        if (argc == 0) {
            std::map<std::string, mrb_value> callbacks;
            cocos2d::MenuItemToggle* retval = cocos2d::MenuItemToggle::create();
            mrb_value ret;
            RClass* rclass = mrb_class_ptr(self);
            ret = object_to_rubyval<cocos2d::MenuItemToggle>(mrb, "CC::MenuItemToggle", (cocos2d::MenuItemToggle*)retval, rclass);
            if (callbacks.size() > 0) {
                mrb_value hash = mrb_iv_get(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"));
                if (!mrb_hash_p(hash)) {
                    hash = mrb_hash_new(mrb);
                }
                for (auto elm : callbacks) {
                    mrb_hash_set(mrb, hash, mrb_str_new_cstr(mrb, elm.first.c_str()), elm.second);
                    mrb_iv_set(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"), hash);
                }
            }
            g_rubyValue.push_back(ret);
            mrb_funcall(mrb, ret, "initialize", 0);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined static method : cocos2d::MenuItemToggle#create");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_MenuItemToggle_createWithCallback_static(mrb_state* mrb, mrb_value self)
{
    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 2) {
            std::map<std::string, mrb_value> callbacks;
            std::function<void (cocos2d::Ref *)> arg0;
            do {
			    // Lambda binding for ruby.
			    unsigned long idx = g_rubyValue.size();
			    arg0 = [mrb, self, idx](cocos2d::Ref* larg0) -> void {
			        mrb_value ruby_arg0;
			        ruby_arg0 = object_to_rubyval<cocos2d::Ref>(mrb, "CC::Ref", (cocos2d::Ref*)larg0, nullptr);
			        mrb_value _self = g_rubyValue[idx];
			        mrb_value hash = mrb_iv_get(mrb, _self, mrb_intern_cstr(mrb, "__callback_hash"));
			        mrb_value func = mrb_hash_get(mrb, hash, mrb_str_new_cstr(mrb, "createWithCallback->arg0"));
			        mrb_value mrb_ret = mrb_funcall(mrb, func, "call", 1, ruby_arg0);
			        if (mrb_exception_p(mrb_ret)) {
			            mrb_exc_raise(mrb, mrb_ret);
			        }
			    };
			    callbacks["createWithCallback->arg0"] = argv[0];
			    break;
			} while(0);
            if (!ok) { break; }

            cocos2d::MenuItem* arg1;
            ok = rubyval_to_object<cocos2d::MenuItem>(mrb, argv[1], "CC::MenuItem", &arg1);
            if (!ok) { break; }

            cocos2d::MenuItemToggle* retval = cocos2d::MenuItemToggle::createWithCallback(arg0, arg1, NULL);
            mrb_value ret;
            RClass* rclass = mrb_class_ptr(self);
            ret = object_to_rubyval<cocos2d::MenuItemToggle>(mrb, "CC::MenuItemToggle", (cocos2d::MenuItemToggle*)retval, rclass);
            if (callbacks.size() > 0) {
                mrb_value hash = mrb_iv_get(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"));
                if (!mrb_hash_p(hash)) {
                    hash = mrb_hash_new(mrb);
                }
                for (auto elm : callbacks) {
                    mrb_hash_set(mrb, hash, mrb_str_new_cstr(mrb, elm.first.c_str()), elm.second);
                    mrb_iv_set(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"), hash);
                }
            }
            g_rubyValue.push_back(ret);
            mrb_funcall(mrb, ret, "initialize", 0);
            return ret;
        }
        if (argc == 3) {
            std::map<std::string, mrb_value> callbacks;
            std::function<void (cocos2d::Ref *)> arg0;
            do {
			    // Lambda binding for ruby.
			    unsigned long idx = g_rubyValue.size();
			    arg0 = [mrb, self, idx](cocos2d::Ref* larg0) -> void {
			        mrb_value ruby_arg0;
			        ruby_arg0 = object_to_rubyval<cocos2d::Ref>(mrb, "CC::Ref", (cocos2d::Ref*)larg0, nullptr);
			        mrb_value _self = g_rubyValue[idx];
			        mrb_value hash = mrb_iv_get(mrb, _self, mrb_intern_cstr(mrb, "__callback_hash"));
			        mrb_value func = mrb_hash_get(mrb, hash, mrb_str_new_cstr(mrb, "createWithCallback->arg0"));
			        mrb_value mrb_ret = mrb_funcall(mrb, func, "call", 1, ruby_arg0);
			        if (mrb_exception_p(mrb_ret)) {
			            mrb_exc_raise(mrb, mrb_ret);
			        }
			    };
			    callbacks["createWithCallback->arg0"] = argv[0];
			    break;
			} while(0);
            if (!ok) { break; }

            cocos2d::MenuItem* arg1;
            ok = rubyval_to_object<cocos2d::MenuItem>(mrb, argv[1], "CC::MenuItem", &arg1);
            if (!ok) { break; }

            cocos2d::MenuItem* arg2;
            ok = rubyval_to_object<cocos2d::MenuItem>(mrb, argv[2], "CC::MenuItem", &arg2);
            if (!ok) { break; }

            cocos2d::MenuItemToggle* retval = cocos2d::MenuItemToggle::createWithCallback(arg0, arg1, arg2, NULL);
            mrb_value ret;
            RClass* rclass = mrb_class_ptr(self);
            ret = object_to_rubyval<cocos2d::MenuItemToggle>(mrb, "CC::MenuItemToggle", (cocos2d::MenuItemToggle*)retval, rclass);
            if (callbacks.size() > 0) {
                mrb_value hash = mrb_iv_get(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"));
                if (!mrb_hash_p(hash)) {
                    hash = mrb_hash_new(mrb);
                }
                for (auto elm : callbacks) {
                    mrb_hash_set(mrb, hash, mrb_str_new_cstr(mrb, elm.first.c_str()), elm.second);
                    mrb_iv_set(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"), hash);
                }
            }
            g_rubyValue.push_back(ret);
            mrb_funcall(mrb, ret, "initialize", 0);
            return ret;
        }
        if (argc == 4) {
            std::map<std::string, mrb_value> callbacks;
            std::function<void (cocos2d::Ref *)> arg0;
            do {
			    // Lambda binding for ruby.
			    unsigned long idx = g_rubyValue.size();
			    arg0 = [mrb, self, idx](cocos2d::Ref* larg0) -> void {
			        mrb_value ruby_arg0;
			        ruby_arg0 = object_to_rubyval<cocos2d::Ref>(mrb, "CC::Ref", (cocos2d::Ref*)larg0, nullptr);
			        mrb_value _self = g_rubyValue[idx];
			        mrb_value hash = mrb_iv_get(mrb, _self, mrb_intern_cstr(mrb, "__callback_hash"));
			        mrb_value func = mrb_hash_get(mrb, hash, mrb_str_new_cstr(mrb, "createWithCallback->arg0"));
			        mrb_value mrb_ret = mrb_funcall(mrb, func, "call", 1, ruby_arg0);
			        if (mrb_exception_p(mrb_ret)) {
			            mrb_exc_raise(mrb, mrb_ret);
			        }
			    };
			    callbacks["createWithCallback->arg0"] = argv[0];
			    break;
			} while(0);
            if (!ok) { break; }

            cocos2d::MenuItem* arg1;
            ok = rubyval_to_object<cocos2d::MenuItem>(mrb, argv[1], "CC::MenuItem", &arg1);
            if (!ok) { break; }

            cocos2d::MenuItem* arg2;
            ok = rubyval_to_object<cocos2d::MenuItem>(mrb, argv[2], "CC::MenuItem", &arg2);
            if (!ok) { break; }

            cocos2d::MenuItem* arg3;
            ok = rubyval_to_object<cocos2d::MenuItem>(mrb, argv[3], "CC::MenuItem", &arg3);
            if (!ok) { break; }

            cocos2d::MenuItemToggle* retval = cocos2d::MenuItemToggle::createWithCallback(arg0, arg1, arg2, arg3, NULL);
            mrb_value ret;
            RClass* rclass = mrb_class_ptr(self);
            ret = object_to_rubyval<cocos2d::MenuItemToggle>(mrb, "CC::MenuItemToggle", (cocos2d::MenuItemToggle*)retval, rclass);
            if (callbacks.size() > 0) {
                mrb_value hash = mrb_iv_get(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"));
                if (!mrb_hash_p(hash)) {
                    hash = mrb_hash_new(mrb);
                }
                for (auto elm : callbacks) {
                    mrb_hash_set(mrb, hash, mrb_str_new_cstr(mrb, elm.first.c_str()), elm.second);
                    mrb_iv_set(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"), hash);
                }
            }
            g_rubyValue.push_back(ret);
            mrb_funcall(mrb, ret, "initialize", 0);
            return ret;
        }
        if (argc == 5) {
            std::map<std::string, mrb_value> callbacks;
            std::function<void (cocos2d::Ref *)> arg0;
            do {
			    // Lambda binding for ruby.
			    unsigned long idx = g_rubyValue.size();
			    arg0 = [mrb, self, idx](cocos2d::Ref* larg0) -> void {
			        mrb_value ruby_arg0;
			        ruby_arg0 = object_to_rubyval<cocos2d::Ref>(mrb, "CC::Ref", (cocos2d::Ref*)larg0, nullptr);
			        mrb_value _self = g_rubyValue[idx];
			        mrb_value hash = mrb_iv_get(mrb, _self, mrb_intern_cstr(mrb, "__callback_hash"));
			        mrb_value func = mrb_hash_get(mrb, hash, mrb_str_new_cstr(mrb, "createWithCallback->arg0"));
			        mrb_value mrb_ret = mrb_funcall(mrb, func, "call", 1, ruby_arg0);
			        if (mrb_exception_p(mrb_ret)) {
			            mrb_exc_raise(mrb, mrb_ret);
			        }
			    };
			    callbacks["createWithCallback->arg0"] = argv[0];
			    break;
			} while(0);
            if (!ok) { break; }

            cocos2d::MenuItem* arg1;
            ok = rubyval_to_object<cocos2d::MenuItem>(mrb, argv[1], "CC::MenuItem", &arg1);
            if (!ok) { break; }

            cocos2d::MenuItem* arg2;
            ok = rubyval_to_object<cocos2d::MenuItem>(mrb, argv[2], "CC::MenuItem", &arg2);
            if (!ok) { break; }

            cocos2d::MenuItem* arg3;
            ok = rubyval_to_object<cocos2d::MenuItem>(mrb, argv[3], "CC::MenuItem", &arg3);
            if (!ok) { break; }

            cocos2d::MenuItem* arg4;
            ok = rubyval_to_object<cocos2d::MenuItem>(mrb, argv[4], "CC::MenuItem", &arg4);
            if (!ok) { break; }

            cocos2d::MenuItemToggle* retval = cocos2d::MenuItemToggle::createWithCallback(arg0, arg1, arg2, arg3, arg4, NULL);
            mrb_value ret;
            RClass* rclass = mrb_class_ptr(self);
            ret = object_to_rubyval<cocos2d::MenuItemToggle>(mrb, "CC::MenuItemToggle", (cocos2d::MenuItemToggle*)retval, rclass);
            if (callbacks.size() > 0) {
                mrb_value hash = mrb_iv_get(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"));
                if (!mrb_hash_p(hash)) {
                    hash = mrb_hash_new(mrb);
                }
                for (auto elm : callbacks) {
                    mrb_hash_set(mrb, hash, mrb_str_new_cstr(mrb, elm.first.c_str()), elm.second);
                    mrb_iv_set(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"), hash);
                }
            }
            g_rubyValue.push_back(ret);
            mrb_funcall(mrb, ret, "initialize", 0);
            return ret;
        }
        if (argc == 6) {
            std::map<std::string, mrb_value> callbacks;
            std::function<void (cocos2d::Ref *)> arg0;
            do {
			    // Lambda binding for ruby.
			    unsigned long idx = g_rubyValue.size();
			    arg0 = [mrb, self, idx](cocos2d::Ref* larg0) -> void {
			        mrb_value ruby_arg0;
			        ruby_arg0 = object_to_rubyval<cocos2d::Ref>(mrb, "CC::Ref", (cocos2d::Ref*)larg0, nullptr);
			        mrb_value _self = g_rubyValue[idx];
			        mrb_value hash = mrb_iv_get(mrb, _self, mrb_intern_cstr(mrb, "__callback_hash"));
			        mrb_value func = mrb_hash_get(mrb, hash, mrb_str_new_cstr(mrb, "createWithCallback->arg0"));
			        mrb_value mrb_ret = mrb_funcall(mrb, func, "call", 1, ruby_arg0);
			        if (mrb_exception_p(mrb_ret)) {
			            mrb_exc_raise(mrb, mrb_ret);
			        }
			    };
			    callbacks["createWithCallback->arg0"] = argv[0];
			    break;
			} while(0);
            if (!ok) { break; }

            cocos2d::MenuItem* arg1;
            ok = rubyval_to_object<cocos2d::MenuItem>(mrb, argv[1], "CC::MenuItem", &arg1);
            if (!ok) { break; }

            cocos2d::MenuItem* arg2;
            ok = rubyval_to_object<cocos2d::MenuItem>(mrb, argv[2], "CC::MenuItem", &arg2);
            if (!ok) { break; }

            cocos2d::MenuItem* arg3;
            ok = rubyval_to_object<cocos2d::MenuItem>(mrb, argv[3], "CC::MenuItem", &arg3);
            if (!ok) { break; }

            cocos2d::MenuItem* arg4;
            ok = rubyval_to_object<cocos2d::MenuItem>(mrb, argv[4], "CC::MenuItem", &arg4);
            if (!ok) { break; }

            cocos2d::MenuItem* arg5;
            ok = rubyval_to_object<cocos2d::MenuItem>(mrb, argv[5], "CC::MenuItem", &arg5);
            if (!ok) { break; }

            cocos2d::MenuItemToggle* retval = cocos2d::MenuItemToggle::createWithCallback(arg0, arg1, arg2, arg3, arg4, arg5, NULL);
            mrb_value ret;
            RClass* rclass = mrb_class_ptr(self);
            ret = object_to_rubyval<cocos2d::MenuItemToggle>(mrb, "CC::MenuItemToggle", (cocos2d::MenuItemToggle*)retval, rclass);
            if (callbacks.size() > 0) {
                mrb_value hash = mrb_iv_get(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"));
                if (!mrb_hash_p(hash)) {
                    hash = mrb_hash_new(mrb);
                }
                for (auto elm : callbacks) {
                    mrb_hash_set(mrb, hash, mrb_str_new_cstr(mrb, elm.first.c_str()), elm.second);
                    mrb_iv_set(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"), hash);
                }
            }
            g_rubyValue.push_back(ret);
            mrb_funcall(mrb, ret, "initialize", 0);
            return ret;
        }
        if (argc == 7) {
            std::map<std::string, mrb_value> callbacks;
            std::function<void (cocos2d::Ref *)> arg0;
            do {
			    // Lambda binding for ruby.
			    unsigned long idx = g_rubyValue.size();
			    arg0 = [mrb, self, idx](cocos2d::Ref* larg0) -> void {
			        mrb_value ruby_arg0;
			        ruby_arg0 = object_to_rubyval<cocos2d::Ref>(mrb, "CC::Ref", (cocos2d::Ref*)larg0, nullptr);
			        mrb_value _self = g_rubyValue[idx];
			        mrb_value hash = mrb_iv_get(mrb, _self, mrb_intern_cstr(mrb, "__callback_hash"));
			        mrb_value func = mrb_hash_get(mrb, hash, mrb_str_new_cstr(mrb, "createWithCallback->arg0"));
			        mrb_value mrb_ret = mrb_funcall(mrb, func, "call", 1, ruby_arg0);
			        if (mrb_exception_p(mrb_ret)) {
			            mrb_exc_raise(mrb, mrb_ret);
			        }
			    };
			    callbacks["createWithCallback->arg0"] = argv[0];
			    break;
			} while(0);
            if (!ok) { break; }

            cocos2d::MenuItem* arg1;
            ok = rubyval_to_object<cocos2d::MenuItem>(mrb, argv[1], "CC::MenuItem", &arg1);
            if (!ok) { break; }

            cocos2d::MenuItem* arg2;
            ok = rubyval_to_object<cocos2d::MenuItem>(mrb, argv[2], "CC::MenuItem", &arg2);
            if (!ok) { break; }

            cocos2d::MenuItem* arg3;
            ok = rubyval_to_object<cocos2d::MenuItem>(mrb, argv[3], "CC::MenuItem", &arg3);
            if (!ok) { break; }

            cocos2d::MenuItem* arg4;
            ok = rubyval_to_object<cocos2d::MenuItem>(mrb, argv[4], "CC::MenuItem", &arg4);
            if (!ok) { break; }

            cocos2d::MenuItem* arg5;
            ok = rubyval_to_object<cocos2d::MenuItem>(mrb, argv[5], "CC::MenuItem", &arg5);
            if (!ok) { break; }

            cocos2d::MenuItem* arg6;
            ok = rubyval_to_object<cocos2d::MenuItem>(mrb, argv[6], "CC::MenuItem", &arg6);
            if (!ok) { break; }

            cocos2d::MenuItemToggle* retval = cocos2d::MenuItemToggle::createWithCallback(arg0, arg1, arg2, arg3, arg4, arg5, arg6, NULL);
            mrb_value ret;
            RClass* rclass = mrb_class_ptr(self);
            ret = object_to_rubyval<cocos2d::MenuItemToggle>(mrb, "CC::MenuItemToggle", (cocos2d::MenuItemToggle*)retval, rclass);
            if (callbacks.size() > 0) {
                mrb_value hash = mrb_iv_get(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"));
                if (!mrb_hash_p(hash)) {
                    hash = mrb_hash_new(mrb);
                }
                for (auto elm : callbacks) {
                    mrb_hash_set(mrb, hash, mrb_str_new_cstr(mrb, elm.first.c_str()), elm.second);
                    mrb_iv_set(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"), hash);
                }
            }
            g_rubyValue.push_back(ret);
            mrb_funcall(mrb, ret, "initialize", 0);
            return ret;
        }
        if (argc == 8) {
            std::map<std::string, mrb_value> callbacks;
            std::function<void (cocos2d::Ref *)> arg0;
            do {
			    // Lambda binding for ruby.
			    unsigned long idx = g_rubyValue.size();
			    arg0 = [mrb, self, idx](cocos2d::Ref* larg0) -> void {
			        mrb_value ruby_arg0;
			        ruby_arg0 = object_to_rubyval<cocos2d::Ref>(mrb, "CC::Ref", (cocos2d::Ref*)larg0, nullptr);
			        mrb_value _self = g_rubyValue[idx];
			        mrb_value hash = mrb_iv_get(mrb, _self, mrb_intern_cstr(mrb, "__callback_hash"));
			        mrb_value func = mrb_hash_get(mrb, hash, mrb_str_new_cstr(mrb, "createWithCallback->arg0"));
			        mrb_value mrb_ret = mrb_funcall(mrb, func, "call", 1, ruby_arg0);
			        if (mrb_exception_p(mrb_ret)) {
			            mrb_exc_raise(mrb, mrb_ret);
			        }
			    };
			    callbacks["createWithCallback->arg0"] = argv[0];
			    break;
			} while(0);
            if (!ok) { break; }

            cocos2d::MenuItem* arg1;
            ok = rubyval_to_object<cocos2d::MenuItem>(mrb, argv[1], "CC::MenuItem", &arg1);
            if (!ok) { break; }

            cocos2d::MenuItem* arg2;
            ok = rubyval_to_object<cocos2d::MenuItem>(mrb, argv[2], "CC::MenuItem", &arg2);
            if (!ok) { break; }

            cocos2d::MenuItem* arg3;
            ok = rubyval_to_object<cocos2d::MenuItem>(mrb, argv[3], "CC::MenuItem", &arg3);
            if (!ok) { break; }

            cocos2d::MenuItem* arg4;
            ok = rubyval_to_object<cocos2d::MenuItem>(mrb, argv[4], "CC::MenuItem", &arg4);
            if (!ok) { break; }

            cocos2d::MenuItem* arg5;
            ok = rubyval_to_object<cocos2d::MenuItem>(mrb, argv[5], "CC::MenuItem", &arg5);
            if (!ok) { break; }

            cocos2d::MenuItem* arg6;
            ok = rubyval_to_object<cocos2d::MenuItem>(mrb, argv[6], "CC::MenuItem", &arg6);
            if (!ok) { break; }

            cocos2d::MenuItem* arg7;
            ok = rubyval_to_object<cocos2d::MenuItem>(mrb, argv[7], "CC::MenuItem", &arg7);
            if (!ok) { break; }

            cocos2d::MenuItemToggle* retval = cocos2d::MenuItemToggle::createWithCallback(arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7, NULL);
            mrb_value ret;
            RClass* rclass = mrb_class_ptr(self);
            ret = object_to_rubyval<cocos2d::MenuItemToggle>(mrb, "CC::MenuItemToggle", (cocos2d::MenuItemToggle*)retval, rclass);
            if (callbacks.size() > 0) {
                mrb_value hash = mrb_iv_get(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"));
                if (!mrb_hash_p(hash)) {
                    hash = mrb_hash_new(mrb);
                }
                for (auto elm : callbacks) {
                    mrb_hash_set(mrb, hash, mrb_str_new_cstr(mrb, elm.first.c_str()), elm.second);
                    mrb_iv_set(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"), hash);
                }
            }
            g_rubyValue.push_back(ret);
            mrb_funcall(mrb, ret, "initialize", 0);
            return ret;
        }
        if (argc == 9) {
            std::map<std::string, mrb_value> callbacks;
            std::function<void (cocos2d::Ref *)> arg0;
            do {
			    // Lambda binding for ruby.
			    unsigned long idx = g_rubyValue.size();
			    arg0 = [mrb, self, idx](cocos2d::Ref* larg0) -> void {
			        mrb_value ruby_arg0;
			        ruby_arg0 = object_to_rubyval<cocos2d::Ref>(mrb, "CC::Ref", (cocos2d::Ref*)larg0, nullptr);
			        mrb_value _self = g_rubyValue[idx];
			        mrb_value hash = mrb_iv_get(mrb, _self, mrb_intern_cstr(mrb, "__callback_hash"));
			        mrb_value func = mrb_hash_get(mrb, hash, mrb_str_new_cstr(mrb, "createWithCallback->arg0"));
			        mrb_value mrb_ret = mrb_funcall(mrb, func, "call", 1, ruby_arg0);
			        if (mrb_exception_p(mrb_ret)) {
			            mrb_exc_raise(mrb, mrb_ret);
			        }
			    };
			    callbacks["createWithCallback->arg0"] = argv[0];
			    break;
			} while(0);
            if (!ok) { break; }

            cocos2d::MenuItem* arg1;
            ok = rubyval_to_object<cocos2d::MenuItem>(mrb, argv[1], "CC::MenuItem", &arg1);
            if (!ok) { break; }

            cocos2d::MenuItem* arg2;
            ok = rubyval_to_object<cocos2d::MenuItem>(mrb, argv[2], "CC::MenuItem", &arg2);
            if (!ok) { break; }

            cocos2d::MenuItem* arg3;
            ok = rubyval_to_object<cocos2d::MenuItem>(mrb, argv[3], "CC::MenuItem", &arg3);
            if (!ok) { break; }

            cocos2d::MenuItem* arg4;
            ok = rubyval_to_object<cocos2d::MenuItem>(mrb, argv[4], "CC::MenuItem", &arg4);
            if (!ok) { break; }

            cocos2d::MenuItem* arg5;
            ok = rubyval_to_object<cocos2d::MenuItem>(mrb, argv[5], "CC::MenuItem", &arg5);
            if (!ok) { break; }

            cocos2d::MenuItem* arg6;
            ok = rubyval_to_object<cocos2d::MenuItem>(mrb, argv[6], "CC::MenuItem", &arg6);
            if (!ok) { break; }

            cocos2d::MenuItem* arg7;
            ok = rubyval_to_object<cocos2d::MenuItem>(mrb, argv[7], "CC::MenuItem", &arg7);
            if (!ok) { break; }

            cocos2d::MenuItem* arg8;
            ok = rubyval_to_object<cocos2d::MenuItem>(mrb, argv[8], "CC::MenuItem", &arg8);
            if (!ok) { break; }

            cocos2d::MenuItemToggle* retval = cocos2d::MenuItemToggle::createWithCallback(arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, NULL);
            mrb_value ret;
            RClass* rclass = mrb_class_ptr(self);
            ret = object_to_rubyval<cocos2d::MenuItemToggle>(mrb, "CC::MenuItemToggle", (cocos2d::MenuItemToggle*)retval, rclass);
            if (callbacks.size() > 0) {
                mrb_value hash = mrb_iv_get(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"));
                if (!mrb_hash_p(hash)) {
                    hash = mrb_hash_new(mrb);
                }
                for (auto elm : callbacks) {
                    mrb_hash_set(mrb, hash, mrb_str_new_cstr(mrb, elm.first.c_str()), elm.second);
                    mrb_iv_set(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"), hash);
                }
            }
            g_rubyValue.push_back(ret);
            mrb_funcall(mrb, ret, "initialize", 0);
            return ret;
        }
        if (argc == 10) {
            std::map<std::string, mrb_value> callbacks;
            std::function<void (cocos2d::Ref *)> arg0;
            do {
			    // Lambda binding for ruby.
			    unsigned long idx = g_rubyValue.size();
			    arg0 = [mrb, self, idx](cocos2d::Ref* larg0) -> void {
			        mrb_value ruby_arg0;
			        ruby_arg0 = object_to_rubyval<cocos2d::Ref>(mrb, "CC::Ref", (cocos2d::Ref*)larg0, nullptr);
			        mrb_value _self = g_rubyValue[idx];
			        mrb_value hash = mrb_iv_get(mrb, _self, mrb_intern_cstr(mrb, "__callback_hash"));
			        mrb_value func = mrb_hash_get(mrb, hash, mrb_str_new_cstr(mrb, "createWithCallback->arg0"));
			        mrb_value mrb_ret = mrb_funcall(mrb, func, "call", 1, ruby_arg0);
			        if (mrb_exception_p(mrb_ret)) {
			            mrb_exc_raise(mrb, mrb_ret);
			        }
			    };
			    callbacks["createWithCallback->arg0"] = argv[0];
			    break;
			} while(0);
            if (!ok) { break; }

            cocos2d::MenuItem* arg1;
            ok = rubyval_to_object<cocos2d::MenuItem>(mrb, argv[1], "CC::MenuItem", &arg1);
            if (!ok) { break; }

            cocos2d::MenuItem* arg2;
            ok = rubyval_to_object<cocos2d::MenuItem>(mrb, argv[2], "CC::MenuItem", &arg2);
            if (!ok) { break; }

            cocos2d::MenuItem* arg3;
            ok = rubyval_to_object<cocos2d::MenuItem>(mrb, argv[3], "CC::MenuItem", &arg3);
            if (!ok) { break; }

            cocos2d::MenuItem* arg4;
            ok = rubyval_to_object<cocos2d::MenuItem>(mrb, argv[4], "CC::MenuItem", &arg4);
            if (!ok) { break; }

            cocos2d::MenuItem* arg5;
            ok = rubyval_to_object<cocos2d::MenuItem>(mrb, argv[5], "CC::MenuItem", &arg5);
            if (!ok) { break; }

            cocos2d::MenuItem* arg6;
            ok = rubyval_to_object<cocos2d::MenuItem>(mrb, argv[6], "CC::MenuItem", &arg6);
            if (!ok) { break; }

            cocos2d::MenuItem* arg7;
            ok = rubyval_to_object<cocos2d::MenuItem>(mrb, argv[7], "CC::MenuItem", &arg7);
            if (!ok) { break; }

            cocos2d::MenuItem* arg8;
            ok = rubyval_to_object<cocos2d::MenuItem>(mrb, argv[8], "CC::MenuItem", &arg8);
            if (!ok) { break; }

            cocos2d::MenuItem* arg9;
            ok = rubyval_to_object<cocos2d::MenuItem>(mrb, argv[9], "CC::MenuItem", &arg9);
            if (!ok) { break; }

            cocos2d::MenuItemToggle* retval = cocos2d::MenuItemToggle::createWithCallback(arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, NULL);
            mrb_value ret;
            RClass* rclass = mrb_class_ptr(self);
            ret = object_to_rubyval<cocos2d::MenuItemToggle>(mrb, "CC::MenuItemToggle", (cocos2d::MenuItemToggle*)retval, rclass);
            if (callbacks.size() > 0) {
                mrb_value hash = mrb_iv_get(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"));
                if (!mrb_hash_p(hash)) {
                    hash = mrb_hash_new(mrb);
                }
                for (auto elm : callbacks) {
                    mrb_hash_set(mrb, hash, mrb_str_new_cstr(mrb, elm.first.c_str()), elm.second);
                    mrb_iv_set(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"), hash);
                }
            }
            g_rubyValue.push_back(ret);
            mrb_funcall(mrb, ret, "initialize", 0);
            return ret;
        }
        if (argc == 11) {
            std::map<std::string, mrb_value> callbacks;
            std::function<void (cocos2d::Ref *)> arg0;
            do {
			    // Lambda binding for ruby.
			    unsigned long idx = g_rubyValue.size();
			    arg0 = [mrb, self, idx](cocos2d::Ref* larg0) -> void {
			        mrb_value ruby_arg0;
			        ruby_arg0 = object_to_rubyval<cocos2d::Ref>(mrb, "CC::Ref", (cocos2d::Ref*)larg0, nullptr);
			        mrb_value _self = g_rubyValue[idx];
			        mrb_value hash = mrb_iv_get(mrb, _self, mrb_intern_cstr(mrb, "__callback_hash"));
			        mrb_value func = mrb_hash_get(mrb, hash, mrb_str_new_cstr(mrb, "createWithCallback->arg0"));
			        mrb_value mrb_ret = mrb_funcall(mrb, func, "call", 1, ruby_arg0);
			        if (mrb_exception_p(mrb_ret)) {
			            mrb_exc_raise(mrb, mrb_ret);
			        }
			    };
			    callbacks["createWithCallback->arg0"] = argv[0];
			    break;
			} while(0);
            if (!ok) { break; }

            cocos2d::MenuItem* arg1;
            ok = rubyval_to_object<cocos2d::MenuItem>(mrb, argv[1], "CC::MenuItem", &arg1);
            if (!ok) { break; }

            cocos2d::MenuItem* arg2;
            ok = rubyval_to_object<cocos2d::MenuItem>(mrb, argv[2], "CC::MenuItem", &arg2);
            if (!ok) { break; }

            cocos2d::MenuItem* arg3;
            ok = rubyval_to_object<cocos2d::MenuItem>(mrb, argv[3], "CC::MenuItem", &arg3);
            if (!ok) { break; }

            cocos2d::MenuItem* arg4;
            ok = rubyval_to_object<cocos2d::MenuItem>(mrb, argv[4], "CC::MenuItem", &arg4);
            if (!ok) { break; }

            cocos2d::MenuItem* arg5;
            ok = rubyval_to_object<cocos2d::MenuItem>(mrb, argv[5], "CC::MenuItem", &arg5);
            if (!ok) { break; }

            cocos2d::MenuItem* arg6;
            ok = rubyval_to_object<cocos2d::MenuItem>(mrb, argv[6], "CC::MenuItem", &arg6);
            if (!ok) { break; }

            cocos2d::MenuItem* arg7;
            ok = rubyval_to_object<cocos2d::MenuItem>(mrb, argv[7], "CC::MenuItem", &arg7);
            if (!ok) { break; }

            cocos2d::MenuItem* arg8;
            ok = rubyval_to_object<cocos2d::MenuItem>(mrb, argv[8], "CC::MenuItem", &arg8);
            if (!ok) { break; }

            cocos2d::MenuItem* arg9;
            ok = rubyval_to_object<cocos2d::MenuItem>(mrb, argv[9], "CC::MenuItem", &arg9);
            if (!ok) { break; }

            cocos2d::MenuItem* arg10;
            ok = rubyval_to_object<cocos2d::MenuItem>(mrb, argv[10], "CC::MenuItem", &arg10);
            if (!ok) { break; }

            cocos2d::MenuItemToggle* retval = cocos2d::MenuItemToggle::createWithCallback(arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, NULL);
            mrb_value ret;
            RClass* rclass = mrb_class_ptr(self);
            ret = object_to_rubyval<cocos2d::MenuItemToggle>(mrb, "CC::MenuItemToggle", (cocos2d::MenuItemToggle*)retval, rclass);
            if (callbacks.size() > 0) {
                mrb_value hash = mrb_iv_get(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"));
                if (!mrb_hash_p(hash)) {
                    hash = mrb_hash_new(mrb);
                }
                for (auto elm : callbacks) {
                    mrb_hash_set(mrb, hash, mrb_str_new_cstr(mrb, elm.first.c_str()), elm.second);
                    mrb_iv_set(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"), hash);
                }
            }
            g_rubyValue.push_back(ret);
            mrb_funcall(mrb, ret, "initialize", 0);
            return ret;
        }
    } while (0);
    do {
        if (argc == 2) {
            std::map<std::string, mrb_value> callbacks;
            std::function<void (cocos2d::Ref *)> arg0;
            do {
			    // Lambda binding for ruby.
			    unsigned long idx = g_rubyValue.size();
			    arg0 = [mrb, self, idx](cocos2d::Ref* larg0) -> void {
			        mrb_value ruby_arg0;
			        ruby_arg0 = object_to_rubyval<cocos2d::Ref>(mrb, "CC::Ref", (cocos2d::Ref*)larg0, nullptr);
			        mrb_value _self = g_rubyValue[idx];
			        mrb_value hash = mrb_iv_get(mrb, _self, mrb_intern_cstr(mrb, "__callback_hash"));
			        mrb_value func = mrb_hash_get(mrb, hash, mrb_str_new_cstr(mrb, "createWithCallback->arg0"));
			        mrb_value mrb_ret = mrb_funcall(mrb, func, "call", 1, ruby_arg0);
			        if (mrb_exception_p(mrb_ret)) {
			            mrb_exc_raise(mrb, mrb_ret);
			        }
			    };
			    callbacks["createWithCallback->arg0"] = argv[0];
			    break;
			} while(0);
            if (!ok) { break; }

            cocos2d::Vector<cocos2d::MenuItem *> arg1;
            ok = rubyval_to_ccvector(mrb, argv[1], &arg1, "CC::MenuItemToggle.createWithCallback");
            if (!ok) { break; }

            cocos2d::MenuItemToggle* retval = cocos2d::MenuItemToggle::createWithCallback(arg0, arg1);
            mrb_value ret;
            RClass* rclass = mrb_class_ptr(self);
            ret = object_to_rubyval<cocos2d::MenuItemToggle>(mrb, "CC::MenuItemToggle", (cocos2d::MenuItemToggle*)retval, rclass);
            if (callbacks.size() > 0) {
                mrb_value hash = mrb_iv_get(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"));
                if (!mrb_hash_p(hash)) {
                    hash = mrb_hash_new(mrb);
                }
                for (auto elm : callbacks) {
                    mrb_hash_set(mrb, hash, mrb_str_new_cstr(mrb, elm.first.c_str()), elm.second);
                    mrb_iv_set(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"), hash);
                }
            }
            g_rubyValue.push_back(ret);
            mrb_funcall(mrb, ret, "initialize", 0);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined static method : cocos2d::MenuItemToggle#createWithCallback");

    return mrb_nil_value();
}

void ruby_register_cocos2dx_MenuItemToggle(mrb_state* mrb, struct RClass* rmodule)
{
    std::string typeName = typeid(cocos2d::MenuItemToggle).name();
    g_rubyType[typeName] = "CC::MenuItemToggle";
    g_rubyDataType[typeName] = &ruby_cocos2dx_Ref_type;

    struct RClass* p_rmodule = mrb->object_class;
    p_rmodule = mrb_module_get_under(mrb, p_rmodule, "CC");
    struct RClass* p_rclass = mrb_class_get_under(mrb, p_rmodule, "MenuItem");
    struct RClass *rclass = mrb_define_class_under(mrb, rmodule, "MenuItemToggle", p_rclass);
    MRB_SET_INSTANCE_TT(rclass, MRB_TT_DATA);

    mrb_define_method(mrb, rclass, "set_sub_items", ruby_cocos2dx_MenuItemToggle_setSubItems, ARGS_REQ(1));
    mrb_define_method(mrb, rclass, "get_sub_items", ruby_cocos2dx_MenuItemToggle_getSubItems, ARGS_NONE());
    mrb_define_method(mrb, rclass, "get_selected_index", ruby_cocos2dx_MenuItemToggle_getSelectedIndex, ARGS_NONE());
    mrb_define_method(mrb, rclass, "add_sub_item", ruby_cocos2dx_MenuItemToggle_addSubItem, ARGS_REQ(1));
    mrb_define_method(mrb, rclass, "get_selected_item", ruby_cocos2dx_MenuItemToggle_getSelectedItem, ARGS_NONE());
    mrb_define_method(mrb, rclass, "set_selected_index", ruby_cocos2dx_MenuItemToggle_setSelectedIndex, ARGS_REQ(1));
    mrb_define_class_method(mrb, rclass, "create", ruby_cocos2dx_MenuItemToggle_create_static, ARGS_REQ(0)|ARGS_OPT(1));
    mrb_define_class_method(mrb, rclass, "create_with_callback", ruby_cocos2dx_MenuItemToggle_createWithCallback_static, ARGS_REQ(2));
}
mrb_value ruby_cocos2dx_Menu_setEnabled(mrb_state* mrb, mrb_value self)
{
    cocos2d::Menu* cobj = static_cast<cocos2d::Menu*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            bool arg0;
            ok = rubyval_to_boolean(mrb, argv[0], &arg0, "CC::Menu.setEnabled");
            if (!ok) { break; }
            cobj->setEnabled(arg0);
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::Menu#setEnabled");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Menu_alignItemsVertically(mrb_state* mrb, mrb_value self)
{
    cocos2d::Menu* cobj = static_cast<cocos2d::Menu*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            cobj->alignItemsVertically();
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::Menu#alignItemsVertically");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Menu_isEnabled(mrb_state* mrb, mrb_value self)
{
    cocos2d::Menu* cobj = static_cast<cocos2d::Menu*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            bool retval = cobj->isEnabled();
            mrb_value ret;
            ret = mrb_bool_value((mrb_bool)retval);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::Menu#isEnabled");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Menu_alignItemsInRowsWithArray(mrb_state* mrb, mrb_value self)
{
    cocos2d::Menu* cobj = static_cast<cocos2d::Menu*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            cocos2d::ValueVector arg0;
            ok = rubyval_to_ccvaluevector(mrb, argv[0], &arg0, "CC::Menu.alignItemsInRowsWithArray");
            if (!ok) { break; }
            cobj->alignItemsInRowsWithArray(arg0);
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::Menu#alignItemsInRowsWithArray");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Menu_alignItemsHorizontally(mrb_state* mrb, mrb_value self)
{
    cocos2d::Menu* cobj = static_cast<cocos2d::Menu*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            cobj->alignItemsHorizontally();
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::Menu#alignItemsHorizontally");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Menu_alignItemsHorizontallyWithPadding(mrb_state* mrb, mrb_value self)
{
    cocos2d::Menu* cobj = static_cast<cocos2d::Menu*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            double arg0;
            ok = rubyval_to_number(mrb, argv[0], (double*)&arg0, "CC::Menu.alignItemsHorizontallyWithPadding");
            if (!ok) { break; }
            cobj->alignItemsHorizontallyWithPadding(arg0);
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::Menu#alignItemsHorizontallyWithPadding");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Menu_alignItemsInColumnsWithArray(mrb_state* mrb, mrb_value self)
{
    cocos2d::Menu* cobj = static_cast<cocos2d::Menu*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            cocos2d::ValueVector arg0;
            ok = rubyval_to_ccvaluevector(mrb, argv[0], &arg0, "CC::Menu.alignItemsInColumnsWithArray");
            if (!ok) { break; }
            cobj->alignItemsInColumnsWithArray(arg0);
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::Menu#alignItemsInColumnsWithArray");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Menu_alignItemsVerticallyWithPadding(mrb_state* mrb, mrb_value self)
{
    cocos2d::Menu* cobj = static_cast<cocos2d::Menu*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            double arg0;
            ok = rubyval_to_number(mrb, argv[0], (double*)&arg0, "CC::Menu.alignItemsVerticallyWithPadding");
            if (!ok) { break; }
            cobj->alignItemsVerticallyWithPadding(arg0);
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::Menu#alignItemsVerticallyWithPadding");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Menu_alignItemsInRows(mrb_state* mrb, mrb_value self)
{
    cocos2d::Menu* cobj = static_cast<cocos2d::Menu*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            int arg0;
            ok = rubyval_to_int32(mrb, argv[0], (int*)&arg0, "CC::Menu.alignItemsInRows");
            if (!ok) { break; }
            cobj->alignItemsInRows(arg0, NULL);
            return self;
        }
        if (argc == 2) {
            int arg0;
            ok = rubyval_to_int32(mrb, argv[0], (int*)&arg0, "CC::Menu.alignItemsInRows");
            if (!ok) { break; }
            int arg1;
            ok = rubyval_to_int32(mrb, argv[1], (int*)&arg1, "CC::Menu.alignItemsInRows");
            if (!ok) { break; }
            cobj->alignItemsInRows(arg0, arg1, NULL);
            return self;
        }
        if (argc == 3) {
            int arg0;
            ok = rubyval_to_int32(mrb, argv[0], (int*)&arg0, "CC::Menu.alignItemsInRows");
            if (!ok) { break; }
            int arg1;
            ok = rubyval_to_int32(mrb, argv[1], (int*)&arg1, "CC::Menu.alignItemsInRows");
            if (!ok) { break; }
            int arg2;
            ok = rubyval_to_int32(mrb, argv[2], (int*)&arg2, "CC::Menu.alignItemsInRows");
            if (!ok) { break; }
            cobj->alignItemsInRows(arg0, arg1, arg2, NULL);
            return self;
        }
        if (argc == 4) {
            int arg0;
            ok = rubyval_to_int32(mrb, argv[0], (int*)&arg0, "CC::Menu.alignItemsInRows");
            if (!ok) { break; }
            int arg1;
            ok = rubyval_to_int32(mrb, argv[1], (int*)&arg1, "CC::Menu.alignItemsInRows");
            if (!ok) { break; }
            int arg2;
            ok = rubyval_to_int32(mrb, argv[2], (int*)&arg2, "CC::Menu.alignItemsInRows");
            if (!ok) { break; }
            int arg3;
            ok = rubyval_to_int32(mrb, argv[3], (int*)&arg3, "CC::Menu.alignItemsInRows");
            if (!ok) { break; }
            cobj->alignItemsInRows(arg0, arg1, arg2, arg3, NULL);
            return self;
        }
        if (argc == 5) {
            int arg0;
            ok = rubyval_to_int32(mrb, argv[0], (int*)&arg0, "CC::Menu.alignItemsInRows");
            if (!ok) { break; }
            int arg1;
            ok = rubyval_to_int32(mrb, argv[1], (int*)&arg1, "CC::Menu.alignItemsInRows");
            if (!ok) { break; }
            int arg2;
            ok = rubyval_to_int32(mrb, argv[2], (int*)&arg2, "CC::Menu.alignItemsInRows");
            if (!ok) { break; }
            int arg3;
            ok = rubyval_to_int32(mrb, argv[3], (int*)&arg3, "CC::Menu.alignItemsInRows");
            if (!ok) { break; }
            int arg4;
            ok = rubyval_to_int32(mrb, argv[4], (int*)&arg4, "CC::Menu.alignItemsInRows");
            if (!ok) { break; }
            cobj->alignItemsInRows(arg0, arg1, arg2, arg3, arg4, NULL);
            return self;
        }
        if (argc == 6) {
            int arg0;
            ok = rubyval_to_int32(mrb, argv[0], (int*)&arg0, "CC::Menu.alignItemsInRows");
            if (!ok) { break; }
            int arg1;
            ok = rubyval_to_int32(mrb, argv[1], (int*)&arg1, "CC::Menu.alignItemsInRows");
            if (!ok) { break; }
            int arg2;
            ok = rubyval_to_int32(mrb, argv[2], (int*)&arg2, "CC::Menu.alignItemsInRows");
            if (!ok) { break; }
            int arg3;
            ok = rubyval_to_int32(mrb, argv[3], (int*)&arg3, "CC::Menu.alignItemsInRows");
            if (!ok) { break; }
            int arg4;
            ok = rubyval_to_int32(mrb, argv[4], (int*)&arg4, "CC::Menu.alignItemsInRows");
            if (!ok) { break; }
            int arg5;
            ok = rubyval_to_int32(mrb, argv[5], (int*)&arg5, "CC::Menu.alignItemsInRows");
            if (!ok) { break; }
            cobj->alignItemsInRows(arg0, arg1, arg2, arg3, arg4, arg5, NULL);
            return self;
        }
        if (argc == 7) {
            int arg0;
            ok = rubyval_to_int32(mrb, argv[0], (int*)&arg0, "CC::Menu.alignItemsInRows");
            if (!ok) { break; }
            int arg1;
            ok = rubyval_to_int32(mrb, argv[1], (int*)&arg1, "CC::Menu.alignItemsInRows");
            if (!ok) { break; }
            int arg2;
            ok = rubyval_to_int32(mrb, argv[2], (int*)&arg2, "CC::Menu.alignItemsInRows");
            if (!ok) { break; }
            int arg3;
            ok = rubyval_to_int32(mrb, argv[3], (int*)&arg3, "CC::Menu.alignItemsInRows");
            if (!ok) { break; }
            int arg4;
            ok = rubyval_to_int32(mrb, argv[4], (int*)&arg4, "CC::Menu.alignItemsInRows");
            if (!ok) { break; }
            int arg5;
            ok = rubyval_to_int32(mrb, argv[5], (int*)&arg5, "CC::Menu.alignItemsInRows");
            if (!ok) { break; }
            int arg6;
            ok = rubyval_to_int32(mrb, argv[6], (int*)&arg6, "CC::Menu.alignItemsInRows");
            if (!ok) { break; }
            cobj->alignItemsInRows(arg0, arg1, arg2, arg3, arg4, arg5, arg6, NULL);
            return self;
        }
        if (argc == 8) {
            int arg0;
            ok = rubyval_to_int32(mrb, argv[0], (int*)&arg0, "CC::Menu.alignItemsInRows");
            if (!ok) { break; }
            int arg1;
            ok = rubyval_to_int32(mrb, argv[1], (int*)&arg1, "CC::Menu.alignItemsInRows");
            if (!ok) { break; }
            int arg2;
            ok = rubyval_to_int32(mrb, argv[2], (int*)&arg2, "CC::Menu.alignItemsInRows");
            if (!ok) { break; }
            int arg3;
            ok = rubyval_to_int32(mrb, argv[3], (int*)&arg3, "CC::Menu.alignItemsInRows");
            if (!ok) { break; }
            int arg4;
            ok = rubyval_to_int32(mrb, argv[4], (int*)&arg4, "CC::Menu.alignItemsInRows");
            if (!ok) { break; }
            int arg5;
            ok = rubyval_to_int32(mrb, argv[5], (int*)&arg5, "CC::Menu.alignItemsInRows");
            if (!ok) { break; }
            int arg6;
            ok = rubyval_to_int32(mrb, argv[6], (int*)&arg6, "CC::Menu.alignItemsInRows");
            if (!ok) { break; }
            int arg7;
            ok = rubyval_to_int32(mrb, argv[7], (int*)&arg7, "CC::Menu.alignItemsInRows");
            if (!ok) { break; }
            cobj->alignItemsInRows(arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7, NULL);
            return self;
        }
        if (argc == 9) {
            int arg0;
            ok = rubyval_to_int32(mrb, argv[0], (int*)&arg0, "CC::Menu.alignItemsInRows");
            if (!ok) { break; }
            int arg1;
            ok = rubyval_to_int32(mrb, argv[1], (int*)&arg1, "CC::Menu.alignItemsInRows");
            if (!ok) { break; }
            int arg2;
            ok = rubyval_to_int32(mrb, argv[2], (int*)&arg2, "CC::Menu.alignItemsInRows");
            if (!ok) { break; }
            int arg3;
            ok = rubyval_to_int32(mrb, argv[3], (int*)&arg3, "CC::Menu.alignItemsInRows");
            if (!ok) { break; }
            int arg4;
            ok = rubyval_to_int32(mrb, argv[4], (int*)&arg4, "CC::Menu.alignItemsInRows");
            if (!ok) { break; }
            int arg5;
            ok = rubyval_to_int32(mrb, argv[5], (int*)&arg5, "CC::Menu.alignItemsInRows");
            if (!ok) { break; }
            int arg6;
            ok = rubyval_to_int32(mrb, argv[6], (int*)&arg6, "CC::Menu.alignItemsInRows");
            if (!ok) { break; }
            int arg7;
            ok = rubyval_to_int32(mrb, argv[7], (int*)&arg7, "CC::Menu.alignItemsInRows");
            if (!ok) { break; }
            int arg8;
            ok = rubyval_to_int32(mrb, argv[8], (int*)&arg8, "CC::Menu.alignItemsInRows");
            if (!ok) { break; }
            cobj->alignItemsInRows(arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, NULL);
            return self;
        }
        if (argc == 10) {
            int arg0;
            ok = rubyval_to_int32(mrb, argv[0], (int*)&arg0, "CC::Menu.alignItemsInRows");
            if (!ok) { break; }
            int arg1;
            ok = rubyval_to_int32(mrb, argv[1], (int*)&arg1, "CC::Menu.alignItemsInRows");
            if (!ok) { break; }
            int arg2;
            ok = rubyval_to_int32(mrb, argv[2], (int*)&arg2, "CC::Menu.alignItemsInRows");
            if (!ok) { break; }
            int arg3;
            ok = rubyval_to_int32(mrb, argv[3], (int*)&arg3, "CC::Menu.alignItemsInRows");
            if (!ok) { break; }
            int arg4;
            ok = rubyval_to_int32(mrb, argv[4], (int*)&arg4, "CC::Menu.alignItemsInRows");
            if (!ok) { break; }
            int arg5;
            ok = rubyval_to_int32(mrb, argv[5], (int*)&arg5, "CC::Menu.alignItemsInRows");
            if (!ok) { break; }
            int arg6;
            ok = rubyval_to_int32(mrb, argv[6], (int*)&arg6, "CC::Menu.alignItemsInRows");
            if (!ok) { break; }
            int arg7;
            ok = rubyval_to_int32(mrb, argv[7], (int*)&arg7, "CC::Menu.alignItemsInRows");
            if (!ok) { break; }
            int arg8;
            ok = rubyval_to_int32(mrb, argv[8], (int*)&arg8, "CC::Menu.alignItemsInRows");
            if (!ok) { break; }
            int arg9;
            ok = rubyval_to_int32(mrb, argv[9], (int*)&arg9, "CC::Menu.alignItemsInRows");
            if (!ok) { break; }
            cobj->alignItemsInRows(arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, NULL);
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::Menu#alignItemsInRows");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Menu_alignItemsInColumns(mrb_state* mrb, mrb_value self)
{
    cocos2d::Menu* cobj = static_cast<cocos2d::Menu*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            int arg0;
            ok = rubyval_to_int32(mrb, argv[0], (int*)&arg0, "CC::Menu.alignItemsInColumns");
            if (!ok) { break; }
            cobj->alignItemsInColumns(arg0, NULL);
            return self;
        }
        if (argc == 2) {
            int arg0;
            ok = rubyval_to_int32(mrb, argv[0], (int*)&arg0, "CC::Menu.alignItemsInColumns");
            if (!ok) { break; }
            int arg1;
            ok = rubyval_to_int32(mrb, argv[1], (int*)&arg1, "CC::Menu.alignItemsInColumns");
            if (!ok) { break; }
            cobj->alignItemsInColumns(arg0, arg1, NULL);
            return self;
        }
        if (argc == 3) {
            int arg0;
            ok = rubyval_to_int32(mrb, argv[0], (int*)&arg0, "CC::Menu.alignItemsInColumns");
            if (!ok) { break; }
            int arg1;
            ok = rubyval_to_int32(mrb, argv[1], (int*)&arg1, "CC::Menu.alignItemsInColumns");
            if (!ok) { break; }
            int arg2;
            ok = rubyval_to_int32(mrb, argv[2], (int*)&arg2, "CC::Menu.alignItemsInColumns");
            if (!ok) { break; }
            cobj->alignItemsInColumns(arg0, arg1, arg2, NULL);
            return self;
        }
        if (argc == 4) {
            int arg0;
            ok = rubyval_to_int32(mrb, argv[0], (int*)&arg0, "CC::Menu.alignItemsInColumns");
            if (!ok) { break; }
            int arg1;
            ok = rubyval_to_int32(mrb, argv[1], (int*)&arg1, "CC::Menu.alignItemsInColumns");
            if (!ok) { break; }
            int arg2;
            ok = rubyval_to_int32(mrb, argv[2], (int*)&arg2, "CC::Menu.alignItemsInColumns");
            if (!ok) { break; }
            int arg3;
            ok = rubyval_to_int32(mrb, argv[3], (int*)&arg3, "CC::Menu.alignItemsInColumns");
            if (!ok) { break; }
            cobj->alignItemsInColumns(arg0, arg1, arg2, arg3, NULL);
            return self;
        }
        if (argc == 5) {
            int arg0;
            ok = rubyval_to_int32(mrb, argv[0], (int*)&arg0, "CC::Menu.alignItemsInColumns");
            if (!ok) { break; }
            int arg1;
            ok = rubyval_to_int32(mrb, argv[1], (int*)&arg1, "CC::Menu.alignItemsInColumns");
            if (!ok) { break; }
            int arg2;
            ok = rubyval_to_int32(mrb, argv[2], (int*)&arg2, "CC::Menu.alignItemsInColumns");
            if (!ok) { break; }
            int arg3;
            ok = rubyval_to_int32(mrb, argv[3], (int*)&arg3, "CC::Menu.alignItemsInColumns");
            if (!ok) { break; }
            int arg4;
            ok = rubyval_to_int32(mrb, argv[4], (int*)&arg4, "CC::Menu.alignItemsInColumns");
            if (!ok) { break; }
            cobj->alignItemsInColumns(arg0, arg1, arg2, arg3, arg4, NULL);
            return self;
        }
        if (argc == 6) {
            int arg0;
            ok = rubyval_to_int32(mrb, argv[0], (int*)&arg0, "CC::Menu.alignItemsInColumns");
            if (!ok) { break; }
            int arg1;
            ok = rubyval_to_int32(mrb, argv[1], (int*)&arg1, "CC::Menu.alignItemsInColumns");
            if (!ok) { break; }
            int arg2;
            ok = rubyval_to_int32(mrb, argv[2], (int*)&arg2, "CC::Menu.alignItemsInColumns");
            if (!ok) { break; }
            int arg3;
            ok = rubyval_to_int32(mrb, argv[3], (int*)&arg3, "CC::Menu.alignItemsInColumns");
            if (!ok) { break; }
            int arg4;
            ok = rubyval_to_int32(mrb, argv[4], (int*)&arg4, "CC::Menu.alignItemsInColumns");
            if (!ok) { break; }
            int arg5;
            ok = rubyval_to_int32(mrb, argv[5], (int*)&arg5, "CC::Menu.alignItemsInColumns");
            if (!ok) { break; }
            cobj->alignItemsInColumns(arg0, arg1, arg2, arg3, arg4, arg5, NULL);
            return self;
        }
        if (argc == 7) {
            int arg0;
            ok = rubyval_to_int32(mrb, argv[0], (int*)&arg0, "CC::Menu.alignItemsInColumns");
            if (!ok) { break; }
            int arg1;
            ok = rubyval_to_int32(mrb, argv[1], (int*)&arg1, "CC::Menu.alignItemsInColumns");
            if (!ok) { break; }
            int arg2;
            ok = rubyval_to_int32(mrb, argv[2], (int*)&arg2, "CC::Menu.alignItemsInColumns");
            if (!ok) { break; }
            int arg3;
            ok = rubyval_to_int32(mrb, argv[3], (int*)&arg3, "CC::Menu.alignItemsInColumns");
            if (!ok) { break; }
            int arg4;
            ok = rubyval_to_int32(mrb, argv[4], (int*)&arg4, "CC::Menu.alignItemsInColumns");
            if (!ok) { break; }
            int arg5;
            ok = rubyval_to_int32(mrb, argv[5], (int*)&arg5, "CC::Menu.alignItemsInColumns");
            if (!ok) { break; }
            int arg6;
            ok = rubyval_to_int32(mrb, argv[6], (int*)&arg6, "CC::Menu.alignItemsInColumns");
            if (!ok) { break; }
            cobj->alignItemsInColumns(arg0, arg1, arg2, arg3, arg4, arg5, arg6, NULL);
            return self;
        }
        if (argc == 8) {
            int arg0;
            ok = rubyval_to_int32(mrb, argv[0], (int*)&arg0, "CC::Menu.alignItemsInColumns");
            if (!ok) { break; }
            int arg1;
            ok = rubyval_to_int32(mrb, argv[1], (int*)&arg1, "CC::Menu.alignItemsInColumns");
            if (!ok) { break; }
            int arg2;
            ok = rubyval_to_int32(mrb, argv[2], (int*)&arg2, "CC::Menu.alignItemsInColumns");
            if (!ok) { break; }
            int arg3;
            ok = rubyval_to_int32(mrb, argv[3], (int*)&arg3, "CC::Menu.alignItemsInColumns");
            if (!ok) { break; }
            int arg4;
            ok = rubyval_to_int32(mrb, argv[4], (int*)&arg4, "CC::Menu.alignItemsInColumns");
            if (!ok) { break; }
            int arg5;
            ok = rubyval_to_int32(mrb, argv[5], (int*)&arg5, "CC::Menu.alignItemsInColumns");
            if (!ok) { break; }
            int arg6;
            ok = rubyval_to_int32(mrb, argv[6], (int*)&arg6, "CC::Menu.alignItemsInColumns");
            if (!ok) { break; }
            int arg7;
            ok = rubyval_to_int32(mrb, argv[7], (int*)&arg7, "CC::Menu.alignItemsInColumns");
            if (!ok) { break; }
            cobj->alignItemsInColumns(arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7, NULL);
            return self;
        }
        if (argc == 9) {
            int arg0;
            ok = rubyval_to_int32(mrb, argv[0], (int*)&arg0, "CC::Menu.alignItemsInColumns");
            if (!ok) { break; }
            int arg1;
            ok = rubyval_to_int32(mrb, argv[1], (int*)&arg1, "CC::Menu.alignItemsInColumns");
            if (!ok) { break; }
            int arg2;
            ok = rubyval_to_int32(mrb, argv[2], (int*)&arg2, "CC::Menu.alignItemsInColumns");
            if (!ok) { break; }
            int arg3;
            ok = rubyval_to_int32(mrb, argv[3], (int*)&arg3, "CC::Menu.alignItemsInColumns");
            if (!ok) { break; }
            int arg4;
            ok = rubyval_to_int32(mrb, argv[4], (int*)&arg4, "CC::Menu.alignItemsInColumns");
            if (!ok) { break; }
            int arg5;
            ok = rubyval_to_int32(mrb, argv[5], (int*)&arg5, "CC::Menu.alignItemsInColumns");
            if (!ok) { break; }
            int arg6;
            ok = rubyval_to_int32(mrb, argv[6], (int*)&arg6, "CC::Menu.alignItemsInColumns");
            if (!ok) { break; }
            int arg7;
            ok = rubyval_to_int32(mrb, argv[7], (int*)&arg7, "CC::Menu.alignItemsInColumns");
            if (!ok) { break; }
            int arg8;
            ok = rubyval_to_int32(mrb, argv[8], (int*)&arg8, "CC::Menu.alignItemsInColumns");
            if (!ok) { break; }
            cobj->alignItemsInColumns(arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, NULL);
            return self;
        }
        if (argc == 10) {
            int arg0;
            ok = rubyval_to_int32(mrb, argv[0], (int*)&arg0, "CC::Menu.alignItemsInColumns");
            if (!ok) { break; }
            int arg1;
            ok = rubyval_to_int32(mrb, argv[1], (int*)&arg1, "CC::Menu.alignItemsInColumns");
            if (!ok) { break; }
            int arg2;
            ok = rubyval_to_int32(mrb, argv[2], (int*)&arg2, "CC::Menu.alignItemsInColumns");
            if (!ok) { break; }
            int arg3;
            ok = rubyval_to_int32(mrb, argv[3], (int*)&arg3, "CC::Menu.alignItemsInColumns");
            if (!ok) { break; }
            int arg4;
            ok = rubyval_to_int32(mrb, argv[4], (int*)&arg4, "CC::Menu.alignItemsInColumns");
            if (!ok) { break; }
            int arg5;
            ok = rubyval_to_int32(mrb, argv[5], (int*)&arg5, "CC::Menu.alignItemsInColumns");
            if (!ok) { break; }
            int arg6;
            ok = rubyval_to_int32(mrb, argv[6], (int*)&arg6, "CC::Menu.alignItemsInColumns");
            if (!ok) { break; }
            int arg7;
            ok = rubyval_to_int32(mrb, argv[7], (int*)&arg7, "CC::Menu.alignItemsInColumns");
            if (!ok) { break; }
            int arg8;
            ok = rubyval_to_int32(mrb, argv[8], (int*)&arg8, "CC::Menu.alignItemsInColumns");
            if (!ok) { break; }
            int arg9;
            ok = rubyval_to_int32(mrb, argv[9], (int*)&arg9, "CC::Menu.alignItemsInColumns");
            if (!ok) { break; }
            cobj->alignItemsInColumns(arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, NULL);
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::Menu#alignItemsInColumns");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Menu_create_static(mrb_state* mrb, mrb_value self)
{
    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            std::map<std::string, mrb_value> callbacks;
            cocos2d::MenuItem* arg0;
            ok = rubyval_to_object<cocos2d::MenuItem>(mrb, argv[0], "CC::MenuItem", &arg0);
            if (!ok) { break; }

            cocos2d::Menu* retval = cocos2d::Menu::create(arg0, NULL);
            mrb_value ret;
            RClass* rclass = mrb_class_ptr(self);
            ret = object_to_rubyval<cocos2d::Menu>(mrb, "CC::Menu", (cocos2d::Menu*)retval, rclass);
            if (callbacks.size() > 0) {
                mrb_value hash = mrb_iv_get(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"));
                if (!mrb_hash_p(hash)) {
                    hash = mrb_hash_new(mrb);
                }
                for (auto elm : callbacks) {
                    mrb_hash_set(mrb, hash, mrb_str_new_cstr(mrb, elm.first.c_str()), elm.second);
                    mrb_iv_set(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"), hash);
                }
            }
            g_rubyValue.push_back(ret);
            mrb_funcall(mrb, ret, "initialize", 0);
            return ret;
        }
        if (argc == 2) {
            std::map<std::string, mrb_value> callbacks;
            cocos2d::MenuItem* arg0;
            ok = rubyval_to_object<cocos2d::MenuItem>(mrb, argv[0], "CC::MenuItem", &arg0);
            if (!ok) { break; }

            cocos2d::MenuItem* arg1;
            ok = rubyval_to_object<cocos2d::MenuItem>(mrb, argv[1], "CC::MenuItem", &arg1);
            if (!ok) { break; }

            cocos2d::Menu* retval = cocos2d::Menu::create(arg0, arg1, NULL);
            mrb_value ret;
            RClass* rclass = mrb_class_ptr(self);
            ret = object_to_rubyval<cocos2d::Menu>(mrb, "CC::Menu", (cocos2d::Menu*)retval, rclass);
            if (callbacks.size() > 0) {
                mrb_value hash = mrb_iv_get(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"));
                if (!mrb_hash_p(hash)) {
                    hash = mrb_hash_new(mrb);
                }
                for (auto elm : callbacks) {
                    mrb_hash_set(mrb, hash, mrb_str_new_cstr(mrb, elm.first.c_str()), elm.second);
                    mrb_iv_set(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"), hash);
                }
            }
            g_rubyValue.push_back(ret);
            mrb_funcall(mrb, ret, "initialize", 0);
            return ret;
        }
        if (argc == 3) {
            std::map<std::string, mrb_value> callbacks;
            cocos2d::MenuItem* arg0;
            ok = rubyval_to_object<cocos2d::MenuItem>(mrb, argv[0], "CC::MenuItem", &arg0);
            if (!ok) { break; }

            cocos2d::MenuItem* arg1;
            ok = rubyval_to_object<cocos2d::MenuItem>(mrb, argv[1], "CC::MenuItem", &arg1);
            if (!ok) { break; }

            cocos2d::MenuItem* arg2;
            ok = rubyval_to_object<cocos2d::MenuItem>(mrb, argv[2], "CC::MenuItem", &arg2);
            if (!ok) { break; }

            cocos2d::Menu* retval = cocos2d::Menu::create(arg0, arg1, arg2, NULL);
            mrb_value ret;
            RClass* rclass = mrb_class_ptr(self);
            ret = object_to_rubyval<cocos2d::Menu>(mrb, "CC::Menu", (cocos2d::Menu*)retval, rclass);
            if (callbacks.size() > 0) {
                mrb_value hash = mrb_iv_get(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"));
                if (!mrb_hash_p(hash)) {
                    hash = mrb_hash_new(mrb);
                }
                for (auto elm : callbacks) {
                    mrb_hash_set(mrb, hash, mrb_str_new_cstr(mrb, elm.first.c_str()), elm.second);
                    mrb_iv_set(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"), hash);
                }
            }
            g_rubyValue.push_back(ret);
            mrb_funcall(mrb, ret, "initialize", 0);
            return ret;
        }
        if (argc == 4) {
            std::map<std::string, mrb_value> callbacks;
            cocos2d::MenuItem* arg0;
            ok = rubyval_to_object<cocos2d::MenuItem>(mrb, argv[0], "CC::MenuItem", &arg0);
            if (!ok) { break; }

            cocos2d::MenuItem* arg1;
            ok = rubyval_to_object<cocos2d::MenuItem>(mrb, argv[1], "CC::MenuItem", &arg1);
            if (!ok) { break; }

            cocos2d::MenuItem* arg2;
            ok = rubyval_to_object<cocos2d::MenuItem>(mrb, argv[2], "CC::MenuItem", &arg2);
            if (!ok) { break; }

            cocos2d::MenuItem* arg3;
            ok = rubyval_to_object<cocos2d::MenuItem>(mrb, argv[3], "CC::MenuItem", &arg3);
            if (!ok) { break; }

            cocos2d::Menu* retval = cocos2d::Menu::create(arg0, arg1, arg2, arg3, NULL);
            mrb_value ret;
            RClass* rclass = mrb_class_ptr(self);
            ret = object_to_rubyval<cocos2d::Menu>(mrb, "CC::Menu", (cocos2d::Menu*)retval, rclass);
            if (callbacks.size() > 0) {
                mrb_value hash = mrb_iv_get(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"));
                if (!mrb_hash_p(hash)) {
                    hash = mrb_hash_new(mrb);
                }
                for (auto elm : callbacks) {
                    mrb_hash_set(mrb, hash, mrb_str_new_cstr(mrb, elm.first.c_str()), elm.second);
                    mrb_iv_set(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"), hash);
                }
            }
            g_rubyValue.push_back(ret);
            mrb_funcall(mrb, ret, "initialize", 0);
            return ret;
        }
        if (argc == 5) {
            std::map<std::string, mrb_value> callbacks;
            cocos2d::MenuItem* arg0;
            ok = rubyval_to_object<cocos2d::MenuItem>(mrb, argv[0], "CC::MenuItem", &arg0);
            if (!ok) { break; }

            cocos2d::MenuItem* arg1;
            ok = rubyval_to_object<cocos2d::MenuItem>(mrb, argv[1], "CC::MenuItem", &arg1);
            if (!ok) { break; }

            cocos2d::MenuItem* arg2;
            ok = rubyval_to_object<cocos2d::MenuItem>(mrb, argv[2], "CC::MenuItem", &arg2);
            if (!ok) { break; }

            cocos2d::MenuItem* arg3;
            ok = rubyval_to_object<cocos2d::MenuItem>(mrb, argv[3], "CC::MenuItem", &arg3);
            if (!ok) { break; }

            cocos2d::MenuItem* arg4;
            ok = rubyval_to_object<cocos2d::MenuItem>(mrb, argv[4], "CC::MenuItem", &arg4);
            if (!ok) { break; }

            cocos2d::Menu* retval = cocos2d::Menu::create(arg0, arg1, arg2, arg3, arg4, NULL);
            mrb_value ret;
            RClass* rclass = mrb_class_ptr(self);
            ret = object_to_rubyval<cocos2d::Menu>(mrb, "CC::Menu", (cocos2d::Menu*)retval, rclass);
            if (callbacks.size() > 0) {
                mrb_value hash = mrb_iv_get(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"));
                if (!mrb_hash_p(hash)) {
                    hash = mrb_hash_new(mrb);
                }
                for (auto elm : callbacks) {
                    mrb_hash_set(mrb, hash, mrb_str_new_cstr(mrb, elm.first.c_str()), elm.second);
                    mrb_iv_set(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"), hash);
                }
            }
            g_rubyValue.push_back(ret);
            mrb_funcall(mrb, ret, "initialize", 0);
            return ret;
        }
        if (argc == 6) {
            std::map<std::string, mrb_value> callbacks;
            cocos2d::MenuItem* arg0;
            ok = rubyval_to_object<cocos2d::MenuItem>(mrb, argv[0], "CC::MenuItem", &arg0);
            if (!ok) { break; }

            cocos2d::MenuItem* arg1;
            ok = rubyval_to_object<cocos2d::MenuItem>(mrb, argv[1], "CC::MenuItem", &arg1);
            if (!ok) { break; }

            cocos2d::MenuItem* arg2;
            ok = rubyval_to_object<cocos2d::MenuItem>(mrb, argv[2], "CC::MenuItem", &arg2);
            if (!ok) { break; }

            cocos2d::MenuItem* arg3;
            ok = rubyval_to_object<cocos2d::MenuItem>(mrb, argv[3], "CC::MenuItem", &arg3);
            if (!ok) { break; }

            cocos2d::MenuItem* arg4;
            ok = rubyval_to_object<cocos2d::MenuItem>(mrb, argv[4], "CC::MenuItem", &arg4);
            if (!ok) { break; }

            cocos2d::MenuItem* arg5;
            ok = rubyval_to_object<cocos2d::MenuItem>(mrb, argv[5], "CC::MenuItem", &arg5);
            if (!ok) { break; }

            cocos2d::Menu* retval = cocos2d::Menu::create(arg0, arg1, arg2, arg3, arg4, arg5, NULL);
            mrb_value ret;
            RClass* rclass = mrb_class_ptr(self);
            ret = object_to_rubyval<cocos2d::Menu>(mrb, "CC::Menu", (cocos2d::Menu*)retval, rclass);
            if (callbacks.size() > 0) {
                mrb_value hash = mrb_iv_get(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"));
                if (!mrb_hash_p(hash)) {
                    hash = mrb_hash_new(mrb);
                }
                for (auto elm : callbacks) {
                    mrb_hash_set(mrb, hash, mrb_str_new_cstr(mrb, elm.first.c_str()), elm.second);
                    mrb_iv_set(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"), hash);
                }
            }
            g_rubyValue.push_back(ret);
            mrb_funcall(mrb, ret, "initialize", 0);
            return ret;
        }
        if (argc == 7) {
            std::map<std::string, mrb_value> callbacks;
            cocos2d::MenuItem* arg0;
            ok = rubyval_to_object<cocos2d::MenuItem>(mrb, argv[0], "CC::MenuItem", &arg0);
            if (!ok) { break; }

            cocos2d::MenuItem* arg1;
            ok = rubyval_to_object<cocos2d::MenuItem>(mrb, argv[1], "CC::MenuItem", &arg1);
            if (!ok) { break; }

            cocos2d::MenuItem* arg2;
            ok = rubyval_to_object<cocos2d::MenuItem>(mrb, argv[2], "CC::MenuItem", &arg2);
            if (!ok) { break; }

            cocos2d::MenuItem* arg3;
            ok = rubyval_to_object<cocos2d::MenuItem>(mrb, argv[3], "CC::MenuItem", &arg3);
            if (!ok) { break; }

            cocos2d::MenuItem* arg4;
            ok = rubyval_to_object<cocos2d::MenuItem>(mrb, argv[4], "CC::MenuItem", &arg4);
            if (!ok) { break; }

            cocos2d::MenuItem* arg5;
            ok = rubyval_to_object<cocos2d::MenuItem>(mrb, argv[5], "CC::MenuItem", &arg5);
            if (!ok) { break; }

            cocos2d::MenuItem* arg6;
            ok = rubyval_to_object<cocos2d::MenuItem>(mrb, argv[6], "CC::MenuItem", &arg6);
            if (!ok) { break; }

            cocos2d::Menu* retval = cocos2d::Menu::create(arg0, arg1, arg2, arg3, arg4, arg5, arg6, NULL);
            mrb_value ret;
            RClass* rclass = mrb_class_ptr(self);
            ret = object_to_rubyval<cocos2d::Menu>(mrb, "CC::Menu", (cocos2d::Menu*)retval, rclass);
            if (callbacks.size() > 0) {
                mrb_value hash = mrb_iv_get(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"));
                if (!mrb_hash_p(hash)) {
                    hash = mrb_hash_new(mrb);
                }
                for (auto elm : callbacks) {
                    mrb_hash_set(mrb, hash, mrb_str_new_cstr(mrb, elm.first.c_str()), elm.second);
                    mrb_iv_set(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"), hash);
                }
            }
            g_rubyValue.push_back(ret);
            mrb_funcall(mrb, ret, "initialize", 0);
            return ret;
        }
        if (argc == 8) {
            std::map<std::string, mrb_value> callbacks;
            cocos2d::MenuItem* arg0;
            ok = rubyval_to_object<cocos2d::MenuItem>(mrb, argv[0], "CC::MenuItem", &arg0);
            if (!ok) { break; }

            cocos2d::MenuItem* arg1;
            ok = rubyval_to_object<cocos2d::MenuItem>(mrb, argv[1], "CC::MenuItem", &arg1);
            if (!ok) { break; }

            cocos2d::MenuItem* arg2;
            ok = rubyval_to_object<cocos2d::MenuItem>(mrb, argv[2], "CC::MenuItem", &arg2);
            if (!ok) { break; }

            cocos2d::MenuItem* arg3;
            ok = rubyval_to_object<cocos2d::MenuItem>(mrb, argv[3], "CC::MenuItem", &arg3);
            if (!ok) { break; }

            cocos2d::MenuItem* arg4;
            ok = rubyval_to_object<cocos2d::MenuItem>(mrb, argv[4], "CC::MenuItem", &arg4);
            if (!ok) { break; }

            cocos2d::MenuItem* arg5;
            ok = rubyval_to_object<cocos2d::MenuItem>(mrb, argv[5], "CC::MenuItem", &arg5);
            if (!ok) { break; }

            cocos2d::MenuItem* arg6;
            ok = rubyval_to_object<cocos2d::MenuItem>(mrb, argv[6], "CC::MenuItem", &arg6);
            if (!ok) { break; }

            cocos2d::MenuItem* arg7;
            ok = rubyval_to_object<cocos2d::MenuItem>(mrb, argv[7], "CC::MenuItem", &arg7);
            if (!ok) { break; }

            cocos2d::Menu* retval = cocos2d::Menu::create(arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7, NULL);
            mrb_value ret;
            RClass* rclass = mrb_class_ptr(self);
            ret = object_to_rubyval<cocos2d::Menu>(mrb, "CC::Menu", (cocos2d::Menu*)retval, rclass);
            if (callbacks.size() > 0) {
                mrb_value hash = mrb_iv_get(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"));
                if (!mrb_hash_p(hash)) {
                    hash = mrb_hash_new(mrb);
                }
                for (auto elm : callbacks) {
                    mrb_hash_set(mrb, hash, mrb_str_new_cstr(mrb, elm.first.c_str()), elm.second);
                    mrb_iv_set(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"), hash);
                }
            }
            g_rubyValue.push_back(ret);
            mrb_funcall(mrb, ret, "initialize", 0);
            return ret;
        }
        if (argc == 9) {
            std::map<std::string, mrb_value> callbacks;
            cocos2d::MenuItem* arg0;
            ok = rubyval_to_object<cocos2d::MenuItem>(mrb, argv[0], "CC::MenuItem", &arg0);
            if (!ok) { break; }

            cocos2d::MenuItem* arg1;
            ok = rubyval_to_object<cocos2d::MenuItem>(mrb, argv[1], "CC::MenuItem", &arg1);
            if (!ok) { break; }

            cocos2d::MenuItem* arg2;
            ok = rubyval_to_object<cocos2d::MenuItem>(mrb, argv[2], "CC::MenuItem", &arg2);
            if (!ok) { break; }

            cocos2d::MenuItem* arg3;
            ok = rubyval_to_object<cocos2d::MenuItem>(mrb, argv[3], "CC::MenuItem", &arg3);
            if (!ok) { break; }

            cocos2d::MenuItem* arg4;
            ok = rubyval_to_object<cocos2d::MenuItem>(mrb, argv[4], "CC::MenuItem", &arg4);
            if (!ok) { break; }

            cocos2d::MenuItem* arg5;
            ok = rubyval_to_object<cocos2d::MenuItem>(mrb, argv[5], "CC::MenuItem", &arg5);
            if (!ok) { break; }

            cocos2d::MenuItem* arg6;
            ok = rubyval_to_object<cocos2d::MenuItem>(mrb, argv[6], "CC::MenuItem", &arg6);
            if (!ok) { break; }

            cocos2d::MenuItem* arg7;
            ok = rubyval_to_object<cocos2d::MenuItem>(mrb, argv[7], "CC::MenuItem", &arg7);
            if (!ok) { break; }

            cocos2d::MenuItem* arg8;
            ok = rubyval_to_object<cocos2d::MenuItem>(mrb, argv[8], "CC::MenuItem", &arg8);
            if (!ok) { break; }

            cocos2d::Menu* retval = cocos2d::Menu::create(arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, NULL);
            mrb_value ret;
            RClass* rclass = mrb_class_ptr(self);
            ret = object_to_rubyval<cocos2d::Menu>(mrb, "CC::Menu", (cocos2d::Menu*)retval, rclass);
            if (callbacks.size() > 0) {
                mrb_value hash = mrb_iv_get(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"));
                if (!mrb_hash_p(hash)) {
                    hash = mrb_hash_new(mrb);
                }
                for (auto elm : callbacks) {
                    mrb_hash_set(mrb, hash, mrb_str_new_cstr(mrb, elm.first.c_str()), elm.second);
                    mrb_iv_set(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"), hash);
                }
            }
            g_rubyValue.push_back(ret);
            mrb_funcall(mrb, ret, "initialize", 0);
            return ret;
        }
        if (argc == 10) {
            std::map<std::string, mrb_value> callbacks;
            cocos2d::MenuItem* arg0;
            ok = rubyval_to_object<cocos2d::MenuItem>(mrb, argv[0], "CC::MenuItem", &arg0);
            if (!ok) { break; }

            cocos2d::MenuItem* arg1;
            ok = rubyval_to_object<cocos2d::MenuItem>(mrb, argv[1], "CC::MenuItem", &arg1);
            if (!ok) { break; }

            cocos2d::MenuItem* arg2;
            ok = rubyval_to_object<cocos2d::MenuItem>(mrb, argv[2], "CC::MenuItem", &arg2);
            if (!ok) { break; }

            cocos2d::MenuItem* arg3;
            ok = rubyval_to_object<cocos2d::MenuItem>(mrb, argv[3], "CC::MenuItem", &arg3);
            if (!ok) { break; }

            cocos2d::MenuItem* arg4;
            ok = rubyval_to_object<cocos2d::MenuItem>(mrb, argv[4], "CC::MenuItem", &arg4);
            if (!ok) { break; }

            cocos2d::MenuItem* arg5;
            ok = rubyval_to_object<cocos2d::MenuItem>(mrb, argv[5], "CC::MenuItem", &arg5);
            if (!ok) { break; }

            cocos2d::MenuItem* arg6;
            ok = rubyval_to_object<cocos2d::MenuItem>(mrb, argv[6], "CC::MenuItem", &arg6);
            if (!ok) { break; }

            cocos2d::MenuItem* arg7;
            ok = rubyval_to_object<cocos2d::MenuItem>(mrb, argv[7], "CC::MenuItem", &arg7);
            if (!ok) { break; }

            cocos2d::MenuItem* arg8;
            ok = rubyval_to_object<cocos2d::MenuItem>(mrb, argv[8], "CC::MenuItem", &arg8);
            if (!ok) { break; }

            cocos2d::MenuItem* arg9;
            ok = rubyval_to_object<cocos2d::MenuItem>(mrb, argv[9], "CC::MenuItem", &arg9);
            if (!ok) { break; }

            cocos2d::Menu* retval = cocos2d::Menu::create(arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, NULL);
            mrb_value ret;
            RClass* rclass = mrb_class_ptr(self);
            ret = object_to_rubyval<cocos2d::Menu>(mrb, "CC::Menu", (cocos2d::Menu*)retval, rclass);
            if (callbacks.size() > 0) {
                mrb_value hash = mrb_iv_get(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"));
                if (!mrb_hash_p(hash)) {
                    hash = mrb_hash_new(mrb);
                }
                for (auto elm : callbacks) {
                    mrb_hash_set(mrb, hash, mrb_str_new_cstr(mrb, elm.first.c_str()), elm.second);
                    mrb_iv_set(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"), hash);
                }
            }
            g_rubyValue.push_back(ret);
            mrb_funcall(mrb, ret, "initialize", 0);
            return ret;
        }
    } while (0);
    do {
        if (argc == 0) {
            std::map<std::string, mrb_value> callbacks;
            cocos2d::Menu* retval = cocos2d::Menu::create();
            mrb_value ret;
            RClass* rclass = mrb_class_ptr(self);
            ret = object_to_rubyval<cocos2d::Menu>(mrb, "CC::Menu", (cocos2d::Menu*)retval, rclass);
            if (callbacks.size() > 0) {
                mrb_value hash = mrb_iv_get(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"));
                if (!mrb_hash_p(hash)) {
                    hash = mrb_hash_new(mrb);
                }
                for (auto elm : callbacks) {
                    mrb_hash_set(mrb, hash, mrb_str_new_cstr(mrb, elm.first.c_str()), elm.second);
                    mrb_iv_set(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"), hash);
                }
            }
            g_rubyValue.push_back(ret);
            mrb_funcall(mrb, ret, "initialize", 0);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined static method : cocos2d::Menu#create");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Menu_createWithArray_static(mrb_state* mrb, mrb_value self)
{
    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            std::map<std::string, mrb_value> callbacks;
            cocos2d::Vector<cocos2d::MenuItem *> arg0;
            ok = rubyval_to_ccvector(mrb, argv[0], &arg0, "CC::Menu.createWithArray");
            if (!ok) { break; }

            cocos2d::Menu* retval = cocos2d::Menu::createWithArray(arg0);
            mrb_value ret;
            RClass* rclass = mrb_class_ptr(self);
            ret = object_to_rubyval<cocos2d::Menu>(mrb, "CC::Menu", (cocos2d::Menu*)retval, rclass);
            if (callbacks.size() > 0) {
                mrb_value hash = mrb_iv_get(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"));
                if (!mrb_hash_p(hash)) {
                    hash = mrb_hash_new(mrb);
                }
                for (auto elm : callbacks) {
                    mrb_hash_set(mrb, hash, mrb_str_new_cstr(mrb, elm.first.c_str()), elm.second);
                    mrb_iv_set(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"), hash);
                }
            }
            g_rubyValue.push_back(ret);
            mrb_funcall(mrb, ret, "initialize", 0);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined static method : cocos2d::Menu#createWithArray");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Menu_createWithItem_static(mrb_state* mrb, mrb_value self)
{
    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            std::map<std::string, mrb_value> callbacks;
            cocos2d::MenuItem* arg0;
            ok = rubyval_to_object<cocos2d::MenuItem>(mrb, argv[0], "CC::MenuItem", &arg0);
            if (!ok) { break; }

            cocos2d::Menu* retval = cocos2d::Menu::createWithItem(arg0);
            mrb_value ret;
            RClass* rclass = mrb_class_ptr(self);
            ret = object_to_rubyval<cocos2d::Menu>(mrb, "CC::Menu", (cocos2d::Menu*)retval, rclass);
            if (callbacks.size() > 0) {
                mrb_value hash = mrb_iv_get(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"));
                if (!mrb_hash_p(hash)) {
                    hash = mrb_hash_new(mrb);
                }
                for (auto elm : callbacks) {
                    mrb_hash_set(mrb, hash, mrb_str_new_cstr(mrb, elm.first.c_str()), elm.second);
                    mrb_iv_set(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"), hash);
                }
            }
            g_rubyValue.push_back(ret);
            mrb_funcall(mrb, ret, "initialize", 0);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined static method : cocos2d::Menu#createWithItem");

    return mrb_nil_value();
}

void ruby_cocos2dx_Menu_State_enum_init(mrb_state* mrb, struct RClass* renum)
{
    do {
        mrb_value ev = mrb_fixnum_value((mrb_int)cocos2d::Menu::State::WAITING);
        mrb_mod_cv_set(mrb, renum, mrb_intern_cstr(mrb, "WAITING"), ev);
    } while (0);

    do {
        mrb_value ev = mrb_fixnum_value((mrb_int)cocos2d::Menu::State::TRACKING_TOUCH);
        mrb_mod_cv_set(mrb, renum, mrb_intern_cstr(mrb, "TRACKING_TOUCH"), ev);
    } while (0);

}

void ruby_register_cocos2dx_Menu(mrb_state* mrb, struct RClass* rmodule)
{
    std::string typeName = typeid(cocos2d::Menu).name();
    g_rubyType[typeName] = "CC::Menu";
    g_rubyDataType[typeName] = &ruby_cocos2dx_Ref_type;

    struct RClass* p_rmodule = mrb->object_class;
    p_rmodule = mrb_module_get_under(mrb, p_rmodule, "CC");
    struct RClass* p_rclass = mrb_class_get_under(mrb, p_rmodule, "Layer");
    struct RClass *rclass = mrb_define_class_under(mrb, rmodule, "Menu", p_rclass);
    MRB_SET_INSTANCE_TT(rclass, MRB_TT_DATA);

    mrb_define_method(mrb, rclass, "set_enabled", ruby_cocos2dx_Menu_setEnabled, ARGS_REQ(1));
    mrb_define_method(mrb, rclass, "align_items_vertically", ruby_cocos2dx_Menu_alignItemsVertically, ARGS_NONE());
    mrb_define_method(mrb, rclass, "enabled?", ruby_cocos2dx_Menu_isEnabled, ARGS_NONE());
    mrb_define_method(mrb, rclass, "align_items_in_rows_with_array", ruby_cocos2dx_Menu_alignItemsInRowsWithArray, ARGS_REQ(1));
    mrb_define_method(mrb, rclass, "align_items_horizontally", ruby_cocos2dx_Menu_alignItemsHorizontally, ARGS_NONE());
    mrb_define_method(mrb, rclass, "align_items_horizontally_with_padding", ruby_cocos2dx_Menu_alignItemsHorizontallyWithPadding, ARGS_REQ(1));
    mrb_define_method(mrb, rclass, "align_items_in_columns_with_array", ruby_cocos2dx_Menu_alignItemsInColumnsWithArray, ARGS_REQ(1));
    mrb_define_method(mrb, rclass, "align_items_vertically_with_padding", ruby_cocos2dx_Menu_alignItemsVerticallyWithPadding, ARGS_REQ(1));
    mrb_define_method(mrb, rclass, "align_items_in_rows", ruby_cocos2dx_Menu_alignItemsInRows, ARGS_REQ(1));
    mrb_define_method(mrb, rclass, "align_items_in_columns", ruby_cocos2dx_Menu_alignItemsInColumns, ARGS_REQ(1));
    mrb_define_class_method(mrb, rclass, "create", ruby_cocos2dx_Menu_create_static, ARGS_REQ(0)|ARGS_OPT(1));
    mrb_define_class_method(mrb, rclass, "create_with_array", ruby_cocos2dx_Menu_createWithArray_static, ARGS_REQ(1));
    mrb_define_class_method(mrb, rclass, "create_with_item", ruby_cocos2dx_Menu_createWithItem_static, ARGS_REQ(1));
    struct RClass* renum_State = mrb_define_module_under(mrb, rclass, "State");
    ruby_cocos2dx_Menu_State_enum_init(mrb, renum_State);
    mrb_define_class_method(mrb, renum_State, "WAITING", ruby_cocos2dx_constant_get, ARGS_NONE());
    mrb_define_class_method(mrb, renum_State, "TRACKING_TOUCH", ruby_cocos2dx_constant_get, ARGS_NONE());
}
mrb_value ruby_cocos2dx_ClippingNode_hasContent(mrb_state* mrb, mrb_value self)
{
    cocos2d::ClippingNode* cobj = static_cast<cocos2d::ClippingNode*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            bool retval = cobj->hasContent();
            mrb_value ret;
            ret = mrb_bool_value((mrb_bool)retval);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::ClippingNode#hasContent");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_ClippingNode_setInverted(mrb_state* mrb, mrb_value self)
{
    cocos2d::ClippingNode* cobj = static_cast<cocos2d::ClippingNode*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            bool arg0;
            ok = rubyval_to_boolean(mrb, argv[0], &arg0, "CC::ClippingNode.setInverted");
            if (!ok) { break; }
            cobj->setInverted(arg0);
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::ClippingNode#setInverted");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_ClippingNode_setStencil(mrb_state* mrb, mrb_value self)
{
    cocos2d::ClippingNode* cobj = static_cast<cocos2d::ClippingNode*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            cocos2d::Node* arg0;
            ok = rubyval_to_object<cocos2d::Node>(mrb, argv[0], "CC::Node", &arg0);
            if (!ok) { break; }
            cobj->setStencil(arg0);
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::ClippingNode#setStencil");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_ClippingNode_getAlphaThreshold(mrb_state* mrb, mrb_value self)
{
    cocos2d::ClippingNode* cobj = static_cast<cocos2d::ClippingNode*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            double retval = cobj->getAlphaThreshold();
            mrb_value ret;
            ret = mrb_float_value(mrb, (mrb_float)retval);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::ClippingNode#getAlphaThreshold");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_ClippingNode_getStencil(mrb_state* mrb, mrb_value self)
{
    cocos2d::ClippingNode* cobj = static_cast<cocos2d::ClippingNode*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            cocos2d::Node* retval = cobj->getStencil();
            mrb_value ret;
            ret = object_to_rubyval<cocos2d::Node>(mrb, "CC::Node", (cocos2d::Node*)retval, nullptr);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::ClippingNode#getStencil");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_ClippingNode_setAlphaThreshold(mrb_state* mrb, mrb_value self)
{
    cocos2d::ClippingNode* cobj = static_cast<cocos2d::ClippingNode*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            double arg0;
            ok = rubyval_to_number(mrb, argv[0], (double*)&arg0, "CC::ClippingNode.setAlphaThreshold");
            if (!ok) { break; }
            cobj->setAlphaThreshold(arg0);
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::ClippingNode#setAlphaThreshold");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_ClippingNode_isInverted(mrb_state* mrb, mrb_value self)
{
    cocos2d::ClippingNode* cobj = static_cast<cocos2d::ClippingNode*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            bool retval = cobj->isInverted();
            mrb_value ret;
            ret = mrb_bool_value((mrb_bool)retval);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::ClippingNode#isInverted");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_ClippingNode_create_static(mrb_state* mrb, mrb_value self)
{
    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            std::map<std::string, mrb_value> callbacks;
            cocos2d::Node* arg0;
            ok = rubyval_to_object<cocos2d::Node>(mrb, argv[0], "CC::Node", &arg0);
            if (!ok) { break; }

            cocos2d::ClippingNode* retval = cocos2d::ClippingNode::create(arg0);
            mrb_value ret;
            RClass* rclass = mrb_class_ptr(self);
            ret = object_to_rubyval<cocos2d::ClippingNode>(mrb, "CC::ClippingNode", (cocos2d::ClippingNode*)retval, rclass);
            if (callbacks.size() > 0) {
                mrb_value hash = mrb_iv_get(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"));
                if (!mrb_hash_p(hash)) {
                    hash = mrb_hash_new(mrb);
                }
                for (auto elm : callbacks) {
                    mrb_hash_set(mrb, hash, mrb_str_new_cstr(mrb, elm.first.c_str()), elm.second);
                    mrb_iv_set(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"), hash);
                }
            }
            g_rubyValue.push_back(ret);
            mrb_funcall(mrb, ret, "initialize", 0);
            return ret;
        }
    } while (0);
    do {
        if (argc == 0) {
            std::map<std::string, mrb_value> callbacks;
            cocos2d::ClippingNode* retval = cocos2d::ClippingNode::create();
            mrb_value ret;
            RClass* rclass = mrb_class_ptr(self);
            ret = object_to_rubyval<cocos2d::ClippingNode>(mrb, "CC::ClippingNode", (cocos2d::ClippingNode*)retval, rclass);
            if (callbacks.size() > 0) {
                mrb_value hash = mrb_iv_get(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"));
                if (!mrb_hash_p(hash)) {
                    hash = mrb_hash_new(mrb);
                }
                for (auto elm : callbacks) {
                    mrb_hash_set(mrb, hash, mrb_str_new_cstr(mrb, elm.first.c_str()), elm.second);
                    mrb_iv_set(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"), hash);
                }
            }
            g_rubyValue.push_back(ret);
            mrb_funcall(mrb, ret, "initialize", 0);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined static method : cocos2d::ClippingNode#create");

    return mrb_nil_value();
}

void ruby_register_cocos2dx_ClippingNode(mrb_state* mrb, struct RClass* rmodule)
{
    std::string typeName = typeid(cocos2d::ClippingNode).name();
    g_rubyType[typeName] = "CC::ClippingNode";
    g_rubyDataType[typeName] = &ruby_cocos2dx_Ref_type;

    struct RClass* p_rmodule = mrb->object_class;
    p_rmodule = mrb_module_get_under(mrb, p_rmodule, "CC");
    struct RClass* p_rclass = mrb_class_get_under(mrb, p_rmodule, "Node");
    struct RClass *rclass = mrb_define_class_under(mrb, rmodule, "ClippingNode", p_rclass);
    MRB_SET_INSTANCE_TT(rclass, MRB_TT_DATA);

    mrb_define_method(mrb, rclass, "has_content", ruby_cocos2dx_ClippingNode_hasContent, ARGS_NONE());
    mrb_define_method(mrb, rclass, "set_inverted", ruby_cocos2dx_ClippingNode_setInverted, ARGS_REQ(1));
    mrb_define_method(mrb, rclass, "set_stencil", ruby_cocos2dx_ClippingNode_setStencil, ARGS_REQ(1));
    mrb_define_method(mrb, rclass, "get_alpha_threshold", ruby_cocos2dx_ClippingNode_getAlphaThreshold, ARGS_NONE());
    mrb_define_method(mrb, rclass, "get_stencil", ruby_cocos2dx_ClippingNode_getStencil, ARGS_NONE());
    mrb_define_method(mrb, rclass, "set_alpha_threshold", ruby_cocos2dx_ClippingNode_setAlphaThreshold, ARGS_REQ(1));
    mrb_define_method(mrb, rclass, "inverted?", ruby_cocos2dx_ClippingNode_isInverted, ARGS_NONE());
    mrb_define_class_method(mrb, rclass, "create", ruby_cocos2dx_ClippingNode_create_static, ARGS_REQ(0)|ARGS_OPT(1));
}
mrb_value ruby_cocos2dx_ClippingRectangleNode_isClippingEnabled(mrb_state* mrb, mrb_value self)
{
    cocos2d::ClippingRectangleNode* cobj = static_cast<cocos2d::ClippingRectangleNode*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            bool retval = cobj->isClippingEnabled();
            mrb_value ret;
            ret = mrb_bool_value((mrb_bool)retval);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::ClippingRectangleNode#isClippingEnabled");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_ClippingRectangleNode_setClippingEnabled(mrb_state* mrb, mrb_value self)
{
    cocos2d::ClippingRectangleNode* cobj = static_cast<cocos2d::ClippingRectangleNode*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            bool arg0;
            ok = rubyval_to_boolean(mrb, argv[0], &arg0, "CC::ClippingRectangleNode.setClippingEnabled");
            if (!ok) { break; }
            cobj->setClippingEnabled(arg0);
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::ClippingRectangleNode#setClippingEnabled");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_ClippingRectangleNode_getClippingRegion(mrb_state* mrb, mrb_value self)
{
    cocos2d::ClippingRectangleNode* cobj = static_cast<cocos2d::ClippingRectangleNode*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            cocos2d::Rect retval = cobj->getClippingRegion();
            cocos2d::Rect* retval_ptr = new cocos2d::Rect(retval);
            mrb_value ret;
            ret = object_to_rubyval<cocos2d::Rect>(mrb, "CC::Rect", (cocos2d::Rect*)retval_ptr, nullptr);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::ClippingRectangleNode#getClippingRegion");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_ClippingRectangleNode_setClippingRegion(mrb_state* mrb, mrb_value self)
{
    cocos2d::ClippingRectangleNode* cobj = static_cast<cocos2d::ClippingRectangleNode*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            cocos2d::Rect* arg0;
            ok = rubyval_to_object<cocos2d::Rect>(mrb, argv[0], "CC::Rect", &arg0);
            if (!ok) { break; }
            cobj->setClippingRegion(*arg0);
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::ClippingRectangleNode#setClippingRegion");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_ClippingRectangleNode_create_static(mrb_state* mrb, mrb_value self)
{
    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 0) {
            std::map<std::string, mrb_value> callbacks;
            cocos2d::ClippingRectangleNode* retval = cocos2d::ClippingRectangleNode::create();
            mrb_value ret;
            RClass* rclass = mrb_class_ptr(self);
            ret = object_to_rubyval<cocos2d::ClippingRectangleNode>(mrb, "CC::ClippingRectangleNode", (cocos2d::ClippingRectangleNode*)retval, rclass);
            if (callbacks.size() > 0) {
                mrb_value hash = mrb_iv_get(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"));
                if (!mrb_hash_p(hash)) {
                    hash = mrb_hash_new(mrb);
                }
                for (auto elm : callbacks) {
                    mrb_hash_set(mrb, hash, mrb_str_new_cstr(mrb, elm.first.c_str()), elm.second);
                    mrb_iv_set(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"), hash);
                }
            }
            g_rubyValue.push_back(ret);
            mrb_funcall(mrb, ret, "initialize", 0);
            return ret;
        }
    } while (0);
    do {
        if (argc == 1) {
            std::map<std::string, mrb_value> callbacks;
            cocos2d::Rect* arg0;
            ok = rubyval_to_object<cocos2d::Rect>(mrb, argv[0], "CC::Rect", &arg0);
            if (!ok) { break; }

            cocos2d::ClippingRectangleNode* retval = cocos2d::ClippingRectangleNode::create(*arg0);
            mrb_value ret;
            RClass* rclass = mrb_class_ptr(self);
            ret = object_to_rubyval<cocos2d::ClippingRectangleNode>(mrb, "CC::ClippingRectangleNode", (cocos2d::ClippingRectangleNode*)retval, rclass);
            if (callbacks.size() > 0) {
                mrb_value hash = mrb_iv_get(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"));
                if (!mrb_hash_p(hash)) {
                    hash = mrb_hash_new(mrb);
                }
                for (auto elm : callbacks) {
                    mrb_hash_set(mrb, hash, mrb_str_new_cstr(mrb, elm.first.c_str()), elm.second);
                    mrb_iv_set(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"), hash);
                }
            }
            g_rubyValue.push_back(ret);
            mrb_funcall(mrb, ret, "initialize", 0);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined static method : cocos2d::ClippingRectangleNode#create");

    return mrb_nil_value();
}

void ruby_register_cocos2dx_ClippingRectangleNode(mrb_state* mrb, struct RClass* rmodule)
{
    std::string typeName = typeid(cocos2d::ClippingRectangleNode).name();
    g_rubyType[typeName] = "CC::ClippingRectangleNode";
    g_rubyDataType[typeName] = &ruby_cocos2dx_Ref_type;

    struct RClass* p_rmodule = mrb->object_class;
    p_rmodule = mrb_module_get_under(mrb, p_rmodule, "CC");
    struct RClass* p_rclass = mrb_class_get_under(mrb, p_rmodule, "Node");
    struct RClass *rclass = mrb_define_class_under(mrb, rmodule, "ClippingRectangleNode", p_rclass);
    MRB_SET_INSTANCE_TT(rclass, MRB_TT_DATA);

    mrb_define_method(mrb, rclass, "clipping_enabled?", ruby_cocos2dx_ClippingRectangleNode_isClippingEnabled, ARGS_NONE());
    mrb_define_method(mrb, rclass, "set_clipping_enabled", ruby_cocos2dx_ClippingRectangleNode_setClippingEnabled, ARGS_REQ(1));
    mrb_define_method(mrb, rclass, "get_clipping_region", ruby_cocos2dx_ClippingRectangleNode_getClippingRegion, ARGS_NONE());
    mrb_define_method(mrb, rclass, "set_clipping_region", ruby_cocos2dx_ClippingRectangleNode_setClippingRegion, ARGS_REQ(1));
    mrb_define_class_method(mrb, rclass, "create", ruby_cocos2dx_ClippingRectangleNode_create_static, ARGS_REQ(0)|ARGS_OPT(1));
}
mrb_value ruby_cocos2dx_MotionStreak_reset(mrb_state* mrb, mrb_value self)
{
    cocos2d::MotionStreak* cobj = static_cast<cocos2d::MotionStreak*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            cobj->reset();
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::MotionStreak#reset");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_MotionStreak_setTexture(mrb_state* mrb, mrb_value self)
{
    cocos2d::MotionStreak* cobj = static_cast<cocos2d::MotionStreak*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            cocos2d::Texture2D* arg0;
            ok = rubyval_to_object<cocos2d::Texture2D>(mrb, argv[0], "CC::Texture2D", &arg0);
            if (!ok) { break; }
            cobj->setTexture(arg0);
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::MotionStreak#setTexture");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_MotionStreak_getTexture(mrb_state* mrb, mrb_value self)
{
    cocos2d::MotionStreak* cobj = static_cast<cocos2d::MotionStreak*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            cocos2d::Texture2D* retval = cobj->getTexture();
            mrb_value ret;
            ret = object_to_rubyval<cocos2d::Texture2D>(mrb, "CC::Texture2D", (cocos2d::Texture2D*)retval, nullptr);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::MotionStreak#getTexture");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_MotionStreak_tintWithColor(mrb_state* mrb, mrb_value self)
{
    cocos2d::MotionStreak* cobj = static_cast<cocos2d::MotionStreak*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            cocos2d::Color3B* arg0;
            ok = rubyval_to_object<cocos2d::Color3B>(mrb, argv[0], "CC::Color3B", &arg0);
            if (!ok) { break; }
            cobj->tintWithColor(*arg0);
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::MotionStreak#tintWithColor");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_MotionStreak_setBlendFunc(mrb_state* mrb, mrb_value self)
{
    cocos2d::MotionStreak* cobj = static_cast<cocos2d::MotionStreak*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            cocos2d::BlendFunc* arg0;
            ok = rubyval_to_object<cocos2d::BlendFunc>(mrb, argv[0], "CC::BlendFunc", &arg0);
            if (!ok) { break; }
            cobj->setBlendFunc(*arg0);
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::MotionStreak#setBlendFunc");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_MotionStreak_setStartingPositionInitialized(mrb_state* mrb, mrb_value self)
{
    cocos2d::MotionStreak* cobj = static_cast<cocos2d::MotionStreak*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            bool arg0;
            ok = rubyval_to_boolean(mrb, argv[0], &arg0, "CC::MotionStreak.setStartingPositionInitialized");
            if (!ok) { break; }
            cobj->setStartingPositionInitialized(arg0);
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::MotionStreak#setStartingPositionInitialized");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_MotionStreak_getBlendFunc(mrb_state* mrb, mrb_value self)
{
    cocos2d::MotionStreak* cobj = static_cast<cocos2d::MotionStreak*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            cocos2d::BlendFunc retval = cobj->getBlendFunc();
            cocos2d::BlendFunc* retval_ptr = new cocos2d::BlendFunc(retval);
            mrb_value ret;
            ret = object_to_rubyval<cocos2d::BlendFunc>(mrb, "CC::BlendFunc", (cocos2d::BlendFunc*)retval_ptr, nullptr);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::MotionStreak#getBlendFunc");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_MotionStreak_isStartingPositionInitialized(mrb_state* mrb, mrb_value self)
{
    cocos2d::MotionStreak* cobj = static_cast<cocos2d::MotionStreak*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            bool retval = cobj->isStartingPositionInitialized();
            mrb_value ret;
            ret = mrb_bool_value((mrb_bool)retval);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::MotionStreak#isStartingPositionInitialized");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_MotionStreak_isFastMode(mrb_state* mrb, mrb_value self)
{
    cocos2d::MotionStreak* cobj = static_cast<cocos2d::MotionStreak*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            bool retval = cobj->isFastMode();
            mrb_value ret;
            ret = mrb_bool_value((mrb_bool)retval);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::MotionStreak#isFastMode");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_MotionStreak_setFastMode(mrb_state* mrb, mrb_value self)
{
    cocos2d::MotionStreak* cobj = static_cast<cocos2d::MotionStreak*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            bool arg0;
            ok = rubyval_to_boolean(mrb, argv[0], &arg0, "CC::MotionStreak.setFastMode");
            if (!ok) { break; }
            cobj->setFastMode(arg0);
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::MotionStreak#setFastMode");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_MotionStreak_create_static(mrb_state* mrb, mrb_value self)
{
    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 5) {
            std::map<std::string, mrb_value> callbacks;
            double arg0;
            ok = rubyval_to_number(mrb, argv[0], (double*)&arg0, "CC::MotionStreak.create");
            if (!ok) { break; }

            double arg1;
            ok = rubyval_to_number(mrb, argv[1], (double*)&arg1, "CC::MotionStreak.create");
            if (!ok) { break; }

            double arg2;
            ok = rubyval_to_number(mrb, argv[2], (double*)&arg2, "CC::MotionStreak.create");
            if (!ok) { break; }

            cocos2d::Color3B* arg3;
            ok = rubyval_to_object<cocos2d::Color3B>(mrb, argv[3], "CC::Color3B", &arg3);
            if (!ok) { break; }

            cocos2d::Texture2D* arg4;
            ok = rubyval_to_object<cocos2d::Texture2D>(mrb, argv[4], "CC::Texture2D", &arg4);
            if (!ok) { break; }

            cocos2d::MotionStreak* retval = cocos2d::MotionStreak::create(arg0, arg1, arg2, *arg3, arg4);
            mrb_value ret;
            RClass* rclass = mrb_class_ptr(self);
            ret = object_to_rubyval<cocos2d::MotionStreak>(mrb, "CC::MotionStreak", (cocos2d::MotionStreak*)retval, rclass);
            if (callbacks.size() > 0) {
                mrb_value hash = mrb_iv_get(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"));
                if (!mrb_hash_p(hash)) {
                    hash = mrb_hash_new(mrb);
                }
                for (auto elm : callbacks) {
                    mrb_hash_set(mrb, hash, mrb_str_new_cstr(mrb, elm.first.c_str()), elm.second);
                    mrb_iv_set(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"), hash);
                }
            }
            g_rubyValue.push_back(ret);
            mrb_funcall(mrb, ret, "initialize", 0);
            return ret;
        }
    } while (0);
    do {
        if (argc == 5) {
            std::map<std::string, mrb_value> callbacks;
            double arg0;
            ok = rubyval_to_number(mrb, argv[0], (double*)&arg0, "CC::MotionStreak.create");
            if (!ok) { break; }

            double arg1;
            ok = rubyval_to_number(mrb, argv[1], (double*)&arg1, "CC::MotionStreak.create");
            if (!ok) { break; }

            double arg2;
            ok = rubyval_to_number(mrb, argv[2], (double*)&arg2, "CC::MotionStreak.create");
            if (!ok) { break; }

            cocos2d::Color3B* arg3;
            ok = rubyval_to_object<cocos2d::Color3B>(mrb, argv[3], "CC::Color3B", &arg3);
            if (!ok) { break; }

            std::string arg4;
            ok = rubyval_to_std_string(mrb, argv[4], &arg4, "CC::MotionStreak.create");
            if (!ok) { break; }

            cocos2d::MotionStreak* retval = cocos2d::MotionStreak::create(arg0, arg1, arg2, *arg3, arg4);
            mrb_value ret;
            RClass* rclass = mrb_class_ptr(self);
            ret = object_to_rubyval<cocos2d::MotionStreak>(mrb, "CC::MotionStreak", (cocos2d::MotionStreak*)retval, rclass);
            if (callbacks.size() > 0) {
                mrb_value hash = mrb_iv_get(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"));
                if (!mrb_hash_p(hash)) {
                    hash = mrb_hash_new(mrb);
                }
                for (auto elm : callbacks) {
                    mrb_hash_set(mrb, hash, mrb_str_new_cstr(mrb, elm.first.c_str()), elm.second);
                    mrb_iv_set(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"), hash);
                }
            }
            g_rubyValue.push_back(ret);
            mrb_funcall(mrb, ret, "initialize", 0);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined static method : cocos2d::MotionStreak#create");

    return mrb_nil_value();
}

void ruby_register_cocos2dx_MotionStreak(mrb_state* mrb, struct RClass* rmodule)
{
    std::string typeName = typeid(cocos2d::MotionStreak).name();
    g_rubyType[typeName] = "CC::MotionStreak";
    g_rubyDataType[typeName] = &ruby_cocos2dx_Ref_type;

    struct RClass* p_rmodule = mrb->object_class;
    p_rmodule = mrb_module_get_under(mrb, p_rmodule, "CC");
    struct RClass* p_rclass = mrb_class_get_under(mrb, p_rmodule, "Node");
    struct RClass *rclass = mrb_define_class_under(mrb, rmodule, "MotionStreak", p_rclass);
    MRB_SET_INSTANCE_TT(rclass, MRB_TT_DATA);

    mrb_define_method(mrb, rclass, "reset", ruby_cocos2dx_MotionStreak_reset, ARGS_NONE());
    mrb_define_method(mrb, rclass, "set_texture", ruby_cocos2dx_MotionStreak_setTexture, ARGS_REQ(1));
    mrb_define_method(mrb, rclass, "get_texture", ruby_cocos2dx_MotionStreak_getTexture, ARGS_NONE());
    mrb_define_method(mrb, rclass, "tint_with_color", ruby_cocos2dx_MotionStreak_tintWithColor, ARGS_REQ(1));
    mrb_define_method(mrb, rclass, "set_blend_func", ruby_cocos2dx_MotionStreak_setBlendFunc, ARGS_REQ(1));
    mrb_define_method(mrb, rclass, "set_starting_position_initialized", ruby_cocos2dx_MotionStreak_setStartingPositionInitialized, ARGS_REQ(1));
    mrb_define_method(mrb, rclass, "get_blend_func", ruby_cocos2dx_MotionStreak_getBlendFunc, ARGS_NONE());
    mrb_define_method(mrb, rclass, "starting_position_initialized?", ruby_cocos2dx_MotionStreak_isStartingPositionInitialized, ARGS_NONE());
    mrb_define_method(mrb, rclass, "fast_mode?", ruby_cocos2dx_MotionStreak_isFastMode, ARGS_NONE());
    mrb_define_method(mrb, rclass, "set_fast_mode", ruby_cocos2dx_MotionStreak_setFastMode, ARGS_REQ(1));
    mrb_define_class_method(mrb, rclass, "create", ruby_cocos2dx_MotionStreak_create_static, ARGS_REQ(5));
}
mrb_value ruby_cocos2dx_ProgressTimer_isReverseDirection(mrb_state* mrb, mrb_value self)
{
    cocos2d::ProgressTimer* cobj = static_cast<cocos2d::ProgressTimer*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            bool retval = cobj->isReverseDirection();
            mrb_value ret;
            ret = mrb_bool_value((mrb_bool)retval);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::ProgressTimer#isReverseDirection");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_ProgressTimer_setBarChangeRate(mrb_state* mrb, mrb_value self)
{
    cocos2d::ProgressTimer* cobj = static_cast<cocos2d::ProgressTimer*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            cocos2d::Vec2* arg0;
            ok = rubyval_to_object<cocos2d::Vec2>(mrb, argv[0], "CC::Vec2", &arg0);
            if (!ok) { break; }
            cobj->setBarChangeRate(*arg0);
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::ProgressTimer#setBarChangeRate");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_ProgressTimer_getPercentage(mrb_state* mrb, mrb_value self)
{
    cocos2d::ProgressTimer* cobj = static_cast<cocos2d::ProgressTimer*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            double retval = cobj->getPercentage();
            mrb_value ret;
            ret = mrb_float_value(mrb, (mrb_float)retval);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::ProgressTimer#getPercentage");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_ProgressTimer_setSprite(mrb_state* mrb, mrb_value self)
{
    cocos2d::ProgressTimer* cobj = static_cast<cocos2d::ProgressTimer*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            cocos2d::Sprite* arg0;
            ok = rubyval_to_object<cocos2d::Sprite>(mrb, argv[0], "CC::Sprite", &arg0);
            if (!ok) { break; }
            cobj->setSprite(arg0);
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::ProgressTimer#setSprite");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_ProgressTimer_getType(mrb_state* mrb, mrb_value self)
{
    cocos2d::ProgressTimer* cobj = static_cast<cocos2d::ProgressTimer*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            int retval = (int)cobj->getType();
            mrb_value ret;
            ret = mrb_fixnum_value((mrb_int)retval);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::ProgressTimer#getType");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_ProgressTimer_getSprite(mrb_state* mrb, mrb_value self)
{
    cocos2d::ProgressTimer* cobj = static_cast<cocos2d::ProgressTimer*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            cocos2d::Sprite* retval = cobj->getSprite();
            mrb_value ret;
            ret = object_to_rubyval<cocos2d::Sprite>(mrb, "CC::Sprite", (cocos2d::Sprite*)retval, nullptr);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::ProgressTimer#getSprite");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_ProgressTimer_setMidpoint(mrb_state* mrb, mrb_value self)
{
    cocos2d::ProgressTimer* cobj = static_cast<cocos2d::ProgressTimer*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            cocos2d::Vec2* arg0;
            ok = rubyval_to_object<cocos2d::Vec2>(mrb, argv[0], "CC::Vec2", &arg0);
            if (!ok) { break; }
            cobj->setMidpoint(*arg0);
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::ProgressTimer#setMidpoint");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_ProgressTimer_getBarChangeRate(mrb_state* mrb, mrb_value self)
{
    cocos2d::ProgressTimer* cobj = static_cast<cocos2d::ProgressTimer*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            cocos2d::Vec2 retval = cobj->getBarChangeRate();
            cocos2d::Vec2* retval_ptr = new cocos2d::Vec2(retval);
            mrb_value ret;
            ret = object_to_rubyval<cocos2d::Vec2>(mrb, "CC::Vec2", (cocos2d::Vec2*)retval_ptr, nullptr);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::ProgressTimer#getBarChangeRate");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_ProgressTimer_setReverseDirection(mrb_state* mrb, mrb_value self)
{
    cocos2d::ProgressTimer* cobj = static_cast<cocos2d::ProgressTimer*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            bool arg0;
            ok = rubyval_to_boolean(mrb, argv[0], &arg0, "CC::ProgressTimer.setReverseDirection");
            if (!ok) { break; }
            cobj->setReverseDirection(arg0);
            return self;
        }
    } while (0);
    do {
        if (argc == 1) {
            bool arg0;
            ok = rubyval_to_boolean(mrb, argv[0], &arg0, "CC::ProgressTimer.setReverseDirection");
            if (!ok) { break; }
            cobj->setReverseProgress(arg0);
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::ProgressTimer#setReverseDirection");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_ProgressTimer_getMidpoint(mrb_state* mrb, mrb_value self)
{
    cocos2d::ProgressTimer* cobj = static_cast<cocos2d::ProgressTimer*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            cocos2d::Vec2 retval = cobj->getMidpoint();
            cocos2d::Vec2* retval_ptr = new cocos2d::Vec2(retval);
            mrb_value ret;
            ret = object_to_rubyval<cocos2d::Vec2>(mrb, "CC::Vec2", (cocos2d::Vec2*)retval_ptr, nullptr);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::ProgressTimer#getMidpoint");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_ProgressTimer_setPercentage(mrb_state* mrb, mrb_value self)
{
    cocos2d::ProgressTimer* cobj = static_cast<cocos2d::ProgressTimer*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            double arg0;
            ok = rubyval_to_number(mrb, argv[0], (double*)&arg0, "CC::ProgressTimer.setPercentage");
            if (!ok) { break; }
            cobj->setPercentage(arg0);
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::ProgressTimer#setPercentage");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_ProgressTimer_setType(mrb_state* mrb, mrb_value self)
{
    cocos2d::ProgressTimer* cobj = static_cast<cocos2d::ProgressTimer*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            cocos2d::ProgressTimer::Type arg0;
            ok = rubyval_to_int32(mrb, argv[0], (int*)&arg0, "CC::ProgressTimer.setType");
            if (!ok) { break; }
            cobj->setType(arg0);
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::ProgressTimer#setType");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_ProgressTimer_create_static(mrb_state* mrb, mrb_value self)
{
    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            std::map<std::string, mrb_value> callbacks;
            cocos2d::Sprite* arg0;
            ok = rubyval_to_object<cocos2d::Sprite>(mrb, argv[0], "CC::Sprite", &arg0);
            if (!ok) { break; }

            cocos2d::ProgressTimer* retval = cocos2d::ProgressTimer::create(arg0);
            mrb_value ret;
            RClass* rclass = mrb_class_ptr(self);
            ret = object_to_rubyval<cocos2d::ProgressTimer>(mrb, "CC::ProgressTimer", (cocos2d::ProgressTimer*)retval, rclass);
            if (callbacks.size() > 0) {
                mrb_value hash = mrb_iv_get(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"));
                if (!mrb_hash_p(hash)) {
                    hash = mrb_hash_new(mrb);
                }
                for (auto elm : callbacks) {
                    mrb_hash_set(mrb, hash, mrb_str_new_cstr(mrb, elm.first.c_str()), elm.second);
                    mrb_iv_set(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"), hash);
                }
            }
            g_rubyValue.push_back(ret);
            mrb_funcall(mrb, ret, "initialize", 0);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined static method : cocos2d::ProgressTimer#create");

    return mrb_nil_value();
}

void ruby_cocos2dx_ProgressTimer_Type_enum_init(mrb_state* mrb, struct RClass* renum)
{
    do {
        mrb_value ev = mrb_fixnum_value((mrb_int)cocos2d::ProgressTimer::Type::RADIAL);
        mrb_mod_cv_set(mrb, renum, mrb_intern_cstr(mrb, "RADIAL"), ev);
    } while (0);

    do {
        mrb_value ev = mrb_fixnum_value((mrb_int)cocos2d::ProgressTimer::Type::BAR);
        mrb_mod_cv_set(mrb, renum, mrb_intern_cstr(mrb, "BAR"), ev);
    } while (0);

}

void ruby_register_cocos2dx_ProgressTimer(mrb_state* mrb, struct RClass* rmodule)
{
    std::string typeName = typeid(cocos2d::ProgressTimer).name();
    g_rubyType[typeName] = "CC::ProgressTimer";
    g_rubyDataType[typeName] = &ruby_cocos2dx_Ref_type;

    struct RClass* p_rmodule = mrb->object_class;
    p_rmodule = mrb_module_get_under(mrb, p_rmodule, "CC");
    struct RClass* p_rclass = mrb_class_get_under(mrb, p_rmodule, "Node");
    struct RClass *rclass = mrb_define_class_under(mrb, rmodule, "ProgressTimer", p_rclass);
    MRB_SET_INSTANCE_TT(rclass, MRB_TT_DATA);

    mrb_define_method(mrb, rclass, "reverse_direction?", ruby_cocos2dx_ProgressTimer_isReverseDirection, ARGS_NONE());
    mrb_define_method(mrb, rclass, "set_bar_change_rate", ruby_cocos2dx_ProgressTimer_setBarChangeRate, ARGS_REQ(1));
    mrb_define_method(mrb, rclass, "get_percentage", ruby_cocos2dx_ProgressTimer_getPercentage, ARGS_NONE());
    mrb_define_method(mrb, rclass, "set_sprite", ruby_cocos2dx_ProgressTimer_setSprite, ARGS_REQ(1));
    mrb_define_method(mrb, rclass, "get_type", ruby_cocos2dx_ProgressTimer_getType, ARGS_NONE());
    mrb_define_method(mrb, rclass, "get_sprite", ruby_cocos2dx_ProgressTimer_getSprite, ARGS_NONE());
    mrb_define_method(mrb, rclass, "set_midpoint", ruby_cocos2dx_ProgressTimer_setMidpoint, ARGS_REQ(1));
    mrb_define_method(mrb, rclass, "get_bar_change_rate", ruby_cocos2dx_ProgressTimer_getBarChangeRate, ARGS_NONE());
    mrb_define_method(mrb, rclass, "set_reverse_direction", ruby_cocos2dx_ProgressTimer_setReverseDirection, ARGS_REQ(1));
    mrb_define_method(mrb, rclass, "get_midpoint", ruby_cocos2dx_ProgressTimer_getMidpoint, ARGS_NONE());
    mrb_define_method(mrb, rclass, "set_percentage", ruby_cocos2dx_ProgressTimer_setPercentage, ARGS_REQ(1));
    mrb_define_method(mrb, rclass, "set_type", ruby_cocos2dx_ProgressTimer_setType, ARGS_REQ(1));
    mrb_define_class_method(mrb, rclass, "create", ruby_cocos2dx_ProgressTimer_create_static, ARGS_REQ(1));
    struct RClass* renum_Type = mrb_define_module_under(mrb, rclass, "Type");
    ruby_cocos2dx_ProgressTimer_Type_enum_init(mrb, renum_Type);
    mrb_define_class_method(mrb, renum_Type, "RADIAL", ruby_cocos2dx_constant_get, ARGS_NONE());
    mrb_define_class_method(mrb, renum_Type, "BAR", ruby_cocos2dx_constant_get, ARGS_NONE());
}
mrb_value ruby_cocos2dx_Sprite_setSpriteFrame(mrb_state* mrb, mrb_value self)
{
    cocos2d::Sprite* cobj = static_cast<cocos2d::Sprite*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            cocos2d::SpriteFrame* arg0;
            ok = rubyval_to_object<cocos2d::SpriteFrame>(mrb, argv[0], "CC::SpriteFrame", &arg0);
            if (!ok) { break; }
            cobj->setSpriteFrame(arg0);
            return self;
        }
    } while (0);
    do {
        if (argc == 1) {
            std::string arg0;
            ok = rubyval_to_std_string(mrb, argv[0], &arg0, "CC::Sprite.setSpriteFrame");
            if (!ok) { break; }
            cobj->setSpriteFrame(arg0);
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::Sprite#setSpriteFrame");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Sprite_setTexture(mrb_state* mrb, mrb_value self)
{
    cocos2d::Sprite* cobj = static_cast<cocos2d::Sprite*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            cocos2d::Texture2D* arg0;
            ok = rubyval_to_object<cocos2d::Texture2D>(mrb, argv[0], "CC::Texture2D", &arg0);
            if (!ok) { break; }
            cobj->setTexture(arg0);
            return self;
        }
    } while (0);
    do {
        if (argc == 1) {
            std::string arg0;
            ok = rubyval_to_std_string(mrb, argv[0], &arg0, "CC::Sprite.setTexture");
            if (!ok) { break; }
            cobj->setTexture(arg0);
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::Sprite#setTexture");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Sprite_getTexture(mrb_state* mrb, mrb_value self)
{
    cocos2d::Sprite* cobj = static_cast<cocos2d::Sprite*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            cocos2d::Texture2D* retval = cobj->getTexture();
            mrb_value ret;
            ret = object_to_rubyval<cocos2d::Texture2D>(mrb, "CC::Texture2D", (cocos2d::Texture2D*)retval, nullptr);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::Sprite#getTexture");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Sprite_setFlippedY(mrb_state* mrb, mrb_value self)
{
    cocos2d::Sprite* cobj = static_cast<cocos2d::Sprite*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            bool arg0;
            ok = rubyval_to_boolean(mrb, argv[0], &arg0, "CC::Sprite.setFlippedY");
            if (!ok) { break; }
            cobj->setFlippedY(arg0);
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::Sprite#setFlippedY");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Sprite_setFlippedX(mrb_state* mrb, mrb_value self)
{
    cocos2d::Sprite* cobj = static_cast<cocos2d::Sprite*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            bool arg0;
            ok = rubyval_to_boolean(mrb, argv[0], &arg0, "CC::Sprite.setFlippedX");
            if (!ok) { break; }
            cobj->setFlippedX(arg0);
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::Sprite#setFlippedX");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Sprite_getBatchNode(mrb_state* mrb, mrb_value self)
{
    cocos2d::Sprite* cobj = static_cast<cocos2d::Sprite*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            cocos2d::SpriteBatchNode* retval = cobj->getBatchNode();
            mrb_value ret;
            ret = object_to_rubyval<cocos2d::SpriteBatchNode>(mrb, "CC::SpriteBatchNode", (cocos2d::SpriteBatchNode*)retval, nullptr);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::Sprite#getBatchNode");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Sprite_getOffsetPosition(mrb_state* mrb, mrb_value self)
{
    cocos2d::Sprite* cobj = static_cast<cocos2d::Sprite*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            cocos2d::Vec2 retval = cobj->getOffsetPosition();
            cocos2d::Vec2* retval_ptr = new cocos2d::Vec2(retval);
            mrb_value ret;
            ret = object_to_rubyval<cocos2d::Vec2>(mrb, "CC::Vec2", (cocos2d::Vec2*)retval_ptr, nullptr);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::Sprite#getOffsetPosition");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Sprite_removeAllChildrenWithCleanup(mrb_state* mrb, mrb_value self)
{
    cocos2d::Sprite* cobj = static_cast<cocos2d::Sprite*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            bool arg0;
            ok = rubyval_to_boolean(mrb, argv[0], &arg0, "CC::Sprite.removeAllChildrenWithCleanup");
            if (!ok) { break; }
            cobj->removeAllChildrenWithCleanup(arg0);
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::Sprite#removeAllChildrenWithCleanup");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Sprite_updateTransform(mrb_state* mrb, mrb_value self)
{
    cocos2d::Sprite* cobj = static_cast<cocos2d::Sprite*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            cobj->updateTransform();
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::Sprite#updateTransform");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Sprite_setTextureRect(mrb_state* mrb, mrb_value self)
{
    cocos2d::Sprite* cobj = static_cast<cocos2d::Sprite*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 3) {
            cocos2d::Rect* arg0;
            ok = rubyval_to_object<cocos2d::Rect>(mrb, argv[0], "CC::Rect", &arg0);
            if (!ok) { break; }
            bool arg1;
            ok = rubyval_to_boolean(mrb, argv[1], &arg1, "CC::Sprite.setTextureRect");
            if (!ok) { break; }
            cocos2d::Size* arg2;
            ok = rubyval_to_object<cocos2d::Size>(mrb, argv[2], "CC::Size", &arg2);
            if (!ok) { break; }
            cobj->setTextureRect(*arg0, arg1, *arg2);
            return self;
        }
    } while (0);
    do {
        if (argc == 1) {
            cocos2d::Rect* arg0;
            ok = rubyval_to_object<cocos2d::Rect>(mrb, argv[0], "CC::Rect", &arg0);
            if (!ok) { break; }
            cobj->setTextureRect(*arg0);
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::Sprite#setTextureRect");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Sprite_isFrameDisplayed(mrb_state* mrb, mrb_value self)
{
    cocos2d::Sprite* cobj = static_cast<cocos2d::Sprite*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            cocos2d::SpriteFrame* arg0;
            ok = rubyval_to_object<cocos2d::SpriteFrame>(mrb, argv[0], "CC::SpriteFrame", &arg0);
            if (!ok) { break; }
            bool retval = cobj->isFrameDisplayed(arg0);
            mrb_value ret;
            ret = mrb_bool_value((mrb_bool)retval);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::Sprite#isFrameDisplayed");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Sprite_getAtlasIndex(mrb_state* mrb, mrb_value self)
{
    cocos2d::Sprite* cobj = static_cast<cocos2d::Sprite*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            ssize_t retval = cobj->getAtlasIndex();
            mrb_value ret;
            ret = mrb_fixnum_value((mrb_int)retval);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::Sprite#getAtlasIndex");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Sprite_setBatchNode(mrb_state* mrb, mrb_value self)
{
    cocos2d::Sprite* cobj = static_cast<cocos2d::Sprite*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            cocos2d::SpriteBatchNode* arg0;
            ok = rubyval_to_object<cocos2d::SpriteBatchNode>(mrb, argv[0], "CC::SpriteBatchNode", &arg0);
            if (!ok) { break; }
            cobj->setBatchNode(arg0);
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::Sprite#setBatchNode");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Sprite_getBlendFunc(mrb_state* mrb, mrb_value self)
{
    cocos2d::Sprite* cobj = static_cast<cocos2d::Sprite*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            cocos2d::BlendFunc retval = cobj->getBlendFunc();
            cocos2d::BlendFunc* retval_ptr = new cocos2d::BlendFunc(retval);
            mrb_value ret;
            ret = object_to_rubyval<cocos2d::BlendFunc>(mrb, "CC::BlendFunc", (cocos2d::BlendFunc*)retval_ptr, nullptr);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::Sprite#getBlendFunc");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Sprite_setDisplayFrameWithAnimationName(mrb_state* mrb, mrb_value self)
{
    cocos2d::Sprite* cobj = static_cast<cocos2d::Sprite*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 2) {
            std::string arg0;
            ok = rubyval_to_std_string(mrb, argv[0], &arg0, "CC::Sprite.setDisplayFrameWithAnimationName");
            if (!ok) { break; }
            ssize_t arg1;
            ok = rubyval_to_ssize(mrb, argv[1], &arg1, "CC::Sprite.setDisplayFrameWithAnimationName");
            if (!ok) { break; }
            cobj->setDisplayFrameWithAnimationName(arg0, arg1);
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::Sprite#setDisplayFrameWithAnimationName");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Sprite_setTextureAtlas(mrb_state* mrb, mrb_value self)
{
    cocos2d::Sprite* cobj = static_cast<cocos2d::Sprite*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            cocos2d::TextureAtlas* arg0;
            ok = rubyval_to_object<cocos2d::TextureAtlas>(mrb, argv[0], "CC::TextureAtlas", &arg0);
            if (!ok) { break; }
            cobj->setTextureAtlas(arg0);
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::Sprite#setTextureAtlas");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Sprite_getSpriteFrame(mrb_state* mrb, mrb_value self)
{
    cocos2d::Sprite* cobj = static_cast<cocos2d::Sprite*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            cocos2d::SpriteFrame* retval = cobj->getSpriteFrame();
            mrb_value ret;
            ret = object_to_rubyval<cocos2d::SpriteFrame>(mrb, "CC::SpriteFrame", (cocos2d::SpriteFrame*)retval, nullptr);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::Sprite#getSpriteFrame");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Sprite_isDirty(mrb_state* mrb, mrb_value self)
{
    cocos2d::Sprite* cobj = static_cast<cocos2d::Sprite*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            bool retval = cobj->isDirty();
            mrb_value ret;
            ret = mrb_bool_value((mrb_bool)retval);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::Sprite#isDirty");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Sprite_setAtlasIndex(mrb_state* mrb, mrb_value self)
{
    cocos2d::Sprite* cobj = static_cast<cocos2d::Sprite*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            ssize_t arg0;
            ok = rubyval_to_ssize(mrb, argv[0], &arg0, "CC::Sprite.setAtlasIndex");
            if (!ok) { break; }
            cobj->setAtlasIndex(arg0);
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::Sprite#setAtlasIndex");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Sprite_setDirty(mrb_state* mrb, mrb_value self)
{
    cocos2d::Sprite* cobj = static_cast<cocos2d::Sprite*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            bool arg0;
            ok = rubyval_to_boolean(mrb, argv[0], &arg0, "CC::Sprite.setDirty");
            if (!ok) { break; }
            cobj->setDirty(arg0);
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::Sprite#setDirty");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Sprite_isTextureRectRotated(mrb_state* mrb, mrb_value self)
{
    cocos2d::Sprite* cobj = static_cast<cocos2d::Sprite*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            bool retval = cobj->isTextureRectRotated();
            mrb_value ret;
            ret = mrb_bool_value((mrb_bool)retval);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::Sprite#isTextureRectRotated");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Sprite_getTextureRect(mrb_state* mrb, mrb_value self)
{
    cocos2d::Sprite* cobj = static_cast<cocos2d::Sprite*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            cocos2d::Rect retval = cobj->getTextureRect();
            cocos2d::Rect* retval_ptr = new cocos2d::Rect(retval);
            mrb_value ret;
            ret = object_to_rubyval<cocos2d::Rect>(mrb, "CC::Rect", (cocos2d::Rect*)retval_ptr, nullptr);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::Sprite#getTextureRect");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Sprite_setBlendFunc(mrb_state* mrb, mrb_value self)
{
    cocos2d::Sprite* cobj = static_cast<cocos2d::Sprite*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            cocos2d::BlendFunc* arg0;
            ok = rubyval_to_object<cocos2d::BlendFunc>(mrb, argv[0], "CC::BlendFunc", &arg0);
            if (!ok) { break; }
            cobj->setBlendFunc(*arg0);
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::Sprite#setBlendFunc");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Sprite_getTextureAtlas(mrb_state* mrb, mrb_value self)
{
    cocos2d::Sprite* cobj = static_cast<cocos2d::Sprite*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            cocos2d::TextureAtlas* retval = cobj->getTextureAtlas();
            mrb_value ret;
            ret = object_to_rubyval<cocos2d::TextureAtlas>(mrb, "CC::TextureAtlas", (cocos2d::TextureAtlas*)retval, nullptr);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::Sprite#getTextureAtlas");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Sprite_isFlippedX(mrb_state* mrb, mrb_value self)
{
    cocos2d::Sprite* cobj = static_cast<cocos2d::Sprite*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            bool retval = cobj->isFlippedX();
            mrb_value ret;
            ret = mrb_bool_value((mrb_bool)retval);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::Sprite#isFlippedX");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Sprite_isFlippedY(mrb_state* mrb, mrb_value self)
{
    cocos2d::Sprite* cobj = static_cast<cocos2d::Sprite*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            bool retval = cobj->isFlippedY();
            mrb_value ret;
            ret = mrb_bool_value((mrb_bool)retval);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::Sprite#isFlippedY");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Sprite_setVertexRect(mrb_state* mrb, mrb_value self)
{
    cocos2d::Sprite* cobj = static_cast<cocos2d::Sprite*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            cocos2d::Rect* arg0;
            ok = rubyval_to_object<cocos2d::Rect>(mrb, argv[0], "CC::Rect", &arg0);
            if (!ok) { break; }
            cobj->setVertexRect(*arg0);
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::Sprite#setVertexRect");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Sprite_create_static(mrb_state* mrb, mrb_value self)
{
    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            std::map<std::string, mrb_value> callbacks;
            std::string arg0;
            ok = rubyval_to_std_string(mrb, argv[0], &arg0, "CC::Sprite.create");
            if (!ok) { break; }

            cocos2d::Sprite* retval = cocos2d::Sprite::create(arg0);
            mrb_value ret;
            RClass* rclass = mrb_class_ptr(self);
            ret = object_to_rubyval<cocos2d::Sprite>(mrb, "CC::Sprite", (cocos2d::Sprite*)retval, rclass);
            if (callbacks.size() > 0) {
                mrb_value hash = mrb_iv_get(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"));
                if (!mrb_hash_p(hash)) {
                    hash = mrb_hash_new(mrb);
                }
                for (auto elm : callbacks) {
                    mrb_hash_set(mrb, hash, mrb_str_new_cstr(mrb, elm.first.c_str()), elm.second);
                    mrb_iv_set(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"), hash);
                }
            }
            g_rubyValue.push_back(ret);
            mrb_funcall(mrb, ret, "initialize", 0);
            return ret;
        }
    } while (0);
    do {
        if (argc == 0) {
            std::map<std::string, mrb_value> callbacks;
            cocos2d::Sprite* retval = cocos2d::Sprite::create();
            mrb_value ret;
            RClass* rclass = mrb_class_ptr(self);
            ret = object_to_rubyval<cocos2d::Sprite>(mrb, "CC::Sprite", (cocos2d::Sprite*)retval, rclass);
            if (callbacks.size() > 0) {
                mrb_value hash = mrb_iv_get(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"));
                if (!mrb_hash_p(hash)) {
                    hash = mrb_hash_new(mrb);
                }
                for (auto elm : callbacks) {
                    mrb_hash_set(mrb, hash, mrb_str_new_cstr(mrb, elm.first.c_str()), elm.second);
                    mrb_iv_set(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"), hash);
                }
            }
            g_rubyValue.push_back(ret);
            mrb_funcall(mrb, ret, "initialize", 0);
            return ret;
        }
    } while (0);
    do {
        if (argc == 2) {
            std::map<std::string, mrb_value> callbacks;
            std::string arg0;
            ok = rubyval_to_std_string(mrb, argv[0], &arg0, "CC::Sprite.create");
            if (!ok) { break; }

            cocos2d::Rect* arg1;
            ok = rubyval_to_object<cocos2d::Rect>(mrb, argv[1], "CC::Rect", &arg1);
            if (!ok) { break; }

            cocos2d::Sprite* retval = cocos2d::Sprite::create(arg0, *arg1);
            mrb_value ret;
            RClass* rclass = mrb_class_ptr(self);
            ret = object_to_rubyval<cocos2d::Sprite>(mrb, "CC::Sprite", (cocos2d::Sprite*)retval, rclass);
            if (callbacks.size() > 0) {
                mrb_value hash = mrb_iv_get(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"));
                if (!mrb_hash_p(hash)) {
                    hash = mrb_hash_new(mrb);
                }
                for (auto elm : callbacks) {
                    mrb_hash_set(mrb, hash, mrb_str_new_cstr(mrb, elm.first.c_str()), elm.second);
                    mrb_iv_set(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"), hash);
                }
            }
            g_rubyValue.push_back(ret);
            mrb_funcall(mrb, ret, "initialize", 0);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined static method : cocos2d::Sprite#create");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Sprite_createWithTexture_static(mrb_state* mrb, mrb_value self)
{
    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 2) {
            std::map<std::string, mrb_value> callbacks;
            cocos2d::Texture2D* arg0;
            ok = rubyval_to_object<cocos2d::Texture2D>(mrb, argv[0], "CC::Texture2D", &arg0);
            if (!ok) { break; }

            cocos2d::Rect* arg1;
            ok = rubyval_to_object<cocos2d::Rect>(mrb, argv[1], "CC::Rect", &arg1);
            if (!ok) { break; }

            cocos2d::Sprite* retval = cocos2d::Sprite::createWithTexture(arg0, *arg1);
            mrb_value ret;
            RClass* rclass = mrb_class_ptr(self);
            ret = object_to_rubyval<cocos2d::Sprite>(mrb, "CC::Sprite", (cocos2d::Sprite*)retval, rclass);
            if (callbacks.size() > 0) {
                mrb_value hash = mrb_iv_get(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"));
                if (!mrb_hash_p(hash)) {
                    hash = mrb_hash_new(mrb);
                }
                for (auto elm : callbacks) {
                    mrb_hash_set(mrb, hash, mrb_str_new_cstr(mrb, elm.first.c_str()), elm.second);
                    mrb_iv_set(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"), hash);
                }
            }
            g_rubyValue.push_back(ret);
            mrb_funcall(mrb, ret, "initialize", 0);
            return ret;
        }
    } while (0);
    do {
        if (argc == 3) {
            std::map<std::string, mrb_value> callbacks;
            cocos2d::Texture2D* arg0;
            ok = rubyval_to_object<cocos2d::Texture2D>(mrb, argv[0], "CC::Texture2D", &arg0);
            if (!ok) { break; }

            cocos2d::Rect* arg1;
            ok = rubyval_to_object<cocos2d::Rect>(mrb, argv[1], "CC::Rect", &arg1);
            if (!ok) { break; }

            bool arg2;
            ok = rubyval_to_boolean(mrb, argv[2], &arg2, "CC::Sprite.createWithTexture");
            if (!ok) { break; }

            cocos2d::Sprite* retval = cocos2d::Sprite::createWithTexture(arg0, *arg1, arg2);
            mrb_value ret;
            RClass* rclass = mrb_class_ptr(self);
            ret = object_to_rubyval<cocos2d::Sprite>(mrb, "CC::Sprite", (cocos2d::Sprite*)retval, rclass);
            if (callbacks.size() > 0) {
                mrb_value hash = mrb_iv_get(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"));
                if (!mrb_hash_p(hash)) {
                    hash = mrb_hash_new(mrb);
                }
                for (auto elm : callbacks) {
                    mrb_hash_set(mrb, hash, mrb_str_new_cstr(mrb, elm.first.c_str()), elm.second);
                    mrb_iv_set(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"), hash);
                }
            }
            g_rubyValue.push_back(ret);
            mrb_funcall(mrb, ret, "initialize", 0);
            return ret;
        }
    } while (0);
    do {
        if (argc == 1) {
            std::map<std::string, mrb_value> callbacks;
            cocos2d::Texture2D* arg0;
            ok = rubyval_to_object<cocos2d::Texture2D>(mrb, argv[0], "CC::Texture2D", &arg0);
            if (!ok) { break; }

            cocos2d::Sprite* retval = cocos2d::Sprite::createWithTexture(arg0);
            mrb_value ret;
            RClass* rclass = mrb_class_ptr(self);
            ret = object_to_rubyval<cocos2d::Sprite>(mrb, "CC::Sprite", (cocos2d::Sprite*)retval, rclass);
            if (callbacks.size() > 0) {
                mrb_value hash = mrb_iv_get(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"));
                if (!mrb_hash_p(hash)) {
                    hash = mrb_hash_new(mrb);
                }
                for (auto elm : callbacks) {
                    mrb_hash_set(mrb, hash, mrb_str_new_cstr(mrb, elm.first.c_str()), elm.second);
                    mrb_iv_set(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"), hash);
                }
            }
            g_rubyValue.push_back(ret);
            mrb_funcall(mrb, ret, "initialize", 0);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined static method : cocos2d::Sprite#createWithTexture");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Sprite_createWithSpriteFrameName_static(mrb_state* mrb, mrb_value self)
{
    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            std::map<std::string, mrb_value> callbacks;
            std::string arg0;
            ok = rubyval_to_std_string(mrb, argv[0], &arg0, "CC::Sprite.createWithSpriteFrameName");
            if (!ok) { break; }

            cocos2d::Sprite* retval = cocos2d::Sprite::createWithSpriteFrameName(arg0);
            mrb_value ret;
            RClass* rclass = mrb_class_ptr(self);
            ret = object_to_rubyval<cocos2d::Sprite>(mrb, "CC::Sprite", (cocos2d::Sprite*)retval, rclass);
            if (callbacks.size() > 0) {
                mrb_value hash = mrb_iv_get(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"));
                if (!mrb_hash_p(hash)) {
                    hash = mrb_hash_new(mrb);
                }
                for (auto elm : callbacks) {
                    mrb_hash_set(mrb, hash, mrb_str_new_cstr(mrb, elm.first.c_str()), elm.second);
                    mrb_iv_set(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"), hash);
                }
            }
            g_rubyValue.push_back(ret);
            mrb_funcall(mrb, ret, "initialize", 0);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined static method : cocos2d::Sprite#createWithSpriteFrameName");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Sprite_createWithSpriteFrame_static(mrb_state* mrb, mrb_value self)
{
    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            std::map<std::string, mrb_value> callbacks;
            cocos2d::SpriteFrame* arg0;
            ok = rubyval_to_object<cocos2d::SpriteFrame>(mrb, argv[0], "CC::SpriteFrame", &arg0);
            if (!ok) { break; }

            cocos2d::Sprite* retval = cocos2d::Sprite::createWithSpriteFrame(arg0);
            mrb_value ret;
            RClass* rclass = mrb_class_ptr(self);
            ret = object_to_rubyval<cocos2d::Sprite>(mrb, "CC::Sprite", (cocos2d::Sprite*)retval, rclass);
            if (callbacks.size() > 0) {
                mrb_value hash = mrb_iv_get(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"));
                if (!mrb_hash_p(hash)) {
                    hash = mrb_hash_new(mrb);
                }
                for (auto elm : callbacks) {
                    mrb_hash_set(mrb, hash, mrb_str_new_cstr(mrb, elm.first.c_str()), elm.second);
                    mrb_iv_set(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"), hash);
                }
            }
            g_rubyValue.push_back(ret);
            mrb_funcall(mrb, ret, "initialize", 0);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined static method : cocos2d::Sprite#createWithSpriteFrame");

    return mrb_nil_value();
}

void ruby_cocos2dx_Sprite_constants_init(mrb_state* mrb, struct RClass* rclass)
{
    do {
        mrb_value ret;
        ret = mrb_fixnum_value((mrb_int)cocos2d::Sprite::INDEX_NOT_INITIALIZED);
        mrb_mod_cv_set(mrb, rclass, mrb_intern_cstr(mrb, "INDEX_NOT_INITIALIZED"), ret);
    } while (0);

}

void ruby_register_cocos2dx_Sprite(mrb_state* mrb, struct RClass* rmodule)
{
    std::string typeName = typeid(cocos2d::Sprite).name();
    g_rubyType[typeName] = "CC::Sprite";
    g_rubyDataType[typeName] = &ruby_cocos2dx_Ref_type;

    struct RClass* p_rmodule = mrb->object_class;
    p_rmodule = mrb_module_get_under(mrb, p_rmodule, "CC");
    struct RClass* p_rclass = mrb_class_get_under(mrb, p_rmodule, "Node");
    struct RClass *rclass = mrb_define_class_under(mrb, rmodule, "Sprite", p_rclass);
    MRB_SET_INSTANCE_TT(rclass, MRB_TT_DATA);

    mrb_define_method(mrb, rclass, "set_sprite_frame", ruby_cocos2dx_Sprite_setSpriteFrame, ARGS_REQ(1));
    mrb_define_method(mrb, rclass, "set_texture", ruby_cocos2dx_Sprite_setTexture, ARGS_REQ(1));
    mrb_define_method(mrb, rclass, "get_texture", ruby_cocos2dx_Sprite_getTexture, ARGS_NONE());
    mrb_define_method(mrb, rclass, "set_flipped_y", ruby_cocos2dx_Sprite_setFlippedY, ARGS_REQ(1));
    mrb_define_method(mrb, rclass, "set_flipped_x", ruby_cocos2dx_Sprite_setFlippedX, ARGS_REQ(1));
    mrb_define_method(mrb, rclass, "get_batch_node", ruby_cocos2dx_Sprite_getBatchNode, ARGS_NONE());
    mrb_define_method(mrb, rclass, "get_offset_position", ruby_cocos2dx_Sprite_getOffsetPosition, ARGS_NONE());
    mrb_define_method(mrb, rclass, "remove_all_children_with_cleanup", ruby_cocos2dx_Sprite_removeAllChildrenWithCleanup, ARGS_REQ(1));
    mrb_define_method(mrb, rclass, "update_transform", ruby_cocos2dx_Sprite_updateTransform, ARGS_NONE());
    mrb_define_method(mrb, rclass, "set_texture_rect", ruby_cocos2dx_Sprite_setTextureRect, ARGS_REQ(1)|ARGS_OPT(2));
    mrb_define_method(mrb, rclass, "frame_displayed?", ruby_cocos2dx_Sprite_isFrameDisplayed, ARGS_REQ(1));
    mrb_define_method(mrb, rclass, "get_atlas_index", ruby_cocos2dx_Sprite_getAtlasIndex, ARGS_NONE());
    mrb_define_method(mrb, rclass, "set_batch_node", ruby_cocos2dx_Sprite_setBatchNode, ARGS_REQ(1));
    mrb_define_method(mrb, rclass, "get_blend_func", ruby_cocos2dx_Sprite_getBlendFunc, ARGS_NONE());
    mrb_define_method(mrb, rclass, "set_display_frame_with_animation_name", ruby_cocos2dx_Sprite_setDisplayFrameWithAnimationName, ARGS_REQ(2));
    mrb_define_method(mrb, rclass, "set_texture_atlas", ruby_cocos2dx_Sprite_setTextureAtlas, ARGS_REQ(1));
    mrb_define_method(mrb, rclass, "get_sprite_frame", ruby_cocos2dx_Sprite_getSpriteFrame, ARGS_NONE());
    mrb_define_method(mrb, rclass, "dirty?", ruby_cocos2dx_Sprite_isDirty, ARGS_NONE());
    mrb_define_method(mrb, rclass, "set_atlas_index", ruby_cocos2dx_Sprite_setAtlasIndex, ARGS_REQ(1));
    mrb_define_method(mrb, rclass, "set_dirty", ruby_cocos2dx_Sprite_setDirty, ARGS_REQ(1));
    mrb_define_method(mrb, rclass, "texture_rect_rotated?", ruby_cocos2dx_Sprite_isTextureRectRotated, ARGS_NONE());
    mrb_define_method(mrb, rclass, "get_texture_rect", ruby_cocos2dx_Sprite_getTextureRect, ARGS_NONE());
    mrb_define_method(mrb, rclass, "set_blend_func", ruby_cocos2dx_Sprite_setBlendFunc, ARGS_REQ(1));
    mrb_define_method(mrb, rclass, "get_texture_atlas", ruby_cocos2dx_Sprite_getTextureAtlas, ARGS_NONE());
    mrb_define_method(mrb, rclass, "flipped_x?", ruby_cocos2dx_Sprite_isFlippedX, ARGS_NONE());
    mrb_define_method(mrb, rclass, "flipped_y?", ruby_cocos2dx_Sprite_isFlippedY, ARGS_NONE());
    mrb_define_method(mrb, rclass, "set_vertex_rect", ruby_cocos2dx_Sprite_setVertexRect, ARGS_REQ(1));
    mrb_define_class_method(mrb, rclass, "create", ruby_cocos2dx_Sprite_create_static, ARGS_REQ(0)|ARGS_OPT(2));
    mrb_define_class_method(mrb, rclass, "create_with_texture", ruby_cocos2dx_Sprite_createWithTexture_static, ARGS_REQ(1)|ARGS_OPT(2));
    mrb_define_class_method(mrb, rclass, "create_with_sprite_frame_name", ruby_cocos2dx_Sprite_createWithSpriteFrameName_static, ARGS_REQ(1));
    mrb_define_class_method(mrb, rclass, "create_with_sprite_frame", ruby_cocos2dx_Sprite_createWithSpriteFrame_static, ARGS_REQ(1));
    ruby_cocos2dx_Sprite_constants_init(mrb, rclass);
    mrb_define_class_method(mrb, rclass, "INDEX_NOT_INITIALIZED", ruby_cocos2dx_constant_get, ARGS_NONE());
}
mrb_value ruby_cocos2dx_Image_hasPremultipliedAlpha(mrb_state* mrb, mrb_value self)
{
    cocos2d::Image* cobj = static_cast<cocos2d::Image*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            bool retval = cobj->hasPremultipliedAlpha();
            mrb_value ret;
            ret = mrb_bool_value((mrb_bool)retval);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::Image#hasPremultipliedAlpha");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Image_saveToFile(mrb_state* mrb, mrb_value self)
{
    cocos2d::Image* cobj = static_cast<cocos2d::Image*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            std::string arg0;
            ok = rubyval_to_std_string(mrb, argv[0], &arg0, "CC::Image.saveToFile");
            if (!ok) { break; }
            bool retval = cobj->saveToFile(arg0);
            mrb_value ret;
            ret = mrb_bool_value((mrb_bool)retval);
            return ret;
        }
    } while (0);
    do {
        if (argc == 2) {
            std::string arg0;
            ok = rubyval_to_std_string(mrb, argv[0], &arg0, "CC::Image.saveToFile");
            if (!ok) { break; }
            bool arg1;
            ok = rubyval_to_boolean(mrb, argv[1], &arg1, "CC::Image.saveToFile");
            if (!ok) { break; }
            bool retval = cobj->saveToFile(arg0, arg1);
            mrb_value ret;
            ret = mrb_bool_value((mrb_bool)retval);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::Image#saveToFile");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Image_hasAlpha(mrb_state* mrb, mrb_value self)
{
    cocos2d::Image* cobj = static_cast<cocos2d::Image*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            bool retval = cobj->hasAlpha();
            mrb_value ret;
            ret = mrb_bool_value((mrb_bool)retval);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::Image#hasAlpha");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Image_isCompressed(mrb_state* mrb, mrb_value self)
{
    cocos2d::Image* cobj = static_cast<cocos2d::Image*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            bool retval = cobj->isCompressed();
            mrb_value ret;
            ret = mrb_bool_value((mrb_bool)retval);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::Image#isCompressed");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Image_getHeight(mrb_state* mrb, mrb_value self)
{
    cocos2d::Image* cobj = static_cast<cocos2d::Image*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            int retval = cobj->getHeight();
            mrb_value ret;
            ret = mrb_fixnum_value((mrb_int)retval);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::Image#getHeight");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Image_initWithImageFile(mrb_state* mrb, mrb_value self)
{
    cocos2d::Image* cobj = static_cast<cocos2d::Image*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            std::string arg0;
            ok = rubyval_to_std_string(mrb, argv[0], &arg0, "CC::Image.initWithImageFile");
            if (!ok) { break; }
            bool retval = cobj->initWithImageFile(arg0);
            mrb_value ret;
            ret = mrb_bool_value((mrb_bool)retval);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::Image#initWithImageFile");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Image_getWidth(mrb_state* mrb, mrb_value self)
{
    cocos2d::Image* cobj = static_cast<cocos2d::Image*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            int retval = cobj->getWidth();
            mrb_value ret;
            ret = mrb_fixnum_value((mrb_int)retval);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::Image#getWidth");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Image_getBitPerPixel(mrb_state* mrb, mrb_value self)
{
    cocos2d::Image* cobj = static_cast<cocos2d::Image*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            int retval = cobj->getBitPerPixel();
            mrb_value ret;
            ret = mrb_fixnum_value((mrb_int)retval);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::Image#getBitPerPixel");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Image_getFileType(mrb_state* mrb, mrb_value self)
{
    cocos2d::Image* cobj = static_cast<cocos2d::Image*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            int retval = (int)cobj->getFileType();
            mrb_value ret;
            ret = mrb_fixnum_value((mrb_int)retval);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::Image#getFileType");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Image_getNumberOfMipmaps(mrb_state* mrb, mrb_value self)
{
    cocos2d::Image* cobj = static_cast<cocos2d::Image*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            int retval = cobj->getNumberOfMipmaps();
            mrb_value ret;
            ret = mrb_fixnum_value((mrb_int)retval);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::Image#getNumberOfMipmaps");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Image_getRenderFormat(mrb_state* mrb, mrb_value self)
{
    cocos2d::Image* cobj = static_cast<cocos2d::Image*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            int retval = (int)cobj->getRenderFormat();
            mrb_value ret;
            ret = mrb_fixnum_value((mrb_int)retval);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::Image#getRenderFormat");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Image_setPVRImagesHavePremultipliedAlpha_static(mrb_state* mrb, mrb_value self)
{
    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            bool arg0;
            ok = rubyval_to_boolean(mrb, argv[0], &arg0, "CC::Image.setPVRImagesHavePremultipliedAlpha");
            if (!ok) { break; }

            cocos2d::Image::setPVRImagesHavePremultipliedAlpha(arg0);
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined static method : cocos2d::Image#setPVRImagesHavePremultipliedAlpha");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Image_constructor(mrb_state* mrb, mrb_value self)
{

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            cocos2d::Image* cobj = new cocos2d::Image();
            DATA_TYPE(self) = &ruby_cocos2dx_Ref_type;
            DATA_PTR(self) = cobj;
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::Image#Image");

    return mrb_nil_value();
}


void ruby_cocos2dx_Image_Format_enum_init(mrb_state* mrb, struct RClass* renum)
{
    do {
        mrb_value ev = mrb_fixnum_value((mrb_int)cocos2d::Image::Format::JPG);
        mrb_mod_cv_set(mrb, renum, mrb_intern_cstr(mrb, "JPG"), ev);
    } while (0);

    do {
        mrb_value ev = mrb_fixnum_value((mrb_int)cocos2d::Image::Format::PNG);
        mrb_mod_cv_set(mrb, renum, mrb_intern_cstr(mrb, "PNG"), ev);
    } while (0);

    do {
        mrb_value ev = mrb_fixnum_value((mrb_int)cocos2d::Image::Format::TIFF);
        mrb_mod_cv_set(mrb, renum, mrb_intern_cstr(mrb, "TIFF"), ev);
    } while (0);

    do {
        mrb_value ev = mrb_fixnum_value((mrb_int)cocos2d::Image::Format::WEBP);
        mrb_mod_cv_set(mrb, renum, mrb_intern_cstr(mrb, "WEBP"), ev);
    } while (0);

    do {
        mrb_value ev = mrb_fixnum_value((mrb_int)cocos2d::Image::Format::PVR);
        mrb_mod_cv_set(mrb, renum, mrb_intern_cstr(mrb, "PVR"), ev);
    } while (0);

    do {
        mrb_value ev = mrb_fixnum_value((mrb_int)cocos2d::Image::Format::ETC);
        mrb_mod_cv_set(mrb, renum, mrb_intern_cstr(mrb, "ETC"), ev);
    } while (0);

    do {
        mrb_value ev = mrb_fixnum_value((mrb_int)cocos2d::Image::Format::S3TC);
        mrb_mod_cv_set(mrb, renum, mrb_intern_cstr(mrb, "S3TC"), ev);
    } while (0);

    do {
        mrb_value ev = mrb_fixnum_value((mrb_int)cocos2d::Image::Format::ATITC);
        mrb_mod_cv_set(mrb, renum, mrb_intern_cstr(mrb, "ATITC"), ev);
    } while (0);

    do {
        mrb_value ev = mrb_fixnum_value((mrb_int)cocos2d::Image::Format::TGA);
        mrb_mod_cv_set(mrb, renum, mrb_intern_cstr(mrb, "TGA"), ev);
    } while (0);

    do {
        mrb_value ev = mrb_fixnum_value((mrb_int)cocos2d::Image::Format::RAW_DATA);
        mrb_mod_cv_set(mrb, renum, mrb_intern_cstr(mrb, "RAW_DATA"), ev);
    } while (0);

    do {
        mrb_value ev = mrb_fixnum_value((mrb_int)cocos2d::Image::Format::UNKOWN);
        mrb_mod_cv_set(mrb, renum, mrb_intern_cstr(mrb, "UNKOWN"), ev);
    } while (0);

}

void ruby_register_cocos2dx_Image(mrb_state* mrb, struct RClass* rmodule)
{
    std::string typeName = typeid(cocos2d::Image).name();
    g_rubyType[typeName] = "CC::Image";
    g_rubyDataType[typeName] = &ruby_cocos2dx_Ref_type;

    struct RClass* p_rmodule = mrb->object_class;
    p_rmodule = mrb_module_get_under(mrb, p_rmodule, "CC");
    struct RClass* p_rclass = mrb_class_get_under(mrb, p_rmodule, "Ref");
    struct RClass *rclass = mrb_define_class_under(mrb, rmodule, "Image", p_rclass);
    MRB_SET_INSTANCE_TT(rclass, MRB_TT_DATA);

    mrb_define_method(mrb, rclass, "initialize", ruby_cocos2dx_Image_constructor, ARGS_NONE());
    mrb_define_method(mrb, rclass, "has_premultiplied_alpha", ruby_cocos2dx_Image_hasPremultipliedAlpha, ARGS_NONE());
    mrb_define_method(mrb, rclass, "save_to_file", ruby_cocos2dx_Image_saveToFile, ARGS_REQ(2));
    mrb_define_method(mrb, rclass, "has_alpha", ruby_cocos2dx_Image_hasAlpha, ARGS_NONE());
    mrb_define_method(mrb, rclass, "compressed?", ruby_cocos2dx_Image_isCompressed, ARGS_NONE());
    mrb_define_method(mrb, rclass, "get_height", ruby_cocos2dx_Image_getHeight, ARGS_NONE());
    mrb_define_method(mrb, rclass, "init_with_image_file", ruby_cocos2dx_Image_initWithImageFile, ARGS_REQ(1));
    mrb_define_method(mrb, rclass, "get_width", ruby_cocos2dx_Image_getWidth, ARGS_NONE());
    mrb_define_method(mrb, rclass, "get_bit_per_pixel", ruby_cocos2dx_Image_getBitPerPixel, ARGS_NONE());
    mrb_define_method(mrb, rclass, "get_file_type", ruby_cocos2dx_Image_getFileType, ARGS_NONE());
    mrb_define_method(mrb, rclass, "get_number_of_mipmaps", ruby_cocos2dx_Image_getNumberOfMipmaps, ARGS_NONE());
    mrb_define_method(mrb, rclass, "get_render_format", ruby_cocos2dx_Image_getRenderFormat, ARGS_NONE());
    mrb_define_class_method(mrb, rclass, "set_pvrimages_have_premultiplied_alpha", ruby_cocos2dx_Image_setPVRImagesHavePremultipliedAlpha_static, ARGS_REQ(1));
    struct RClass* renum_Format = mrb_define_module_under(mrb, rclass, "Format");
    ruby_cocos2dx_Image_Format_enum_init(mrb, renum_Format);
    mrb_define_class_method(mrb, renum_Format, "JPG", ruby_cocos2dx_constant_get, ARGS_NONE());
    mrb_define_class_method(mrb, renum_Format, "PNG", ruby_cocos2dx_constant_get, ARGS_NONE());
    mrb_define_class_method(mrb, renum_Format, "TIFF", ruby_cocos2dx_constant_get, ARGS_NONE());
    mrb_define_class_method(mrb, renum_Format, "WEBP", ruby_cocos2dx_constant_get, ARGS_NONE());
    mrb_define_class_method(mrb, renum_Format, "PVR", ruby_cocos2dx_constant_get, ARGS_NONE());
    mrb_define_class_method(mrb, renum_Format, "ETC", ruby_cocos2dx_constant_get, ARGS_NONE());
    mrb_define_class_method(mrb, renum_Format, "S3TC", ruby_cocos2dx_constant_get, ARGS_NONE());
    mrb_define_class_method(mrb, renum_Format, "ATITC", ruby_cocos2dx_constant_get, ARGS_NONE());
    mrb_define_class_method(mrb, renum_Format, "TGA", ruby_cocos2dx_constant_get, ARGS_NONE());
    mrb_define_class_method(mrb, renum_Format, "RAW_DATA", ruby_cocos2dx_constant_get, ARGS_NONE());
    mrb_define_class_method(mrb, renum_Format, "UNKOWN", ruby_cocos2dx_constant_get, ARGS_NONE());
}
mrb_value ruby_cocos2dx_RenderTexture_setVirtualViewport(mrb_state* mrb, mrb_value self)
{
    cocos2d::RenderTexture* cobj = static_cast<cocos2d::RenderTexture*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 3) {
            cocos2d::Vec2* arg0;
            ok = rubyval_to_object<cocos2d::Vec2>(mrb, argv[0], "CC::Vec2", &arg0);
            if (!ok) { break; }
            cocos2d::Rect* arg1;
            ok = rubyval_to_object<cocos2d::Rect>(mrb, argv[1], "CC::Rect", &arg1);
            if (!ok) { break; }
            cocos2d::Rect* arg2;
            ok = rubyval_to_object<cocos2d::Rect>(mrb, argv[2], "CC::Rect", &arg2);
            if (!ok) { break; }
            cobj->setVirtualViewport(*arg0, *arg1, *arg2);
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::RenderTexture#setVirtualViewport");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_RenderTexture_clearStencil(mrb_state* mrb, mrb_value self)
{
    cocos2d::RenderTexture* cobj = static_cast<cocos2d::RenderTexture*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            int arg0;
            ok = rubyval_to_int32(mrb, argv[0], (int*)&arg0, "CC::RenderTexture.clearStencil");
            if (!ok) { break; }
            cobj->clearStencil(arg0);
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::RenderTexture#clearStencil");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_RenderTexture_getClearDepth(mrb_state* mrb, mrb_value self)
{
    cocos2d::RenderTexture* cobj = static_cast<cocos2d::RenderTexture*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            double retval = cobj->getClearDepth();
            mrb_value ret;
            ret = mrb_float_value(mrb, (mrb_float)retval);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::RenderTexture#getClearDepth");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_RenderTexture_getClearStencil(mrb_state* mrb, mrb_value self)
{
    cocos2d::RenderTexture* cobj = static_cast<cocos2d::RenderTexture*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            int retval = cobj->getClearStencil();
            mrb_value ret;
            ret = mrb_fixnum_value((mrb_int)retval);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::RenderTexture#getClearStencil");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_RenderTexture_end(mrb_state* mrb, mrb_value self)
{
    cocos2d::RenderTexture* cobj = static_cast<cocos2d::RenderTexture*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            cobj->end();
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::RenderTexture#end");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_RenderTexture_setClearStencil(mrb_state* mrb, mrb_value self)
{
    cocos2d::RenderTexture* cobj = static_cast<cocos2d::RenderTexture*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            int arg0;
            ok = rubyval_to_int32(mrb, argv[0], (int*)&arg0, "CC::RenderTexture.setClearStencil");
            if (!ok) { break; }
            cobj->setClearStencil(arg0);
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::RenderTexture#setClearStencil");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_RenderTexture_setSprite(mrb_state* mrb, mrb_value self)
{
    cocos2d::RenderTexture* cobj = static_cast<cocos2d::RenderTexture*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            cocos2d::Sprite* arg0;
            ok = rubyval_to_object<cocos2d::Sprite>(mrb, argv[0], "CC::Sprite", &arg0);
            if (!ok) { break; }
            cobj->setSprite(arg0);
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::RenderTexture#setSprite");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_RenderTexture_getSprite(mrb_state* mrb, mrb_value self)
{
    cocos2d::RenderTexture* cobj = static_cast<cocos2d::RenderTexture*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            cocos2d::Sprite* retval = cobj->getSprite();
            mrb_value ret;
            ret = object_to_rubyval<cocos2d::Sprite>(mrb, "CC::Sprite", (cocos2d::Sprite*)retval, nullptr);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::RenderTexture#getSprite");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_RenderTexture_isAutoDraw(mrb_state* mrb, mrb_value self)
{
    cocos2d::RenderTexture* cobj = static_cast<cocos2d::RenderTexture*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            bool retval = cobj->isAutoDraw();
            mrb_value ret;
            ret = mrb_bool_value((mrb_bool)retval);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::RenderTexture#isAutoDraw");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_RenderTexture_setKeepMatrix(mrb_state* mrb, mrb_value self)
{
    cocos2d::RenderTexture* cobj = static_cast<cocos2d::RenderTexture*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            bool arg0;
            ok = rubyval_to_boolean(mrb, argv[0], &arg0, "CC::RenderTexture.setKeepMatrix");
            if (!ok) { break; }
            cobj->setKeepMatrix(arg0);
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::RenderTexture#setKeepMatrix");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_RenderTexture_setClearFlags(mrb_state* mrb, mrb_value self)
{
    cocos2d::RenderTexture* cobj = static_cast<cocos2d::RenderTexture*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            unsigned int arg0;
            ok = rubyval_to_uint32(mrb, argv[0], &arg0, "CC::RenderTexture.setClearFlags");
            if (!ok) { break; }
            cobj->setClearFlags(arg0);
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::RenderTexture#setClearFlags");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_RenderTexture_begin(mrb_state* mrb, mrb_value self)
{
    cocos2d::RenderTexture* cobj = static_cast<cocos2d::RenderTexture*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            cobj->begin();
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::RenderTexture#begin");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_RenderTexture_saveToFile(mrb_state* mrb, mrb_value self)
{
    cocos2d::RenderTexture* cobj = static_cast<cocos2d::RenderTexture*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 2) {
            std::string arg0;
            ok = rubyval_to_std_string(mrb, argv[0], &arg0, "CC::RenderTexture.saveToFile");
            if (!ok) { break; }
            cocos2d::Image::Format arg1;
            ok = rubyval_to_int32(mrb, argv[1], (int*)&arg1, "CC::RenderTexture.saveToFile");
            if (!ok) { break; }
            bool retval = cobj->saveToFile(arg0, arg1);
            mrb_value ret;
            ret = mrb_bool_value((mrb_bool)retval);
            return ret;
        }
    } while (0);
    do {
        if (argc == 3) {
            std::string arg0;
            ok = rubyval_to_std_string(mrb, argv[0], &arg0, "CC::RenderTexture.saveToFile");
            if (!ok) { break; }
            cocos2d::Image::Format arg1;
            ok = rubyval_to_int32(mrb, argv[1], (int*)&arg1, "CC::RenderTexture.saveToFile");
            if (!ok) { break; }
            bool arg2;
            ok = rubyval_to_boolean(mrb, argv[2], &arg2, "CC::RenderTexture.saveToFile");
            if (!ok) { break; }
            bool retval = cobj->saveToFile(arg0, arg1, arg2);
            mrb_value ret;
            ret = mrb_bool_value((mrb_bool)retval);
            return ret;
        }
    } while (0);
    do {
        if (argc == 4) {
            std::string arg0;
            ok = rubyval_to_std_string(mrb, argv[0], &arg0, "CC::RenderTexture.saveToFile");
            if (!ok) { break; }
            cocos2d::Image::Format arg1;
            ok = rubyval_to_int32(mrb, argv[1], (int*)&arg1, "CC::RenderTexture.saveToFile");
            if (!ok) { break; }
            bool arg2;
            ok = rubyval_to_boolean(mrb, argv[2], &arg2, "CC::RenderTexture.saveToFile");
            if (!ok) { break; }
            std::function<void (cocos2d::RenderTexture *, std::basic_string<char> )> arg3;
            do {
			    // Lambda binding for ruby.
			    unsigned long idx = -1;
			    arg3 = [mrb, self, idx](cocos2d::RenderTexture* larg0, const std::basic_string<char> & larg1) -> void {
			        mrb_value ruby_arg0;
			        ruby_arg0 = object_to_rubyval<cocos2d::RenderTexture>(mrb, "CC::RenderTexture", (cocos2d::RenderTexture*)larg0, nullptr);
			        mrb_value ruby_arg1;
			        ruby_arg1 = mrb_str_new_cstr(mrb, larg1.c_str());
			        mrb_value hash = mrb_iv_get(mrb, self, mrb_intern_cstr(mrb, "__callback_hash"));
			        mrb_value func = mrb_hash_get(mrb, hash, mrb_str_new_cstr(mrb, "saveToFile->arg3"));
			        mrb_value mrb_ret = mrb_funcall(mrb, func, "call", 2, ruby_arg0, ruby_arg1);
			        if (mrb_exception_p(mrb_ret)) {
			            mrb_exc_raise(mrb, mrb_ret);
			        }
			    };
			    mrb_value hash = mrb_iv_get(mrb, self, mrb_intern_cstr(mrb, "__callback_hash"));
			    if (!mrb_hash_p(hash)) {
			        hash = mrb_hash_new(mrb);
			    }
			    mrb_hash_set(mrb, hash, mrb_str_new_cstr(mrb, "saveToFile->arg3"), argv[3]);
			    mrb_iv_set(mrb, self, mrb_intern_cstr(mrb, "__callback_hash"), hash);
			    break;
			} while(0);
            bool retval = cobj->saveToFile(arg0, arg1, arg2, arg3);
            mrb_value ret;
            ret = mrb_bool_value((mrb_bool)retval);
            return ret;
        }
    } while (0);
    do {
        if (argc == 1) {
            std::string arg0;
            ok = rubyval_to_std_string(mrb, argv[0], &arg0, "CC::RenderTexture.saveToFile");
            if (!ok) { break; }
            bool retval = cobj->saveToFile(arg0);
            mrb_value ret;
            ret = mrb_bool_value((mrb_bool)retval);
            return ret;
        }
    } while (0);
    do {
        if (argc == 2) {
            std::string arg0;
            ok = rubyval_to_std_string(mrb, argv[0], &arg0, "CC::RenderTexture.saveToFile");
            if (!ok) { break; }
            bool arg1;
            ok = rubyval_to_boolean(mrb, argv[1], &arg1, "CC::RenderTexture.saveToFile");
            if (!ok) { break; }
            bool retval = cobj->saveToFile(arg0, arg1);
            mrb_value ret;
            ret = mrb_bool_value((mrb_bool)retval);
            return ret;
        }
    } while (0);
    do {
        if (argc == 3) {
            std::string arg0;
            ok = rubyval_to_std_string(mrb, argv[0], &arg0, "CC::RenderTexture.saveToFile");
            if (!ok) { break; }
            bool arg1;
            ok = rubyval_to_boolean(mrb, argv[1], &arg1, "CC::RenderTexture.saveToFile");
            if (!ok) { break; }
            std::function<void (cocos2d::RenderTexture *, std::basic_string<char> )> arg2;
            do {
			    // Lambda binding for ruby.
			    unsigned long idx = -1;
			    arg2 = [mrb, self, idx](cocos2d::RenderTexture* larg0, const std::basic_string<char> & larg1) -> void {
			        mrb_value ruby_arg0;
			        ruby_arg0 = object_to_rubyval<cocos2d::RenderTexture>(mrb, "CC::RenderTexture", (cocos2d::RenderTexture*)larg0, nullptr);
			        mrb_value ruby_arg1;
			        ruby_arg1 = mrb_str_new_cstr(mrb, larg1.c_str());
			        mrb_value hash = mrb_iv_get(mrb, self, mrb_intern_cstr(mrb, "__callback_hash"));
			        mrb_value func = mrb_hash_get(mrb, hash, mrb_str_new_cstr(mrb, "saveToFile->arg2"));
			        mrb_value mrb_ret = mrb_funcall(mrb, func, "call", 2, ruby_arg0, ruby_arg1);
			        if (mrb_exception_p(mrb_ret)) {
			            mrb_exc_raise(mrb, mrb_ret);
			        }
			    };
			    mrb_value hash = mrb_iv_get(mrb, self, mrb_intern_cstr(mrb, "__callback_hash"));
			    if (!mrb_hash_p(hash)) {
			        hash = mrb_hash_new(mrb);
			    }
			    mrb_hash_set(mrb, hash, mrb_str_new_cstr(mrb, "saveToFile->arg2"), argv[2]);
			    mrb_iv_set(mrb, self, mrb_intern_cstr(mrb, "__callback_hash"), hash);
			    break;
			} while(0);
            bool retval = cobj->saveToFile(arg0, arg1, arg2);
            mrb_value ret;
            ret = mrb_bool_value((mrb_bool)retval);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::RenderTexture#saveToFile");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_RenderTexture_setAutoDraw(mrb_state* mrb, mrb_value self)
{
    cocos2d::RenderTexture* cobj = static_cast<cocos2d::RenderTexture*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            bool arg0;
            ok = rubyval_to_boolean(mrb, argv[0], &arg0, "CC::RenderTexture.setAutoDraw");
            if (!ok) { break; }
            cobj->setAutoDraw(arg0);
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::RenderTexture#setAutoDraw");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_RenderTexture_setClearColor(mrb_state* mrb, mrb_value self)
{
    cocos2d::RenderTexture* cobj = static_cast<cocos2d::RenderTexture*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            cocos2d::Color4F* arg0;
            ok = rubyval_to_object<cocos2d::Color4F>(mrb, argv[0], "CC::Color4F", &arg0);
            if (!ok) { break; }
            cobj->setClearColor(*arg0);
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::RenderTexture#setClearColor");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_RenderTexture_endToLua(mrb_state* mrb, mrb_value self)
{
    cocos2d::RenderTexture* cobj = static_cast<cocos2d::RenderTexture*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            cobj->endToLua();
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::RenderTexture#endToLua");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_RenderTexture_beginWithClear(mrb_state* mrb, mrb_value self)
{
    cocos2d::RenderTexture* cobj = static_cast<cocos2d::RenderTexture*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 5) {
            double arg0;
            ok = rubyval_to_number(mrb, argv[0], (double*)&arg0, "CC::RenderTexture.beginWithClear");
            if (!ok) { break; }
            double arg1;
            ok = rubyval_to_number(mrb, argv[1], (double*)&arg1, "CC::RenderTexture.beginWithClear");
            if (!ok) { break; }
            double arg2;
            ok = rubyval_to_number(mrb, argv[2], (double*)&arg2, "CC::RenderTexture.beginWithClear");
            if (!ok) { break; }
            double arg3;
            ok = rubyval_to_number(mrb, argv[3], (double*)&arg3, "CC::RenderTexture.beginWithClear");
            if (!ok) { break; }
            double arg4;
            ok = rubyval_to_number(mrb, argv[4], (double*)&arg4, "CC::RenderTexture.beginWithClear");
            if (!ok) { break; }
            cobj->beginWithClear(arg0, arg1, arg2, arg3, arg4);
            return self;
        }
    } while (0);
    do {
        if (argc == 4) {
            double arg0;
            ok = rubyval_to_number(mrb, argv[0], (double*)&arg0, "CC::RenderTexture.beginWithClear");
            if (!ok) { break; }
            double arg1;
            ok = rubyval_to_number(mrb, argv[1], (double*)&arg1, "CC::RenderTexture.beginWithClear");
            if (!ok) { break; }
            double arg2;
            ok = rubyval_to_number(mrb, argv[2], (double*)&arg2, "CC::RenderTexture.beginWithClear");
            if (!ok) { break; }
            double arg3;
            ok = rubyval_to_number(mrb, argv[3], (double*)&arg3, "CC::RenderTexture.beginWithClear");
            if (!ok) { break; }
            cobj->beginWithClear(arg0, arg1, arg2, arg3);
            return self;
        }
    } while (0);
    do {
        if (argc == 6) {
            double arg0;
            ok = rubyval_to_number(mrb, argv[0], (double*)&arg0, "CC::RenderTexture.beginWithClear");
            if (!ok) { break; }
            double arg1;
            ok = rubyval_to_number(mrb, argv[1], (double*)&arg1, "CC::RenderTexture.beginWithClear");
            if (!ok) { break; }
            double arg2;
            ok = rubyval_to_number(mrb, argv[2], (double*)&arg2, "CC::RenderTexture.beginWithClear");
            if (!ok) { break; }
            double arg3;
            ok = rubyval_to_number(mrb, argv[3], (double*)&arg3, "CC::RenderTexture.beginWithClear");
            if (!ok) { break; }
            double arg4;
            ok = rubyval_to_number(mrb, argv[4], (double*)&arg4, "CC::RenderTexture.beginWithClear");
            if (!ok) { break; }
            int arg5;
            ok = rubyval_to_int32(mrb, argv[5], (int*)&arg5, "CC::RenderTexture.beginWithClear");
            if (!ok) { break; }
            cobj->beginWithClear(arg0, arg1, arg2, arg3, arg4, arg5);
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::RenderTexture#beginWithClear");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_RenderTexture_clearDepth(mrb_state* mrb, mrb_value self)
{
    cocos2d::RenderTexture* cobj = static_cast<cocos2d::RenderTexture*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            double arg0;
            ok = rubyval_to_number(mrb, argv[0], (double*)&arg0, "CC::RenderTexture.clearDepth");
            if (!ok) { break; }
            cobj->clearDepth(arg0);
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::RenderTexture#clearDepth");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_RenderTexture_getClearColor(mrb_state* mrb, mrb_value self)
{
    cocos2d::RenderTexture* cobj = static_cast<cocos2d::RenderTexture*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            cocos2d::Color4F retval = cobj->getClearColor();
            cocos2d::Color4F* retval_ptr = new cocos2d::Color4F(retval);
            mrb_value ret;
            ret = object_to_rubyval<cocos2d::Color4F>(mrb, "CC::Color4F", (cocos2d::Color4F*)retval_ptr, nullptr);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::RenderTexture#getClearColor");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_RenderTexture_clear(mrb_state* mrb, mrb_value self)
{
    cocos2d::RenderTexture* cobj = static_cast<cocos2d::RenderTexture*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 4) {
            double arg0;
            ok = rubyval_to_number(mrb, argv[0], (double*)&arg0, "CC::RenderTexture.clear");
            if (!ok) { break; }
            double arg1;
            ok = rubyval_to_number(mrb, argv[1], (double*)&arg1, "CC::RenderTexture.clear");
            if (!ok) { break; }
            double arg2;
            ok = rubyval_to_number(mrb, argv[2], (double*)&arg2, "CC::RenderTexture.clear");
            if (!ok) { break; }
            double arg3;
            ok = rubyval_to_number(mrb, argv[3], (double*)&arg3, "CC::RenderTexture.clear");
            if (!ok) { break; }
            cobj->clear(arg0, arg1, arg2, arg3);
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::RenderTexture#clear");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_RenderTexture_getClearFlags(mrb_state* mrb, mrb_value self)
{
    cocos2d::RenderTexture* cobj = static_cast<cocos2d::RenderTexture*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            unsigned int retval = cobj->getClearFlags();
            mrb_value ret;
            ret = mrb_fixnum_value((mrb_int)retval);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::RenderTexture#getClearFlags");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_RenderTexture_newImage(mrb_state* mrb, mrb_value self)
{
    cocos2d::RenderTexture* cobj = static_cast<cocos2d::RenderTexture*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 0) {
            cocos2d::Image* retval = cobj->newImage();
            mrb_value ret;
            ret = object_to_rubyval<cocos2d::Image>(mrb, "CC::Image", (cocos2d::Image*)retval, nullptr);
            return ret;
        }
    } while (0);
    do {
        if (argc == 1) {
            bool arg0;
            ok = rubyval_to_boolean(mrb, argv[0], &arg0, "CC::RenderTexture.newImage");
            if (!ok) { break; }
            cocos2d::Image* retval = cobj->newImage(arg0);
            mrb_value ret;
            ret = object_to_rubyval<cocos2d::Image>(mrb, "CC::Image", (cocos2d::Image*)retval, nullptr);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::RenderTexture#newImage");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_RenderTexture_setClearDepth(mrb_state* mrb, mrb_value self)
{
    cocos2d::RenderTexture* cobj = static_cast<cocos2d::RenderTexture*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            double arg0;
            ok = rubyval_to_number(mrb, argv[0], (double*)&arg0, "CC::RenderTexture.setClearDepth");
            if (!ok) { break; }
            cobj->setClearDepth(arg0);
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::RenderTexture#setClearDepth");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_RenderTexture_initWithWidthAndHeight(mrb_state* mrb, mrb_value self)
{
    cocos2d::RenderTexture* cobj = static_cast<cocos2d::RenderTexture*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 4) {
            int arg0;
            ok = rubyval_to_int32(mrb, argv[0], (int*)&arg0, "CC::RenderTexture.initWithWidthAndHeight");
            if (!ok) { break; }
            int arg1;
            ok = rubyval_to_int32(mrb, argv[1], (int*)&arg1, "CC::RenderTexture.initWithWidthAndHeight");
            if (!ok) { break; }
            cocos2d::Texture2D::PixelFormat arg2;
            ok = rubyval_to_int32(mrb, argv[2], (int*)&arg2, "CC::RenderTexture.initWithWidthAndHeight");
            if (!ok) { break; }
            unsigned int arg3;
            ok = rubyval_to_uint32(mrb, argv[3], &arg3, "CC::RenderTexture.initWithWidthAndHeight");
            if (!ok) { break; }
            bool retval = cobj->initWithWidthAndHeight(arg0, arg1, arg2, arg3);
            mrb_value ret;
            ret = mrb_bool_value((mrb_bool)retval);
            return ret;
        }
    } while (0);
    do {
        if (argc == 3) {
            int arg0;
            ok = rubyval_to_int32(mrb, argv[0], (int*)&arg0, "CC::RenderTexture.initWithWidthAndHeight");
            if (!ok) { break; }
            int arg1;
            ok = rubyval_to_int32(mrb, argv[1], (int*)&arg1, "CC::RenderTexture.initWithWidthAndHeight");
            if (!ok) { break; }
            cocos2d::Texture2D::PixelFormat arg2;
            ok = rubyval_to_int32(mrb, argv[2], (int*)&arg2, "CC::RenderTexture.initWithWidthAndHeight");
            if (!ok) { break; }
            bool retval = cobj->initWithWidthAndHeight(arg0, arg1, arg2);
            mrb_value ret;
            ret = mrb_bool_value((mrb_bool)retval);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::RenderTexture#initWithWidthAndHeight");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_RenderTexture_create_static(mrb_state* mrb, mrb_value self)
{
    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 3) {
            std::map<std::string, mrb_value> callbacks;
            int arg0;
            ok = rubyval_to_int32(mrb, argv[0], (int*)&arg0, "CC::RenderTexture.create");
            if (!ok) { break; }

            int arg1;
            ok = rubyval_to_int32(mrb, argv[1], (int*)&arg1, "CC::RenderTexture.create");
            if (!ok) { break; }

            cocos2d::Texture2D::PixelFormat arg2;
            ok = rubyval_to_int32(mrb, argv[2], (int*)&arg2, "CC::RenderTexture.create");
            if (!ok) { break; }

            cocos2d::RenderTexture* retval = cocos2d::RenderTexture::create(arg0, arg1, arg2);
            mrb_value ret;
            RClass* rclass = mrb_class_ptr(self);
            ret = object_to_rubyval<cocos2d::RenderTexture>(mrb, "CC::RenderTexture", (cocos2d::RenderTexture*)retval, rclass);
            if (callbacks.size() > 0) {
                mrb_value hash = mrb_iv_get(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"));
                if (!mrb_hash_p(hash)) {
                    hash = mrb_hash_new(mrb);
                }
                for (auto elm : callbacks) {
                    mrb_hash_set(mrb, hash, mrb_str_new_cstr(mrb, elm.first.c_str()), elm.second);
                    mrb_iv_set(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"), hash);
                }
            }
            g_rubyValue.push_back(ret);
            mrb_funcall(mrb, ret, "initialize", 0);
            return ret;
        }
    } while (0);
    do {
        if (argc == 4) {
            std::map<std::string, mrb_value> callbacks;
            int arg0;
            ok = rubyval_to_int32(mrb, argv[0], (int*)&arg0, "CC::RenderTexture.create");
            if (!ok) { break; }

            int arg1;
            ok = rubyval_to_int32(mrb, argv[1], (int*)&arg1, "CC::RenderTexture.create");
            if (!ok) { break; }

            cocos2d::Texture2D::PixelFormat arg2;
            ok = rubyval_to_int32(mrb, argv[2], (int*)&arg2, "CC::RenderTexture.create");
            if (!ok) { break; }

            unsigned int arg3;
            ok = rubyval_to_uint32(mrb, argv[3], &arg3, "CC::RenderTexture.create");
            if (!ok) { break; }

            cocos2d::RenderTexture* retval = cocos2d::RenderTexture::create(arg0, arg1, arg2, arg3);
            mrb_value ret;
            RClass* rclass = mrb_class_ptr(self);
            ret = object_to_rubyval<cocos2d::RenderTexture>(mrb, "CC::RenderTexture", (cocos2d::RenderTexture*)retval, rclass);
            if (callbacks.size() > 0) {
                mrb_value hash = mrb_iv_get(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"));
                if (!mrb_hash_p(hash)) {
                    hash = mrb_hash_new(mrb);
                }
                for (auto elm : callbacks) {
                    mrb_hash_set(mrb, hash, mrb_str_new_cstr(mrb, elm.first.c_str()), elm.second);
                    mrb_iv_set(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"), hash);
                }
            }
            g_rubyValue.push_back(ret);
            mrb_funcall(mrb, ret, "initialize", 0);
            return ret;
        }
    } while (0);
    do {
        if (argc == 2) {
            std::map<std::string, mrb_value> callbacks;
            int arg0;
            ok = rubyval_to_int32(mrb, argv[0], (int*)&arg0, "CC::RenderTexture.create");
            if (!ok) { break; }

            int arg1;
            ok = rubyval_to_int32(mrb, argv[1], (int*)&arg1, "CC::RenderTexture.create");
            if (!ok) { break; }

            cocos2d::RenderTexture* retval = cocos2d::RenderTexture::create(arg0, arg1);
            mrb_value ret;
            RClass* rclass = mrb_class_ptr(self);
            ret = object_to_rubyval<cocos2d::RenderTexture>(mrb, "CC::RenderTexture", (cocos2d::RenderTexture*)retval, rclass);
            if (callbacks.size() > 0) {
                mrb_value hash = mrb_iv_get(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"));
                if (!mrb_hash_p(hash)) {
                    hash = mrb_hash_new(mrb);
                }
                for (auto elm : callbacks) {
                    mrb_hash_set(mrb, hash, mrb_str_new_cstr(mrb, elm.first.c_str()), elm.second);
                    mrb_iv_set(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"), hash);
                }
            }
            g_rubyValue.push_back(ret);
            mrb_funcall(mrb, ret, "initialize", 0);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined static method : cocos2d::RenderTexture#create");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_RenderTexture_constructor(mrb_state* mrb, mrb_value self)
{

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            cocos2d::RenderTexture* cobj = new cocos2d::RenderTexture();
            DATA_TYPE(self) = &ruby_cocos2dx_Ref_type;
            DATA_PTR(self) = cobj;
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::RenderTexture#RenderTexture");

    return mrb_nil_value();
}


void ruby_register_cocos2dx_RenderTexture(mrb_state* mrb, struct RClass* rmodule)
{
    std::string typeName = typeid(cocos2d::RenderTexture).name();
    g_rubyType[typeName] = "CC::RenderTexture";
    g_rubyDataType[typeName] = &ruby_cocos2dx_Ref_type;

    struct RClass* p_rmodule = mrb->object_class;
    p_rmodule = mrb_module_get_under(mrb, p_rmodule, "CC");
    struct RClass* p_rclass = mrb_class_get_under(mrb, p_rmodule, "Node");
    struct RClass *rclass = mrb_define_class_under(mrb, rmodule, "RenderTexture", p_rclass);
    MRB_SET_INSTANCE_TT(rclass, MRB_TT_DATA);

    mrb_define_method(mrb, rclass, "initialize", ruby_cocos2dx_RenderTexture_constructor, ARGS_NONE());
    mrb_define_method(mrb, rclass, "set_virtual_viewport", ruby_cocos2dx_RenderTexture_setVirtualViewport, ARGS_REQ(3));
    mrb_define_method(mrb, rclass, "clear_stencil", ruby_cocos2dx_RenderTexture_clearStencil, ARGS_REQ(1));
    mrb_define_method(mrb, rclass, "get_clear_depth", ruby_cocos2dx_RenderTexture_getClearDepth, ARGS_NONE());
    mrb_define_method(mrb, rclass, "get_clear_stencil", ruby_cocos2dx_RenderTexture_getClearStencil, ARGS_NONE());
    mrb_define_method(mrb, rclass, "end", ruby_cocos2dx_RenderTexture_end, ARGS_NONE());
    mrb_define_method(mrb, rclass, "set_clear_stencil", ruby_cocos2dx_RenderTexture_setClearStencil, ARGS_REQ(1));
    mrb_define_method(mrb, rclass, "set_sprite", ruby_cocos2dx_RenderTexture_setSprite, ARGS_REQ(1));
    mrb_define_method(mrb, rclass, "get_sprite", ruby_cocos2dx_RenderTexture_getSprite, ARGS_NONE());
    mrb_define_method(mrb, rclass, "auto_draw?", ruby_cocos2dx_RenderTexture_isAutoDraw, ARGS_NONE());
    mrb_define_method(mrb, rclass, "set_keep_matrix", ruby_cocos2dx_RenderTexture_setKeepMatrix, ARGS_REQ(1));
    mrb_define_method(mrb, rclass, "set_clear_flags", ruby_cocos2dx_RenderTexture_setClearFlags, ARGS_REQ(1));
    mrb_define_method(mrb, rclass, "begin", ruby_cocos2dx_RenderTexture_begin, ARGS_NONE());
    mrb_define_method(mrb, rclass, "save_to_file", ruby_cocos2dx_RenderTexture_saveToFile, ARGS_REQ(1)|ARGS_OPT(3));
    mrb_define_method(mrb, rclass, "set_auto_draw", ruby_cocos2dx_RenderTexture_setAutoDraw, ARGS_REQ(1));
    mrb_define_method(mrb, rclass, "set_clear_color", ruby_cocos2dx_RenderTexture_setClearColor, ARGS_REQ(1));
    mrb_define_method(mrb, rclass, "end_to_lua", ruby_cocos2dx_RenderTexture_endToLua, ARGS_NONE());
    mrb_define_method(mrb, rclass, "begin_with_clear", ruby_cocos2dx_RenderTexture_beginWithClear, ARGS_REQ(4)|ARGS_OPT(2));
    mrb_define_method(mrb, rclass, "clear_depth", ruby_cocos2dx_RenderTexture_clearDepth, ARGS_REQ(1));
    mrb_define_method(mrb, rclass, "get_clear_color", ruby_cocos2dx_RenderTexture_getClearColor, ARGS_NONE());
    mrb_define_method(mrb, rclass, "clear", ruby_cocos2dx_RenderTexture_clear, ARGS_REQ(4));
    mrb_define_method(mrb, rclass, "get_clear_flags", ruby_cocos2dx_RenderTexture_getClearFlags, ARGS_NONE());
    mrb_define_method(mrb, rclass, "new_image", ruby_cocos2dx_RenderTexture_newImage, ARGS_REQ(1));
    mrb_define_method(mrb, rclass, "set_clear_depth", ruby_cocos2dx_RenderTexture_setClearDepth, ARGS_REQ(1));
    mrb_define_method(mrb, rclass, "init_with_width_and_height", ruby_cocos2dx_RenderTexture_initWithWidthAndHeight, ARGS_REQ(3)|ARGS_OPT(1));
    mrb_define_class_method(mrb, rclass, "create", ruby_cocos2dx_RenderTexture_create_static, ARGS_REQ(2)|ARGS_OPT(2));
}
mrb_value ruby_cocos2dx_NodeGrid_setTarget(mrb_state* mrb, mrb_value self)
{
    cocos2d::NodeGrid* cobj = static_cast<cocos2d::NodeGrid*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            cocos2d::Node* arg0;
            ok = rubyval_to_object<cocos2d::Node>(mrb, argv[0], "CC::Node", &arg0);
            if (!ok) { break; }
            cobj->setTarget(arg0);
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::NodeGrid#setTarget");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_NodeGrid_getGrid(mrb_state* mrb, mrb_value self)
{
    cocos2d::NodeGrid* cobj = static_cast<cocos2d::NodeGrid*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            const cocos2d::GridBase* retval = cobj->getGrid();
            mrb_value ret;
            ret = object_to_rubyval<cocos2d::GridBase>(mrb, "CC::GridBase", (cocos2d::GridBase*)retval, nullptr);
            return ret;
        }
    } while (0);
    do {
        if (argc == 0) {
            cocos2d::GridBase* retval = cobj->getGrid();
            mrb_value ret;
            ret = object_to_rubyval<cocos2d::GridBase>(mrb, "CC::GridBase", (cocos2d::GridBase*)retval, nullptr);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::NodeGrid#getGrid");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_NodeGrid_setGrid(mrb_state* mrb, mrb_value self)
{
    cocos2d::NodeGrid* cobj = static_cast<cocos2d::NodeGrid*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            cocos2d::GridBase* arg0;
            ok = rubyval_to_object<cocos2d::GridBase>(mrb, argv[0], "CC::GridBase", &arg0);
            if (!ok) { break; }
            cobj->setGrid(arg0);
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::NodeGrid#setGrid");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_NodeGrid_create_static(mrb_state* mrb, mrb_value self)
{
    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            std::map<std::string, mrb_value> callbacks;
            cocos2d::NodeGrid* retval = cocos2d::NodeGrid::create();
            mrb_value ret;
            RClass* rclass = mrb_class_ptr(self);
            ret = object_to_rubyval<cocos2d::NodeGrid>(mrb, "CC::NodeGrid", (cocos2d::NodeGrid*)retval, rclass);
            if (callbacks.size() > 0) {
                mrb_value hash = mrb_iv_get(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"));
                if (!mrb_hash_p(hash)) {
                    hash = mrb_hash_new(mrb);
                }
                for (auto elm : callbacks) {
                    mrb_hash_set(mrb, hash, mrb_str_new_cstr(mrb, elm.first.c_str()), elm.second);
                    mrb_iv_set(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"), hash);
                }
            }
            g_rubyValue.push_back(ret);
            mrb_funcall(mrb, ret, "initialize", 0);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined static method : cocos2d::NodeGrid#create");

    return mrb_nil_value();
}

void ruby_register_cocos2dx_NodeGrid(mrb_state* mrb, struct RClass* rmodule)
{
    std::string typeName = typeid(cocos2d::NodeGrid).name();
    g_rubyType[typeName] = "CC::NodeGrid";
    g_rubyDataType[typeName] = &ruby_cocos2dx_Ref_type;

    struct RClass* p_rmodule = mrb->object_class;
    p_rmodule = mrb_module_get_under(mrb, p_rmodule, "CC");
    struct RClass* p_rclass = mrb_class_get_under(mrb, p_rmodule, "Node");
    struct RClass *rclass = mrb_define_class_under(mrb, rmodule, "NodeGrid", p_rclass);
    MRB_SET_INSTANCE_TT(rclass, MRB_TT_DATA);

    mrb_define_method(mrb, rclass, "set_target", ruby_cocos2dx_NodeGrid_setTarget, ARGS_REQ(1));
    mrb_define_method(mrb, rclass, "get_grid", ruby_cocos2dx_NodeGrid_getGrid, ARGS_NONE());
    mrb_define_method(mrb, rclass, "set_grid", ruby_cocos2dx_NodeGrid_setGrid, ARGS_REQ(1));
    mrb_define_class_method(mrb, rclass, "create", ruby_cocos2dx_NodeGrid_create_static, ARGS_NONE());
}
mrb_value ruby_cocos2dx_ParticleBatchNode_setTexture(mrb_state* mrb, mrb_value self)
{
    cocos2d::ParticleBatchNode* cobj = static_cast<cocos2d::ParticleBatchNode*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            cocos2d::Texture2D* arg0;
            ok = rubyval_to_object<cocos2d::Texture2D>(mrb, argv[0], "CC::Texture2D", &arg0);
            if (!ok) { break; }
            cobj->setTexture(arg0);
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::ParticleBatchNode#setTexture");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_ParticleBatchNode_disableParticle(mrb_state* mrb, mrb_value self)
{
    cocos2d::ParticleBatchNode* cobj = static_cast<cocos2d::ParticleBatchNode*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            int arg0;
            ok = rubyval_to_int32(mrb, argv[0], (int*)&arg0, "CC::ParticleBatchNode.disableParticle");
            if (!ok) { break; }
            cobj->disableParticle(arg0);
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::ParticleBatchNode#disableParticle");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_ParticleBatchNode_getTexture(mrb_state* mrb, mrb_value self)
{
    cocos2d::ParticleBatchNode* cobj = static_cast<cocos2d::ParticleBatchNode*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            cocos2d::Texture2D* retval = cobj->getTexture();
            mrb_value ret;
            ret = object_to_rubyval<cocos2d::Texture2D>(mrb, "CC::Texture2D", (cocos2d::Texture2D*)retval, nullptr);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::ParticleBatchNode#getTexture");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_ParticleBatchNode_setTextureAtlas(mrb_state* mrb, mrb_value self)
{
    cocos2d::ParticleBatchNode* cobj = static_cast<cocos2d::ParticleBatchNode*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            cocos2d::TextureAtlas* arg0;
            ok = rubyval_to_object<cocos2d::TextureAtlas>(mrb, argv[0], "CC::TextureAtlas", &arg0);
            if (!ok) { break; }
            cobj->setTextureAtlas(arg0);
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::ParticleBatchNode#setTextureAtlas");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_ParticleBatchNode_setBlendFunc(mrb_state* mrb, mrb_value self)
{
    cocos2d::ParticleBatchNode* cobj = static_cast<cocos2d::ParticleBatchNode*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            cocos2d::BlendFunc* arg0;
            ok = rubyval_to_object<cocos2d::BlendFunc>(mrb, argv[0], "CC::BlendFunc", &arg0);
            if (!ok) { break; }
            cobj->setBlendFunc(*arg0);
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::ParticleBatchNode#setBlendFunc");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_ParticleBatchNode_removeAllChildrenWithCleanup(mrb_state* mrb, mrb_value self)
{
    cocos2d::ParticleBatchNode* cobj = static_cast<cocos2d::ParticleBatchNode*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            bool arg0;
            ok = rubyval_to_boolean(mrb, argv[0], &arg0, "CC::ParticleBatchNode.removeAllChildrenWithCleanup");
            if (!ok) { break; }
            cobj->removeAllChildrenWithCleanup(arg0);
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::ParticleBatchNode#removeAllChildrenWithCleanup");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_ParticleBatchNode_getTextureAtlas(mrb_state* mrb, mrb_value self)
{
    cocos2d::ParticleBatchNode* cobj = static_cast<cocos2d::ParticleBatchNode*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            cocos2d::TextureAtlas* retval = cobj->getTextureAtlas();
            mrb_value ret;
            ret = object_to_rubyval<cocos2d::TextureAtlas>(mrb, "CC::TextureAtlas", (cocos2d::TextureAtlas*)retval, nullptr);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::ParticleBatchNode#getTextureAtlas");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_ParticleBatchNode_getBlendFunc(mrb_state* mrb, mrb_value self)
{
    cocos2d::ParticleBatchNode* cobj = static_cast<cocos2d::ParticleBatchNode*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            cocos2d::BlendFunc retval = cobj->getBlendFunc();
            cocos2d::BlendFunc* retval_ptr = new cocos2d::BlendFunc(retval);
            mrb_value ret;
            ret = object_to_rubyval<cocos2d::BlendFunc>(mrb, "CC::BlendFunc", (cocos2d::BlendFunc*)retval_ptr, nullptr);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::ParticleBatchNode#getBlendFunc");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_ParticleBatchNode_insertChild(mrb_state* mrb, mrb_value self)
{
    cocos2d::ParticleBatchNode* cobj = static_cast<cocos2d::ParticleBatchNode*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 2) {
            cocos2d::ParticleSystem* arg0;
            ok = rubyval_to_object<cocos2d::ParticleSystem>(mrb, argv[0], "CC::ParticleSystem", &arg0);
            if (!ok) { break; }
            int arg1;
            ok = rubyval_to_int32(mrb, argv[1], (int*)&arg1, "CC::ParticleBatchNode.insertChild");
            if (!ok) { break; }
            cobj->insertChild(arg0, arg1);
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::ParticleBatchNode#insertChild");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_ParticleBatchNode_removeChildAtIndex(mrb_state* mrb, mrb_value self)
{
    cocos2d::ParticleBatchNode* cobj = static_cast<cocos2d::ParticleBatchNode*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 2) {
            int arg0;
            ok = rubyval_to_int32(mrb, argv[0], (int*)&arg0, "CC::ParticleBatchNode.removeChildAtIndex");
            if (!ok) { break; }
            bool arg1;
            ok = rubyval_to_boolean(mrb, argv[1], &arg1, "CC::ParticleBatchNode.removeChildAtIndex");
            if (!ok) { break; }
            cobj->removeChildAtIndex(arg0, arg1);
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::ParticleBatchNode#removeChildAtIndex");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_ParticleBatchNode_create_static(mrb_state* mrb, mrb_value self)
{
    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            std::map<std::string, mrb_value> callbacks;
            std::string arg0;
            ok = rubyval_to_std_string(mrb, argv[0], &arg0, "CC::ParticleBatchNode.create");
            if (!ok) { break; }

            cocos2d::ParticleBatchNode* retval = cocos2d::ParticleBatchNode::create(arg0);
            mrb_value ret;
            RClass* rclass = mrb_class_ptr(self);
            ret = object_to_rubyval<cocos2d::ParticleBatchNode>(mrb, "CC::ParticleBatchNode", (cocos2d::ParticleBatchNode*)retval, rclass);
            if (callbacks.size() > 0) {
                mrb_value hash = mrb_iv_get(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"));
                if (!mrb_hash_p(hash)) {
                    hash = mrb_hash_new(mrb);
                }
                for (auto elm : callbacks) {
                    mrb_hash_set(mrb, hash, mrb_str_new_cstr(mrb, elm.first.c_str()), elm.second);
                    mrb_iv_set(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"), hash);
                }
            }
            g_rubyValue.push_back(ret);
            mrb_funcall(mrb, ret, "initialize", 0);
            return ret;
        }
    } while (0);
    do {
        if (argc == 2) {
            std::map<std::string, mrb_value> callbacks;
            std::string arg0;
            ok = rubyval_to_std_string(mrb, argv[0], &arg0, "CC::ParticleBatchNode.create");
            if (!ok) { break; }

            int arg1;
            ok = rubyval_to_int32(mrb, argv[1], (int*)&arg1, "CC::ParticleBatchNode.create");
            if (!ok) { break; }

            cocos2d::ParticleBatchNode* retval = cocos2d::ParticleBatchNode::create(arg0, arg1);
            mrb_value ret;
            RClass* rclass = mrb_class_ptr(self);
            ret = object_to_rubyval<cocos2d::ParticleBatchNode>(mrb, "CC::ParticleBatchNode", (cocos2d::ParticleBatchNode*)retval, rclass);
            if (callbacks.size() > 0) {
                mrb_value hash = mrb_iv_get(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"));
                if (!mrb_hash_p(hash)) {
                    hash = mrb_hash_new(mrb);
                }
                for (auto elm : callbacks) {
                    mrb_hash_set(mrb, hash, mrb_str_new_cstr(mrb, elm.first.c_str()), elm.second);
                    mrb_iv_set(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"), hash);
                }
            }
            g_rubyValue.push_back(ret);
            mrb_funcall(mrb, ret, "initialize", 0);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined static method : cocos2d::ParticleBatchNode#create");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_ParticleBatchNode_createWithTexture_static(mrb_state* mrb, mrb_value self)
{
    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            std::map<std::string, mrb_value> callbacks;
            cocos2d::Texture2D* arg0;
            ok = rubyval_to_object<cocos2d::Texture2D>(mrb, argv[0], "CC::Texture2D", &arg0);
            if (!ok) { break; }

            cocos2d::ParticleBatchNode* retval = cocos2d::ParticleBatchNode::createWithTexture(arg0);
            mrb_value ret;
            RClass* rclass = mrb_class_ptr(self);
            ret = object_to_rubyval<cocos2d::ParticleBatchNode>(mrb, "CC::ParticleBatchNode", (cocos2d::ParticleBatchNode*)retval, rclass);
            if (callbacks.size() > 0) {
                mrb_value hash = mrb_iv_get(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"));
                if (!mrb_hash_p(hash)) {
                    hash = mrb_hash_new(mrb);
                }
                for (auto elm : callbacks) {
                    mrb_hash_set(mrb, hash, mrb_str_new_cstr(mrb, elm.first.c_str()), elm.second);
                    mrb_iv_set(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"), hash);
                }
            }
            g_rubyValue.push_back(ret);
            mrb_funcall(mrb, ret, "initialize", 0);
            return ret;
        }
    } while (0);
    do {
        if (argc == 2) {
            std::map<std::string, mrb_value> callbacks;
            cocos2d::Texture2D* arg0;
            ok = rubyval_to_object<cocos2d::Texture2D>(mrb, argv[0], "CC::Texture2D", &arg0);
            if (!ok) { break; }

            int arg1;
            ok = rubyval_to_int32(mrb, argv[1], (int*)&arg1, "CC::ParticleBatchNode.createWithTexture");
            if (!ok) { break; }

            cocos2d::ParticleBatchNode* retval = cocos2d::ParticleBatchNode::createWithTexture(arg0, arg1);
            mrb_value ret;
            RClass* rclass = mrb_class_ptr(self);
            ret = object_to_rubyval<cocos2d::ParticleBatchNode>(mrb, "CC::ParticleBatchNode", (cocos2d::ParticleBatchNode*)retval, rclass);
            if (callbacks.size() > 0) {
                mrb_value hash = mrb_iv_get(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"));
                if (!mrb_hash_p(hash)) {
                    hash = mrb_hash_new(mrb);
                }
                for (auto elm : callbacks) {
                    mrb_hash_set(mrb, hash, mrb_str_new_cstr(mrb, elm.first.c_str()), elm.second);
                    mrb_iv_set(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"), hash);
                }
            }
            g_rubyValue.push_back(ret);
            mrb_funcall(mrb, ret, "initialize", 0);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined static method : cocos2d::ParticleBatchNode#createWithTexture");

    return mrb_nil_value();
}

void ruby_register_cocos2dx_ParticleBatchNode(mrb_state* mrb, struct RClass* rmodule)
{
    std::string typeName = typeid(cocos2d::ParticleBatchNode).name();
    g_rubyType[typeName] = "CC::ParticleBatchNode";
    g_rubyDataType[typeName] = &ruby_cocos2dx_Ref_type;

    struct RClass* p_rmodule = mrb->object_class;
    p_rmodule = mrb_module_get_under(mrb, p_rmodule, "CC");
    struct RClass* p_rclass = mrb_class_get_under(mrb, p_rmodule, "Node");
    struct RClass *rclass = mrb_define_class_under(mrb, rmodule, "ParticleBatchNode", p_rclass);
    MRB_SET_INSTANCE_TT(rclass, MRB_TT_DATA);

    mrb_define_method(mrb, rclass, "set_texture", ruby_cocos2dx_ParticleBatchNode_setTexture, ARGS_REQ(1));
    mrb_define_method(mrb, rclass, "disable_particle", ruby_cocos2dx_ParticleBatchNode_disableParticle, ARGS_REQ(1));
    mrb_define_method(mrb, rclass, "get_texture", ruby_cocos2dx_ParticleBatchNode_getTexture, ARGS_NONE());
    mrb_define_method(mrb, rclass, "set_texture_atlas", ruby_cocos2dx_ParticleBatchNode_setTextureAtlas, ARGS_REQ(1));
    mrb_define_method(mrb, rclass, "set_blend_func", ruby_cocos2dx_ParticleBatchNode_setBlendFunc, ARGS_REQ(1));
    mrb_define_method(mrb, rclass, "remove_all_children_with_cleanup", ruby_cocos2dx_ParticleBatchNode_removeAllChildrenWithCleanup, ARGS_REQ(1));
    mrb_define_method(mrb, rclass, "get_texture_atlas", ruby_cocos2dx_ParticleBatchNode_getTextureAtlas, ARGS_NONE());
    mrb_define_method(mrb, rclass, "get_blend_func", ruby_cocos2dx_ParticleBatchNode_getBlendFunc, ARGS_NONE());
    mrb_define_method(mrb, rclass, "insert_child", ruby_cocos2dx_ParticleBatchNode_insertChild, ARGS_REQ(2));
    mrb_define_method(mrb, rclass, "remove_child_at_index", ruby_cocos2dx_ParticleBatchNode_removeChildAtIndex, ARGS_REQ(2));
    mrb_define_class_method(mrb, rclass, "create", ruby_cocos2dx_ParticleBatchNode_create_static, ARGS_REQ(2));
    mrb_define_class_method(mrb, rclass, "create_with_texture", ruby_cocos2dx_ParticleBatchNode_createWithTexture_static, ARGS_REQ(2));
}
mrb_value ruby_cocos2dx_ParticleSystem_getStartSizeVar(mrb_state* mrb, mrb_value self)
{
    cocos2d::ParticleSystem* cobj = static_cast<cocos2d::ParticleSystem*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            double retval = cobj->getStartSizeVar();
            mrb_value ret;
            ret = mrb_float_value(mrb, (mrb_float)retval);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::ParticleSystem#getStartSizeVar");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_ParticleSystem_getTexture(mrb_state* mrb, mrb_value self)
{
    cocos2d::ParticleSystem* cobj = static_cast<cocos2d::ParticleSystem*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            cocos2d::Texture2D* retval = cobj->getTexture();
            mrb_value ret;
            ret = object_to_rubyval<cocos2d::Texture2D>(mrb, "CC::Texture2D", (cocos2d::Texture2D*)retval, nullptr);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::ParticleSystem#getTexture");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_ParticleSystem_isFull(mrb_state* mrb, mrb_value self)
{
    cocos2d::ParticleSystem* cobj = static_cast<cocos2d::ParticleSystem*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            bool retval = cobj->isFull();
            mrb_value ret;
            ret = mrb_bool_value((mrb_bool)retval);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::ParticleSystem#isFull");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_ParticleSystem_getBatchNode(mrb_state* mrb, mrb_value self)
{
    cocos2d::ParticleSystem* cobj = static_cast<cocos2d::ParticleSystem*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            cocos2d::ParticleBatchNode* retval = cobj->getBatchNode();
            mrb_value ret;
            ret = object_to_rubyval<cocos2d::ParticleBatchNode>(mrb, "CC::ParticleBatchNode", (cocos2d::ParticleBatchNode*)retval, nullptr);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::ParticleSystem#getBatchNode");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_ParticleSystem_getStartColor(mrb_state* mrb, mrb_value self)
{
    cocos2d::ParticleSystem* cobj = static_cast<cocos2d::ParticleSystem*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            cocos2d::Color4F retval = cobj->getStartColor();
            cocos2d::Color4F* retval_ptr = new cocos2d::Color4F(retval);
            mrb_value ret;
            ret = object_to_rubyval<cocos2d::Color4F>(mrb, "CC::Color4F", (cocos2d::Color4F*)retval_ptr, nullptr);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::ParticleSystem#getStartColor");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_ParticleSystem_getPositionType(mrb_state* mrb, mrb_value self)
{
    cocos2d::ParticleSystem* cobj = static_cast<cocos2d::ParticleSystem*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            int retval = (int)cobj->getPositionType();
            mrb_value ret;
            ret = mrb_fixnum_value((mrb_int)retval);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::ParticleSystem#getPositionType");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_ParticleSystem_setPosVar(mrb_state* mrb, mrb_value self)
{
    cocos2d::ParticleSystem* cobj = static_cast<cocos2d::ParticleSystem*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            cocos2d::Vec2* arg0;
            ok = rubyval_to_object<cocos2d::Vec2>(mrb, argv[0], "CC::Vec2", &arg0);
            if (!ok) { break; }
            cobj->setPosVar(*arg0);
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::ParticleSystem#setPosVar");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_ParticleSystem_getEndSpin(mrb_state* mrb, mrb_value self)
{
    cocos2d::ParticleSystem* cobj = static_cast<cocos2d::ParticleSystem*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            double retval = cobj->getEndSpin();
            mrb_value ret;
            ret = mrb_float_value(mrb, (mrb_float)retval);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::ParticleSystem#getEndSpin");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_ParticleSystem_setRotatePerSecondVar(mrb_state* mrb, mrb_value self)
{
    cocos2d::ParticleSystem* cobj = static_cast<cocos2d::ParticleSystem*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            double arg0;
            ok = rubyval_to_number(mrb, argv[0], (double*)&arg0, "CC::ParticleSystem.setRotatePerSecondVar");
            if (!ok) { break; }
            cobj->setRotatePerSecondVar(arg0);
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::ParticleSystem#setRotatePerSecondVar");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_ParticleSystem_getStartSpinVar(mrb_state* mrb, mrb_value self)
{
    cocos2d::ParticleSystem* cobj = static_cast<cocos2d::ParticleSystem*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            double retval = cobj->getStartSpinVar();
            mrb_value ret;
            ret = mrb_float_value(mrb, (mrb_float)retval);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::ParticleSystem#getStartSpinVar");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_ParticleSystem_getRadialAccelVar(mrb_state* mrb, mrb_value self)
{
    cocos2d::ParticleSystem* cobj = static_cast<cocos2d::ParticleSystem*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            double retval = cobj->getRadialAccelVar();
            mrb_value ret;
            ret = mrb_float_value(mrb, (mrb_float)retval);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::ParticleSystem#getRadialAccelVar");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_ParticleSystem_getEndSizeVar(mrb_state* mrb, mrb_value self)
{
    cocos2d::ParticleSystem* cobj = static_cast<cocos2d::ParticleSystem*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            double retval = cobj->getEndSizeVar();
            mrb_value ret;
            ret = mrb_float_value(mrb, (mrb_float)retval);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::ParticleSystem#getEndSizeVar");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_ParticleSystem_setRotation(mrb_state* mrb, mrb_value self)
{
    cocos2d::ParticleSystem* cobj = static_cast<cocos2d::ParticleSystem*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            double arg0;
            ok = rubyval_to_number(mrb, argv[0], (double*)&arg0, "CC::ParticleSystem.setRotation");
            if (!ok) { break; }
            cobj->setRotation(arg0);
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::ParticleSystem#setRotation");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_ParticleSystem_setTangentialAccel(mrb_state* mrb, mrb_value self)
{
    cocos2d::ParticleSystem* cobj = static_cast<cocos2d::ParticleSystem*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            double arg0;
            ok = rubyval_to_number(mrb, argv[0], (double*)&arg0, "CC::ParticleSystem.setTangentialAccel");
            if (!ok) { break; }
            cobj->setTangentialAccel(arg0);
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::ParticleSystem#setTangentialAccel");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_ParticleSystem_setScaleY(mrb_state* mrb, mrb_value self)
{
    cocos2d::ParticleSystem* cobj = static_cast<cocos2d::ParticleSystem*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            double arg0;
            ok = rubyval_to_number(mrb, argv[0], (double*)&arg0, "CC::ParticleSystem.setScaleY");
            if (!ok) { break; }
            cobj->setScaleY(arg0);
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::ParticleSystem#setScaleY");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_ParticleSystem_setScaleX(mrb_state* mrb, mrb_value self)
{
    cocos2d::ParticleSystem* cobj = static_cast<cocos2d::ParticleSystem*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            double arg0;
            ok = rubyval_to_number(mrb, argv[0], (double*)&arg0, "CC::ParticleSystem.setScaleX");
            if (!ok) { break; }
            cobj->setScaleX(arg0);
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::ParticleSystem#setScaleX");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_ParticleSystem_getRadialAccel(mrb_state* mrb, mrb_value self)
{
    cocos2d::ParticleSystem* cobj = static_cast<cocos2d::ParticleSystem*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            double retval = cobj->getRadialAccel();
            mrb_value ret;
            ret = mrb_float_value(mrb, (mrb_float)retval);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::ParticleSystem#getRadialAccel");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_ParticleSystem_setStartRadius(mrb_state* mrb, mrb_value self)
{
    cocos2d::ParticleSystem* cobj = static_cast<cocos2d::ParticleSystem*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            double arg0;
            ok = rubyval_to_number(mrb, argv[0], (double*)&arg0, "CC::ParticleSystem.setStartRadius");
            if (!ok) { break; }
            cobj->setStartRadius(arg0);
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::ParticleSystem#setStartRadius");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_ParticleSystem_setRotatePerSecond(mrb_state* mrb, mrb_value self)
{
    cocos2d::ParticleSystem* cobj = static_cast<cocos2d::ParticleSystem*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            double arg0;
            ok = rubyval_to_number(mrb, argv[0], (double*)&arg0, "CC::ParticleSystem.setRotatePerSecond");
            if (!ok) { break; }
            cobj->setRotatePerSecond(arg0);
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::ParticleSystem#setRotatePerSecond");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_ParticleSystem_setEndSize(mrb_state* mrb, mrb_value self)
{
    cocos2d::ParticleSystem* cobj = static_cast<cocos2d::ParticleSystem*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            double arg0;
            ok = rubyval_to_number(mrb, argv[0], (double*)&arg0, "CC::ParticleSystem.setEndSize");
            if (!ok) { break; }
            cobj->setEndSize(arg0);
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::ParticleSystem#setEndSize");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_ParticleSystem_getGravity(mrb_state* mrb, mrb_value self)
{
    cocos2d::ParticleSystem* cobj = static_cast<cocos2d::ParticleSystem*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            cocos2d::Vec2 retval = cobj->getGravity();
            cocos2d::Vec2* retval_ptr = new cocos2d::Vec2(retval);
            mrb_value ret;
            ret = object_to_rubyval<cocos2d::Vec2>(mrb, "CC::Vec2", (cocos2d::Vec2*)retval_ptr, nullptr);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::ParticleSystem#getGravity");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_ParticleSystem_getTangentialAccel(mrb_state* mrb, mrb_value self)
{
    cocos2d::ParticleSystem* cobj = static_cast<cocos2d::ParticleSystem*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            double retval = cobj->getTangentialAccel();
            mrb_value ret;
            ret = mrb_float_value(mrb, (mrb_float)retval);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::ParticleSystem#getTangentialAccel");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_ParticleSystem_setEndRadius(mrb_state* mrb, mrb_value self)
{
    cocos2d::ParticleSystem* cobj = static_cast<cocos2d::ParticleSystem*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            double arg0;
            ok = rubyval_to_number(mrb, argv[0], (double*)&arg0, "CC::ParticleSystem.setEndRadius");
            if (!ok) { break; }
            cobj->setEndRadius(arg0);
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::ParticleSystem#setEndRadius");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_ParticleSystem_getSpeed(mrb_state* mrb, mrb_value self)
{
    cocos2d::ParticleSystem* cobj = static_cast<cocos2d::ParticleSystem*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            double retval = cobj->getSpeed();
            mrb_value ret;
            ret = mrb_float_value(mrb, (mrb_float)retval);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::ParticleSystem#getSpeed");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_ParticleSystem_getAngle(mrb_state* mrb, mrb_value self)
{
    cocos2d::ParticleSystem* cobj = static_cast<cocos2d::ParticleSystem*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            double retval = cobj->getAngle();
            mrb_value ret;
            ret = mrb_float_value(mrb, (mrb_float)retval);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::ParticleSystem#getAngle");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_ParticleSystem_setEndColor(mrb_state* mrb, mrb_value self)
{
    cocos2d::ParticleSystem* cobj = static_cast<cocos2d::ParticleSystem*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            cocos2d::Color4F* arg0;
            ok = rubyval_to_object<cocos2d::Color4F>(mrb, argv[0], "CC::Color4F", &arg0);
            if (!ok) { break; }
            cobj->setEndColor(*arg0);
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::ParticleSystem#setEndColor");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_ParticleSystem_setStartSpin(mrb_state* mrb, mrb_value self)
{
    cocos2d::ParticleSystem* cobj = static_cast<cocos2d::ParticleSystem*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            double arg0;
            ok = rubyval_to_number(mrb, argv[0], (double*)&arg0, "CC::ParticleSystem.setStartSpin");
            if (!ok) { break; }
            cobj->setStartSpin(arg0);
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::ParticleSystem#setStartSpin");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_ParticleSystem_setDuration(mrb_state* mrb, mrb_value self)
{
    cocos2d::ParticleSystem* cobj = static_cast<cocos2d::ParticleSystem*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            double arg0;
            ok = rubyval_to_number(mrb, argv[0], (double*)&arg0, "CC::ParticleSystem.setDuration");
            if (!ok) { break; }
            cobj->setDuration(arg0);
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::ParticleSystem#setDuration");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_ParticleSystem_setTexture(mrb_state* mrb, mrb_value self)
{
    cocos2d::ParticleSystem* cobj = static_cast<cocos2d::ParticleSystem*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            cocos2d::Texture2D* arg0;
            ok = rubyval_to_object<cocos2d::Texture2D>(mrb, argv[0], "CC::Texture2D", &arg0);
            if (!ok) { break; }
            cobj->setTexture(arg0);
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::ParticleSystem#setTexture");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_ParticleSystem_getPosVar(mrb_state* mrb, mrb_value self)
{
    cocos2d::ParticleSystem* cobj = static_cast<cocos2d::ParticleSystem*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            cocos2d::Vec2 retval = cobj->getPosVar();
            cocos2d::Vec2* retval_ptr = new cocos2d::Vec2(retval);
            mrb_value ret;
            ret = object_to_rubyval<cocos2d::Vec2>(mrb, "CC::Vec2", (cocos2d::Vec2*)retval_ptr, nullptr);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::ParticleSystem#getPosVar");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_ParticleSystem_updateWithNoTime(mrb_state* mrb, mrb_value self)
{
    cocos2d::ParticleSystem* cobj = static_cast<cocos2d::ParticleSystem*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            cobj->updateWithNoTime();
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::ParticleSystem#updateWithNoTime");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_ParticleSystem_isBlendAdditive(mrb_state* mrb, mrb_value self)
{
    cocos2d::ParticleSystem* cobj = static_cast<cocos2d::ParticleSystem*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            bool retval = cobj->isBlendAdditive();
            mrb_value ret;
            ret = mrb_bool_value((mrb_bool)retval);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::ParticleSystem#isBlendAdditive");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_ParticleSystem_getSpeedVar(mrb_state* mrb, mrb_value self)
{
    cocos2d::ParticleSystem* cobj = static_cast<cocos2d::ParticleSystem*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            double retval = cobj->getSpeedVar();
            mrb_value ret;
            ret = mrb_float_value(mrb, (mrb_float)retval);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::ParticleSystem#getSpeedVar");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_ParticleSystem_setPositionType(mrb_state* mrb, mrb_value self)
{
    cocos2d::ParticleSystem* cobj = static_cast<cocos2d::ParticleSystem*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            cocos2d::ParticleSystem::PositionType arg0;
            ok = rubyval_to_int32(mrb, argv[0], (int*)&arg0, "CC::ParticleSystem.setPositionType");
            if (!ok) { break; }
            cobj->setPositionType(arg0);
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::ParticleSystem#setPositionType");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_ParticleSystem_stopSystem(mrb_state* mrb, mrb_value self)
{
    cocos2d::ParticleSystem* cobj = static_cast<cocos2d::ParticleSystem*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            cobj->stopSystem();
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::ParticleSystem#stopSystem");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_ParticleSystem_getSourcePosition(mrb_state* mrb, mrb_value self)
{
    cocos2d::ParticleSystem* cobj = static_cast<cocos2d::ParticleSystem*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            cocos2d::Vec2 retval = cobj->getSourcePosition();
            cocos2d::Vec2* retval_ptr = new cocos2d::Vec2(retval);
            mrb_value ret;
            ret = object_to_rubyval<cocos2d::Vec2>(mrb, "CC::Vec2", (cocos2d::Vec2*)retval_ptr, nullptr);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::ParticleSystem#getSourcePosition");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_ParticleSystem_setLifeVar(mrb_state* mrb, mrb_value self)
{
    cocos2d::ParticleSystem* cobj = static_cast<cocos2d::ParticleSystem*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            double arg0;
            ok = rubyval_to_number(mrb, argv[0], (double*)&arg0, "CC::ParticleSystem.setLifeVar");
            if (!ok) { break; }
            cobj->setLifeVar(arg0);
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::ParticleSystem#setLifeVar");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_ParticleSystem_setTotalParticles(mrb_state* mrb, mrb_value self)
{
    cocos2d::ParticleSystem* cobj = static_cast<cocos2d::ParticleSystem*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            int arg0;
            ok = rubyval_to_int32(mrb, argv[0], (int*)&arg0, "CC::ParticleSystem.setTotalParticles");
            if (!ok) { break; }
            cobj->setTotalParticles(arg0);
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::ParticleSystem#setTotalParticles");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_ParticleSystem_setEndColorVar(mrb_state* mrb, mrb_value self)
{
    cocos2d::ParticleSystem* cobj = static_cast<cocos2d::ParticleSystem*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            cocos2d::Color4F* arg0;
            ok = rubyval_to_object<cocos2d::Color4F>(mrb, argv[0], "CC::Color4F", &arg0);
            if (!ok) { break; }
            cobj->setEndColorVar(*arg0);
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::ParticleSystem#setEndColorVar");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_ParticleSystem_getAtlasIndex(mrb_state* mrb, mrb_value self)
{
    cocos2d::ParticleSystem* cobj = static_cast<cocos2d::ParticleSystem*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            int retval = cobj->getAtlasIndex();
            mrb_value ret;
            ret = mrb_fixnum_value((mrb_int)retval);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::ParticleSystem#getAtlasIndex");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_ParticleSystem_getStartSize(mrb_state* mrb, mrb_value self)
{
    cocos2d::ParticleSystem* cobj = static_cast<cocos2d::ParticleSystem*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            double retval = cobj->getStartSize();
            mrb_value ret;
            ret = mrb_float_value(mrb, (mrb_float)retval);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::ParticleSystem#getStartSize");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_ParticleSystem_setStartSpinVar(mrb_state* mrb, mrb_value self)
{
    cocos2d::ParticleSystem* cobj = static_cast<cocos2d::ParticleSystem*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            double arg0;
            ok = rubyval_to_number(mrb, argv[0], (double*)&arg0, "CC::ParticleSystem.setStartSpinVar");
            if (!ok) { break; }
            cobj->setStartSpinVar(arg0);
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::ParticleSystem#setStartSpinVar");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_ParticleSystem_resetSystem(mrb_state* mrb, mrb_value self)
{
    cocos2d::ParticleSystem* cobj = static_cast<cocos2d::ParticleSystem*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            cobj->resetSystem();
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::ParticleSystem#resetSystem");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_ParticleSystem_setAtlasIndex(mrb_state* mrb, mrb_value self)
{
    cocos2d::ParticleSystem* cobj = static_cast<cocos2d::ParticleSystem*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            int arg0;
            ok = rubyval_to_int32(mrb, argv[0], (int*)&arg0, "CC::ParticleSystem.setAtlasIndex");
            if (!ok) { break; }
            cobj->setAtlasIndex(arg0);
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::ParticleSystem#setAtlasIndex");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_ParticleSystem_setTangentialAccelVar(mrb_state* mrb, mrb_value self)
{
    cocos2d::ParticleSystem* cobj = static_cast<cocos2d::ParticleSystem*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            double arg0;
            ok = rubyval_to_number(mrb, argv[0], (double*)&arg0, "CC::ParticleSystem.setTangentialAccelVar");
            if (!ok) { break; }
            cobj->setTangentialAccelVar(arg0);
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::ParticleSystem#setTangentialAccelVar");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_ParticleSystem_setEndRadiusVar(mrb_state* mrb, mrb_value self)
{
    cocos2d::ParticleSystem* cobj = static_cast<cocos2d::ParticleSystem*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            double arg0;
            ok = rubyval_to_number(mrb, argv[0], (double*)&arg0, "CC::ParticleSystem.setEndRadiusVar");
            if (!ok) { break; }
            cobj->setEndRadiusVar(arg0);
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::ParticleSystem#setEndRadiusVar");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_ParticleSystem_getEndRadius(mrb_state* mrb, mrb_value self)
{
    cocos2d::ParticleSystem* cobj = static_cast<cocos2d::ParticleSystem*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            double retval = cobj->getEndRadius();
            mrb_value ret;
            ret = mrb_float_value(mrb, (mrb_float)retval);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::ParticleSystem#getEndRadius");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_ParticleSystem_isOpacityModifyRGB(mrb_state* mrb, mrb_value self)
{
    cocos2d::ParticleSystem* cobj = static_cast<cocos2d::ParticleSystem*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            bool retval = cobj->isOpacityModifyRGB();
            mrb_value ret;
            ret = mrb_bool_value((mrb_bool)retval);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::ParticleSystem#isOpacityModifyRGB");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_ParticleSystem_isActive(mrb_state* mrb, mrb_value self)
{
    cocos2d::ParticleSystem* cobj = static_cast<cocos2d::ParticleSystem*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            bool retval = cobj->isActive();
            mrb_value ret;
            ret = mrb_bool_value((mrb_bool)retval);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::ParticleSystem#isActive");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_ParticleSystem_setRadialAccelVar(mrb_state* mrb, mrb_value self)
{
    cocos2d::ParticleSystem* cobj = static_cast<cocos2d::ParticleSystem*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            double arg0;
            ok = rubyval_to_number(mrb, argv[0], (double*)&arg0, "CC::ParticleSystem.setRadialAccelVar");
            if (!ok) { break; }
            cobj->setRadialAccelVar(arg0);
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::ParticleSystem#setRadialAccelVar");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_ParticleSystem_setStartSize(mrb_state* mrb, mrb_value self)
{
    cocos2d::ParticleSystem* cobj = static_cast<cocos2d::ParticleSystem*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            double arg0;
            ok = rubyval_to_number(mrb, argv[0], (double*)&arg0, "CC::ParticleSystem.setStartSize");
            if (!ok) { break; }
            cobj->setStartSize(arg0);
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::ParticleSystem#setStartSize");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_ParticleSystem_setSpeed(mrb_state* mrb, mrb_value self)
{
    cocos2d::ParticleSystem* cobj = static_cast<cocos2d::ParticleSystem*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            double arg0;
            ok = rubyval_to_number(mrb, argv[0], (double*)&arg0, "CC::ParticleSystem.setSpeed");
            if (!ok) { break; }
            cobj->setSpeed(arg0);
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::ParticleSystem#setSpeed");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_ParticleSystem_getStartSpin(mrb_state* mrb, mrb_value self)
{
    cocos2d::ParticleSystem* cobj = static_cast<cocos2d::ParticleSystem*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            double retval = cobj->getStartSpin();
            mrb_value ret;
            ret = mrb_float_value(mrb, (mrb_float)retval);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::ParticleSystem#getStartSpin");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_ParticleSystem_getRotatePerSecond(mrb_state* mrb, mrb_value self)
{
    cocos2d::ParticleSystem* cobj = static_cast<cocos2d::ParticleSystem*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            double retval = cobj->getRotatePerSecond();
            mrb_value ret;
            ret = mrb_float_value(mrb, (mrb_float)retval);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::ParticleSystem#getRotatePerSecond");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_ParticleSystem_setEmitterMode(mrb_state* mrb, mrb_value self)
{
    cocos2d::ParticleSystem* cobj = static_cast<cocos2d::ParticleSystem*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            cocos2d::ParticleSystem::Mode arg0;
            ok = rubyval_to_int32(mrb, argv[0], (int*)&arg0, "CC::ParticleSystem.setEmitterMode");
            if (!ok) { break; }
            cobj->setEmitterMode(arg0);
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::ParticleSystem#setEmitterMode");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_ParticleSystem_getDuration(mrb_state* mrb, mrb_value self)
{
    cocos2d::ParticleSystem* cobj = static_cast<cocos2d::ParticleSystem*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            double retval = cobj->getDuration();
            mrb_value ret;
            ret = mrb_float_value(mrb, (mrb_float)retval);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::ParticleSystem#getDuration");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_ParticleSystem_setSourcePosition(mrb_state* mrb, mrb_value self)
{
    cocos2d::ParticleSystem* cobj = static_cast<cocos2d::ParticleSystem*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            cocos2d::Vec2* arg0;
            ok = rubyval_to_object<cocos2d::Vec2>(mrb, argv[0], "CC::Vec2", &arg0);
            if (!ok) { break; }
            cobj->setSourcePosition(*arg0);
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::ParticleSystem#setSourcePosition");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_ParticleSystem_getEndSpinVar(mrb_state* mrb, mrb_value self)
{
    cocos2d::ParticleSystem* cobj = static_cast<cocos2d::ParticleSystem*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            double retval = cobj->getEndSpinVar();
            mrb_value ret;
            ret = mrb_float_value(mrb, (mrb_float)retval);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::ParticleSystem#getEndSpinVar");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_ParticleSystem_setBlendAdditive(mrb_state* mrb, mrb_value self)
{
    cocos2d::ParticleSystem* cobj = static_cast<cocos2d::ParticleSystem*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            bool arg0;
            ok = rubyval_to_boolean(mrb, argv[0], &arg0, "CC::ParticleSystem.setBlendAdditive");
            if (!ok) { break; }
            cobj->setBlendAdditive(arg0);
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::ParticleSystem#setBlendAdditive");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_ParticleSystem_setLife(mrb_state* mrb, mrb_value self)
{
    cocos2d::ParticleSystem* cobj = static_cast<cocos2d::ParticleSystem*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            double arg0;
            ok = rubyval_to_number(mrb, argv[0], (double*)&arg0, "CC::ParticleSystem.setLife");
            if (!ok) { break; }
            cobj->setLife(arg0);
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::ParticleSystem#setLife");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_ParticleSystem_setAngleVar(mrb_state* mrb, mrb_value self)
{
    cocos2d::ParticleSystem* cobj = static_cast<cocos2d::ParticleSystem*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            double arg0;
            ok = rubyval_to_number(mrb, argv[0], (double*)&arg0, "CC::ParticleSystem.setAngleVar");
            if (!ok) { break; }
            cobj->setAngleVar(arg0);
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::ParticleSystem#setAngleVar");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_ParticleSystem_setRotationIsDir(mrb_state* mrb, mrb_value self)
{
    cocos2d::ParticleSystem* cobj = static_cast<cocos2d::ParticleSystem*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            bool arg0;
            ok = rubyval_to_boolean(mrb, argv[0], &arg0, "CC::ParticleSystem.setRotationIsDir");
            if (!ok) { break; }
            cobj->setRotationIsDir(arg0);
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::ParticleSystem#setRotationIsDir");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_ParticleSystem_setEndSizeVar(mrb_state* mrb, mrb_value self)
{
    cocos2d::ParticleSystem* cobj = static_cast<cocos2d::ParticleSystem*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            double arg0;
            ok = rubyval_to_number(mrb, argv[0], (double*)&arg0, "CC::ParticleSystem.setEndSizeVar");
            if (!ok) { break; }
            cobj->setEndSizeVar(arg0);
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::ParticleSystem#setEndSizeVar");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_ParticleSystem_setAngle(mrb_state* mrb, mrb_value self)
{
    cocos2d::ParticleSystem* cobj = static_cast<cocos2d::ParticleSystem*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            double arg0;
            ok = rubyval_to_number(mrb, argv[0], (double*)&arg0, "CC::ParticleSystem.setAngle");
            if (!ok) { break; }
            cobj->setAngle(arg0);
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::ParticleSystem#setAngle");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_ParticleSystem_setBatchNode(mrb_state* mrb, mrb_value self)
{
    cocos2d::ParticleSystem* cobj = static_cast<cocos2d::ParticleSystem*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            cocos2d::ParticleBatchNode* arg0;
            ok = rubyval_to_object<cocos2d::ParticleBatchNode>(mrb, argv[0], "CC::ParticleBatchNode", &arg0);
            if (!ok) { break; }
            cobj->setBatchNode(arg0);
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::ParticleSystem#setBatchNode");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_ParticleSystem_getTangentialAccelVar(mrb_state* mrb, mrb_value self)
{
    cocos2d::ParticleSystem* cobj = static_cast<cocos2d::ParticleSystem*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            double retval = cobj->getTangentialAccelVar();
            mrb_value ret;
            ret = mrb_float_value(mrb, (mrb_float)retval);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::ParticleSystem#getTangentialAccelVar");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_ParticleSystem_getEmitterMode(mrb_state* mrb, mrb_value self)
{
    cocos2d::ParticleSystem* cobj = static_cast<cocos2d::ParticleSystem*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            int retval = (int)cobj->getEmitterMode();
            mrb_value ret;
            ret = mrb_fixnum_value((mrb_int)retval);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::ParticleSystem#getEmitterMode");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_ParticleSystem_setEndSpinVar(mrb_state* mrb, mrb_value self)
{
    cocos2d::ParticleSystem* cobj = static_cast<cocos2d::ParticleSystem*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            double arg0;
            ok = rubyval_to_number(mrb, argv[0], (double*)&arg0, "CC::ParticleSystem.setEndSpinVar");
            if (!ok) { break; }
            cobj->setEndSpinVar(arg0);
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::ParticleSystem#setEndSpinVar");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_ParticleSystem_getAngleVar(mrb_state* mrb, mrb_value self)
{
    cocos2d::ParticleSystem* cobj = static_cast<cocos2d::ParticleSystem*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            double retval = cobj->getAngleVar();
            mrb_value ret;
            ret = mrb_float_value(mrb, (mrb_float)retval);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::ParticleSystem#getAngleVar");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_ParticleSystem_setStartColor(mrb_state* mrb, mrb_value self)
{
    cocos2d::ParticleSystem* cobj = static_cast<cocos2d::ParticleSystem*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            cocos2d::Color4F* arg0;
            ok = rubyval_to_object<cocos2d::Color4F>(mrb, argv[0], "CC::Color4F", &arg0);
            if (!ok) { break; }
            cobj->setStartColor(*arg0);
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::ParticleSystem#setStartColor");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_ParticleSystem_getRotatePerSecondVar(mrb_state* mrb, mrb_value self)
{
    cocos2d::ParticleSystem* cobj = static_cast<cocos2d::ParticleSystem*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            double retval = cobj->getRotatePerSecondVar();
            mrb_value ret;
            ret = mrb_float_value(mrb, (mrb_float)retval);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::ParticleSystem#getRotatePerSecondVar");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_ParticleSystem_getEndSize(mrb_state* mrb, mrb_value self)
{
    cocos2d::ParticleSystem* cobj = static_cast<cocos2d::ParticleSystem*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            double retval = cobj->getEndSize();
            mrb_value ret;
            ret = mrb_float_value(mrb, (mrb_float)retval);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::ParticleSystem#getEndSize");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_ParticleSystem_getLife(mrb_state* mrb, mrb_value self)
{
    cocos2d::ParticleSystem* cobj = static_cast<cocos2d::ParticleSystem*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            double retval = cobj->getLife();
            mrb_value ret;
            ret = mrb_float_value(mrb, (mrb_float)retval);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::ParticleSystem#getLife");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_ParticleSystem_setSpeedVar(mrb_state* mrb, mrb_value self)
{
    cocos2d::ParticleSystem* cobj = static_cast<cocos2d::ParticleSystem*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            double arg0;
            ok = rubyval_to_number(mrb, argv[0], (double*)&arg0, "CC::ParticleSystem.setSpeedVar");
            if (!ok) { break; }
            cobj->setSpeedVar(arg0);
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::ParticleSystem#setSpeedVar");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_ParticleSystem_setAutoRemoveOnFinish(mrb_state* mrb, mrb_value self)
{
    cocos2d::ParticleSystem* cobj = static_cast<cocos2d::ParticleSystem*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            bool arg0;
            ok = rubyval_to_boolean(mrb, argv[0], &arg0, "CC::ParticleSystem.setAutoRemoveOnFinish");
            if (!ok) { break; }
            cobj->setAutoRemoveOnFinish(arg0);
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::ParticleSystem#setAutoRemoveOnFinish");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_ParticleSystem_setGravity(mrb_state* mrb, mrb_value self)
{
    cocos2d::ParticleSystem* cobj = static_cast<cocos2d::ParticleSystem*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            cocos2d::Vec2* arg0;
            ok = rubyval_to_object<cocos2d::Vec2>(mrb, argv[0], "CC::Vec2", &arg0);
            if (!ok) { break; }
            cobj->setGravity(*arg0);
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::ParticleSystem#setGravity");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_ParticleSystem_postStep(mrb_state* mrb, mrb_value self)
{
    cocos2d::ParticleSystem* cobj = static_cast<cocos2d::ParticleSystem*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            cobj->postStep();
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::ParticleSystem#postStep");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_ParticleSystem_setEmissionRate(mrb_state* mrb, mrb_value self)
{
    cocos2d::ParticleSystem* cobj = static_cast<cocos2d::ParticleSystem*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            double arg0;
            ok = rubyval_to_number(mrb, argv[0], (double*)&arg0, "CC::ParticleSystem.setEmissionRate");
            if (!ok) { break; }
            cobj->setEmissionRate(arg0);
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::ParticleSystem#setEmissionRate");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_ParticleSystem_getEndColorVar(mrb_state* mrb, mrb_value self)
{
    cocos2d::ParticleSystem* cobj = static_cast<cocos2d::ParticleSystem*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            cocos2d::Color4F retval = cobj->getEndColorVar();
            cocos2d::Color4F* retval_ptr = new cocos2d::Color4F(retval);
            mrb_value ret;
            ret = object_to_rubyval<cocos2d::Color4F>(mrb, "CC::Color4F", (cocos2d::Color4F*)retval_ptr, nullptr);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::ParticleSystem#getEndColorVar");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_ParticleSystem_getRotationIsDir(mrb_state* mrb, mrb_value self)
{
    cocos2d::ParticleSystem* cobj = static_cast<cocos2d::ParticleSystem*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            bool retval = cobj->getRotationIsDir();
            mrb_value ret;
            ret = mrb_bool_value((mrb_bool)retval);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::ParticleSystem#getRotationIsDir");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_ParticleSystem_setScale(mrb_state* mrb, mrb_value self)
{
    cocos2d::ParticleSystem* cobj = static_cast<cocos2d::ParticleSystem*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            double arg0;
            ok = rubyval_to_number(mrb, argv[0], (double*)&arg0, "CC::ParticleSystem.setScale");
            if (!ok) { break; }
            cobj->setScale(arg0);
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::ParticleSystem#setScale");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_ParticleSystem_getEmissionRate(mrb_state* mrb, mrb_value self)
{
    cocos2d::ParticleSystem* cobj = static_cast<cocos2d::ParticleSystem*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            double retval = cobj->getEmissionRate();
            mrb_value ret;
            ret = mrb_float_value(mrb, (mrb_float)retval);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::ParticleSystem#getEmissionRate");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_ParticleSystem_getEndColor(mrb_state* mrb, mrb_value self)
{
    cocos2d::ParticleSystem* cobj = static_cast<cocos2d::ParticleSystem*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            cocos2d::Color4F retval = cobj->getEndColor();
            cocos2d::Color4F* retval_ptr = new cocos2d::Color4F(retval);
            mrb_value ret;
            ret = object_to_rubyval<cocos2d::Color4F>(mrb, "CC::Color4F", (cocos2d::Color4F*)retval_ptr, nullptr);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::ParticleSystem#getEndColor");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_ParticleSystem_getLifeVar(mrb_state* mrb, mrb_value self)
{
    cocos2d::ParticleSystem* cobj = static_cast<cocos2d::ParticleSystem*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            double retval = cobj->getLifeVar();
            mrb_value ret;
            ret = mrb_float_value(mrb, (mrb_float)retval);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::ParticleSystem#getLifeVar");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_ParticleSystem_setStartSizeVar(mrb_state* mrb, mrb_value self)
{
    cocos2d::ParticleSystem* cobj = static_cast<cocos2d::ParticleSystem*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            double arg0;
            ok = rubyval_to_number(mrb, argv[0], (double*)&arg0, "CC::ParticleSystem.setStartSizeVar");
            if (!ok) { break; }
            cobj->setStartSizeVar(arg0);
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::ParticleSystem#setStartSizeVar");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_ParticleSystem_setOpacityModifyRGB(mrb_state* mrb, mrb_value self)
{
    cocos2d::ParticleSystem* cobj = static_cast<cocos2d::ParticleSystem*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            bool arg0;
            ok = rubyval_to_boolean(mrb, argv[0], &arg0, "CC::ParticleSystem.setOpacityModifyRGB");
            if (!ok) { break; }
            cobj->setOpacityModifyRGB(arg0);
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::ParticleSystem#setOpacityModifyRGB");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_ParticleSystem_addParticle(mrb_state* mrb, mrb_value self)
{
    cocos2d::ParticleSystem* cobj = static_cast<cocos2d::ParticleSystem*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            bool retval = cobj->addParticle();
            mrb_value ret;
            ret = mrb_bool_value((mrb_bool)retval);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::ParticleSystem#addParticle");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_ParticleSystem_getStartRadius(mrb_state* mrb, mrb_value self)
{
    cocos2d::ParticleSystem* cobj = static_cast<cocos2d::ParticleSystem*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            double retval = cobj->getStartRadius();
            mrb_value ret;
            ret = mrb_float_value(mrb, (mrb_float)retval);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::ParticleSystem#getStartRadius");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_ParticleSystem_getParticleCount(mrb_state* mrb, mrb_value self)
{
    cocos2d::ParticleSystem* cobj = static_cast<cocos2d::ParticleSystem*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            unsigned int retval = cobj->getParticleCount();
            mrb_value ret;
            ret = mrb_fixnum_value((mrb_int)retval);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::ParticleSystem#getParticleCount");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_ParticleSystem_getStartRadiusVar(mrb_state* mrb, mrb_value self)
{
    cocos2d::ParticleSystem* cobj = static_cast<cocos2d::ParticleSystem*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            double retval = cobj->getStartRadiusVar();
            mrb_value ret;
            ret = mrb_float_value(mrb, (mrb_float)retval);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::ParticleSystem#getStartRadiusVar");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_ParticleSystem_getBlendFunc(mrb_state* mrb, mrb_value self)
{
    cocos2d::ParticleSystem* cobj = static_cast<cocos2d::ParticleSystem*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            cocos2d::BlendFunc retval = cobj->getBlendFunc();
            cocos2d::BlendFunc* retval_ptr = new cocos2d::BlendFunc(retval);
            mrb_value ret;
            ret = object_to_rubyval<cocos2d::BlendFunc>(mrb, "CC::BlendFunc", (cocos2d::BlendFunc*)retval_ptr, nullptr);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::ParticleSystem#getBlendFunc");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_ParticleSystem_setStartColorVar(mrb_state* mrb, mrb_value self)
{
    cocos2d::ParticleSystem* cobj = static_cast<cocos2d::ParticleSystem*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            cocos2d::Color4F* arg0;
            ok = rubyval_to_object<cocos2d::Color4F>(mrb, argv[0], "CC::Color4F", &arg0);
            if (!ok) { break; }
            cobj->setStartColorVar(*arg0);
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::ParticleSystem#setStartColorVar");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_ParticleSystem_setEndSpin(mrb_state* mrb, mrb_value self)
{
    cocos2d::ParticleSystem* cobj = static_cast<cocos2d::ParticleSystem*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            double arg0;
            ok = rubyval_to_number(mrb, argv[0], (double*)&arg0, "CC::ParticleSystem.setEndSpin");
            if (!ok) { break; }
            cobj->setEndSpin(arg0);
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::ParticleSystem#setEndSpin");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_ParticleSystem_setRadialAccel(mrb_state* mrb, mrb_value self)
{
    cocos2d::ParticleSystem* cobj = static_cast<cocos2d::ParticleSystem*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            double arg0;
            ok = rubyval_to_number(mrb, argv[0], (double*)&arg0, "CC::ParticleSystem.setRadialAccel");
            if (!ok) { break; }
            cobj->setRadialAccel(arg0);
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::ParticleSystem#setRadialAccel");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_ParticleSystem_isAutoRemoveOnFinish(mrb_state* mrb, mrb_value self)
{
    cocos2d::ParticleSystem* cobj = static_cast<cocos2d::ParticleSystem*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            bool retval = cobj->isAutoRemoveOnFinish();
            mrb_value ret;
            ret = mrb_bool_value((mrb_bool)retval);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::ParticleSystem#isAutoRemoveOnFinish");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_ParticleSystem_getTotalParticles(mrb_state* mrb, mrb_value self)
{
    cocos2d::ParticleSystem* cobj = static_cast<cocos2d::ParticleSystem*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            int retval = cobj->getTotalParticles();
            mrb_value ret;
            ret = mrb_fixnum_value((mrb_int)retval);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::ParticleSystem#getTotalParticles");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_ParticleSystem_setStartRadiusVar(mrb_state* mrb, mrb_value self)
{
    cocos2d::ParticleSystem* cobj = static_cast<cocos2d::ParticleSystem*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            double arg0;
            ok = rubyval_to_number(mrb, argv[0], (double*)&arg0, "CC::ParticleSystem.setStartRadiusVar");
            if (!ok) { break; }
            cobj->setStartRadiusVar(arg0);
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::ParticleSystem#setStartRadiusVar");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_ParticleSystem_setBlendFunc(mrb_state* mrb, mrb_value self)
{
    cocos2d::ParticleSystem* cobj = static_cast<cocos2d::ParticleSystem*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            cocos2d::BlendFunc* arg0;
            ok = rubyval_to_object<cocos2d::BlendFunc>(mrb, argv[0], "CC::BlendFunc", &arg0);
            if (!ok) { break; }
            cobj->setBlendFunc(*arg0);
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::ParticleSystem#setBlendFunc");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_ParticleSystem_getEndRadiusVar(mrb_state* mrb, mrb_value self)
{
    cocos2d::ParticleSystem* cobj = static_cast<cocos2d::ParticleSystem*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            double retval = cobj->getEndRadiusVar();
            mrb_value ret;
            ret = mrb_float_value(mrb, (mrb_float)retval);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::ParticleSystem#getEndRadiusVar");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_ParticleSystem_getStartColorVar(mrb_state* mrb, mrb_value self)
{
    cocos2d::ParticleSystem* cobj = static_cast<cocos2d::ParticleSystem*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            cocos2d::Color4F retval = cobj->getStartColorVar();
            cocos2d::Color4F* retval_ptr = new cocos2d::Color4F(retval);
            mrb_value ret;
            ret = object_to_rubyval<cocos2d::Color4F>(mrb, "CC::Color4F", (cocos2d::Color4F*)retval_ptr, nullptr);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::ParticleSystem#getStartColorVar");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_ParticleSystem_create_static(mrb_state* mrb, mrb_value self)
{
    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            std::map<std::string, mrb_value> callbacks;
            std::string arg0;
            ok = rubyval_to_std_string(mrb, argv[0], &arg0, "CC::ParticleSystem.create");
            if (!ok) { break; }

            cocos2d::ParticleSystem* retval = cocos2d::ParticleSystem::create(arg0);
            mrb_value ret;
            RClass* rclass = mrb_class_ptr(self);
            ret = object_to_rubyval<cocos2d::ParticleSystem>(mrb, "CC::ParticleSystem", (cocos2d::ParticleSystem*)retval, rclass);
            if (callbacks.size() > 0) {
                mrb_value hash = mrb_iv_get(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"));
                if (!mrb_hash_p(hash)) {
                    hash = mrb_hash_new(mrb);
                }
                for (auto elm : callbacks) {
                    mrb_hash_set(mrb, hash, mrb_str_new_cstr(mrb, elm.first.c_str()), elm.second);
                    mrb_iv_set(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"), hash);
                }
            }
            g_rubyValue.push_back(ret);
            mrb_funcall(mrb, ret, "initialize", 0);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined static method : cocos2d::ParticleSystem#create");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_ParticleSystem_createWithTotalParticles_static(mrb_state* mrb, mrb_value self)
{
    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            std::map<std::string, mrb_value> callbacks;
            int arg0;
            ok = rubyval_to_int32(mrb, argv[0], (int*)&arg0, "CC::ParticleSystem.createWithTotalParticles");
            if (!ok) { break; }

            cocos2d::ParticleSystem* retval = cocos2d::ParticleSystem::createWithTotalParticles(arg0);
            mrb_value ret;
            RClass* rclass = mrb_class_ptr(self);
            ret = object_to_rubyval<cocos2d::ParticleSystem>(mrb, "CC::ParticleSystem", (cocos2d::ParticleSystem*)retval, rclass);
            if (callbacks.size() > 0) {
                mrb_value hash = mrb_iv_get(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"));
                if (!mrb_hash_p(hash)) {
                    hash = mrb_hash_new(mrb);
                }
                for (auto elm : callbacks) {
                    mrb_hash_set(mrb, hash, mrb_str_new_cstr(mrb, elm.first.c_str()), elm.second);
                    mrb_iv_set(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"), hash);
                }
            }
            g_rubyValue.push_back(ret);
            mrb_funcall(mrb, ret, "initialize", 0);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined static method : cocos2d::ParticleSystem#createWithTotalParticles");

    return mrb_nil_value();
}

void ruby_cocos2dx_ParticleSystem_N_enum_init(mrb_state* mrb, struct RClass* renum)
{
    do {
        mrb_value ev = mrb_fixnum_value((mrb_int)cocos2d::ParticleSystem::DURATION_INFINITY);
        mrb_mod_cv_set(mrb, renum, mrb_intern_cstr(mrb, "DURATION_INFINITY"), ev);
    } while (0);

    do {
        mrb_value ev = mrb_fixnum_value((mrb_int)cocos2d::ParticleSystem::START_SIZE_EQUAL_TO_END_SIZE);
        mrb_mod_cv_set(mrb, renum, mrb_intern_cstr(mrb, "START_SIZE_EQUAL_TO_END_SIZE"), ev);
    } while (0);

    do {
        mrb_value ev = mrb_fixnum_value((mrb_int)cocos2d::ParticleSystem::START_RADIUS_EQUAL_TO_END_RADIUS);
        mrb_mod_cv_set(mrb, renum, mrb_intern_cstr(mrb, "START_RADIUS_EQUAL_TO_END_RADIUS"), ev);
    } while (0);

}

void ruby_cocos2dx_ParticleSystem_Mode_enum_init(mrb_state* mrb, struct RClass* renum)
{
    do {
        mrb_value ev = mrb_fixnum_value((mrb_int)cocos2d::ParticleSystem::Mode::GRAVITY);
        mrb_mod_cv_set(mrb, renum, mrb_intern_cstr(mrb, "GRAVITY"), ev);
    } while (0);

    do {
        mrb_value ev = mrb_fixnum_value((mrb_int)cocos2d::ParticleSystem::Mode::RADIUS);
        mrb_mod_cv_set(mrb, renum, mrb_intern_cstr(mrb, "RADIUS"), ev);
    } while (0);

}

void ruby_cocos2dx_ParticleSystem_PositionType_enum_init(mrb_state* mrb, struct RClass* renum)
{
    do {
        mrb_value ev = mrb_fixnum_value((mrb_int)cocos2d::ParticleSystem::PositionType::FREE);
        mrb_mod_cv_set(mrb, renum, mrb_intern_cstr(mrb, "FREE"), ev);
    } while (0);

    do {
        mrb_value ev = mrb_fixnum_value((mrb_int)cocos2d::ParticleSystem::PositionType::RELATIVE);
        mrb_mod_cv_set(mrb, renum, mrb_intern_cstr(mrb, "RELATIVE"), ev);
    } while (0);

    do {
        mrb_value ev = mrb_fixnum_value((mrb_int)cocos2d::ParticleSystem::PositionType::GROUPED);
        mrb_mod_cv_set(mrb, renum, mrb_intern_cstr(mrb, "GROUPED"), ev);
    } while (0);

}

void ruby_register_cocos2dx_ParticleSystem(mrb_state* mrb, struct RClass* rmodule)
{
    std::string typeName = typeid(cocos2d::ParticleSystem).name();
    g_rubyType[typeName] = "CC::ParticleSystem";
    g_rubyDataType[typeName] = &ruby_cocos2dx_Ref_type;

    struct RClass* p_rmodule = mrb->object_class;
    p_rmodule = mrb_module_get_under(mrb, p_rmodule, "CC");
    struct RClass* p_rclass = mrb_class_get_under(mrb, p_rmodule, "Node");
    struct RClass *rclass = mrb_define_class_under(mrb, rmodule, "ParticleSystem", p_rclass);
    MRB_SET_INSTANCE_TT(rclass, MRB_TT_DATA);

    mrb_define_method(mrb, rclass, "get_start_size_var", ruby_cocos2dx_ParticleSystem_getStartSizeVar, ARGS_NONE());
    mrb_define_method(mrb, rclass, "get_texture", ruby_cocos2dx_ParticleSystem_getTexture, ARGS_NONE());
    mrb_define_method(mrb, rclass, "full?", ruby_cocos2dx_ParticleSystem_isFull, ARGS_NONE());
    mrb_define_method(mrb, rclass, "get_batch_node", ruby_cocos2dx_ParticleSystem_getBatchNode, ARGS_NONE());
    mrb_define_method(mrb, rclass, "get_start_color", ruby_cocos2dx_ParticleSystem_getStartColor, ARGS_NONE());
    mrb_define_method(mrb, rclass, "get_position_type", ruby_cocos2dx_ParticleSystem_getPositionType, ARGS_NONE());
    mrb_define_method(mrb, rclass, "set_pos_var", ruby_cocos2dx_ParticleSystem_setPosVar, ARGS_REQ(1));
    mrb_define_method(mrb, rclass, "get_end_spin", ruby_cocos2dx_ParticleSystem_getEndSpin, ARGS_NONE());
    mrb_define_method(mrb, rclass, "set_rotate_per_second_var", ruby_cocos2dx_ParticleSystem_setRotatePerSecondVar, ARGS_REQ(1));
    mrb_define_method(mrb, rclass, "get_start_spin_var", ruby_cocos2dx_ParticleSystem_getStartSpinVar, ARGS_NONE());
    mrb_define_method(mrb, rclass, "get_radial_accel_var", ruby_cocos2dx_ParticleSystem_getRadialAccelVar, ARGS_NONE());
    mrb_define_method(mrb, rclass, "get_end_size_var", ruby_cocos2dx_ParticleSystem_getEndSizeVar, ARGS_NONE());
    mrb_define_method(mrb, rclass, "set_rotation", ruby_cocos2dx_ParticleSystem_setRotation, ARGS_REQ(1));
    mrb_define_method(mrb, rclass, "set_tangential_accel", ruby_cocos2dx_ParticleSystem_setTangentialAccel, ARGS_REQ(1));
    mrb_define_method(mrb, rclass, "set_scale_y", ruby_cocos2dx_ParticleSystem_setScaleY, ARGS_REQ(1));
    mrb_define_method(mrb, rclass, "set_scale_x", ruby_cocos2dx_ParticleSystem_setScaleX, ARGS_REQ(1));
    mrb_define_method(mrb, rclass, "get_radial_accel", ruby_cocos2dx_ParticleSystem_getRadialAccel, ARGS_NONE());
    mrb_define_method(mrb, rclass, "set_start_radius", ruby_cocos2dx_ParticleSystem_setStartRadius, ARGS_REQ(1));
    mrb_define_method(mrb, rclass, "set_rotate_per_second", ruby_cocos2dx_ParticleSystem_setRotatePerSecond, ARGS_REQ(1));
    mrb_define_method(mrb, rclass, "set_end_size", ruby_cocos2dx_ParticleSystem_setEndSize, ARGS_REQ(1));
    mrb_define_method(mrb, rclass, "get_gravity", ruby_cocos2dx_ParticleSystem_getGravity, ARGS_NONE());
    mrb_define_method(mrb, rclass, "get_tangential_accel", ruby_cocos2dx_ParticleSystem_getTangentialAccel, ARGS_NONE());
    mrb_define_method(mrb, rclass, "set_end_radius", ruby_cocos2dx_ParticleSystem_setEndRadius, ARGS_REQ(1));
    mrb_define_method(mrb, rclass, "get_speed", ruby_cocos2dx_ParticleSystem_getSpeed, ARGS_NONE());
    mrb_define_method(mrb, rclass, "get_angle", ruby_cocos2dx_ParticleSystem_getAngle, ARGS_NONE());
    mrb_define_method(mrb, rclass, "set_end_color", ruby_cocos2dx_ParticleSystem_setEndColor, ARGS_REQ(1));
    mrb_define_method(mrb, rclass, "set_start_spin", ruby_cocos2dx_ParticleSystem_setStartSpin, ARGS_REQ(1));
    mrb_define_method(mrb, rclass, "set_duration", ruby_cocos2dx_ParticleSystem_setDuration, ARGS_REQ(1));
    mrb_define_method(mrb, rclass, "set_texture", ruby_cocos2dx_ParticleSystem_setTexture, ARGS_REQ(1));
    mrb_define_method(mrb, rclass, "get_pos_var", ruby_cocos2dx_ParticleSystem_getPosVar, ARGS_NONE());
    mrb_define_method(mrb, rclass, "update_with_no_time", ruby_cocos2dx_ParticleSystem_updateWithNoTime, ARGS_NONE());
    mrb_define_method(mrb, rclass, "blend_additive?", ruby_cocos2dx_ParticleSystem_isBlendAdditive, ARGS_NONE());
    mrb_define_method(mrb, rclass, "get_speed_var", ruby_cocos2dx_ParticleSystem_getSpeedVar, ARGS_NONE());
    mrb_define_method(mrb, rclass, "set_position_type", ruby_cocos2dx_ParticleSystem_setPositionType, ARGS_REQ(1));
    mrb_define_method(mrb, rclass, "stop_system", ruby_cocos2dx_ParticleSystem_stopSystem, ARGS_NONE());
    mrb_define_method(mrb, rclass, "get_source_position", ruby_cocos2dx_ParticleSystem_getSourcePosition, ARGS_NONE());
    mrb_define_method(mrb, rclass, "set_life_var", ruby_cocos2dx_ParticleSystem_setLifeVar, ARGS_REQ(1));
    mrb_define_method(mrb, rclass, "set_total_particles", ruby_cocos2dx_ParticleSystem_setTotalParticles, ARGS_REQ(1));
    mrb_define_method(mrb, rclass, "set_end_color_var", ruby_cocos2dx_ParticleSystem_setEndColorVar, ARGS_REQ(1));
    mrb_define_method(mrb, rclass, "get_atlas_index", ruby_cocos2dx_ParticleSystem_getAtlasIndex, ARGS_NONE());
    mrb_define_method(mrb, rclass, "get_start_size", ruby_cocos2dx_ParticleSystem_getStartSize, ARGS_NONE());
    mrb_define_method(mrb, rclass, "set_start_spin_var", ruby_cocos2dx_ParticleSystem_setStartSpinVar, ARGS_REQ(1));
    mrb_define_method(mrb, rclass, "reset_system", ruby_cocos2dx_ParticleSystem_resetSystem, ARGS_NONE());
    mrb_define_method(mrb, rclass, "set_atlas_index", ruby_cocos2dx_ParticleSystem_setAtlasIndex, ARGS_REQ(1));
    mrb_define_method(mrb, rclass, "set_tangential_accel_var", ruby_cocos2dx_ParticleSystem_setTangentialAccelVar, ARGS_REQ(1));
    mrb_define_method(mrb, rclass, "set_end_radius_var", ruby_cocos2dx_ParticleSystem_setEndRadiusVar, ARGS_REQ(1));
    mrb_define_method(mrb, rclass, "get_end_radius", ruby_cocos2dx_ParticleSystem_getEndRadius, ARGS_NONE());
    mrb_define_method(mrb, rclass, "opacity_modify_rgb?", ruby_cocos2dx_ParticleSystem_isOpacityModifyRGB, ARGS_NONE());
    mrb_define_method(mrb, rclass, "active?", ruby_cocos2dx_ParticleSystem_isActive, ARGS_NONE());
    mrb_define_method(mrb, rclass, "set_radial_accel_var", ruby_cocos2dx_ParticleSystem_setRadialAccelVar, ARGS_REQ(1));
    mrb_define_method(mrb, rclass, "set_start_size", ruby_cocos2dx_ParticleSystem_setStartSize, ARGS_REQ(1));
    mrb_define_method(mrb, rclass, "set_speed", ruby_cocos2dx_ParticleSystem_setSpeed, ARGS_REQ(1));
    mrb_define_method(mrb, rclass, "get_start_spin", ruby_cocos2dx_ParticleSystem_getStartSpin, ARGS_NONE());
    mrb_define_method(mrb, rclass, "get_rotate_per_second", ruby_cocos2dx_ParticleSystem_getRotatePerSecond, ARGS_NONE());
    mrb_define_method(mrb, rclass, "set_emitter_mode", ruby_cocos2dx_ParticleSystem_setEmitterMode, ARGS_REQ(1));
    mrb_define_method(mrb, rclass, "get_duration", ruby_cocos2dx_ParticleSystem_getDuration, ARGS_NONE());
    mrb_define_method(mrb, rclass, "set_source_position", ruby_cocos2dx_ParticleSystem_setSourcePosition, ARGS_REQ(1));
    mrb_define_method(mrb, rclass, "get_end_spin_var", ruby_cocos2dx_ParticleSystem_getEndSpinVar, ARGS_NONE());
    mrb_define_method(mrb, rclass, "set_blend_additive", ruby_cocos2dx_ParticleSystem_setBlendAdditive, ARGS_REQ(1));
    mrb_define_method(mrb, rclass, "set_life", ruby_cocos2dx_ParticleSystem_setLife, ARGS_REQ(1));
    mrb_define_method(mrb, rclass, "set_angle_var", ruby_cocos2dx_ParticleSystem_setAngleVar, ARGS_REQ(1));
    mrb_define_method(mrb, rclass, "set_rotation_is_dir", ruby_cocos2dx_ParticleSystem_setRotationIsDir, ARGS_REQ(1));
    mrb_define_method(mrb, rclass, "set_end_size_var", ruby_cocos2dx_ParticleSystem_setEndSizeVar, ARGS_REQ(1));
    mrb_define_method(mrb, rclass, "set_angle", ruby_cocos2dx_ParticleSystem_setAngle, ARGS_REQ(1));
    mrb_define_method(mrb, rclass, "set_batch_node", ruby_cocos2dx_ParticleSystem_setBatchNode, ARGS_REQ(1));
    mrb_define_method(mrb, rclass, "get_tangential_accel_var", ruby_cocos2dx_ParticleSystem_getTangentialAccelVar, ARGS_NONE());
    mrb_define_method(mrb, rclass, "get_emitter_mode", ruby_cocos2dx_ParticleSystem_getEmitterMode, ARGS_NONE());
    mrb_define_method(mrb, rclass, "set_end_spin_var", ruby_cocos2dx_ParticleSystem_setEndSpinVar, ARGS_REQ(1));
    mrb_define_method(mrb, rclass, "get_angle_var", ruby_cocos2dx_ParticleSystem_getAngleVar, ARGS_NONE());
    mrb_define_method(mrb, rclass, "set_start_color", ruby_cocos2dx_ParticleSystem_setStartColor, ARGS_REQ(1));
    mrb_define_method(mrb, rclass, "get_rotate_per_second_var", ruby_cocos2dx_ParticleSystem_getRotatePerSecondVar, ARGS_NONE());
    mrb_define_method(mrb, rclass, "get_end_size", ruby_cocos2dx_ParticleSystem_getEndSize, ARGS_NONE());
    mrb_define_method(mrb, rclass, "get_life", ruby_cocos2dx_ParticleSystem_getLife, ARGS_NONE());
    mrb_define_method(mrb, rclass, "set_speed_var", ruby_cocos2dx_ParticleSystem_setSpeedVar, ARGS_REQ(1));
    mrb_define_method(mrb, rclass, "set_auto_remove_on_finish", ruby_cocos2dx_ParticleSystem_setAutoRemoveOnFinish, ARGS_REQ(1));
    mrb_define_method(mrb, rclass, "set_gravity", ruby_cocos2dx_ParticleSystem_setGravity, ARGS_REQ(1));
    mrb_define_method(mrb, rclass, "post_step", ruby_cocos2dx_ParticleSystem_postStep, ARGS_NONE());
    mrb_define_method(mrb, rclass, "set_emission_rate", ruby_cocos2dx_ParticleSystem_setEmissionRate, ARGS_REQ(1));
    mrb_define_method(mrb, rclass, "get_end_color_var", ruby_cocos2dx_ParticleSystem_getEndColorVar, ARGS_NONE());
    mrb_define_method(mrb, rclass, "get_rotation_is_dir", ruby_cocos2dx_ParticleSystem_getRotationIsDir, ARGS_NONE());
    mrb_define_method(mrb, rclass, "set_scale", ruby_cocos2dx_ParticleSystem_setScale, ARGS_REQ(1));
    mrb_define_method(mrb, rclass, "get_emission_rate", ruby_cocos2dx_ParticleSystem_getEmissionRate, ARGS_NONE());
    mrb_define_method(mrb, rclass, "get_end_color", ruby_cocos2dx_ParticleSystem_getEndColor, ARGS_NONE());
    mrb_define_method(mrb, rclass, "get_life_var", ruby_cocos2dx_ParticleSystem_getLifeVar, ARGS_NONE());
    mrb_define_method(mrb, rclass, "set_start_size_var", ruby_cocos2dx_ParticleSystem_setStartSizeVar, ARGS_REQ(1));
    mrb_define_method(mrb, rclass, "set_opacity_modify_rgb", ruby_cocos2dx_ParticleSystem_setOpacityModifyRGB, ARGS_REQ(1));
    mrb_define_method(mrb, rclass, "add_particle", ruby_cocos2dx_ParticleSystem_addParticle, ARGS_NONE());
    mrb_define_method(mrb, rclass, "get_start_radius", ruby_cocos2dx_ParticleSystem_getStartRadius, ARGS_NONE());
    mrb_define_method(mrb, rclass, "get_particle_count", ruby_cocos2dx_ParticleSystem_getParticleCount, ARGS_NONE());
    mrb_define_method(mrb, rclass, "get_start_radius_var", ruby_cocos2dx_ParticleSystem_getStartRadiusVar, ARGS_NONE());
    mrb_define_method(mrb, rclass, "get_blend_func", ruby_cocos2dx_ParticleSystem_getBlendFunc, ARGS_NONE());
    mrb_define_method(mrb, rclass, "set_start_color_var", ruby_cocos2dx_ParticleSystem_setStartColorVar, ARGS_REQ(1));
    mrb_define_method(mrb, rclass, "set_end_spin", ruby_cocos2dx_ParticleSystem_setEndSpin, ARGS_REQ(1));
    mrb_define_method(mrb, rclass, "set_radial_accel", ruby_cocos2dx_ParticleSystem_setRadialAccel, ARGS_REQ(1));
    mrb_define_method(mrb, rclass, "auto_remove_on_finish?", ruby_cocos2dx_ParticleSystem_isAutoRemoveOnFinish, ARGS_NONE());
    mrb_define_method(mrb, rclass, "get_total_particles", ruby_cocos2dx_ParticleSystem_getTotalParticles, ARGS_NONE());
    mrb_define_method(mrb, rclass, "set_start_radius_var", ruby_cocos2dx_ParticleSystem_setStartRadiusVar, ARGS_REQ(1));
    mrb_define_method(mrb, rclass, "set_blend_func", ruby_cocos2dx_ParticleSystem_setBlendFunc, ARGS_REQ(1));
    mrb_define_method(mrb, rclass, "get_end_radius_var", ruby_cocos2dx_ParticleSystem_getEndRadiusVar, ARGS_NONE());
    mrb_define_method(mrb, rclass, "get_start_color_var", ruby_cocos2dx_ParticleSystem_getStartColorVar, ARGS_NONE());
    mrb_define_class_method(mrb, rclass, "create", ruby_cocos2dx_ParticleSystem_create_static, ARGS_REQ(1));
    mrb_define_class_method(mrb, rclass, "create_with_total_particles", ruby_cocos2dx_ParticleSystem_createWithTotalParticles_static, ARGS_REQ(1));
    ruby_cocos2dx_ParticleSystem_N_enum_init(mrb, rclass);
    mrb_define_class_method(mrb, rclass, "DURATION_INFINITY", ruby_cocos2dx_constant_get, ARGS_NONE());
    mrb_define_class_method(mrb, rclass, "START_SIZE_EQUAL_TO_END_SIZE", ruby_cocos2dx_constant_get, ARGS_NONE());
    mrb_define_class_method(mrb, rclass, "START_RADIUS_EQUAL_TO_END_RADIUS", ruby_cocos2dx_constant_get, ARGS_NONE());
    struct RClass* renum_Mode = mrb_define_module_under(mrb, rclass, "Mode");
    ruby_cocos2dx_ParticleSystem_Mode_enum_init(mrb, renum_Mode);
    mrb_define_class_method(mrb, renum_Mode, "GRAVITY", ruby_cocos2dx_constant_get, ARGS_NONE());
    mrb_define_class_method(mrb, renum_Mode, "RADIUS", ruby_cocos2dx_constant_get, ARGS_NONE());
    struct RClass* renum_PositionType = mrb_define_module_under(mrb, rclass, "PositionType");
    ruby_cocos2dx_ParticleSystem_PositionType_enum_init(mrb, renum_PositionType);
    mrb_define_class_method(mrb, renum_PositionType, "FREE", ruby_cocos2dx_constant_get, ARGS_NONE());
    mrb_define_class_method(mrb, renum_PositionType, "RELATIVE", ruby_cocos2dx_constant_get, ARGS_NONE());
    mrb_define_class_method(mrb, renum_PositionType, "GROUPED", ruby_cocos2dx_constant_get, ARGS_NONE());
}
mrb_value ruby_cocos2dx_ParticleSystemQuad_setDisplayFrame(mrb_state* mrb, mrb_value self)
{
    cocos2d::ParticleSystemQuad* cobj = static_cast<cocos2d::ParticleSystemQuad*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            cocos2d::SpriteFrame* arg0;
            ok = rubyval_to_object<cocos2d::SpriteFrame>(mrb, argv[0], "CC::SpriteFrame", &arg0);
            if (!ok) { break; }
            cobj->setDisplayFrame(arg0);
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::ParticleSystemQuad#setDisplayFrame");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_ParticleSystemQuad_setTextureWithRect(mrb_state* mrb, mrb_value self)
{
    cocos2d::ParticleSystemQuad* cobj = static_cast<cocos2d::ParticleSystemQuad*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 2) {
            cocos2d::Texture2D* arg0;
            ok = rubyval_to_object<cocos2d::Texture2D>(mrb, argv[0], "CC::Texture2D", &arg0);
            if (!ok) { break; }
            cocos2d::Rect* arg1;
            ok = rubyval_to_object<cocos2d::Rect>(mrb, argv[1], "CC::Rect", &arg1);
            if (!ok) { break; }
            cobj->setTextureWithRect(arg0, *arg1);
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::ParticleSystemQuad#setTextureWithRect");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_ParticleSystemQuad_listenRendererRecreated(mrb_state* mrb, mrb_value self)
{
    cocos2d::ParticleSystemQuad* cobj = static_cast<cocos2d::ParticleSystemQuad*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            cocos2d::EventCustom* arg0;
            ok = rubyval_to_object<cocos2d::EventCustom>(mrb, argv[0], "CC::EventCustom", &arg0);
            if (!ok) { break; }
            cobj->listenRendererRecreated(arg0);
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::ParticleSystemQuad#listenRendererRecreated");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_ParticleSystemQuad_create_static(mrb_state* mrb, mrb_value self)
{
    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            std::map<std::string, mrb_value> callbacks;
            std::string arg0;
            ok = rubyval_to_std_string(mrb, argv[0], &arg0, "CC::ParticleSystemQuad.create");
            if (!ok) { break; }

            cocos2d::ParticleSystemQuad* retval = cocos2d::ParticleSystemQuad::create(arg0);
            mrb_value ret;
            RClass* rclass = mrb_class_ptr(self);
            ret = object_to_rubyval<cocos2d::ParticleSystemQuad>(mrb, "CC::ParticleSystemQuad", (cocos2d::ParticleSystemQuad*)retval, rclass);
            if (callbacks.size() > 0) {
                mrb_value hash = mrb_iv_get(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"));
                if (!mrb_hash_p(hash)) {
                    hash = mrb_hash_new(mrb);
                }
                for (auto elm : callbacks) {
                    mrb_hash_set(mrb, hash, mrb_str_new_cstr(mrb, elm.first.c_str()), elm.second);
                    mrb_iv_set(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"), hash);
                }
            }
            g_rubyValue.push_back(ret);
            mrb_funcall(mrb, ret, "initialize", 0);
            return ret;
        }
    } while (0);
    do {
        if (argc == 0) {
            std::map<std::string, mrb_value> callbacks;
            cocos2d::ParticleSystemQuad* retval = cocos2d::ParticleSystemQuad::create();
            mrb_value ret;
            RClass* rclass = mrb_class_ptr(self);
            ret = object_to_rubyval<cocos2d::ParticleSystemQuad>(mrb, "CC::ParticleSystemQuad", (cocos2d::ParticleSystemQuad*)retval, rclass);
            if (callbacks.size() > 0) {
                mrb_value hash = mrb_iv_get(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"));
                if (!mrb_hash_p(hash)) {
                    hash = mrb_hash_new(mrb);
                }
                for (auto elm : callbacks) {
                    mrb_hash_set(mrb, hash, mrb_str_new_cstr(mrb, elm.first.c_str()), elm.second);
                    mrb_iv_set(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"), hash);
                }
            }
            g_rubyValue.push_back(ret);
            mrb_funcall(mrb, ret, "initialize", 0);
            return ret;
        }
    } while (0);
    do {
        if (argc == 1) {
            std::map<std::string, mrb_value> callbacks;
            cocos2d::ValueMap arg0;
            ok = rubyval_to_ccvaluemap(mrb, argv[0], &arg0, "CC::ParticleSystemQuad.create");
            if (!ok) { break; }

            cocos2d::ParticleSystemQuad* retval = cocos2d::ParticleSystemQuad::create(arg0);
            mrb_value ret;
            RClass* rclass = mrb_class_ptr(self);
            ret = object_to_rubyval<cocos2d::ParticleSystemQuad>(mrb, "CC::ParticleSystemQuad", (cocos2d::ParticleSystemQuad*)retval, rclass);
            if (callbacks.size() > 0) {
                mrb_value hash = mrb_iv_get(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"));
                if (!mrb_hash_p(hash)) {
                    hash = mrb_hash_new(mrb);
                }
                for (auto elm : callbacks) {
                    mrb_hash_set(mrb, hash, mrb_str_new_cstr(mrb, elm.first.c_str()), elm.second);
                    mrb_iv_set(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"), hash);
                }
            }
            g_rubyValue.push_back(ret);
            mrb_funcall(mrb, ret, "initialize", 0);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined static method : cocos2d::ParticleSystemQuad#create");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_ParticleSystemQuad_createWithTotalParticles_static(mrb_state* mrb, mrb_value self)
{
    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            std::map<std::string, mrb_value> callbacks;
            int arg0;
            ok = rubyval_to_int32(mrb, argv[0], (int*)&arg0, "CC::ParticleSystemQuad.createWithTotalParticles");
            if (!ok) { break; }

            cocos2d::ParticleSystemQuad* retval = cocos2d::ParticleSystemQuad::createWithTotalParticles(arg0);
            mrb_value ret;
            RClass* rclass = mrb_class_ptr(self);
            ret = object_to_rubyval<cocos2d::ParticleSystemQuad>(mrb, "CC::ParticleSystemQuad", (cocos2d::ParticleSystemQuad*)retval, rclass);
            if (callbacks.size() > 0) {
                mrb_value hash = mrb_iv_get(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"));
                if (!mrb_hash_p(hash)) {
                    hash = mrb_hash_new(mrb);
                }
                for (auto elm : callbacks) {
                    mrb_hash_set(mrb, hash, mrb_str_new_cstr(mrb, elm.first.c_str()), elm.second);
                    mrb_iv_set(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"), hash);
                }
            }
            g_rubyValue.push_back(ret);
            mrb_funcall(mrb, ret, "initialize", 0);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined static method : cocos2d::ParticleSystemQuad#createWithTotalParticles");

    return mrb_nil_value();
}

void ruby_register_cocos2dx_ParticleSystemQuad(mrb_state* mrb, struct RClass* rmodule)
{
    std::string typeName = typeid(cocos2d::ParticleSystemQuad).name();
    g_rubyType[typeName] = "CC::ParticleSystemQuad";
    g_rubyDataType[typeName] = &ruby_cocos2dx_Ref_type;

    struct RClass* p_rmodule = mrb->object_class;
    p_rmodule = mrb_module_get_under(mrb, p_rmodule, "CC");
    struct RClass* p_rclass = mrb_class_get_under(mrb, p_rmodule, "ParticleSystem");
    struct RClass *rclass = mrb_define_class_under(mrb, rmodule, "ParticleSystemQuad", p_rclass);
    MRB_SET_INSTANCE_TT(rclass, MRB_TT_DATA);

    mrb_define_method(mrb, rclass, "set_display_frame", ruby_cocos2dx_ParticleSystemQuad_setDisplayFrame, ARGS_REQ(1));
    mrb_define_method(mrb, rclass, "set_texture_with_rect", ruby_cocos2dx_ParticleSystemQuad_setTextureWithRect, ARGS_REQ(2));
    mrb_define_method(mrb, rclass, "listen_renderer_recreated", ruby_cocos2dx_ParticleSystemQuad_listenRendererRecreated, ARGS_REQ(1));
    mrb_define_class_method(mrb, rclass, "create", ruby_cocos2dx_ParticleSystemQuad_create_static, ARGS_REQ(0)|ARGS_OPT(1));
    mrb_define_class_method(mrb, rclass, "create_with_total_particles", ruby_cocos2dx_ParticleSystemQuad_createWithTotalParticles_static, ARGS_REQ(1));
}
mrb_value ruby_cocos2dx_ParticleFire_create_static(mrb_state* mrb, mrb_value self)
{
    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            std::map<std::string, mrb_value> callbacks;
            cocos2d::ParticleFire* retval = cocos2d::ParticleFire::create();
            mrb_value ret;
            RClass* rclass = mrb_class_ptr(self);
            ret = object_to_rubyval<cocos2d::ParticleFire>(mrb, "CC::ParticleFire", (cocos2d::ParticleFire*)retval, rclass);
            if (callbacks.size() > 0) {
                mrb_value hash = mrb_iv_get(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"));
                if (!mrb_hash_p(hash)) {
                    hash = mrb_hash_new(mrb);
                }
                for (auto elm : callbacks) {
                    mrb_hash_set(mrb, hash, mrb_str_new_cstr(mrb, elm.first.c_str()), elm.second);
                    mrb_iv_set(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"), hash);
                }
            }
            g_rubyValue.push_back(ret);
            mrb_funcall(mrb, ret, "initialize", 0);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined static method : cocos2d::ParticleFire#create");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_ParticleFire_createWithTotalParticles_static(mrb_state* mrb, mrb_value self)
{
    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            std::map<std::string, mrb_value> callbacks;
            int arg0;
            ok = rubyval_to_int32(mrb, argv[0], (int*)&arg0, "CC::ParticleFire.createWithTotalParticles");
            if (!ok) { break; }

            cocos2d::ParticleFire* retval = cocos2d::ParticleFire::createWithTotalParticles(arg0);
            mrb_value ret;
            RClass* rclass = mrb_class_ptr(self);
            ret = object_to_rubyval<cocos2d::ParticleFire>(mrb, "CC::ParticleFire", (cocos2d::ParticleFire*)retval, rclass);
            if (callbacks.size() > 0) {
                mrb_value hash = mrb_iv_get(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"));
                if (!mrb_hash_p(hash)) {
                    hash = mrb_hash_new(mrb);
                }
                for (auto elm : callbacks) {
                    mrb_hash_set(mrb, hash, mrb_str_new_cstr(mrb, elm.first.c_str()), elm.second);
                    mrb_iv_set(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"), hash);
                }
            }
            g_rubyValue.push_back(ret);
            mrb_funcall(mrb, ret, "initialize", 0);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined static method : cocos2d::ParticleFire#createWithTotalParticles");

    return mrb_nil_value();
}

void ruby_register_cocos2dx_ParticleFire(mrb_state* mrb, struct RClass* rmodule)
{
    std::string typeName = typeid(cocos2d::ParticleFire).name();
    g_rubyType[typeName] = "CC::ParticleFire";
    g_rubyDataType[typeName] = &ruby_cocos2dx_Ref_type;

    struct RClass* p_rmodule = mrb->object_class;
    p_rmodule = mrb_module_get_under(mrb, p_rmodule, "CC");
    struct RClass* p_rclass = mrb_class_get_under(mrb, p_rmodule, "ParticleSystemQuad");
    struct RClass *rclass = mrb_define_class_under(mrb, rmodule, "ParticleFire", p_rclass);
    MRB_SET_INSTANCE_TT(rclass, MRB_TT_DATA);

    mrb_define_class_method(mrb, rclass, "create", ruby_cocos2dx_ParticleFire_create_static, ARGS_NONE());
    mrb_define_class_method(mrb, rclass, "create_with_total_particles", ruby_cocos2dx_ParticleFire_createWithTotalParticles_static, ARGS_REQ(1));
}
mrb_value ruby_cocos2dx_ParticleFireworks_create_static(mrb_state* mrb, mrb_value self)
{
    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            std::map<std::string, mrb_value> callbacks;
            cocos2d::ParticleFireworks* retval = cocos2d::ParticleFireworks::create();
            mrb_value ret;
            RClass* rclass = mrb_class_ptr(self);
            ret = object_to_rubyval<cocos2d::ParticleFireworks>(mrb, "CC::ParticleFireworks", (cocos2d::ParticleFireworks*)retval, rclass);
            if (callbacks.size() > 0) {
                mrb_value hash = mrb_iv_get(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"));
                if (!mrb_hash_p(hash)) {
                    hash = mrb_hash_new(mrb);
                }
                for (auto elm : callbacks) {
                    mrb_hash_set(mrb, hash, mrb_str_new_cstr(mrb, elm.first.c_str()), elm.second);
                    mrb_iv_set(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"), hash);
                }
            }
            g_rubyValue.push_back(ret);
            mrb_funcall(mrb, ret, "initialize", 0);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined static method : cocos2d::ParticleFireworks#create");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_ParticleFireworks_createWithTotalParticles_static(mrb_state* mrb, mrb_value self)
{
    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            std::map<std::string, mrb_value> callbacks;
            int arg0;
            ok = rubyval_to_int32(mrb, argv[0], (int*)&arg0, "CC::ParticleFireworks.createWithTotalParticles");
            if (!ok) { break; }

            cocos2d::ParticleFireworks* retval = cocos2d::ParticleFireworks::createWithTotalParticles(arg0);
            mrb_value ret;
            RClass* rclass = mrb_class_ptr(self);
            ret = object_to_rubyval<cocos2d::ParticleFireworks>(mrb, "CC::ParticleFireworks", (cocos2d::ParticleFireworks*)retval, rclass);
            if (callbacks.size() > 0) {
                mrb_value hash = mrb_iv_get(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"));
                if (!mrb_hash_p(hash)) {
                    hash = mrb_hash_new(mrb);
                }
                for (auto elm : callbacks) {
                    mrb_hash_set(mrb, hash, mrb_str_new_cstr(mrb, elm.first.c_str()), elm.second);
                    mrb_iv_set(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"), hash);
                }
            }
            g_rubyValue.push_back(ret);
            mrb_funcall(mrb, ret, "initialize", 0);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined static method : cocos2d::ParticleFireworks#createWithTotalParticles");

    return mrb_nil_value();
}

void ruby_register_cocos2dx_ParticleFireworks(mrb_state* mrb, struct RClass* rmodule)
{
    std::string typeName = typeid(cocos2d::ParticleFireworks).name();
    g_rubyType[typeName] = "CC::ParticleFireworks";
    g_rubyDataType[typeName] = &ruby_cocos2dx_Ref_type;

    struct RClass* p_rmodule = mrb->object_class;
    p_rmodule = mrb_module_get_under(mrb, p_rmodule, "CC");
    struct RClass* p_rclass = mrb_class_get_under(mrb, p_rmodule, "ParticleSystemQuad");
    struct RClass *rclass = mrb_define_class_under(mrb, rmodule, "ParticleFireworks", p_rclass);
    MRB_SET_INSTANCE_TT(rclass, MRB_TT_DATA);

    mrb_define_class_method(mrb, rclass, "create", ruby_cocos2dx_ParticleFireworks_create_static, ARGS_NONE());
    mrb_define_class_method(mrb, rclass, "create_with_total_particles", ruby_cocos2dx_ParticleFireworks_createWithTotalParticles_static, ARGS_REQ(1));
}
mrb_value ruby_cocos2dx_ParticleSun_create_static(mrb_state* mrb, mrb_value self)
{
    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            std::map<std::string, mrb_value> callbacks;
            cocos2d::ParticleSun* retval = cocos2d::ParticleSun::create();
            mrb_value ret;
            RClass* rclass = mrb_class_ptr(self);
            ret = object_to_rubyval<cocos2d::ParticleSun>(mrb, "CC::ParticleSun", (cocos2d::ParticleSun*)retval, rclass);
            if (callbacks.size() > 0) {
                mrb_value hash = mrb_iv_get(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"));
                if (!mrb_hash_p(hash)) {
                    hash = mrb_hash_new(mrb);
                }
                for (auto elm : callbacks) {
                    mrb_hash_set(mrb, hash, mrb_str_new_cstr(mrb, elm.first.c_str()), elm.second);
                    mrb_iv_set(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"), hash);
                }
            }
            g_rubyValue.push_back(ret);
            mrb_funcall(mrb, ret, "initialize", 0);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined static method : cocos2d::ParticleSun#create");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_ParticleSun_createWithTotalParticles_static(mrb_state* mrb, mrb_value self)
{
    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            std::map<std::string, mrb_value> callbacks;
            int arg0;
            ok = rubyval_to_int32(mrb, argv[0], (int*)&arg0, "CC::ParticleSun.createWithTotalParticles");
            if (!ok) { break; }

            cocos2d::ParticleSun* retval = cocos2d::ParticleSun::createWithTotalParticles(arg0);
            mrb_value ret;
            RClass* rclass = mrb_class_ptr(self);
            ret = object_to_rubyval<cocos2d::ParticleSun>(mrb, "CC::ParticleSun", (cocos2d::ParticleSun*)retval, rclass);
            if (callbacks.size() > 0) {
                mrb_value hash = mrb_iv_get(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"));
                if (!mrb_hash_p(hash)) {
                    hash = mrb_hash_new(mrb);
                }
                for (auto elm : callbacks) {
                    mrb_hash_set(mrb, hash, mrb_str_new_cstr(mrb, elm.first.c_str()), elm.second);
                    mrb_iv_set(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"), hash);
                }
            }
            g_rubyValue.push_back(ret);
            mrb_funcall(mrb, ret, "initialize", 0);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined static method : cocos2d::ParticleSun#createWithTotalParticles");

    return mrb_nil_value();
}

void ruby_register_cocos2dx_ParticleSun(mrb_state* mrb, struct RClass* rmodule)
{
    std::string typeName = typeid(cocos2d::ParticleSun).name();
    g_rubyType[typeName] = "CC::ParticleSun";
    g_rubyDataType[typeName] = &ruby_cocos2dx_Ref_type;

    struct RClass* p_rmodule = mrb->object_class;
    p_rmodule = mrb_module_get_under(mrb, p_rmodule, "CC");
    struct RClass* p_rclass = mrb_class_get_under(mrb, p_rmodule, "ParticleSystemQuad");
    struct RClass *rclass = mrb_define_class_under(mrb, rmodule, "ParticleSun", p_rclass);
    MRB_SET_INSTANCE_TT(rclass, MRB_TT_DATA);

    mrb_define_class_method(mrb, rclass, "create", ruby_cocos2dx_ParticleSun_create_static, ARGS_NONE());
    mrb_define_class_method(mrb, rclass, "create_with_total_particles", ruby_cocos2dx_ParticleSun_createWithTotalParticles_static, ARGS_REQ(1));
}
mrb_value ruby_cocos2dx_ParticleGalaxy_create_static(mrb_state* mrb, mrb_value self)
{
    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            std::map<std::string, mrb_value> callbacks;
            cocos2d::ParticleGalaxy* retval = cocos2d::ParticleGalaxy::create();
            mrb_value ret;
            RClass* rclass = mrb_class_ptr(self);
            ret = object_to_rubyval<cocos2d::ParticleGalaxy>(mrb, "CC::ParticleGalaxy", (cocos2d::ParticleGalaxy*)retval, rclass);
            if (callbacks.size() > 0) {
                mrb_value hash = mrb_iv_get(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"));
                if (!mrb_hash_p(hash)) {
                    hash = mrb_hash_new(mrb);
                }
                for (auto elm : callbacks) {
                    mrb_hash_set(mrb, hash, mrb_str_new_cstr(mrb, elm.first.c_str()), elm.second);
                    mrb_iv_set(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"), hash);
                }
            }
            g_rubyValue.push_back(ret);
            mrb_funcall(mrb, ret, "initialize", 0);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined static method : cocos2d::ParticleGalaxy#create");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_ParticleGalaxy_createWithTotalParticles_static(mrb_state* mrb, mrb_value self)
{
    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            std::map<std::string, mrb_value> callbacks;
            int arg0;
            ok = rubyval_to_int32(mrb, argv[0], (int*)&arg0, "CC::ParticleGalaxy.createWithTotalParticles");
            if (!ok) { break; }

            cocos2d::ParticleGalaxy* retval = cocos2d::ParticleGalaxy::createWithTotalParticles(arg0);
            mrb_value ret;
            RClass* rclass = mrb_class_ptr(self);
            ret = object_to_rubyval<cocos2d::ParticleGalaxy>(mrb, "CC::ParticleGalaxy", (cocos2d::ParticleGalaxy*)retval, rclass);
            if (callbacks.size() > 0) {
                mrb_value hash = mrb_iv_get(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"));
                if (!mrb_hash_p(hash)) {
                    hash = mrb_hash_new(mrb);
                }
                for (auto elm : callbacks) {
                    mrb_hash_set(mrb, hash, mrb_str_new_cstr(mrb, elm.first.c_str()), elm.second);
                    mrb_iv_set(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"), hash);
                }
            }
            g_rubyValue.push_back(ret);
            mrb_funcall(mrb, ret, "initialize", 0);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined static method : cocos2d::ParticleGalaxy#createWithTotalParticles");

    return mrb_nil_value();
}

void ruby_register_cocos2dx_ParticleGalaxy(mrb_state* mrb, struct RClass* rmodule)
{
    std::string typeName = typeid(cocos2d::ParticleGalaxy).name();
    g_rubyType[typeName] = "CC::ParticleGalaxy";
    g_rubyDataType[typeName] = &ruby_cocos2dx_Ref_type;

    struct RClass* p_rmodule = mrb->object_class;
    p_rmodule = mrb_module_get_under(mrb, p_rmodule, "CC");
    struct RClass* p_rclass = mrb_class_get_under(mrb, p_rmodule, "ParticleSystemQuad");
    struct RClass *rclass = mrb_define_class_under(mrb, rmodule, "ParticleGalaxy", p_rclass);
    MRB_SET_INSTANCE_TT(rclass, MRB_TT_DATA);

    mrb_define_class_method(mrb, rclass, "create", ruby_cocos2dx_ParticleGalaxy_create_static, ARGS_NONE());
    mrb_define_class_method(mrb, rclass, "create_with_total_particles", ruby_cocos2dx_ParticleGalaxy_createWithTotalParticles_static, ARGS_REQ(1));
}
mrb_value ruby_cocos2dx_ParticleFlower_create_static(mrb_state* mrb, mrb_value self)
{
    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            std::map<std::string, mrb_value> callbacks;
            cocos2d::ParticleFlower* retval = cocos2d::ParticleFlower::create();
            mrb_value ret;
            RClass* rclass = mrb_class_ptr(self);
            ret = object_to_rubyval<cocos2d::ParticleFlower>(mrb, "CC::ParticleFlower", (cocos2d::ParticleFlower*)retval, rclass);
            if (callbacks.size() > 0) {
                mrb_value hash = mrb_iv_get(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"));
                if (!mrb_hash_p(hash)) {
                    hash = mrb_hash_new(mrb);
                }
                for (auto elm : callbacks) {
                    mrb_hash_set(mrb, hash, mrb_str_new_cstr(mrb, elm.first.c_str()), elm.second);
                    mrb_iv_set(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"), hash);
                }
            }
            g_rubyValue.push_back(ret);
            mrb_funcall(mrb, ret, "initialize", 0);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined static method : cocos2d::ParticleFlower#create");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_ParticleFlower_createWithTotalParticles_static(mrb_state* mrb, mrb_value self)
{
    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            std::map<std::string, mrb_value> callbacks;
            int arg0;
            ok = rubyval_to_int32(mrb, argv[0], (int*)&arg0, "CC::ParticleFlower.createWithTotalParticles");
            if (!ok) { break; }

            cocos2d::ParticleFlower* retval = cocos2d::ParticleFlower::createWithTotalParticles(arg0);
            mrb_value ret;
            RClass* rclass = mrb_class_ptr(self);
            ret = object_to_rubyval<cocos2d::ParticleFlower>(mrb, "CC::ParticleFlower", (cocos2d::ParticleFlower*)retval, rclass);
            if (callbacks.size() > 0) {
                mrb_value hash = mrb_iv_get(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"));
                if (!mrb_hash_p(hash)) {
                    hash = mrb_hash_new(mrb);
                }
                for (auto elm : callbacks) {
                    mrb_hash_set(mrb, hash, mrb_str_new_cstr(mrb, elm.first.c_str()), elm.second);
                    mrb_iv_set(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"), hash);
                }
            }
            g_rubyValue.push_back(ret);
            mrb_funcall(mrb, ret, "initialize", 0);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined static method : cocos2d::ParticleFlower#createWithTotalParticles");

    return mrb_nil_value();
}

void ruby_register_cocos2dx_ParticleFlower(mrb_state* mrb, struct RClass* rmodule)
{
    std::string typeName = typeid(cocos2d::ParticleFlower).name();
    g_rubyType[typeName] = "CC::ParticleFlower";
    g_rubyDataType[typeName] = &ruby_cocos2dx_Ref_type;

    struct RClass* p_rmodule = mrb->object_class;
    p_rmodule = mrb_module_get_under(mrb, p_rmodule, "CC");
    struct RClass* p_rclass = mrb_class_get_under(mrb, p_rmodule, "ParticleSystemQuad");
    struct RClass *rclass = mrb_define_class_under(mrb, rmodule, "ParticleFlower", p_rclass);
    MRB_SET_INSTANCE_TT(rclass, MRB_TT_DATA);

    mrb_define_class_method(mrb, rclass, "create", ruby_cocos2dx_ParticleFlower_create_static, ARGS_NONE());
    mrb_define_class_method(mrb, rclass, "create_with_total_particles", ruby_cocos2dx_ParticleFlower_createWithTotalParticles_static, ARGS_REQ(1));
}
mrb_value ruby_cocos2dx_ParticleMeteor_create_static(mrb_state* mrb, mrb_value self)
{
    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            std::map<std::string, mrb_value> callbacks;
            cocos2d::ParticleMeteor* retval = cocos2d::ParticleMeteor::create();
            mrb_value ret;
            RClass* rclass = mrb_class_ptr(self);
            ret = object_to_rubyval<cocos2d::ParticleMeteor>(mrb, "CC::ParticleMeteor", (cocos2d::ParticleMeteor*)retval, rclass);
            if (callbacks.size() > 0) {
                mrb_value hash = mrb_iv_get(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"));
                if (!mrb_hash_p(hash)) {
                    hash = mrb_hash_new(mrb);
                }
                for (auto elm : callbacks) {
                    mrb_hash_set(mrb, hash, mrb_str_new_cstr(mrb, elm.first.c_str()), elm.second);
                    mrb_iv_set(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"), hash);
                }
            }
            g_rubyValue.push_back(ret);
            mrb_funcall(mrb, ret, "initialize", 0);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined static method : cocos2d::ParticleMeteor#create");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_ParticleMeteor_createWithTotalParticles_static(mrb_state* mrb, mrb_value self)
{
    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            std::map<std::string, mrb_value> callbacks;
            int arg0;
            ok = rubyval_to_int32(mrb, argv[0], (int*)&arg0, "CC::ParticleMeteor.createWithTotalParticles");
            if (!ok) { break; }

            cocos2d::ParticleMeteor* retval = cocos2d::ParticleMeteor::createWithTotalParticles(arg0);
            mrb_value ret;
            RClass* rclass = mrb_class_ptr(self);
            ret = object_to_rubyval<cocos2d::ParticleMeteor>(mrb, "CC::ParticleMeteor", (cocos2d::ParticleMeteor*)retval, rclass);
            if (callbacks.size() > 0) {
                mrb_value hash = mrb_iv_get(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"));
                if (!mrb_hash_p(hash)) {
                    hash = mrb_hash_new(mrb);
                }
                for (auto elm : callbacks) {
                    mrb_hash_set(mrb, hash, mrb_str_new_cstr(mrb, elm.first.c_str()), elm.second);
                    mrb_iv_set(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"), hash);
                }
            }
            g_rubyValue.push_back(ret);
            mrb_funcall(mrb, ret, "initialize", 0);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined static method : cocos2d::ParticleMeteor#createWithTotalParticles");

    return mrb_nil_value();
}

void ruby_register_cocos2dx_ParticleMeteor(mrb_state* mrb, struct RClass* rmodule)
{
    std::string typeName = typeid(cocos2d::ParticleMeteor).name();
    g_rubyType[typeName] = "CC::ParticleMeteor";
    g_rubyDataType[typeName] = &ruby_cocos2dx_Ref_type;

    struct RClass* p_rmodule = mrb->object_class;
    p_rmodule = mrb_module_get_under(mrb, p_rmodule, "CC");
    struct RClass* p_rclass = mrb_class_get_under(mrb, p_rmodule, "ParticleSystemQuad");
    struct RClass *rclass = mrb_define_class_under(mrb, rmodule, "ParticleMeteor", p_rclass);
    MRB_SET_INSTANCE_TT(rclass, MRB_TT_DATA);

    mrb_define_class_method(mrb, rclass, "create", ruby_cocos2dx_ParticleMeteor_create_static, ARGS_NONE());
    mrb_define_class_method(mrb, rclass, "create_with_total_particles", ruby_cocos2dx_ParticleMeteor_createWithTotalParticles_static, ARGS_REQ(1));
}
mrb_value ruby_cocos2dx_ParticleSpiral_create_static(mrb_state* mrb, mrb_value self)
{
    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            std::map<std::string, mrb_value> callbacks;
            cocos2d::ParticleSpiral* retval = cocos2d::ParticleSpiral::create();
            mrb_value ret;
            RClass* rclass = mrb_class_ptr(self);
            ret = object_to_rubyval<cocos2d::ParticleSpiral>(mrb, "CC::ParticleSpiral", (cocos2d::ParticleSpiral*)retval, rclass);
            if (callbacks.size() > 0) {
                mrb_value hash = mrb_iv_get(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"));
                if (!mrb_hash_p(hash)) {
                    hash = mrb_hash_new(mrb);
                }
                for (auto elm : callbacks) {
                    mrb_hash_set(mrb, hash, mrb_str_new_cstr(mrb, elm.first.c_str()), elm.second);
                    mrb_iv_set(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"), hash);
                }
            }
            g_rubyValue.push_back(ret);
            mrb_funcall(mrb, ret, "initialize", 0);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined static method : cocos2d::ParticleSpiral#create");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_ParticleSpiral_createWithTotalParticles_static(mrb_state* mrb, mrb_value self)
{
    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            std::map<std::string, mrb_value> callbacks;
            int arg0;
            ok = rubyval_to_int32(mrb, argv[0], (int*)&arg0, "CC::ParticleSpiral.createWithTotalParticles");
            if (!ok) { break; }

            cocos2d::ParticleSpiral* retval = cocos2d::ParticleSpiral::createWithTotalParticles(arg0);
            mrb_value ret;
            RClass* rclass = mrb_class_ptr(self);
            ret = object_to_rubyval<cocos2d::ParticleSpiral>(mrb, "CC::ParticleSpiral", (cocos2d::ParticleSpiral*)retval, rclass);
            if (callbacks.size() > 0) {
                mrb_value hash = mrb_iv_get(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"));
                if (!mrb_hash_p(hash)) {
                    hash = mrb_hash_new(mrb);
                }
                for (auto elm : callbacks) {
                    mrb_hash_set(mrb, hash, mrb_str_new_cstr(mrb, elm.first.c_str()), elm.second);
                    mrb_iv_set(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"), hash);
                }
            }
            g_rubyValue.push_back(ret);
            mrb_funcall(mrb, ret, "initialize", 0);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined static method : cocos2d::ParticleSpiral#createWithTotalParticles");

    return mrb_nil_value();
}

void ruby_register_cocos2dx_ParticleSpiral(mrb_state* mrb, struct RClass* rmodule)
{
    std::string typeName = typeid(cocos2d::ParticleSpiral).name();
    g_rubyType[typeName] = "CC::ParticleSpiral";
    g_rubyDataType[typeName] = &ruby_cocos2dx_Ref_type;

    struct RClass* p_rmodule = mrb->object_class;
    p_rmodule = mrb_module_get_under(mrb, p_rmodule, "CC");
    struct RClass* p_rclass = mrb_class_get_under(mrb, p_rmodule, "ParticleSystemQuad");
    struct RClass *rclass = mrb_define_class_under(mrb, rmodule, "ParticleSpiral", p_rclass);
    MRB_SET_INSTANCE_TT(rclass, MRB_TT_DATA);

    mrb_define_class_method(mrb, rclass, "create", ruby_cocos2dx_ParticleSpiral_create_static, ARGS_NONE());
    mrb_define_class_method(mrb, rclass, "create_with_total_particles", ruby_cocos2dx_ParticleSpiral_createWithTotalParticles_static, ARGS_REQ(1));
}
mrb_value ruby_cocos2dx_ParticleExplosion_create_static(mrb_state* mrb, mrb_value self)
{
    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            std::map<std::string, mrb_value> callbacks;
            cocos2d::ParticleExplosion* retval = cocos2d::ParticleExplosion::create();
            mrb_value ret;
            RClass* rclass = mrb_class_ptr(self);
            ret = object_to_rubyval<cocos2d::ParticleExplosion>(mrb, "CC::ParticleExplosion", (cocos2d::ParticleExplosion*)retval, rclass);
            if (callbacks.size() > 0) {
                mrb_value hash = mrb_iv_get(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"));
                if (!mrb_hash_p(hash)) {
                    hash = mrb_hash_new(mrb);
                }
                for (auto elm : callbacks) {
                    mrb_hash_set(mrb, hash, mrb_str_new_cstr(mrb, elm.first.c_str()), elm.second);
                    mrb_iv_set(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"), hash);
                }
            }
            g_rubyValue.push_back(ret);
            mrb_funcall(mrb, ret, "initialize", 0);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined static method : cocos2d::ParticleExplosion#create");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_ParticleExplosion_createWithTotalParticles_static(mrb_state* mrb, mrb_value self)
{
    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            std::map<std::string, mrb_value> callbacks;
            int arg0;
            ok = rubyval_to_int32(mrb, argv[0], (int*)&arg0, "CC::ParticleExplosion.createWithTotalParticles");
            if (!ok) { break; }

            cocos2d::ParticleExplosion* retval = cocos2d::ParticleExplosion::createWithTotalParticles(arg0);
            mrb_value ret;
            RClass* rclass = mrb_class_ptr(self);
            ret = object_to_rubyval<cocos2d::ParticleExplosion>(mrb, "CC::ParticleExplosion", (cocos2d::ParticleExplosion*)retval, rclass);
            if (callbacks.size() > 0) {
                mrb_value hash = mrb_iv_get(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"));
                if (!mrb_hash_p(hash)) {
                    hash = mrb_hash_new(mrb);
                }
                for (auto elm : callbacks) {
                    mrb_hash_set(mrb, hash, mrb_str_new_cstr(mrb, elm.first.c_str()), elm.second);
                    mrb_iv_set(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"), hash);
                }
            }
            g_rubyValue.push_back(ret);
            mrb_funcall(mrb, ret, "initialize", 0);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined static method : cocos2d::ParticleExplosion#createWithTotalParticles");

    return mrb_nil_value();
}

void ruby_register_cocos2dx_ParticleExplosion(mrb_state* mrb, struct RClass* rmodule)
{
    std::string typeName = typeid(cocos2d::ParticleExplosion).name();
    g_rubyType[typeName] = "CC::ParticleExplosion";
    g_rubyDataType[typeName] = &ruby_cocos2dx_Ref_type;

    struct RClass* p_rmodule = mrb->object_class;
    p_rmodule = mrb_module_get_under(mrb, p_rmodule, "CC");
    struct RClass* p_rclass = mrb_class_get_under(mrb, p_rmodule, "ParticleSystemQuad");
    struct RClass *rclass = mrb_define_class_under(mrb, rmodule, "ParticleExplosion", p_rclass);
    MRB_SET_INSTANCE_TT(rclass, MRB_TT_DATA);

    mrb_define_class_method(mrb, rclass, "create", ruby_cocos2dx_ParticleExplosion_create_static, ARGS_NONE());
    mrb_define_class_method(mrb, rclass, "create_with_total_particles", ruby_cocos2dx_ParticleExplosion_createWithTotalParticles_static, ARGS_REQ(1));
}
mrb_value ruby_cocos2dx_ParticleSmoke_create_static(mrb_state* mrb, mrb_value self)
{
    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            std::map<std::string, mrb_value> callbacks;
            cocos2d::ParticleSmoke* retval = cocos2d::ParticleSmoke::create();
            mrb_value ret;
            RClass* rclass = mrb_class_ptr(self);
            ret = object_to_rubyval<cocos2d::ParticleSmoke>(mrb, "CC::ParticleSmoke", (cocos2d::ParticleSmoke*)retval, rclass);
            if (callbacks.size() > 0) {
                mrb_value hash = mrb_iv_get(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"));
                if (!mrb_hash_p(hash)) {
                    hash = mrb_hash_new(mrb);
                }
                for (auto elm : callbacks) {
                    mrb_hash_set(mrb, hash, mrb_str_new_cstr(mrb, elm.first.c_str()), elm.second);
                    mrb_iv_set(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"), hash);
                }
            }
            g_rubyValue.push_back(ret);
            mrb_funcall(mrb, ret, "initialize", 0);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined static method : cocos2d::ParticleSmoke#create");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_ParticleSmoke_createWithTotalParticles_static(mrb_state* mrb, mrb_value self)
{
    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            std::map<std::string, mrb_value> callbacks;
            int arg0;
            ok = rubyval_to_int32(mrb, argv[0], (int*)&arg0, "CC::ParticleSmoke.createWithTotalParticles");
            if (!ok) { break; }

            cocos2d::ParticleSmoke* retval = cocos2d::ParticleSmoke::createWithTotalParticles(arg0);
            mrb_value ret;
            RClass* rclass = mrb_class_ptr(self);
            ret = object_to_rubyval<cocos2d::ParticleSmoke>(mrb, "CC::ParticleSmoke", (cocos2d::ParticleSmoke*)retval, rclass);
            if (callbacks.size() > 0) {
                mrb_value hash = mrb_iv_get(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"));
                if (!mrb_hash_p(hash)) {
                    hash = mrb_hash_new(mrb);
                }
                for (auto elm : callbacks) {
                    mrb_hash_set(mrb, hash, mrb_str_new_cstr(mrb, elm.first.c_str()), elm.second);
                    mrb_iv_set(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"), hash);
                }
            }
            g_rubyValue.push_back(ret);
            mrb_funcall(mrb, ret, "initialize", 0);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined static method : cocos2d::ParticleSmoke#createWithTotalParticles");

    return mrb_nil_value();
}

void ruby_register_cocos2dx_ParticleSmoke(mrb_state* mrb, struct RClass* rmodule)
{
    std::string typeName = typeid(cocos2d::ParticleSmoke).name();
    g_rubyType[typeName] = "CC::ParticleSmoke";
    g_rubyDataType[typeName] = &ruby_cocos2dx_Ref_type;

    struct RClass* p_rmodule = mrb->object_class;
    p_rmodule = mrb_module_get_under(mrb, p_rmodule, "CC");
    struct RClass* p_rclass = mrb_class_get_under(mrb, p_rmodule, "ParticleSystemQuad");
    struct RClass *rclass = mrb_define_class_under(mrb, rmodule, "ParticleSmoke", p_rclass);
    MRB_SET_INSTANCE_TT(rclass, MRB_TT_DATA);

    mrb_define_class_method(mrb, rclass, "create", ruby_cocos2dx_ParticleSmoke_create_static, ARGS_NONE());
    mrb_define_class_method(mrb, rclass, "create_with_total_particles", ruby_cocos2dx_ParticleSmoke_createWithTotalParticles_static, ARGS_REQ(1));
}
mrb_value ruby_cocos2dx_ParticleSnow_create_static(mrb_state* mrb, mrb_value self)
{
    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            std::map<std::string, mrb_value> callbacks;
            cocos2d::ParticleSnow* retval = cocos2d::ParticleSnow::create();
            mrb_value ret;
            RClass* rclass = mrb_class_ptr(self);
            ret = object_to_rubyval<cocos2d::ParticleSnow>(mrb, "CC::ParticleSnow", (cocos2d::ParticleSnow*)retval, rclass);
            if (callbacks.size() > 0) {
                mrb_value hash = mrb_iv_get(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"));
                if (!mrb_hash_p(hash)) {
                    hash = mrb_hash_new(mrb);
                }
                for (auto elm : callbacks) {
                    mrb_hash_set(mrb, hash, mrb_str_new_cstr(mrb, elm.first.c_str()), elm.second);
                    mrb_iv_set(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"), hash);
                }
            }
            g_rubyValue.push_back(ret);
            mrb_funcall(mrb, ret, "initialize", 0);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined static method : cocos2d::ParticleSnow#create");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_ParticleSnow_createWithTotalParticles_static(mrb_state* mrb, mrb_value self)
{
    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            std::map<std::string, mrb_value> callbacks;
            int arg0;
            ok = rubyval_to_int32(mrb, argv[0], (int*)&arg0, "CC::ParticleSnow.createWithTotalParticles");
            if (!ok) { break; }

            cocos2d::ParticleSnow* retval = cocos2d::ParticleSnow::createWithTotalParticles(arg0);
            mrb_value ret;
            RClass* rclass = mrb_class_ptr(self);
            ret = object_to_rubyval<cocos2d::ParticleSnow>(mrb, "CC::ParticleSnow", (cocos2d::ParticleSnow*)retval, rclass);
            if (callbacks.size() > 0) {
                mrb_value hash = mrb_iv_get(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"));
                if (!mrb_hash_p(hash)) {
                    hash = mrb_hash_new(mrb);
                }
                for (auto elm : callbacks) {
                    mrb_hash_set(mrb, hash, mrb_str_new_cstr(mrb, elm.first.c_str()), elm.second);
                    mrb_iv_set(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"), hash);
                }
            }
            g_rubyValue.push_back(ret);
            mrb_funcall(mrb, ret, "initialize", 0);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined static method : cocos2d::ParticleSnow#createWithTotalParticles");

    return mrb_nil_value();
}

void ruby_register_cocos2dx_ParticleSnow(mrb_state* mrb, struct RClass* rmodule)
{
    std::string typeName = typeid(cocos2d::ParticleSnow).name();
    g_rubyType[typeName] = "CC::ParticleSnow";
    g_rubyDataType[typeName] = &ruby_cocos2dx_Ref_type;

    struct RClass* p_rmodule = mrb->object_class;
    p_rmodule = mrb_module_get_under(mrb, p_rmodule, "CC");
    struct RClass* p_rclass = mrb_class_get_under(mrb, p_rmodule, "ParticleSystemQuad");
    struct RClass *rclass = mrb_define_class_under(mrb, rmodule, "ParticleSnow", p_rclass);
    MRB_SET_INSTANCE_TT(rclass, MRB_TT_DATA);

    mrb_define_class_method(mrb, rclass, "create", ruby_cocos2dx_ParticleSnow_create_static, ARGS_NONE());
    mrb_define_class_method(mrb, rclass, "create_with_total_particles", ruby_cocos2dx_ParticleSnow_createWithTotalParticles_static, ARGS_REQ(1));
}
mrb_value ruby_cocos2dx_ParticleRain_create_static(mrb_state* mrb, mrb_value self)
{
    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            std::map<std::string, mrb_value> callbacks;
            cocos2d::ParticleRain* retval = cocos2d::ParticleRain::create();
            mrb_value ret;
            RClass* rclass = mrb_class_ptr(self);
            ret = object_to_rubyval<cocos2d::ParticleRain>(mrb, "CC::ParticleRain", (cocos2d::ParticleRain*)retval, rclass);
            if (callbacks.size() > 0) {
                mrb_value hash = mrb_iv_get(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"));
                if (!mrb_hash_p(hash)) {
                    hash = mrb_hash_new(mrb);
                }
                for (auto elm : callbacks) {
                    mrb_hash_set(mrb, hash, mrb_str_new_cstr(mrb, elm.first.c_str()), elm.second);
                    mrb_iv_set(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"), hash);
                }
            }
            g_rubyValue.push_back(ret);
            mrb_funcall(mrb, ret, "initialize", 0);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined static method : cocos2d::ParticleRain#create");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_ParticleRain_createWithTotalParticles_static(mrb_state* mrb, mrb_value self)
{
    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            std::map<std::string, mrb_value> callbacks;
            int arg0;
            ok = rubyval_to_int32(mrb, argv[0], (int*)&arg0, "CC::ParticleRain.createWithTotalParticles");
            if (!ok) { break; }

            cocos2d::ParticleRain* retval = cocos2d::ParticleRain::createWithTotalParticles(arg0);
            mrb_value ret;
            RClass* rclass = mrb_class_ptr(self);
            ret = object_to_rubyval<cocos2d::ParticleRain>(mrb, "CC::ParticleRain", (cocos2d::ParticleRain*)retval, rclass);
            if (callbacks.size() > 0) {
                mrb_value hash = mrb_iv_get(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"));
                if (!mrb_hash_p(hash)) {
                    hash = mrb_hash_new(mrb);
                }
                for (auto elm : callbacks) {
                    mrb_hash_set(mrb, hash, mrb_str_new_cstr(mrb, elm.first.c_str()), elm.second);
                    mrb_iv_set(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"), hash);
                }
            }
            g_rubyValue.push_back(ret);
            mrb_funcall(mrb, ret, "initialize", 0);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined static method : cocos2d::ParticleRain#createWithTotalParticles");

    return mrb_nil_value();
}

void ruby_register_cocos2dx_ParticleRain(mrb_state* mrb, struct RClass* rmodule)
{
    std::string typeName = typeid(cocos2d::ParticleRain).name();
    g_rubyType[typeName] = "CC::ParticleRain";
    g_rubyDataType[typeName] = &ruby_cocos2dx_Ref_type;

    struct RClass* p_rmodule = mrb->object_class;
    p_rmodule = mrb_module_get_under(mrb, p_rmodule, "CC");
    struct RClass* p_rclass = mrb_class_get_under(mrb, p_rmodule, "ParticleSystemQuad");
    struct RClass *rclass = mrb_define_class_under(mrb, rmodule, "ParticleRain", p_rclass);
    MRB_SET_INSTANCE_TT(rclass, MRB_TT_DATA);

    mrb_define_class_method(mrb, rclass, "create", ruby_cocos2dx_ParticleRain_create_static, ARGS_NONE());
    mrb_define_class_method(mrb, rclass, "create_with_total_particles", ruby_cocos2dx_ParticleRain_createWithTotalParticles_static, ARGS_REQ(1));
}
mrb_value ruby_cocos2dx_GridBase_setGridSize(mrb_state* mrb, mrb_value self)
{
    cocos2d::GridBase* cobj = static_cast<cocos2d::GridBase*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            cocos2d::Size* arg0;
            ok = rubyval_to_object<cocos2d::Size>(mrb, argv[0], "CC::Size", &arg0);
            if (!ok) { break; }
            cobj->setGridSize(*arg0);
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::GridBase#setGridSize");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_GridBase_afterBlit(mrb_state* mrb, mrb_value self)
{
    cocos2d::GridBase* cobj = static_cast<cocos2d::GridBase*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            cobj->afterBlit();
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::GridBase#afterBlit");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_GridBase_afterDraw(mrb_state* mrb, mrb_value self)
{
    cocos2d::GridBase* cobj = static_cast<cocos2d::GridBase*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            cocos2d::Node* arg0;
            ok = rubyval_to_object<cocos2d::Node>(mrb, argv[0], "CC::Node", &arg0);
            if (!ok) { break; }
            cobj->afterDraw(arg0);
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::GridBase#afterDraw");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_GridBase_beforeDraw(mrb_state* mrb, mrb_value self)
{
    cocos2d::GridBase* cobj = static_cast<cocos2d::GridBase*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            cobj->beforeDraw();
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::GridBase#beforeDraw");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_GridBase_calculateVertexPoints(mrb_state* mrb, mrb_value self)
{
    cocos2d::GridBase* cobj = static_cast<cocos2d::GridBase*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            cobj->calculateVertexPoints();
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::GridBase#calculateVertexPoints");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_GridBase_isTextureFlipped(mrb_state* mrb, mrb_value self)
{
    cocos2d::GridBase* cobj = static_cast<cocos2d::GridBase*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            bool retval = cobj->isTextureFlipped();
            mrb_value ret;
            ret = mrb_bool_value((mrb_bool)retval);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::GridBase#isTextureFlipped");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_GridBase_getGridSize(mrb_state* mrb, mrb_value self)
{
    cocos2d::GridBase* cobj = static_cast<cocos2d::GridBase*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            cocos2d::Size retval = cobj->getGridSize();
            cocos2d::Size* retval_ptr = new cocos2d::Size(retval);
            mrb_value ret;
            ret = object_to_rubyval<cocos2d::Size>(mrb, "CC::Size", (cocos2d::Size*)retval_ptr, nullptr);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::GridBase#getGridSize");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_GridBase_getStep(mrb_state* mrb, mrb_value self)
{
    cocos2d::GridBase* cobj = static_cast<cocos2d::GridBase*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            cocos2d::Vec2 retval = cobj->getStep();
            cocos2d::Vec2* retval_ptr = new cocos2d::Vec2(retval);
            mrb_value ret;
            ret = object_to_rubyval<cocos2d::Vec2>(mrb, "CC::Vec2", (cocos2d::Vec2*)retval_ptr, nullptr);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::GridBase#getStep");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_GridBase_set2DProjection(mrb_state* mrb, mrb_value self)
{
    cocos2d::GridBase* cobj = static_cast<cocos2d::GridBase*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            cobj->set2DProjection();
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::GridBase#set2DProjection");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_GridBase_setStep(mrb_state* mrb, mrb_value self)
{
    cocos2d::GridBase* cobj = static_cast<cocos2d::GridBase*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            cocos2d::Vec2* arg0;
            ok = rubyval_to_object<cocos2d::Vec2>(mrb, argv[0], "CC::Vec2", &arg0);
            if (!ok) { break; }
            cobj->setStep(*arg0);
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::GridBase#setStep");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_GridBase_setTextureFlipped(mrb_state* mrb, mrb_value self)
{
    cocos2d::GridBase* cobj = static_cast<cocos2d::GridBase*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            bool arg0;
            ok = rubyval_to_boolean(mrb, argv[0], &arg0, "CC::GridBase.setTextureFlipped");
            if (!ok) { break; }
            cobj->setTextureFlipped(arg0);
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::GridBase#setTextureFlipped");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_GridBase_blit(mrb_state* mrb, mrb_value self)
{
    cocos2d::GridBase* cobj = static_cast<cocos2d::GridBase*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            cobj->blit();
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::GridBase#blit");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_GridBase_setActive(mrb_state* mrb, mrb_value self)
{
    cocos2d::GridBase* cobj = static_cast<cocos2d::GridBase*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            bool arg0;
            ok = rubyval_to_boolean(mrb, argv[0], &arg0, "CC::GridBase.setActive");
            if (!ok) { break; }
            cobj->setActive(arg0);
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::GridBase#setActive");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_GridBase_getReuseGrid(mrb_state* mrb, mrb_value self)
{
    cocos2d::GridBase* cobj = static_cast<cocos2d::GridBase*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            int retval = cobj->getReuseGrid();
            mrb_value ret;
            ret = mrb_fixnum_value((mrb_int)retval);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::GridBase#getReuseGrid");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_GridBase_initWithSize(mrb_state* mrb, mrb_value self)
{
    cocos2d::GridBase* cobj = static_cast<cocos2d::GridBase*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            cocos2d::Size* arg0;
            ok = rubyval_to_object<cocos2d::Size>(mrb, argv[0], "CC::Size", &arg0);
            if (!ok) { break; }
            bool retval = cobj->initWithSize(*arg0);
            mrb_value ret;
            ret = mrb_bool_value((mrb_bool)retval);
            return ret;
        }
    } while (0);
    do {
        if (argc == 3) {
            cocos2d::Size* arg0;
            ok = rubyval_to_object<cocos2d::Size>(mrb, argv[0], "CC::Size", &arg0);
            if (!ok) { break; }
            cocos2d::Texture2D* arg1;
            ok = rubyval_to_object<cocos2d::Texture2D>(mrb, argv[1], "CC::Texture2D", &arg1);
            if (!ok) { break; }
            bool arg2;
            ok = rubyval_to_boolean(mrb, argv[2], &arg2, "CC::GridBase.initWithSize");
            if (!ok) { break; }
            bool retval = cobj->initWithSize(*arg0, arg1, arg2);
            mrb_value ret;
            ret = mrb_bool_value((mrb_bool)retval);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::GridBase#initWithSize");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_GridBase_beforeBlit(mrb_state* mrb, mrb_value self)
{
    cocos2d::GridBase* cobj = static_cast<cocos2d::GridBase*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            cobj->beforeBlit();
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::GridBase#beforeBlit");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_GridBase_setReuseGrid(mrb_state* mrb, mrb_value self)
{
    cocos2d::GridBase* cobj = static_cast<cocos2d::GridBase*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            int arg0;
            ok = rubyval_to_int32(mrb, argv[0], (int*)&arg0, "CC::GridBase.setReuseGrid");
            if (!ok) { break; }
            cobj->setReuseGrid(arg0);
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::GridBase#setReuseGrid");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_GridBase_isActive(mrb_state* mrb, mrb_value self)
{
    cocos2d::GridBase* cobj = static_cast<cocos2d::GridBase*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            bool retval = cobj->isActive();
            mrb_value ret;
            ret = mrb_bool_value((mrb_bool)retval);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::GridBase#isActive");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_GridBase_reuse(mrb_state* mrb, mrb_value self)
{
    cocos2d::GridBase* cobj = static_cast<cocos2d::GridBase*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            cobj->reuse();
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::GridBase#reuse");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_GridBase_create_static(mrb_state* mrb, mrb_value self)
{
    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            std::map<std::string, mrb_value> callbacks;
            cocos2d::Size* arg0;
            ok = rubyval_to_object<cocos2d::Size>(mrb, argv[0], "CC::Size", &arg0);
            if (!ok) { break; }

            cocos2d::GridBase* retval = cocos2d::GridBase::create(*arg0);
            mrb_value ret;
            RClass* rclass = mrb_class_ptr(self);
            ret = object_to_rubyval<cocos2d::GridBase>(mrb, "CC::GridBase", (cocos2d::GridBase*)retval, rclass);
            if (callbacks.size() > 0) {
                mrb_value hash = mrb_iv_get(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"));
                if (!mrb_hash_p(hash)) {
                    hash = mrb_hash_new(mrb);
                }
                for (auto elm : callbacks) {
                    mrb_hash_set(mrb, hash, mrb_str_new_cstr(mrb, elm.first.c_str()), elm.second);
                    mrb_iv_set(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"), hash);
                }
            }
            g_rubyValue.push_back(ret);
            mrb_funcall(mrb, ret, "initialize", 0);
            return ret;
        }
    } while (0);
    do {
        if (argc == 3) {
            std::map<std::string, mrb_value> callbacks;
            cocos2d::Size* arg0;
            ok = rubyval_to_object<cocos2d::Size>(mrb, argv[0], "CC::Size", &arg0);
            if (!ok) { break; }

            cocos2d::Texture2D* arg1;
            ok = rubyval_to_object<cocos2d::Texture2D>(mrb, argv[1], "CC::Texture2D", &arg1);
            if (!ok) { break; }

            bool arg2;
            ok = rubyval_to_boolean(mrb, argv[2], &arg2, "CC::GridBase.create");
            if (!ok) { break; }

            cocos2d::GridBase* retval = cocos2d::GridBase::create(*arg0, arg1, arg2);
            mrb_value ret;
            RClass* rclass = mrb_class_ptr(self);
            ret = object_to_rubyval<cocos2d::GridBase>(mrb, "CC::GridBase", (cocos2d::GridBase*)retval, rclass);
            if (callbacks.size() > 0) {
                mrb_value hash = mrb_iv_get(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"));
                if (!mrb_hash_p(hash)) {
                    hash = mrb_hash_new(mrb);
                }
                for (auto elm : callbacks) {
                    mrb_hash_set(mrb, hash, mrb_str_new_cstr(mrb, elm.first.c_str()), elm.second);
                    mrb_iv_set(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"), hash);
                }
            }
            g_rubyValue.push_back(ret);
            mrb_funcall(mrb, ret, "initialize", 0);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined static method : cocos2d::GridBase#create");

    return mrb_nil_value();
}

void ruby_register_cocos2dx_GridBase(mrb_state* mrb, struct RClass* rmodule)
{
    std::string typeName = typeid(cocos2d::GridBase).name();
    g_rubyType[typeName] = "CC::GridBase";
    g_rubyDataType[typeName] = &ruby_cocos2dx_Ref_type;

    struct RClass* p_rmodule = mrb->object_class;
    p_rmodule = mrb_module_get_under(mrb, p_rmodule, "CC");
    struct RClass* p_rclass = mrb_class_get_under(mrb, p_rmodule, "Ref");
    struct RClass *rclass = mrb_define_class_under(mrb, rmodule, "GridBase", p_rclass);
    MRB_SET_INSTANCE_TT(rclass, MRB_TT_DATA);

    mrb_define_method(mrb, rclass, "set_grid_size", ruby_cocos2dx_GridBase_setGridSize, ARGS_REQ(1));
    mrb_define_method(mrb, rclass, "after_blit", ruby_cocos2dx_GridBase_afterBlit, ARGS_NONE());
    mrb_define_method(mrb, rclass, "after_draw", ruby_cocos2dx_GridBase_afterDraw, ARGS_REQ(1));
    mrb_define_method(mrb, rclass, "before_draw", ruby_cocos2dx_GridBase_beforeDraw, ARGS_NONE());
    mrb_define_method(mrb, rclass, "calculate_vertex_points", ruby_cocos2dx_GridBase_calculateVertexPoints, ARGS_NONE());
    mrb_define_method(mrb, rclass, "texture_flipped?", ruby_cocos2dx_GridBase_isTextureFlipped, ARGS_NONE());
    mrb_define_method(mrb, rclass, "get_grid_size", ruby_cocos2dx_GridBase_getGridSize, ARGS_NONE());
    mrb_define_method(mrb, rclass, "get_step", ruby_cocos2dx_GridBase_getStep, ARGS_NONE());
    mrb_define_method(mrb, rclass, "set2_dprojection", ruby_cocos2dx_GridBase_set2DProjection, ARGS_NONE());
    mrb_define_method(mrb, rclass, "set_step", ruby_cocos2dx_GridBase_setStep, ARGS_REQ(1));
    mrb_define_method(mrb, rclass, "set_texture_flipped", ruby_cocos2dx_GridBase_setTextureFlipped, ARGS_REQ(1));
    mrb_define_method(mrb, rclass, "blit", ruby_cocos2dx_GridBase_blit, ARGS_NONE());
    mrb_define_method(mrb, rclass, "set_active", ruby_cocos2dx_GridBase_setActive, ARGS_REQ(1));
    mrb_define_method(mrb, rclass, "get_reuse_grid", ruby_cocos2dx_GridBase_getReuseGrid, ARGS_NONE());
    mrb_define_method(mrb, rclass, "init_with_size", ruby_cocos2dx_GridBase_initWithSize, ARGS_REQ(1)|ARGS_OPT(2));
    mrb_define_method(mrb, rclass, "before_blit", ruby_cocos2dx_GridBase_beforeBlit, ARGS_NONE());
    mrb_define_method(mrb, rclass, "set_reuse_grid", ruby_cocos2dx_GridBase_setReuseGrid, ARGS_REQ(1));
    mrb_define_method(mrb, rclass, "active?", ruby_cocos2dx_GridBase_isActive, ARGS_NONE());
    mrb_define_method(mrb, rclass, "reuse", ruby_cocos2dx_GridBase_reuse, ARGS_NONE());
    mrb_define_class_method(mrb, rclass, "create", ruby_cocos2dx_GridBase_create_static, ARGS_REQ(1)|ARGS_OPT(2));
}
mrb_value ruby_cocos2dx_Grid3D_getNeedDepthTestForBlit(mrb_state* mrb, mrb_value self)
{
    cocos2d::Grid3D* cobj = static_cast<cocos2d::Grid3D*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            bool retval = cobj->getNeedDepthTestForBlit();
            mrb_value ret;
            ret = mrb_bool_value((mrb_bool)retval);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::Grid3D#getNeedDepthTestForBlit");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Grid3D_setNeedDepthTestForBlit(mrb_state* mrb, mrb_value self)
{
    cocos2d::Grid3D* cobj = static_cast<cocos2d::Grid3D*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            bool arg0;
            ok = rubyval_to_boolean(mrb, argv[0], &arg0, "CC::Grid3D.setNeedDepthTestForBlit");
            if (!ok) { break; }
            cobj->setNeedDepthTestForBlit(arg0);
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::Grid3D#setNeedDepthTestForBlit");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Grid3D_create_static(mrb_state* mrb, mrb_value self)
{
    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            std::map<std::string, mrb_value> callbacks;
            cocos2d::Size* arg0;
            ok = rubyval_to_object<cocos2d::Size>(mrb, argv[0], "CC::Size", &arg0);
            if (!ok) { break; }

            cocos2d::Grid3D* retval = cocos2d::Grid3D::create(*arg0);
            mrb_value ret;
            RClass* rclass = mrb_class_ptr(self);
            ret = object_to_rubyval<cocos2d::Grid3D>(mrb, "CC::Grid3D", (cocos2d::Grid3D*)retval, rclass);
            if (callbacks.size() > 0) {
                mrb_value hash = mrb_iv_get(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"));
                if (!mrb_hash_p(hash)) {
                    hash = mrb_hash_new(mrb);
                }
                for (auto elm : callbacks) {
                    mrb_hash_set(mrb, hash, mrb_str_new_cstr(mrb, elm.first.c_str()), elm.second);
                    mrb_iv_set(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"), hash);
                }
            }
            g_rubyValue.push_back(ret);
            mrb_funcall(mrb, ret, "initialize", 0);
            return ret;
        }
    } while (0);
    do {
        if (argc == 3) {
            std::map<std::string, mrb_value> callbacks;
            cocos2d::Size* arg0;
            ok = rubyval_to_object<cocos2d::Size>(mrb, argv[0], "CC::Size", &arg0);
            if (!ok) { break; }

            cocos2d::Texture2D* arg1;
            ok = rubyval_to_object<cocos2d::Texture2D>(mrb, argv[1], "CC::Texture2D", &arg1);
            if (!ok) { break; }

            bool arg2;
            ok = rubyval_to_boolean(mrb, argv[2], &arg2, "CC::Grid3D.create");
            if (!ok) { break; }

            cocos2d::Grid3D* retval = cocos2d::Grid3D::create(*arg0, arg1, arg2);
            mrb_value ret;
            RClass* rclass = mrb_class_ptr(self);
            ret = object_to_rubyval<cocos2d::Grid3D>(mrb, "CC::Grid3D", (cocos2d::Grid3D*)retval, rclass);
            if (callbacks.size() > 0) {
                mrb_value hash = mrb_iv_get(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"));
                if (!mrb_hash_p(hash)) {
                    hash = mrb_hash_new(mrb);
                }
                for (auto elm : callbacks) {
                    mrb_hash_set(mrb, hash, mrb_str_new_cstr(mrb, elm.first.c_str()), elm.second);
                    mrb_iv_set(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"), hash);
                }
            }
            g_rubyValue.push_back(ret);
            mrb_funcall(mrb, ret, "initialize", 0);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined static method : cocos2d::Grid3D#create");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Grid3D_constructor(mrb_state* mrb, mrb_value self)
{

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            cocos2d::Grid3D* cobj = new cocos2d::Grid3D();
            DATA_TYPE(self) = &ruby_cocos2dx_Ref_type;
            DATA_PTR(self) = cobj;
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::Grid3D#Grid3D");

    return mrb_nil_value();
}


void ruby_register_cocos2dx_Grid3D(mrb_state* mrb, struct RClass* rmodule)
{
    std::string typeName = typeid(cocos2d::Grid3D).name();
    g_rubyType[typeName] = "CC::Grid3D";
    g_rubyDataType[typeName] = &ruby_cocos2dx_Ref_type;

    struct RClass* p_rmodule = mrb->object_class;
    p_rmodule = mrb_module_get_under(mrb, p_rmodule, "CC");
    struct RClass* p_rclass = mrb_class_get_under(mrb, p_rmodule, "GridBase");
    struct RClass *rclass = mrb_define_class_under(mrb, rmodule, "Grid3D", p_rclass);
    MRB_SET_INSTANCE_TT(rclass, MRB_TT_DATA);

    mrb_define_method(mrb, rclass, "initialize", ruby_cocos2dx_Grid3D_constructor, ARGS_NONE());
    mrb_define_method(mrb, rclass, "get_need_depth_test_for_blit", ruby_cocos2dx_Grid3D_getNeedDepthTestForBlit, ARGS_NONE());
    mrb_define_method(mrb, rclass, "set_need_depth_test_for_blit", ruby_cocos2dx_Grid3D_setNeedDepthTestForBlit, ARGS_REQ(1));
    mrb_define_class_method(mrb, rclass, "create", ruby_cocos2dx_Grid3D_create_static, ARGS_REQ(1)|ARGS_OPT(2));
}
mrb_value ruby_cocos2dx_TiledGrid3D_create_static(mrb_state* mrb, mrb_value self)
{
    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            std::map<std::string, mrb_value> callbacks;
            cocos2d::Size* arg0;
            ok = rubyval_to_object<cocos2d::Size>(mrb, argv[0], "CC::Size", &arg0);
            if (!ok) { break; }

            cocos2d::TiledGrid3D* retval = cocos2d::TiledGrid3D::create(*arg0);
            mrb_value ret;
            RClass* rclass = mrb_class_ptr(self);
            ret = object_to_rubyval<cocos2d::TiledGrid3D>(mrb, "CC::TiledGrid3D", (cocos2d::TiledGrid3D*)retval, rclass);
            if (callbacks.size() > 0) {
                mrb_value hash = mrb_iv_get(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"));
                if (!mrb_hash_p(hash)) {
                    hash = mrb_hash_new(mrb);
                }
                for (auto elm : callbacks) {
                    mrb_hash_set(mrb, hash, mrb_str_new_cstr(mrb, elm.first.c_str()), elm.second);
                    mrb_iv_set(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"), hash);
                }
            }
            g_rubyValue.push_back(ret);
            mrb_funcall(mrb, ret, "initialize", 0);
            return ret;
        }
    } while (0);
    do {
        if (argc == 3) {
            std::map<std::string, mrb_value> callbacks;
            cocos2d::Size* arg0;
            ok = rubyval_to_object<cocos2d::Size>(mrb, argv[0], "CC::Size", &arg0);
            if (!ok) { break; }

            cocos2d::Texture2D* arg1;
            ok = rubyval_to_object<cocos2d::Texture2D>(mrb, argv[1], "CC::Texture2D", &arg1);
            if (!ok) { break; }

            bool arg2;
            ok = rubyval_to_boolean(mrb, argv[2], &arg2, "CC::TiledGrid3D.create");
            if (!ok) { break; }

            cocos2d::TiledGrid3D* retval = cocos2d::TiledGrid3D::create(*arg0, arg1, arg2);
            mrb_value ret;
            RClass* rclass = mrb_class_ptr(self);
            ret = object_to_rubyval<cocos2d::TiledGrid3D>(mrb, "CC::TiledGrid3D", (cocos2d::TiledGrid3D*)retval, rclass);
            if (callbacks.size() > 0) {
                mrb_value hash = mrb_iv_get(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"));
                if (!mrb_hash_p(hash)) {
                    hash = mrb_hash_new(mrb);
                }
                for (auto elm : callbacks) {
                    mrb_hash_set(mrb, hash, mrb_str_new_cstr(mrb, elm.first.c_str()), elm.second);
                    mrb_iv_set(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"), hash);
                }
            }
            g_rubyValue.push_back(ret);
            mrb_funcall(mrb, ret, "initialize", 0);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined static method : cocos2d::TiledGrid3D#create");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_TiledGrid3D_constructor(mrb_state* mrb, mrb_value self)
{

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            cocos2d::TiledGrid3D* cobj = new cocos2d::TiledGrid3D();
            DATA_TYPE(self) = &ruby_cocos2dx_Ref_type;
            DATA_PTR(self) = cobj;
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::TiledGrid3D#TiledGrid3D");

    return mrb_nil_value();
}


void ruby_register_cocos2dx_TiledGrid3D(mrb_state* mrb, struct RClass* rmodule)
{
    std::string typeName = typeid(cocos2d::TiledGrid3D).name();
    g_rubyType[typeName] = "CC::TiledGrid3D";
    g_rubyDataType[typeName] = &ruby_cocos2dx_Ref_type;

    struct RClass* p_rmodule = mrb->object_class;
    p_rmodule = mrb_module_get_under(mrb, p_rmodule, "CC");
    struct RClass* p_rclass = mrb_class_get_under(mrb, p_rmodule, "GridBase");
    struct RClass *rclass = mrb_define_class_under(mrb, rmodule, "TiledGrid3D", p_rclass);
    MRB_SET_INSTANCE_TT(rclass, MRB_TT_DATA);

    mrb_define_method(mrb, rclass, "initialize", ruby_cocos2dx_TiledGrid3D_constructor, ARGS_NONE());
    mrb_define_class_method(mrb, rclass, "create", ruby_cocos2dx_TiledGrid3D_create_static, ARGS_REQ(1)|ARGS_OPT(2));
}
void ruby_cocos2dx_global_CameraFlag_enum_init(mrb_state* mrb)
{
    do {
        mrb_value ev = mrb_fixnum_value((mrb_int)CameraFlag::DEFAULT);
        mrb_gv_set(mrb, mrb_intern_cstr(mrb, "DEFAULT"), ev);
    } while (0);

    do {
        mrb_value ev = mrb_fixnum_value((mrb_int)CameraFlag::USER1);
        mrb_gv_set(mrb, mrb_intern_cstr(mrb, "USER1"), ev);
    } while (0);

    do {
        mrb_value ev = mrb_fixnum_value((mrb_int)CameraFlag::USER2);
        mrb_gv_set(mrb, mrb_intern_cstr(mrb, "USER2"), ev);
    } while (0);

    do {
        mrb_value ev = mrb_fixnum_value((mrb_int)CameraFlag::USER3);
        mrb_gv_set(mrb, mrb_intern_cstr(mrb, "USER3"), ev);
    } while (0);

    do {
        mrb_value ev = mrb_fixnum_value((mrb_int)CameraFlag::USER4);
        mrb_gv_set(mrb, mrb_intern_cstr(mrb, "USER4"), ev);
    } while (0);

    do {
        mrb_value ev = mrb_fixnum_value((mrb_int)CameraFlag::USER5);
        mrb_gv_set(mrb, mrb_intern_cstr(mrb, "USER5"), ev);
    } while (0);

    do {
        mrb_value ev = mrb_fixnum_value((mrb_int)CameraFlag::USER6);
        mrb_gv_set(mrb, mrb_intern_cstr(mrb, "USER6"), ev);
    } while (0);

    do {
        mrb_value ev = mrb_fixnum_value((mrb_int)CameraFlag::USER7);
        mrb_gv_set(mrb, mrb_intern_cstr(mrb, "USER7"), ev);
    } while (0);

    do {
        mrb_value ev = mrb_fixnum_value((mrb_int)CameraFlag::USER8);
        mrb_gv_set(mrb, mrb_intern_cstr(mrb, "USER8"), ev);
    } while (0);

}
mrb_value ruby_cocos2dx_Camera_getProjectionMatrix(mrb_state* mrb, mrb_value self)
{
    cocos2d::Camera* cobj = static_cast<cocos2d::Camera*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            cocos2d::Mat4 retval = cobj->getProjectionMatrix();
            cocos2d::Mat4* retval_ptr = new cocos2d::Mat4(retval);
            mrb_value ret;
            ret = object_to_rubyval<cocos2d::Mat4>(mrb, "CC::Mat4", (cocos2d::Mat4*)retval_ptr, nullptr);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::Camera#getProjectionMatrix");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Camera_getViewProjectionMatrix(mrb_state* mrb, mrb_value self)
{
    cocos2d::Camera* cobj = static_cast<cocos2d::Camera*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            cocos2d::Mat4 retval = cobj->getViewProjectionMatrix();
            cocos2d::Mat4* retval_ptr = new cocos2d::Mat4(retval);
            mrb_value ret;
            ret = object_to_rubyval<cocos2d::Mat4>(mrb, "CC::Mat4", (cocos2d::Mat4*)retval_ptr, nullptr);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::Camera#getViewProjectionMatrix");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Camera_getViewMatrix(mrb_state* mrb, mrb_value self)
{
    cocos2d::Camera* cobj = static_cast<cocos2d::Camera*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            cocos2d::Mat4 retval = cobj->getViewMatrix();
            cocos2d::Mat4* retval_ptr = new cocos2d::Mat4(retval);
            mrb_value ret;
            ret = object_to_rubyval<cocos2d::Mat4>(mrb, "CC::Mat4", (cocos2d::Mat4*)retval_ptr, nullptr);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::Camera#getViewMatrix");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Camera_getCameraFlag(mrb_state* mrb, mrb_value self)
{
    cocos2d::Camera* cobj = static_cast<cocos2d::Camera*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            int retval = (int)cobj->getCameraFlag();
            mrb_value ret;
            ret = mrb_fixnum_value((mrb_int)retval);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::Camera#getCameraFlag");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Camera_getType(mrb_state* mrb, mrb_value self)
{
    cocos2d::Camera* cobj = static_cast<cocos2d::Camera*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            int retval = (int)cobj->getType();
            mrb_value ret;
            ret = mrb_fixnum_value((mrb_int)retval);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::Camera#getType");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Camera_getDepthInView(mrb_state* mrb, mrb_value self)
{
    cocos2d::Camera* cobj = static_cast<cocos2d::Camera*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            cocos2d::Mat4* arg0;
            ok = rubyval_to_object<cocos2d::Mat4>(mrb, argv[0], "CC::Mat4", &arg0);
            if (!ok) { break; }
            double retval = cobj->getDepthInView(*arg0);
            mrb_value ret;
            ret = mrb_float_value(mrb, (mrb_float)retval);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::Camera#getDepthInView");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Camera_lookAt(mrb_state* mrb, mrb_value self)
{
    cocos2d::Camera* cobj = static_cast<cocos2d::Camera*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            cocos2d::Vec3* arg0;
            ok = rubyval_to_object<cocos2d::Vec3>(mrb, argv[0], "CC::Vec3", &arg0);
            if (!ok) { break; }
            cobj->lookAt(*arg0);
            return self;
        }
    } while (0);
    do {
        if (argc == 2) {
            cocos2d::Vec3* arg0;
            ok = rubyval_to_object<cocos2d::Vec3>(mrb, argv[0], "CC::Vec3", &arg0);
            if (!ok) { break; }
            cocos2d::Vec3* arg1;
            ok = rubyval_to_object<cocos2d::Vec3>(mrb, argv[1], "CC::Vec3", &arg1);
            if (!ok) { break; }
            cobj->lookAt(*arg0, *arg1);
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::Camera#lookAt");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Camera_isVisibleInFrustum(mrb_state* mrb, mrb_value self)
{
    cocos2d::Camera* cobj = static_cast<cocos2d::Camera*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            const cocos2d::AABB* arg0;
            ok = rubyval_to_object<const cocos2d::AABB>(mrb, argv[0], "CC::AABB", &arg0);
            if (!ok) { break; }
            bool retval = cobj->isVisibleInFrustum(arg0);
            mrb_value ret;
            ret = mrb_bool_value((mrb_bool)retval);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::Camera#isVisibleInFrustum");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Camera_setCameraFlag(mrb_state* mrb, mrb_value self)
{
    cocos2d::Camera* cobj = static_cast<cocos2d::Camera*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            cocos2d::CameraFlag arg0;
            ok = rubyval_to_int32(mrb, argv[0], (int*)&arg0, "CC::Camera.setCameraFlag");
            if (!ok) { break; }
            cobj->setCameraFlag(arg0);
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::Camera#setCameraFlag");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Camera_create_static(mrb_state* mrb, mrb_value self)
{
    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            std::map<std::string, mrb_value> callbacks;
            cocos2d::Camera* retval = cocos2d::Camera::create();
            mrb_value ret;
            RClass* rclass = mrb_class_ptr(self);
            ret = object_to_rubyval<cocos2d::Camera>(mrb, "CC::Camera", (cocos2d::Camera*)retval, rclass);
            if (callbacks.size() > 0) {
                mrb_value hash = mrb_iv_get(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"));
                if (!mrb_hash_p(hash)) {
                    hash = mrb_hash_new(mrb);
                }
                for (auto elm : callbacks) {
                    mrb_hash_set(mrb, hash, mrb_str_new_cstr(mrb, elm.first.c_str()), elm.second);
                    mrb_iv_set(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"), hash);
                }
            }
            g_rubyValue.push_back(ret);
            mrb_funcall(mrb, ret, "initialize", 0);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined static method : cocos2d::Camera#create");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Camera_createPerspective_static(mrb_state* mrb, mrb_value self)
{
    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 4) {
            std::map<std::string, mrb_value> callbacks;
            double arg0;
            ok = rubyval_to_number(mrb, argv[0], (double*)&arg0, "CC::Camera.createPerspective");
            if (!ok) { break; }

            double arg1;
            ok = rubyval_to_number(mrb, argv[1], (double*)&arg1, "CC::Camera.createPerspective");
            if (!ok) { break; }

            double arg2;
            ok = rubyval_to_number(mrb, argv[2], (double*)&arg2, "CC::Camera.createPerspective");
            if (!ok) { break; }

            double arg3;
            ok = rubyval_to_number(mrb, argv[3], (double*)&arg3, "CC::Camera.createPerspective");
            if (!ok) { break; }

            cocos2d::Camera* retval = cocos2d::Camera::createPerspective(arg0, arg1, arg2, arg3);
            mrb_value ret;
            RClass* rclass = mrb_class_ptr(self);
            ret = object_to_rubyval<cocos2d::Camera>(mrb, "CC::Camera", (cocos2d::Camera*)retval, rclass);
            if (callbacks.size() > 0) {
                mrb_value hash = mrb_iv_get(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"));
                if (!mrb_hash_p(hash)) {
                    hash = mrb_hash_new(mrb);
                }
                for (auto elm : callbacks) {
                    mrb_hash_set(mrb, hash, mrb_str_new_cstr(mrb, elm.first.c_str()), elm.second);
                    mrb_iv_set(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"), hash);
                }
            }
            g_rubyValue.push_back(ret);
            mrb_funcall(mrb, ret, "initialize", 0);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined static method : cocos2d::Camera#createPerspective");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Camera_createOrthographic_static(mrb_state* mrb, mrb_value self)
{
    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 4) {
            std::map<std::string, mrb_value> callbacks;
            double arg0;
            ok = rubyval_to_number(mrb, argv[0], (double*)&arg0, "CC::Camera.createOrthographic");
            if (!ok) { break; }

            double arg1;
            ok = rubyval_to_number(mrb, argv[1], (double*)&arg1, "CC::Camera.createOrthographic");
            if (!ok) { break; }

            double arg2;
            ok = rubyval_to_number(mrb, argv[2], (double*)&arg2, "CC::Camera.createOrthographic");
            if (!ok) { break; }

            double arg3;
            ok = rubyval_to_number(mrb, argv[3], (double*)&arg3, "CC::Camera.createOrthographic");
            if (!ok) { break; }

            cocos2d::Camera* retval = cocos2d::Camera::createOrthographic(arg0, arg1, arg2, arg3);
            mrb_value ret;
            RClass* rclass = mrb_class_ptr(self);
            ret = object_to_rubyval<cocos2d::Camera>(mrb, "CC::Camera", (cocos2d::Camera*)retval, rclass);
            if (callbacks.size() > 0) {
                mrb_value hash = mrb_iv_get(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"));
                if (!mrb_hash_p(hash)) {
                    hash = mrb_hash_new(mrb);
                }
                for (auto elm : callbacks) {
                    mrb_hash_set(mrb, hash, mrb_str_new_cstr(mrb, elm.first.c_str()), elm.second);
                    mrb_iv_set(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"), hash);
                }
            }
            g_rubyValue.push_back(ret);
            mrb_funcall(mrb, ret, "initialize", 0);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined static method : cocos2d::Camera#createOrthographic");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Camera_getDefaultCamera_static(mrb_state* mrb, mrb_value self)
{
    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            cocos2d::Camera* retval = cocos2d::Camera::getDefaultCamera();
            mrb_value ret;
            ret = object_to_rubyval<cocos2d::Camera>(mrb, "CC::Camera", (cocos2d::Camera*)retval, nullptr);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined static method : cocos2d::Camera#getDefaultCamera");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Camera_getVisitingCamera_static(mrb_state* mrb, mrb_value self)
{
    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            const cocos2d::Camera* retval = cocos2d::Camera::getVisitingCamera();
            mrb_value ret;
            ret = object_to_rubyval<cocos2d::Camera>(mrb, "CC::Camera", (cocos2d::Camera*)retval, nullptr);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined static method : cocos2d::Camera#getVisitingCamera");

    return mrb_nil_value();
}

void ruby_cocos2dx_Camera_Type_enum_init(mrb_state* mrb, struct RClass* renum)
{
    do {
        mrb_value ev = mrb_fixnum_value((mrb_int)cocos2d::Camera::Type::PERSPECTIVE);
        mrb_mod_cv_set(mrb, renum, mrb_intern_cstr(mrb, "PERSPECTIVE"), ev);
    } while (0);

    do {
        mrb_value ev = mrb_fixnum_value((mrb_int)cocos2d::Camera::Type::ORTHOGRAPHIC);
        mrb_mod_cv_set(mrb, renum, mrb_intern_cstr(mrb, "ORTHOGRAPHIC"), ev);
    } while (0);

}

void ruby_register_cocos2dx_Camera(mrb_state* mrb, struct RClass* rmodule)
{
    std::string typeName = typeid(cocos2d::Camera).name();
    g_rubyType[typeName] = "CC::Camera";
    g_rubyDataType[typeName] = &ruby_cocos2dx_Ref_type;

    struct RClass* p_rmodule = mrb->object_class;
    p_rmodule = mrb_module_get_under(mrb, p_rmodule, "CC");
    struct RClass* p_rclass = mrb_class_get_under(mrb, p_rmodule, "Node");
    struct RClass *rclass = mrb_define_class_under(mrb, rmodule, "Camera", p_rclass);
    MRB_SET_INSTANCE_TT(rclass, MRB_TT_DATA);

    mrb_define_method(mrb, rclass, "get_projection_matrix", ruby_cocos2dx_Camera_getProjectionMatrix, ARGS_NONE());
    mrb_define_method(mrb, rclass, "get_view_projection_matrix", ruby_cocos2dx_Camera_getViewProjectionMatrix, ARGS_NONE());
    mrb_define_method(mrb, rclass, "get_view_matrix", ruby_cocos2dx_Camera_getViewMatrix, ARGS_NONE());
    mrb_define_method(mrb, rclass, "get_camera_flag", ruby_cocos2dx_Camera_getCameraFlag, ARGS_NONE());
    mrb_define_method(mrb, rclass, "get_type", ruby_cocos2dx_Camera_getType, ARGS_NONE());
    mrb_define_method(mrb, rclass, "get_depth_in_view", ruby_cocos2dx_Camera_getDepthInView, ARGS_REQ(1));
    mrb_define_method(mrb, rclass, "look_at", ruby_cocos2dx_Camera_lookAt, ARGS_REQ(2));
    mrb_define_method(mrb, rclass, "visible_in_frustum?", ruby_cocos2dx_Camera_isVisibleInFrustum, ARGS_REQ(1));
    mrb_define_method(mrb, rclass, "set_camera_flag", ruby_cocos2dx_Camera_setCameraFlag, ARGS_REQ(1));
    mrb_define_class_method(mrb, rclass, "create", ruby_cocos2dx_Camera_create_static, ARGS_NONE());
    mrb_define_class_method(mrb, rclass, "create_perspective", ruby_cocos2dx_Camera_createPerspective_static, ARGS_REQ(4));
    mrb_define_class_method(mrb, rclass, "create_orthographic", ruby_cocos2dx_Camera_createOrthographic_static, ARGS_REQ(4));
    mrb_define_class_method(mrb, rclass, "get_default_camera", ruby_cocos2dx_Camera_getDefaultCamera_static, ARGS_NONE());
    mrb_define_class_method(mrb, rclass, "get_visiting_camera", ruby_cocos2dx_Camera_getVisitingCamera_static, ARGS_NONE());
    struct RClass* renum_Type = mrb_define_module_under(mrb, rclass, "Type");
    ruby_cocos2dx_Camera_Type_enum_init(mrb, renum_Type);
    mrb_define_class_method(mrb, renum_Type, "PERSPECTIVE", ruby_cocos2dx_constant_get, ARGS_NONE());
    mrb_define_class_method(mrb, renum_Type, "ORTHOGRAPHIC", ruby_cocos2dx_constant_get, ARGS_NONE());
}
void ruby_cocos2dx_global_LightType_enum_init(mrb_state* mrb)
{
    do {
        mrb_value ev = mrb_fixnum_value((mrb_int)LightType::DIRECTIONAL);
        mrb_gv_set(mrb, mrb_intern_cstr(mrb, "DIRECTIONAL"), ev);
    } while (0);

    do {
        mrb_value ev = mrb_fixnum_value((mrb_int)LightType::POINT);
        mrb_gv_set(mrb, mrb_intern_cstr(mrb, "POINT"), ev);
    } while (0);

    do {
        mrb_value ev = mrb_fixnum_value((mrb_int)LightType::SPOT);
        mrb_gv_set(mrb, mrb_intern_cstr(mrb, "SPOT"), ev);
    } while (0);

    do {
        mrb_value ev = mrb_fixnum_value((mrb_int)LightType::AMBIENT);
        mrb_gv_set(mrb, mrb_intern_cstr(mrb, "AMBIENT"), ev);
    } while (0);

}
void ruby_cocos2dx_global_LightFlag_enum_init(mrb_state* mrb)
{
    do {
        mrb_value ev = mrb_fixnum_value((mrb_int)LightFlag::LIGHT0);
        mrb_gv_set(mrb, mrb_intern_cstr(mrb, "LIGHT0"), ev);
    } while (0);

    do {
        mrb_value ev = mrb_fixnum_value((mrb_int)LightFlag::LIGHT1);
        mrb_gv_set(mrb, mrb_intern_cstr(mrb, "LIGHT1"), ev);
    } while (0);

    do {
        mrb_value ev = mrb_fixnum_value((mrb_int)LightFlag::LIGHT2);
        mrb_gv_set(mrb, mrb_intern_cstr(mrb, "LIGHT2"), ev);
    } while (0);

    do {
        mrb_value ev = mrb_fixnum_value((mrb_int)LightFlag::LIGHT3);
        mrb_gv_set(mrb, mrb_intern_cstr(mrb, "LIGHT3"), ev);
    } while (0);

    do {
        mrb_value ev = mrb_fixnum_value((mrb_int)LightFlag::LIGHT4);
        mrb_gv_set(mrb, mrb_intern_cstr(mrb, "LIGHT4"), ev);
    } while (0);

    do {
        mrb_value ev = mrb_fixnum_value((mrb_int)LightFlag::LIGHT5);
        mrb_gv_set(mrb, mrb_intern_cstr(mrb, "LIGHT5"), ev);
    } while (0);

    do {
        mrb_value ev = mrb_fixnum_value((mrb_int)LightFlag::LIGHT6);
        mrb_gv_set(mrb, mrb_intern_cstr(mrb, "LIGHT6"), ev);
    } while (0);

    do {
        mrb_value ev = mrb_fixnum_value((mrb_int)LightFlag::LIGHT7);
        mrb_gv_set(mrb, mrb_intern_cstr(mrb, "LIGHT7"), ev);
    } while (0);

    do {
        mrb_value ev = mrb_fixnum_value((mrb_int)LightFlag::LIGHT8);
        mrb_gv_set(mrb, mrb_intern_cstr(mrb, "LIGHT8"), ev);
    } while (0);

    do {
        mrb_value ev = mrb_fixnum_value((mrb_int)LightFlag::LIGHT9);
        mrb_gv_set(mrb, mrb_intern_cstr(mrb, "LIGHT9"), ev);
    } while (0);

    do {
        mrb_value ev = mrb_fixnum_value((mrb_int)LightFlag::LIGHT10);
        mrb_gv_set(mrb, mrb_intern_cstr(mrb, "LIGHT10"), ev);
    } while (0);

    do {
        mrb_value ev = mrb_fixnum_value((mrb_int)LightFlag::LIGHT11);
        mrb_gv_set(mrb, mrb_intern_cstr(mrb, "LIGHT11"), ev);
    } while (0);

    do {
        mrb_value ev = mrb_fixnum_value((mrb_int)LightFlag::LIGHT12);
        mrb_gv_set(mrb, mrb_intern_cstr(mrb, "LIGHT12"), ev);
    } while (0);

    do {
        mrb_value ev = mrb_fixnum_value((mrb_int)LightFlag::LIGHT13);
        mrb_gv_set(mrb, mrb_intern_cstr(mrb, "LIGHT13"), ev);
    } while (0);

    do {
        mrb_value ev = mrb_fixnum_value((mrb_int)LightFlag::LIGHT14);
        mrb_gv_set(mrb, mrb_intern_cstr(mrb, "LIGHT14"), ev);
    } while (0);

    do {
        mrb_value ev = mrb_fixnum_value((mrb_int)LightFlag::LIGHT15);
        mrb_gv_set(mrb, mrb_intern_cstr(mrb, "LIGHT15"), ev);
    } while (0);

}
mrb_value ruby_cocos2dx_BaseLight_setEnabled(mrb_state* mrb, mrb_value self)
{
    cocos2d::BaseLight* cobj = static_cast<cocos2d::BaseLight*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            bool arg0;
            ok = rubyval_to_boolean(mrb, argv[0], &arg0, "CC::BaseLight.setEnabled");
            if (!ok) { break; }
            cobj->setEnabled(arg0);
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::BaseLight#setEnabled");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_BaseLight_getIntensity(mrb_state* mrb, mrb_value self)
{
    cocos2d::BaseLight* cobj = static_cast<cocos2d::BaseLight*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            double retval = cobj->getIntensity();
            mrb_value ret;
            ret = mrb_float_value(mrb, (mrb_float)retval);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::BaseLight#getIntensity");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_BaseLight_isEnabled(mrb_state* mrb, mrb_value self)
{
    cocos2d::BaseLight* cobj = static_cast<cocos2d::BaseLight*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            bool retval = cobj->isEnabled();
            mrb_value ret;
            ret = mrb_bool_value((mrb_bool)retval);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::BaseLight#isEnabled");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_BaseLight_getLightType(mrb_state* mrb, mrb_value self)
{
    cocos2d::BaseLight* cobj = static_cast<cocos2d::BaseLight*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            int retval = (int)cobj->getLightType();
            mrb_value ret;
            ret = mrb_fixnum_value((mrb_int)retval);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::BaseLight#getLightType");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_BaseLight_setLightFlag(mrb_state* mrb, mrb_value self)
{
    cocos2d::BaseLight* cobj = static_cast<cocos2d::BaseLight*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            cocos2d::LightFlag arg0;
            ok = rubyval_to_int32(mrb, argv[0], (int*)&arg0, "CC::BaseLight.setLightFlag");
            if (!ok) { break; }
            cobj->setLightFlag(arg0);
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::BaseLight#setLightFlag");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_BaseLight_setIntensity(mrb_state* mrb, mrb_value self)
{
    cocos2d::BaseLight* cobj = static_cast<cocos2d::BaseLight*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            double arg0;
            ok = rubyval_to_number(mrb, argv[0], (double*)&arg0, "CC::BaseLight.setIntensity");
            if (!ok) { break; }
            cobj->setIntensity(arg0);
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::BaseLight#setIntensity");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_BaseLight_getLightFlag(mrb_state* mrb, mrb_value self)
{
    cocos2d::BaseLight* cobj = static_cast<cocos2d::BaseLight*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            int retval = (int)cobj->getLightFlag();
            mrb_value ret;
            ret = mrb_fixnum_value((mrb_int)retval);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::BaseLight#getLightFlag");

    return mrb_nil_value();
}

void ruby_register_cocos2dx_BaseLight(mrb_state* mrb, struct RClass* rmodule)
{
    std::string typeName = typeid(cocos2d::BaseLight).name();
    g_rubyType[typeName] = "CC::BaseLight";
    g_rubyDataType[typeName] = &ruby_cocos2dx_Ref_type;

    struct RClass* p_rmodule = mrb->object_class;
    p_rmodule = mrb_module_get_under(mrb, p_rmodule, "CC");
    struct RClass* p_rclass = mrb_class_get_under(mrb, p_rmodule, "Node");
    struct RClass *rclass = mrb_define_class_under(mrb, rmodule, "BaseLight", p_rclass);
    MRB_SET_INSTANCE_TT(rclass, MRB_TT_DATA);

    mrb_define_method(mrb, rclass, "set_enabled", ruby_cocos2dx_BaseLight_setEnabled, ARGS_REQ(1));
    mrb_define_method(mrb, rclass, "get_intensity", ruby_cocos2dx_BaseLight_getIntensity, ARGS_NONE());
    mrb_define_method(mrb, rclass, "enabled?", ruby_cocos2dx_BaseLight_isEnabled, ARGS_NONE());
    mrb_define_method(mrb, rclass, "get_light_type", ruby_cocos2dx_BaseLight_getLightType, ARGS_NONE());
    mrb_define_method(mrb, rclass, "set_light_flag", ruby_cocos2dx_BaseLight_setLightFlag, ARGS_REQ(1));
    mrb_define_method(mrb, rclass, "set_intensity", ruby_cocos2dx_BaseLight_setIntensity, ARGS_REQ(1));
    mrb_define_method(mrb, rclass, "get_light_flag", ruby_cocos2dx_BaseLight_getLightFlag, ARGS_NONE());
}
mrb_value ruby_cocos2dx_DirectionLight_getDirection(mrb_state* mrb, mrb_value self)
{
    cocos2d::DirectionLight* cobj = static_cast<cocos2d::DirectionLight*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            cocos2d::Vec3 retval = cobj->getDirection();
            cocos2d::Vec3* retval_ptr = new cocos2d::Vec3(retval);
            mrb_value ret;
            ret = object_to_rubyval<cocos2d::Vec3>(mrb, "CC::Vec3", (cocos2d::Vec3*)retval_ptr, nullptr);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::DirectionLight#getDirection");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_DirectionLight_getDirectionInWorld(mrb_state* mrb, mrb_value self)
{
    cocos2d::DirectionLight* cobj = static_cast<cocos2d::DirectionLight*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            cocos2d::Vec3 retval = cobj->getDirectionInWorld();
            cocos2d::Vec3* retval_ptr = new cocos2d::Vec3(retval);
            mrb_value ret;
            ret = object_to_rubyval<cocos2d::Vec3>(mrb, "CC::Vec3", (cocos2d::Vec3*)retval_ptr, nullptr);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::DirectionLight#getDirectionInWorld");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_DirectionLight_setDirection(mrb_state* mrb, mrb_value self)
{
    cocos2d::DirectionLight* cobj = static_cast<cocos2d::DirectionLight*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            cocos2d::Vec3* arg0;
            ok = rubyval_to_object<cocos2d::Vec3>(mrb, argv[0], "CC::Vec3", &arg0);
            if (!ok) { break; }
            cobj->setDirection(*arg0);
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::DirectionLight#setDirection");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_DirectionLight_create_static(mrb_state* mrb, mrb_value self)
{
    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 2) {
            std::map<std::string, mrb_value> callbacks;
            cocos2d::Vec3* arg0;
            ok = rubyval_to_object<cocos2d::Vec3>(mrb, argv[0], "CC::Vec3", &arg0);
            if (!ok) { break; }

            cocos2d::Color3B* arg1;
            ok = rubyval_to_object<cocos2d::Color3B>(mrb, argv[1], "CC::Color3B", &arg1);
            if (!ok) { break; }

            cocos2d::DirectionLight* retval = cocos2d::DirectionLight::create(*arg0, *arg1);
            mrb_value ret;
            RClass* rclass = mrb_class_ptr(self);
            ret = object_to_rubyval<cocos2d::DirectionLight>(mrb, "CC::DirectionLight", (cocos2d::DirectionLight*)retval, rclass);
            if (callbacks.size() > 0) {
                mrb_value hash = mrb_iv_get(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"));
                if (!mrb_hash_p(hash)) {
                    hash = mrb_hash_new(mrb);
                }
                for (auto elm : callbacks) {
                    mrb_hash_set(mrb, hash, mrb_str_new_cstr(mrb, elm.first.c_str()), elm.second);
                    mrb_iv_set(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"), hash);
                }
            }
            g_rubyValue.push_back(ret);
            mrb_funcall(mrb, ret, "initialize", 0);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined static method : cocos2d::DirectionLight#create");

    return mrb_nil_value();
}

void ruby_register_cocos2dx_DirectionLight(mrb_state* mrb, struct RClass* rmodule)
{
    std::string typeName = typeid(cocos2d::DirectionLight).name();
    g_rubyType[typeName] = "CC::DirectionLight";
    g_rubyDataType[typeName] = &ruby_cocos2dx_Ref_type;

    struct RClass* p_rmodule = mrb->object_class;
    p_rmodule = mrb_module_get_under(mrb, p_rmodule, "CC");
    struct RClass* p_rclass = mrb_class_get_under(mrb, p_rmodule, "BaseLight");
    struct RClass *rclass = mrb_define_class_under(mrb, rmodule, "DirectionLight", p_rclass);
    MRB_SET_INSTANCE_TT(rclass, MRB_TT_DATA);

    mrb_define_method(mrb, rclass, "get_direction", ruby_cocos2dx_DirectionLight_getDirection, ARGS_NONE());
    mrb_define_method(mrb, rclass, "get_direction_in_world", ruby_cocos2dx_DirectionLight_getDirectionInWorld, ARGS_NONE());
    mrb_define_method(mrb, rclass, "set_direction", ruby_cocos2dx_DirectionLight_setDirection, ARGS_REQ(1));
    mrb_define_class_method(mrb, rclass, "create", ruby_cocos2dx_DirectionLight_create_static, ARGS_REQ(2));
}
mrb_value ruby_cocos2dx_PointLight_getRange(mrb_state* mrb, mrb_value self)
{
    cocos2d::PointLight* cobj = static_cast<cocos2d::PointLight*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            double retval = cobj->getRange();
            mrb_value ret;
            ret = mrb_float_value(mrb, (mrb_float)retval);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::PointLight#getRange");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_PointLight_setRange(mrb_state* mrb, mrb_value self)
{
    cocos2d::PointLight* cobj = static_cast<cocos2d::PointLight*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            double arg0;
            ok = rubyval_to_number(mrb, argv[0], (double*)&arg0, "CC::PointLight.setRange");
            if (!ok) { break; }
            cobj->setRange(arg0);
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::PointLight#setRange");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_PointLight_create_static(mrb_state* mrb, mrb_value self)
{
    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 3) {
            std::map<std::string, mrb_value> callbacks;
            cocos2d::Vec3* arg0;
            ok = rubyval_to_object<cocos2d::Vec3>(mrb, argv[0], "CC::Vec3", &arg0);
            if (!ok) { break; }

            cocos2d::Color3B* arg1;
            ok = rubyval_to_object<cocos2d::Color3B>(mrb, argv[1], "CC::Color3B", &arg1);
            if (!ok) { break; }

            double arg2;
            ok = rubyval_to_number(mrb, argv[2], (double*)&arg2, "CC::PointLight.create");
            if (!ok) { break; }

            cocos2d::PointLight* retval = cocos2d::PointLight::create(*arg0, *arg1, arg2);
            mrb_value ret;
            RClass* rclass = mrb_class_ptr(self);
            ret = object_to_rubyval<cocos2d::PointLight>(mrb, "CC::PointLight", (cocos2d::PointLight*)retval, rclass);
            if (callbacks.size() > 0) {
                mrb_value hash = mrb_iv_get(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"));
                if (!mrb_hash_p(hash)) {
                    hash = mrb_hash_new(mrb);
                }
                for (auto elm : callbacks) {
                    mrb_hash_set(mrb, hash, mrb_str_new_cstr(mrb, elm.first.c_str()), elm.second);
                    mrb_iv_set(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"), hash);
                }
            }
            g_rubyValue.push_back(ret);
            mrb_funcall(mrb, ret, "initialize", 0);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined static method : cocos2d::PointLight#create");

    return mrb_nil_value();
}

void ruby_register_cocos2dx_PointLight(mrb_state* mrb, struct RClass* rmodule)
{
    std::string typeName = typeid(cocos2d::PointLight).name();
    g_rubyType[typeName] = "CC::PointLight";
    g_rubyDataType[typeName] = &ruby_cocos2dx_Ref_type;

    struct RClass* p_rmodule = mrb->object_class;
    p_rmodule = mrb_module_get_under(mrb, p_rmodule, "CC");
    struct RClass* p_rclass = mrb_class_get_under(mrb, p_rmodule, "BaseLight");
    struct RClass *rclass = mrb_define_class_under(mrb, rmodule, "PointLight", p_rclass);
    MRB_SET_INSTANCE_TT(rclass, MRB_TT_DATA);

    mrb_define_method(mrb, rclass, "get_range", ruby_cocos2dx_PointLight_getRange, ARGS_NONE());
    mrb_define_method(mrb, rclass, "set_range", ruby_cocos2dx_PointLight_setRange, ARGS_REQ(1));
    mrb_define_class_method(mrb, rclass, "create", ruby_cocos2dx_PointLight_create_static, ARGS_REQ(3));
}
mrb_value ruby_cocos2dx_SpotLight_getRange(mrb_state* mrb, mrb_value self)
{
    cocos2d::SpotLight* cobj = static_cast<cocos2d::SpotLight*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            double retval = cobj->getRange();
            mrb_value ret;
            ret = mrb_float_value(mrb, (mrb_float)retval);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::SpotLight#getRange");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_SpotLight_setDirection(mrb_state* mrb, mrb_value self)
{
    cocos2d::SpotLight* cobj = static_cast<cocos2d::SpotLight*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            cocos2d::Vec3* arg0;
            ok = rubyval_to_object<cocos2d::Vec3>(mrb, argv[0], "CC::Vec3", &arg0);
            if (!ok) { break; }
            cobj->setDirection(*arg0);
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::SpotLight#setDirection");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_SpotLight_getCosInnerAngle(mrb_state* mrb, mrb_value self)
{
    cocos2d::SpotLight* cobj = static_cast<cocos2d::SpotLight*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            double retval = cobj->getCosInnerAngle();
            mrb_value ret;
            ret = mrb_float_value(mrb, (mrb_float)retval);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::SpotLight#getCosInnerAngle");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_SpotLight_getOuterAngle(mrb_state* mrb, mrb_value self)
{
    cocos2d::SpotLight* cobj = static_cast<cocos2d::SpotLight*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            double retval = cobj->getOuterAngle();
            mrb_value ret;
            ret = mrb_float_value(mrb, (mrb_float)retval);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::SpotLight#getOuterAngle");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_SpotLight_getInnerAngle(mrb_state* mrb, mrb_value self)
{
    cocos2d::SpotLight* cobj = static_cast<cocos2d::SpotLight*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            double retval = cobj->getInnerAngle();
            mrb_value ret;
            ret = mrb_float_value(mrb, (mrb_float)retval);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::SpotLight#getInnerAngle");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_SpotLight_getDirection(mrb_state* mrb, mrb_value self)
{
    cocos2d::SpotLight* cobj = static_cast<cocos2d::SpotLight*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            cocos2d::Vec3 retval = cobj->getDirection();
            cocos2d::Vec3* retval_ptr = new cocos2d::Vec3(retval);
            mrb_value ret;
            ret = object_to_rubyval<cocos2d::Vec3>(mrb, "CC::Vec3", (cocos2d::Vec3*)retval_ptr, nullptr);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::SpotLight#getDirection");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_SpotLight_getCosOuterAngle(mrb_state* mrb, mrb_value self)
{
    cocos2d::SpotLight* cobj = static_cast<cocos2d::SpotLight*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            double retval = cobj->getCosOuterAngle();
            mrb_value ret;
            ret = mrb_float_value(mrb, (mrb_float)retval);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::SpotLight#getCosOuterAngle");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_SpotLight_setOuterAngle(mrb_state* mrb, mrb_value self)
{
    cocos2d::SpotLight* cobj = static_cast<cocos2d::SpotLight*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            double arg0;
            ok = rubyval_to_number(mrb, argv[0], (double*)&arg0, "CC::SpotLight.setOuterAngle");
            if (!ok) { break; }
            cobj->setOuterAngle(arg0);
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::SpotLight#setOuterAngle");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_SpotLight_setInnerAngle(mrb_state* mrb, mrb_value self)
{
    cocos2d::SpotLight* cobj = static_cast<cocos2d::SpotLight*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            double arg0;
            ok = rubyval_to_number(mrb, argv[0], (double*)&arg0, "CC::SpotLight.setInnerAngle");
            if (!ok) { break; }
            cobj->setInnerAngle(arg0);
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::SpotLight#setInnerAngle");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_SpotLight_getDirectionInWorld(mrb_state* mrb, mrb_value self)
{
    cocos2d::SpotLight* cobj = static_cast<cocos2d::SpotLight*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            cocos2d::Vec3 retval = cobj->getDirectionInWorld();
            cocos2d::Vec3* retval_ptr = new cocos2d::Vec3(retval);
            mrb_value ret;
            ret = object_to_rubyval<cocos2d::Vec3>(mrb, "CC::Vec3", (cocos2d::Vec3*)retval_ptr, nullptr);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::SpotLight#getDirectionInWorld");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_SpotLight_setRange(mrb_state* mrb, mrb_value self)
{
    cocos2d::SpotLight* cobj = static_cast<cocos2d::SpotLight*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            double arg0;
            ok = rubyval_to_number(mrb, argv[0], (double*)&arg0, "CC::SpotLight.setRange");
            if (!ok) { break; }
            cobj->setRange(arg0);
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::SpotLight#setRange");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_SpotLight_create_static(mrb_state* mrb, mrb_value self)
{
    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 6) {
            std::map<std::string, mrb_value> callbacks;
            cocos2d::Vec3* arg0;
            ok = rubyval_to_object<cocos2d::Vec3>(mrb, argv[0], "CC::Vec3", &arg0);
            if (!ok) { break; }

            cocos2d::Vec3* arg1;
            ok = rubyval_to_object<cocos2d::Vec3>(mrb, argv[1], "CC::Vec3", &arg1);
            if (!ok) { break; }

            cocos2d::Color3B* arg2;
            ok = rubyval_to_object<cocos2d::Color3B>(mrb, argv[2], "CC::Color3B", &arg2);
            if (!ok) { break; }

            double arg3;
            ok = rubyval_to_number(mrb, argv[3], (double*)&arg3, "CC::SpotLight.create");
            if (!ok) { break; }

            double arg4;
            ok = rubyval_to_number(mrb, argv[4], (double*)&arg4, "CC::SpotLight.create");
            if (!ok) { break; }

            double arg5;
            ok = rubyval_to_number(mrb, argv[5], (double*)&arg5, "CC::SpotLight.create");
            if (!ok) { break; }

            cocos2d::SpotLight* retval = cocos2d::SpotLight::create(*arg0, *arg1, *arg2, arg3, arg4, arg5);
            mrb_value ret;
            RClass* rclass = mrb_class_ptr(self);
            ret = object_to_rubyval<cocos2d::SpotLight>(mrb, "CC::SpotLight", (cocos2d::SpotLight*)retval, rclass);
            if (callbacks.size() > 0) {
                mrb_value hash = mrb_iv_get(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"));
                if (!mrb_hash_p(hash)) {
                    hash = mrb_hash_new(mrb);
                }
                for (auto elm : callbacks) {
                    mrb_hash_set(mrb, hash, mrb_str_new_cstr(mrb, elm.first.c_str()), elm.second);
                    mrb_iv_set(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"), hash);
                }
            }
            g_rubyValue.push_back(ret);
            mrb_funcall(mrb, ret, "initialize", 0);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined static method : cocos2d::SpotLight#create");

    return mrb_nil_value();
}

void ruby_register_cocos2dx_SpotLight(mrb_state* mrb, struct RClass* rmodule)
{
    std::string typeName = typeid(cocos2d::SpotLight).name();
    g_rubyType[typeName] = "CC::SpotLight";
    g_rubyDataType[typeName] = &ruby_cocos2dx_Ref_type;

    struct RClass* p_rmodule = mrb->object_class;
    p_rmodule = mrb_module_get_under(mrb, p_rmodule, "CC");
    struct RClass* p_rclass = mrb_class_get_under(mrb, p_rmodule, "BaseLight");
    struct RClass *rclass = mrb_define_class_under(mrb, rmodule, "SpotLight", p_rclass);
    MRB_SET_INSTANCE_TT(rclass, MRB_TT_DATA);

    mrb_define_method(mrb, rclass, "get_range", ruby_cocos2dx_SpotLight_getRange, ARGS_NONE());
    mrb_define_method(mrb, rclass, "set_direction", ruby_cocos2dx_SpotLight_setDirection, ARGS_REQ(1));
    mrb_define_method(mrb, rclass, "get_cos_inner_angle", ruby_cocos2dx_SpotLight_getCosInnerAngle, ARGS_NONE());
    mrb_define_method(mrb, rclass, "get_outer_angle", ruby_cocos2dx_SpotLight_getOuterAngle, ARGS_NONE());
    mrb_define_method(mrb, rclass, "get_inner_angle", ruby_cocos2dx_SpotLight_getInnerAngle, ARGS_NONE());
    mrb_define_method(mrb, rclass, "get_direction", ruby_cocos2dx_SpotLight_getDirection, ARGS_NONE());
    mrb_define_method(mrb, rclass, "get_cos_outer_angle", ruby_cocos2dx_SpotLight_getCosOuterAngle, ARGS_NONE());
    mrb_define_method(mrb, rclass, "set_outer_angle", ruby_cocos2dx_SpotLight_setOuterAngle, ARGS_REQ(1));
    mrb_define_method(mrb, rclass, "set_inner_angle", ruby_cocos2dx_SpotLight_setInnerAngle, ARGS_REQ(1));
    mrb_define_method(mrb, rclass, "get_direction_in_world", ruby_cocos2dx_SpotLight_getDirectionInWorld, ARGS_NONE());
    mrb_define_method(mrb, rclass, "set_range", ruby_cocos2dx_SpotLight_setRange, ARGS_REQ(1));
    mrb_define_class_method(mrb, rclass, "create", ruby_cocos2dx_SpotLight_create_static, ARGS_REQ(6));
}
mrb_value ruby_cocos2dx_AmbientLight_create_static(mrb_state* mrb, mrb_value self)
{
    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            std::map<std::string, mrb_value> callbacks;
            cocos2d::Color3B* arg0;
            ok = rubyval_to_object<cocos2d::Color3B>(mrb, argv[0], "CC::Color3B", &arg0);
            if (!ok) { break; }

            cocos2d::AmbientLight* retval = cocos2d::AmbientLight::create(*arg0);
            mrb_value ret;
            RClass* rclass = mrb_class_ptr(self);
            ret = object_to_rubyval<cocos2d::AmbientLight>(mrb, "CC::AmbientLight", (cocos2d::AmbientLight*)retval, rclass);
            if (callbacks.size() > 0) {
                mrb_value hash = mrb_iv_get(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"));
                if (!mrb_hash_p(hash)) {
                    hash = mrb_hash_new(mrb);
                }
                for (auto elm : callbacks) {
                    mrb_hash_set(mrb, hash, mrb_str_new_cstr(mrb, elm.first.c_str()), elm.second);
                    mrb_iv_set(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"), hash);
                }
            }
            g_rubyValue.push_back(ret);
            mrb_funcall(mrb, ret, "initialize", 0);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined static method : cocos2d::AmbientLight#create");

    return mrb_nil_value();
}

void ruby_register_cocos2dx_AmbientLight(mrb_state* mrb, struct RClass* rmodule)
{
    std::string typeName = typeid(cocos2d::AmbientLight).name();
    g_rubyType[typeName] = "CC::AmbientLight";
    g_rubyDataType[typeName] = &ruby_cocos2dx_Ref_type;

    struct RClass* p_rmodule = mrb->object_class;
    p_rmodule = mrb_module_get_under(mrb, p_rmodule, "CC");
    struct RClass* p_rclass = mrb_class_get_under(mrb, p_rmodule, "BaseLight");
    struct RClass *rclass = mrb_define_class_under(mrb, rmodule, "AmbientLight", p_rclass);
    MRB_SET_INSTANCE_TT(rclass, MRB_TT_DATA);

    mrb_define_class_method(mrb, rclass, "create", ruby_cocos2dx_AmbientLight_create_static, ARGS_REQ(1));
}
mrb_value ruby_cocos2dx_GLProgram_getFragmentShaderLog(mrb_state* mrb, mrb_value self)
{
    cocos2d::GLProgram* cobj = static_cast<cocos2d::GLProgram*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            std::string retval = cobj->getFragmentShaderLog();
            mrb_value ret;
            ret = mrb_str_new_cstr(mrb, retval.c_str());
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::GLProgram#getFragmentShaderLog");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_GLProgram_initWithByteArrays(mrb_state* mrb, mrb_value self)
{
    cocos2d::GLProgram* cobj = static_cast<cocos2d::GLProgram*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 2) {
            const char* arg0;
            std::string arg0_tmp; ok = rubyval_to_std_string(mrb, argv[0], &arg0_tmp, "CC::GLProgram:initWithByteArrays"); arg0 = arg0_tmp.c_str();
            if (!ok) { break; }
            const char* arg1;
            std::string arg1_tmp; ok = rubyval_to_std_string(mrb, argv[1], &arg1_tmp, "CC::GLProgram:initWithByteArrays"); arg1 = arg1_tmp.c_str();
            if (!ok) { break; }
            bool retval = cobj->initWithByteArrays(arg0, arg1);
            mrb_value ret;
            ret = mrb_bool_value((mrb_bool)retval);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::GLProgram#initWithByteArrays");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_GLProgram_initWithFilenames(mrb_state* mrb, mrb_value self)
{
    cocos2d::GLProgram* cobj = static_cast<cocos2d::GLProgram*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 2) {
            std::string arg0;
            ok = rubyval_to_std_string(mrb, argv[0], &arg0, "CC::GLProgram.initWithFilenames");
            if (!ok) { break; }
            std::string arg1;
            ok = rubyval_to_std_string(mrb, argv[1], &arg1, "CC::GLProgram.initWithFilenames");
            if (!ok) { break; }
            bool retval = cobj->initWithFilenames(arg0, arg1);
            mrb_value ret;
            ret = mrb_bool_value((mrb_bool)retval);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::GLProgram#initWithFilenames");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_GLProgram_use(mrb_state* mrb, mrb_value self)
{
    cocos2d::GLProgram* cobj = static_cast<cocos2d::GLProgram*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            cobj->use();
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::GLProgram#use");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_GLProgram_getVertexShaderLog(mrb_state* mrb, mrb_value self)
{
    cocos2d::GLProgram* cobj = static_cast<cocos2d::GLProgram*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            std::string retval = cobj->getVertexShaderLog();
            mrb_value ret;
            ret = mrb_str_new_cstr(mrb, retval.c_str());
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::GLProgram#getVertexShaderLog");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_GLProgram_setUniformsForBuiltins(mrb_state* mrb, mrb_value self)
{
    cocos2d::GLProgram* cobj = static_cast<cocos2d::GLProgram*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            cocos2d::Mat4* arg0;
            ok = rubyval_to_object<cocos2d::Mat4>(mrb, argv[0], "CC::Mat4", &arg0);
            if (!ok) { break; }
            cobj->setUniformsForBuiltins(*arg0);
            return self;
        }
    } while (0);
    do {
        if (argc == 0) {
            cobj->setUniformsForBuiltins();
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::GLProgram#setUniformsForBuiltins");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_GLProgram_updateUniforms(mrb_state* mrb, mrb_value self)
{
    cocos2d::GLProgram* cobj = static_cast<cocos2d::GLProgram*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            cobj->updateUniforms();
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::GLProgram#updateUniforms");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_GLProgram_setUniformLocationWith1i(mrb_state* mrb, mrb_value self)
{
    cocos2d::GLProgram* cobj = static_cast<cocos2d::GLProgram*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 2) {
            int arg0;
            ok = rubyval_to_int32(mrb, argv[0], (int*)&arg0, "CC::GLProgram.setUniformLocationWith1i");
            if (!ok) { break; }
            int arg1;
            ok = rubyval_to_int32(mrb, argv[1], (int*)&arg1, "CC::GLProgram.setUniformLocationWith1i");
            if (!ok) { break; }
            cobj->setUniformLocationWith1i(arg0, arg1);
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::GLProgram#setUniformLocationWith1i");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_GLProgram_reset(mrb_state* mrb, mrb_value self)
{
    cocos2d::GLProgram* cobj = static_cast<cocos2d::GLProgram*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            cobj->reset();
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::GLProgram#reset");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_GLProgram_bindAttribLocation(mrb_state* mrb, mrb_value self)
{
    cocos2d::GLProgram* cobj = static_cast<cocos2d::GLProgram*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 2) {
            std::string arg0;
            ok = rubyval_to_std_string(mrb, argv[0], &arg0, "CC::GLProgram.bindAttribLocation");
            if (!ok) { break; }
            unsigned int arg1;
            ok = rubyval_to_uint32(mrb, argv[1], &arg1, "CC::GLProgram.bindAttribLocation");
            if (!ok) { break; }
            cobj->bindAttribLocation(arg0, arg1);
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::GLProgram#bindAttribLocation");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_GLProgram_getAttribLocation(mrb_state* mrb, mrb_value self)
{
    cocos2d::GLProgram* cobj = static_cast<cocos2d::GLProgram*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            std::string arg0;
            ok = rubyval_to_std_string(mrb, argv[0], &arg0, "CC::GLProgram.getAttribLocation");
            if (!ok) { break; }
            int retval = cobj->getAttribLocation(arg0);
            mrb_value ret;
            ret = mrb_fixnum_value((mrb_int)retval);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::GLProgram#getAttribLocation");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_GLProgram_link(mrb_state* mrb, mrb_value self)
{
    cocos2d::GLProgram* cobj = static_cast<cocos2d::GLProgram*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            bool retval = cobj->link();
            mrb_value ret;
            ret = mrb_bool_value((mrb_bool)retval);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::GLProgram#link");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_GLProgram_createWithByteArrays_static(mrb_state* mrb, mrb_value self)
{
    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 2) {
            std::map<std::string, mrb_value> callbacks;
            const char* arg0;
            std::string arg0_tmp; ok = rubyval_to_std_string(mrb, argv[0], &arg0_tmp, "CC::GLProgram:createWithByteArrays"); arg0 = arg0_tmp.c_str();
            if (!ok) { break; }

            const char* arg1;
            std::string arg1_tmp; ok = rubyval_to_std_string(mrb, argv[1], &arg1_tmp, "CC::GLProgram:createWithByteArrays"); arg1 = arg1_tmp.c_str();
            if (!ok) { break; }

            cocos2d::GLProgram* retval = cocos2d::GLProgram::createWithByteArrays(arg0, arg1);
            mrb_value ret;
            RClass* rclass = mrb_class_ptr(self);
            ret = object_to_rubyval<cocos2d::GLProgram>(mrb, "CC::GLProgram", (cocos2d::GLProgram*)retval, rclass);
            if (callbacks.size() > 0) {
                mrb_value hash = mrb_iv_get(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"));
                if (!mrb_hash_p(hash)) {
                    hash = mrb_hash_new(mrb);
                }
                for (auto elm : callbacks) {
                    mrb_hash_set(mrb, hash, mrb_str_new_cstr(mrb, elm.first.c_str()), elm.second);
                    mrb_iv_set(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"), hash);
                }
            }
            g_rubyValue.push_back(ret);
            mrb_funcall(mrb, ret, "initialize", 0);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined static method : cocos2d::GLProgram#createWithByteArrays");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_GLProgram_createWithFilenames_static(mrb_state* mrb, mrb_value self)
{
    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 2) {
            std::map<std::string, mrb_value> callbacks;
            std::string arg0;
            ok = rubyval_to_std_string(mrb, argv[0], &arg0, "CC::GLProgram.createWithFilenames");
            if (!ok) { break; }

            std::string arg1;
            ok = rubyval_to_std_string(mrb, argv[1], &arg1, "CC::GLProgram.createWithFilenames");
            if (!ok) { break; }

            cocos2d::GLProgram* retval = cocos2d::GLProgram::createWithFilenames(arg0, arg1);
            mrb_value ret;
            RClass* rclass = mrb_class_ptr(self);
            ret = object_to_rubyval<cocos2d::GLProgram>(mrb, "CC::GLProgram", (cocos2d::GLProgram*)retval, rclass);
            if (callbacks.size() > 0) {
                mrb_value hash = mrb_iv_get(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"));
                if (!mrb_hash_p(hash)) {
                    hash = mrb_hash_new(mrb);
                }
                for (auto elm : callbacks) {
                    mrb_hash_set(mrb, hash, mrb_str_new_cstr(mrb, elm.first.c_str()), elm.second);
                    mrb_iv_set(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"), hash);
                }
            }
            g_rubyValue.push_back(ret);
            mrb_funcall(mrb, ret, "initialize", 0);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined static method : cocos2d::GLProgram#createWithFilenames");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_GLProgram_constructor(mrb_state* mrb, mrb_value self)
{

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            cocos2d::GLProgram* cobj = new cocos2d::GLProgram();
            DATA_TYPE(self) = &ruby_cocos2dx_Ref_type;
            DATA_PTR(self) = cobj;
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::GLProgram#GLProgram");

    return mrb_nil_value();
}


void ruby_cocos2dx_GLProgram_constants_init(mrb_state* mrb, struct RClass* rclass)
{
    do {
        mrb_value ret;
        ret = mrb_str_new_cstr(mrb, (const char*)cocos2d::GLProgram::SHADER_NAME_POSITION_TEXTURE_COLOR);
        mrb_mod_cv_set(mrb, rclass, mrb_intern_cstr(mrb, "SHADER_NAME_POSITION_TEXTURE_COLOR"), ret);
    } while (0);

    do {
        mrb_value ret;
        ret = mrb_str_new_cstr(mrb, (const char*)cocos2d::GLProgram::SHADER_NAME_POSITION_TEXTURE_COLOR_NO_MVP);
        mrb_mod_cv_set(mrb, rclass, mrb_intern_cstr(mrb, "SHADER_NAME_POSITION_TEXTURE_COLOR_NO_MVP"), ret);
    } while (0);

    do {
        mrb_value ret;
        ret = mrb_str_new_cstr(mrb, (const char*)cocos2d::GLProgram::SHADER_NAME_POSITION_TEXTURE_ALPHA_TEST);
        mrb_mod_cv_set(mrb, rclass, mrb_intern_cstr(mrb, "SHADER_NAME_POSITION_TEXTURE_ALPHA_TEST"), ret);
    } while (0);

    do {
        mrb_value ret;
        ret = mrb_str_new_cstr(mrb, (const char*)cocos2d::GLProgram::SHADER_NAME_POSITION_TEXTURE_ALPHA_TEST_NO_MV);
        mrb_mod_cv_set(mrb, rclass, mrb_intern_cstr(mrb, "SHADER_NAME_POSITION_TEXTURE_ALPHA_TEST_NO_MV"), ret);
    } while (0);

    do {
        mrb_value ret;
        ret = mrb_str_new_cstr(mrb, (const char*)cocos2d::GLProgram::SHADER_NAME_POSITION_COLOR);
        mrb_mod_cv_set(mrb, rclass, mrb_intern_cstr(mrb, "SHADER_NAME_POSITION_COLOR"), ret);
    } while (0);

    do {
        mrb_value ret;
        ret = mrb_str_new_cstr(mrb, (const char*)cocos2d::GLProgram::SHADER_NAME_POSITION_COLOR_TEXASPOINTSIZE);
        mrb_mod_cv_set(mrb, rclass, mrb_intern_cstr(mrb, "SHADER_NAME_POSITION_COLOR_TEXASPOINTSIZE"), ret);
    } while (0);

    do {
        mrb_value ret;
        ret = mrb_str_new_cstr(mrb, (const char*)cocos2d::GLProgram::SHADER_NAME_POSITION_COLOR_NO_MVP);
        mrb_mod_cv_set(mrb, rclass, mrb_intern_cstr(mrb, "SHADER_NAME_POSITION_COLOR_NO_MVP"), ret);
    } while (0);

    do {
        mrb_value ret;
        ret = mrb_str_new_cstr(mrb, (const char*)cocos2d::GLProgram::SHADER_NAME_POSITION_TEXTURE);
        mrb_mod_cv_set(mrb, rclass, mrb_intern_cstr(mrb, "SHADER_NAME_POSITION_TEXTURE"), ret);
    } while (0);

    do {
        mrb_value ret;
        ret = mrb_str_new_cstr(mrb, (const char*)cocos2d::GLProgram::SHADER_NAME_POSITION_TEXTURE_U_COLOR);
        mrb_mod_cv_set(mrb, rclass, mrb_intern_cstr(mrb, "SHADER_NAME_POSITION_TEXTURE_U_COLOR"), ret);
    } while (0);

    do {
        mrb_value ret;
        ret = mrb_str_new_cstr(mrb, (const char*)cocos2d::GLProgram::SHADER_NAME_POSITION_TEXTURE_A8_COLOR);
        mrb_mod_cv_set(mrb, rclass, mrb_intern_cstr(mrb, "SHADER_NAME_POSITION_TEXTURE_A8_COLOR"), ret);
    } while (0);

    do {
        mrb_value ret;
        ret = mrb_str_new_cstr(mrb, (const char*)cocos2d::GLProgram::SHADER_NAME_POSITION_U_COLOR);
        mrb_mod_cv_set(mrb, rclass, mrb_intern_cstr(mrb, "SHADER_NAME_POSITION_U_COLOR"), ret);
    } while (0);

    do {
        mrb_value ret;
        ret = mrb_str_new_cstr(mrb, (const char*)cocos2d::GLProgram::SHADER_NAME_POSITION_LENGTH_TEXTURE_COLOR);
        mrb_mod_cv_set(mrb, rclass, mrb_intern_cstr(mrb, "SHADER_NAME_POSITION_LENGTH_TEXTURE_COLOR"), ret);
    } while (0);

    do {
        mrb_value ret;
        ret = mrb_str_new_cstr(mrb, (const char*)cocos2d::GLProgram::SHADER_NAME_LABEL_NORMAL);
        mrb_mod_cv_set(mrb, rclass, mrb_intern_cstr(mrb, "SHADER_NAME_LABEL_NORMAL"), ret);
    } while (0);

    do {
        mrb_value ret;
        ret = mrb_str_new_cstr(mrb, (const char*)cocos2d::GLProgram::SHADER_NAME_LABEL_OUTLINE);
        mrb_mod_cv_set(mrb, rclass, mrb_intern_cstr(mrb, "SHADER_NAME_LABEL_OUTLINE"), ret);
    } while (0);

    do {
        mrb_value ret;
        ret = mrb_str_new_cstr(mrb, (const char*)cocos2d::GLProgram::SHADER_NAME_LABEL_DISTANCEFIELD_NORMAL);
        mrb_mod_cv_set(mrb, rclass, mrb_intern_cstr(mrb, "SHADER_NAME_LABEL_DISTANCEFIELD_NORMAL"), ret);
    } while (0);

    do {
        mrb_value ret;
        ret = mrb_str_new_cstr(mrb, (const char*)cocos2d::GLProgram::SHADER_NAME_LABEL_DISTANCEFIELD_GLOW);
        mrb_mod_cv_set(mrb, rclass, mrb_intern_cstr(mrb, "SHADER_NAME_LABEL_DISTANCEFIELD_GLOW"), ret);
    } while (0);

    do {
        mrb_value ret;
        ret = mrb_str_new_cstr(mrb, (const char*)cocos2d::GLProgram::SHADER_3D_POSITION);
        mrb_mod_cv_set(mrb, rclass, mrb_intern_cstr(mrb, "SHADER_3D_POSITION"), ret);
    } while (0);

    do {
        mrb_value ret;
        ret = mrb_str_new_cstr(mrb, (const char*)cocos2d::GLProgram::SHADER_3D_POSITION_TEXTURE);
        mrb_mod_cv_set(mrb, rclass, mrb_intern_cstr(mrb, "SHADER_3D_POSITION_TEXTURE"), ret);
    } while (0);

    do {
        mrb_value ret;
        ret = mrb_str_new_cstr(mrb, (const char*)cocos2d::GLProgram::SHADER_3D_SKINPOSITION_TEXTURE);
        mrb_mod_cv_set(mrb, rclass, mrb_intern_cstr(mrb, "SHADER_3D_SKINPOSITION_TEXTURE"), ret);
    } while (0);

    do {
        mrb_value ret;
        ret = mrb_str_new_cstr(mrb, (const char*)cocos2d::GLProgram::SHADER_3D_POSITION_NORMAL);
        mrb_mod_cv_set(mrb, rclass, mrb_intern_cstr(mrb, "SHADER_3D_POSITION_NORMAL"), ret);
    } while (0);

    do {
        mrb_value ret;
        ret = mrb_str_new_cstr(mrb, (const char*)cocos2d::GLProgram::SHADER_3D_POSITION_NORMAL_TEXTURE);
        mrb_mod_cv_set(mrb, rclass, mrb_intern_cstr(mrb, "SHADER_3D_POSITION_NORMAL_TEXTURE"), ret);
    } while (0);

    do {
        mrb_value ret;
        ret = mrb_str_new_cstr(mrb, (const char*)cocos2d::GLProgram::SHADER_3D_SKINPOSITION_NORMAL_TEXTURE);
        mrb_mod_cv_set(mrb, rclass, mrb_intern_cstr(mrb, "SHADER_3D_SKINPOSITION_NORMAL_TEXTURE"), ret);
    } while (0);

    do {
        mrb_value ret;
        ret = mrb_str_new_cstr(mrb, (const char*)cocos2d::GLProgram::UNIFORM_NAME_AMBIENT_COLOR);
        mrb_mod_cv_set(mrb, rclass, mrb_intern_cstr(mrb, "UNIFORM_NAME_AMBIENT_COLOR"), ret);
    } while (0);

    do {
        mrb_value ret;
        ret = mrb_str_new_cstr(mrb, (const char*)cocos2d::GLProgram::UNIFORM_NAME_P_MATRIX);
        mrb_mod_cv_set(mrb, rclass, mrb_intern_cstr(mrb, "UNIFORM_NAME_P_MATRIX"), ret);
    } while (0);

    do {
        mrb_value ret;
        ret = mrb_str_new_cstr(mrb, (const char*)cocos2d::GLProgram::UNIFORM_NAME_MV_MATRIX);
        mrb_mod_cv_set(mrb, rclass, mrb_intern_cstr(mrb, "UNIFORM_NAME_MV_MATRIX"), ret);
    } while (0);

    do {
        mrb_value ret;
        ret = mrb_str_new_cstr(mrb, (const char*)cocos2d::GLProgram::UNIFORM_NAME_MVP_MATRIX);
        mrb_mod_cv_set(mrb, rclass, mrb_intern_cstr(mrb, "UNIFORM_NAME_MVP_MATRIX"), ret);
    } while (0);

    do {
        mrb_value ret;
        ret = mrb_str_new_cstr(mrb, (const char*)cocos2d::GLProgram::UNIFORM_NAME_NORMAL_MATRIX);
        mrb_mod_cv_set(mrb, rclass, mrb_intern_cstr(mrb, "UNIFORM_NAME_NORMAL_MATRIX"), ret);
    } while (0);

    do {
        mrb_value ret;
        ret = mrb_str_new_cstr(mrb, (const char*)cocos2d::GLProgram::UNIFORM_NAME_TIME);
        mrb_mod_cv_set(mrb, rclass, mrb_intern_cstr(mrb, "UNIFORM_NAME_TIME"), ret);
    } while (0);

    do {
        mrb_value ret;
        ret = mrb_str_new_cstr(mrb, (const char*)cocos2d::GLProgram::UNIFORM_NAME_SIN_TIME);
        mrb_mod_cv_set(mrb, rclass, mrb_intern_cstr(mrb, "UNIFORM_NAME_SIN_TIME"), ret);
    } while (0);

    do {
        mrb_value ret;
        ret = mrb_str_new_cstr(mrb, (const char*)cocos2d::GLProgram::UNIFORM_NAME_COS_TIME);
        mrb_mod_cv_set(mrb, rclass, mrb_intern_cstr(mrb, "UNIFORM_NAME_COS_TIME"), ret);
    } while (0);

    do {
        mrb_value ret;
        ret = mrb_str_new_cstr(mrb, (const char*)cocos2d::GLProgram::UNIFORM_NAME_RANDOM01);
        mrb_mod_cv_set(mrb, rclass, mrb_intern_cstr(mrb, "UNIFORM_NAME_RANDOM01"), ret);
    } while (0);

    do {
        mrb_value ret;
        ret = mrb_str_new_cstr(mrb, (const char*)cocos2d::GLProgram::UNIFORM_NAME_SAMPLER0);
        mrb_mod_cv_set(mrb, rclass, mrb_intern_cstr(mrb, "UNIFORM_NAME_SAMPLER0"), ret);
    } while (0);

    do {
        mrb_value ret;
        ret = mrb_str_new_cstr(mrb, (const char*)cocos2d::GLProgram::UNIFORM_NAME_SAMPLER1);
        mrb_mod_cv_set(mrb, rclass, mrb_intern_cstr(mrb, "UNIFORM_NAME_SAMPLER1"), ret);
    } while (0);

    do {
        mrb_value ret;
        ret = mrb_str_new_cstr(mrb, (const char*)cocos2d::GLProgram::UNIFORM_NAME_SAMPLER2);
        mrb_mod_cv_set(mrb, rclass, mrb_intern_cstr(mrb, "UNIFORM_NAME_SAMPLER2"), ret);
    } while (0);

    do {
        mrb_value ret;
        ret = mrb_str_new_cstr(mrb, (const char*)cocos2d::GLProgram::UNIFORM_NAME_SAMPLER3);
        mrb_mod_cv_set(mrb, rclass, mrb_intern_cstr(mrb, "UNIFORM_NAME_SAMPLER3"), ret);
    } while (0);

    do {
        mrb_value ret;
        ret = mrb_str_new_cstr(mrb, (const char*)cocos2d::GLProgram::UNIFORM_NAME_ALPHA_TEST_VALUE);
        mrb_mod_cv_set(mrb, rclass, mrb_intern_cstr(mrb, "UNIFORM_NAME_ALPHA_TEST_VALUE"), ret);
    } while (0);

    do {
        mrb_value ret;
        ret = mrb_str_new_cstr(mrb, (const char*)cocos2d::GLProgram::ATTRIBUTE_NAME_COLOR);
        mrb_mod_cv_set(mrb, rclass, mrb_intern_cstr(mrb, "ATTRIBUTE_NAME_COLOR"), ret);
    } while (0);

    do {
        mrb_value ret;
        ret = mrb_str_new_cstr(mrb, (const char*)cocos2d::GLProgram::ATTRIBUTE_NAME_POSITION);
        mrb_mod_cv_set(mrb, rclass, mrb_intern_cstr(mrb, "ATTRIBUTE_NAME_POSITION"), ret);
    } while (0);

    do {
        mrb_value ret;
        ret = mrb_str_new_cstr(mrb, (const char*)cocos2d::GLProgram::ATTRIBUTE_NAME_TEX_COORD);
        mrb_mod_cv_set(mrb, rclass, mrb_intern_cstr(mrb, "ATTRIBUTE_NAME_TEX_COORD"), ret);
    } while (0);

    do {
        mrb_value ret;
        ret = mrb_str_new_cstr(mrb, (const char*)cocos2d::GLProgram::ATTRIBUTE_NAME_TEX_COORD1);
        mrb_mod_cv_set(mrb, rclass, mrb_intern_cstr(mrb, "ATTRIBUTE_NAME_TEX_COORD1"), ret);
    } while (0);

    do {
        mrb_value ret;
        ret = mrb_str_new_cstr(mrb, (const char*)cocos2d::GLProgram::ATTRIBUTE_NAME_TEX_COORD2);
        mrb_mod_cv_set(mrb, rclass, mrb_intern_cstr(mrb, "ATTRIBUTE_NAME_TEX_COORD2"), ret);
    } while (0);

    do {
        mrb_value ret;
        ret = mrb_str_new_cstr(mrb, (const char*)cocos2d::GLProgram::ATTRIBUTE_NAME_TEX_COORD3);
        mrb_mod_cv_set(mrb, rclass, mrb_intern_cstr(mrb, "ATTRIBUTE_NAME_TEX_COORD3"), ret);
    } while (0);

    do {
        mrb_value ret;
        ret = mrb_str_new_cstr(mrb, (const char*)cocos2d::GLProgram::ATTRIBUTE_NAME_NORMAL);
        mrb_mod_cv_set(mrb, rclass, mrb_intern_cstr(mrb, "ATTRIBUTE_NAME_NORMAL"), ret);
    } while (0);

    do {
        mrb_value ret;
        ret = mrb_str_new_cstr(mrb, (const char*)cocos2d::GLProgram::ATTRIBUTE_NAME_BLEND_WEIGHT);
        mrb_mod_cv_set(mrb, rclass, mrb_intern_cstr(mrb, "ATTRIBUTE_NAME_BLEND_WEIGHT"), ret);
    } while (0);

    do {
        mrb_value ret;
        ret = mrb_str_new_cstr(mrb, (const char*)cocos2d::GLProgram::ATTRIBUTE_NAME_BLEND_INDEX);
        mrb_mod_cv_set(mrb, rclass, mrb_intern_cstr(mrb, "ATTRIBUTE_NAME_BLEND_INDEX"), ret);
    } while (0);

}

void ruby_cocos2dx_GLProgram_N_enum_init(mrb_state* mrb, struct RClass* renum)
{
    do {
        mrb_value ev = mrb_fixnum_value((mrb_int)cocos2d::GLProgram::VERTEX_ATTRIB_POSITION);
        mrb_mod_cv_set(mrb, renum, mrb_intern_cstr(mrb, "VERTEX_ATTRIB_POSITION"), ev);
    } while (0);

    do {
        mrb_value ev = mrb_fixnum_value((mrb_int)cocos2d::GLProgram::VERTEX_ATTRIB_COLOR);
        mrb_mod_cv_set(mrb, renum, mrb_intern_cstr(mrb, "VERTEX_ATTRIB_COLOR"), ev);
    } while (0);

    do {
        mrb_value ev = mrb_fixnum_value((mrb_int)cocos2d::GLProgram::VERTEX_ATTRIB_TEX_COORD);
        mrb_mod_cv_set(mrb, renum, mrb_intern_cstr(mrb, "VERTEX_ATTRIB_TEX_COORD"), ev);
    } while (0);

    do {
        mrb_value ev = mrb_fixnum_value((mrb_int)cocos2d::GLProgram::VERTEX_ATTRIB_TEX_COORD1);
        mrb_mod_cv_set(mrb, renum, mrb_intern_cstr(mrb, "VERTEX_ATTRIB_TEX_COORD1"), ev);
    } while (0);

    do {
        mrb_value ev = mrb_fixnum_value((mrb_int)cocos2d::GLProgram::VERTEX_ATTRIB_TEX_COORD2);
        mrb_mod_cv_set(mrb, renum, mrb_intern_cstr(mrb, "VERTEX_ATTRIB_TEX_COORD2"), ev);
    } while (0);

    do {
        mrb_value ev = mrb_fixnum_value((mrb_int)cocos2d::GLProgram::VERTEX_ATTRIB_TEX_COORD3);
        mrb_mod_cv_set(mrb, renum, mrb_intern_cstr(mrb, "VERTEX_ATTRIB_TEX_COORD3"), ev);
    } while (0);

    do {
        mrb_value ev = mrb_fixnum_value((mrb_int)cocos2d::GLProgram::VERTEX_ATTRIB_NORMAL);
        mrb_mod_cv_set(mrb, renum, mrb_intern_cstr(mrb, "VERTEX_ATTRIB_NORMAL"), ev);
    } while (0);

    do {
        mrb_value ev = mrb_fixnum_value((mrb_int)cocos2d::GLProgram::VERTEX_ATTRIB_BLEND_WEIGHT);
        mrb_mod_cv_set(mrb, renum, mrb_intern_cstr(mrb, "VERTEX_ATTRIB_BLEND_WEIGHT"), ev);
    } while (0);

    do {
        mrb_value ev = mrb_fixnum_value((mrb_int)cocos2d::GLProgram::VERTEX_ATTRIB_BLEND_INDEX);
        mrb_mod_cv_set(mrb, renum, mrb_intern_cstr(mrb, "VERTEX_ATTRIB_BLEND_INDEX"), ev);
    } while (0);

    do {
        mrb_value ev = mrb_fixnum_value((mrb_int)cocos2d::GLProgram::VERTEX_ATTRIB_MAX);
        mrb_mod_cv_set(mrb, renum, mrb_intern_cstr(mrb, "VERTEX_ATTRIB_MAX"), ev);
    } while (0);

    do {
        mrb_value ev = mrb_fixnum_value((mrb_int)cocos2d::GLProgram::VERTEX_ATTRIB_TEX_COORDS);
        mrb_mod_cv_set(mrb, renum, mrb_intern_cstr(mrb, "VERTEX_ATTRIB_TEX_COORDS"), ev);
    } while (0);

    do {
        mrb_value ev = mrb_fixnum_value((mrb_int)cocos2d::GLProgram::UNIFORM_AMBIENT_COLOR);
        mrb_mod_cv_set(mrb, renum, mrb_intern_cstr(mrb, "UNIFORM_AMBIENT_COLOR"), ev);
    } while (0);

    do {
        mrb_value ev = mrb_fixnum_value((mrb_int)cocos2d::GLProgram::UNIFORM_P_MATRIX);
        mrb_mod_cv_set(mrb, renum, mrb_intern_cstr(mrb, "UNIFORM_P_MATRIX"), ev);
    } while (0);

    do {
        mrb_value ev = mrb_fixnum_value((mrb_int)cocos2d::GLProgram::UNIFORM_MV_MATRIX);
        mrb_mod_cv_set(mrb, renum, mrb_intern_cstr(mrb, "UNIFORM_MV_MATRIX"), ev);
    } while (0);

    do {
        mrb_value ev = mrb_fixnum_value((mrb_int)cocos2d::GLProgram::UNIFORM_MVP_MATRIX);
        mrb_mod_cv_set(mrb, renum, mrb_intern_cstr(mrb, "UNIFORM_MVP_MATRIX"), ev);
    } while (0);

    do {
        mrb_value ev = mrb_fixnum_value((mrb_int)cocos2d::GLProgram::UNIFORM_NORMAL_MATRIX);
        mrb_mod_cv_set(mrb, renum, mrb_intern_cstr(mrb, "UNIFORM_NORMAL_MATRIX"), ev);
    } while (0);

    do {
        mrb_value ev = mrb_fixnum_value((mrb_int)cocos2d::GLProgram::UNIFORM_TIME);
        mrb_mod_cv_set(mrb, renum, mrb_intern_cstr(mrb, "UNIFORM_TIME"), ev);
    } while (0);

    do {
        mrb_value ev = mrb_fixnum_value((mrb_int)cocos2d::GLProgram::UNIFORM_SIN_TIME);
        mrb_mod_cv_set(mrb, renum, mrb_intern_cstr(mrb, "UNIFORM_SIN_TIME"), ev);
    } while (0);

    do {
        mrb_value ev = mrb_fixnum_value((mrb_int)cocos2d::GLProgram::UNIFORM_COS_TIME);
        mrb_mod_cv_set(mrb, renum, mrb_intern_cstr(mrb, "UNIFORM_COS_TIME"), ev);
    } while (0);

    do {
        mrb_value ev = mrb_fixnum_value((mrb_int)cocos2d::GLProgram::UNIFORM_RANDOM01);
        mrb_mod_cv_set(mrb, renum, mrb_intern_cstr(mrb, "UNIFORM_RANDOM01"), ev);
    } while (0);

    do {
        mrb_value ev = mrb_fixnum_value((mrb_int)cocos2d::GLProgram::UNIFORM_SAMPLER0);
        mrb_mod_cv_set(mrb, renum, mrb_intern_cstr(mrb, "UNIFORM_SAMPLER0"), ev);
    } while (0);

    do {
        mrb_value ev = mrb_fixnum_value((mrb_int)cocos2d::GLProgram::UNIFORM_SAMPLER1);
        mrb_mod_cv_set(mrb, renum, mrb_intern_cstr(mrb, "UNIFORM_SAMPLER1"), ev);
    } while (0);

    do {
        mrb_value ev = mrb_fixnum_value((mrb_int)cocos2d::GLProgram::UNIFORM_SAMPLER2);
        mrb_mod_cv_set(mrb, renum, mrb_intern_cstr(mrb, "UNIFORM_SAMPLER2"), ev);
    } while (0);

    do {
        mrb_value ev = mrb_fixnum_value((mrb_int)cocos2d::GLProgram::UNIFORM_SAMPLER3);
        mrb_mod_cv_set(mrb, renum, mrb_intern_cstr(mrb, "UNIFORM_SAMPLER3"), ev);
    } while (0);

    do {
        mrb_value ev = mrb_fixnum_value((mrb_int)cocos2d::GLProgram::UNIFORM_MAX);
        mrb_mod_cv_set(mrb, renum, mrb_intern_cstr(mrb, "UNIFORM_MAX"), ev);
    } while (0);

}

void ruby_register_cocos2dx_GLProgram(mrb_state* mrb, struct RClass* rmodule)
{
    std::string typeName = typeid(cocos2d::GLProgram).name();
    g_rubyType[typeName] = "CC::GLProgram";
    g_rubyDataType[typeName] = &ruby_cocos2dx_Ref_type;

    struct RClass* p_rmodule = mrb->object_class;
    p_rmodule = mrb_module_get_under(mrb, p_rmodule, "CC");
    struct RClass* p_rclass = mrb_class_get_under(mrb, p_rmodule, "Ref");
    struct RClass *rclass = mrb_define_class_under(mrb, rmodule, "GLProgram", p_rclass);
    MRB_SET_INSTANCE_TT(rclass, MRB_TT_DATA);

    mrb_define_method(mrb, rclass, "initialize", ruby_cocos2dx_GLProgram_constructor, ARGS_NONE());
    mrb_define_method(mrb, rclass, "get_fragment_shader_log", ruby_cocos2dx_GLProgram_getFragmentShaderLog, ARGS_NONE());
    mrb_define_method(mrb, rclass, "init_with_byte_arrays", ruby_cocos2dx_GLProgram_initWithByteArrays, ARGS_REQ(2));
    mrb_define_method(mrb, rclass, "init_with_filenames", ruby_cocos2dx_GLProgram_initWithFilenames, ARGS_REQ(2));
    mrb_define_method(mrb, rclass, "use", ruby_cocos2dx_GLProgram_use, ARGS_NONE());
    mrb_define_method(mrb, rclass, "get_vertex_shader_log", ruby_cocos2dx_GLProgram_getVertexShaderLog, ARGS_NONE());
    mrb_define_method(mrb, rclass, "set_uniforms_for_builtins", ruby_cocos2dx_GLProgram_setUniformsForBuiltins, ARGS_REQ(0)|ARGS_OPT(1));
    mrb_define_method(mrb, rclass, "update_uniforms", ruby_cocos2dx_GLProgram_updateUniforms, ARGS_NONE());
    mrb_define_method(mrb, rclass, "set_uniform_location_i32", ruby_cocos2dx_GLProgram_setUniformLocationWith1i, ARGS_REQ(2));
    mrb_define_method(mrb, rclass, "reset", ruby_cocos2dx_GLProgram_reset, ARGS_NONE());
    mrb_define_method(mrb, rclass, "bind_attrib_location", ruby_cocos2dx_GLProgram_bindAttribLocation, ARGS_REQ(2));
    mrb_define_method(mrb, rclass, "get_attrib_location", ruby_cocos2dx_GLProgram_getAttribLocation, ARGS_REQ(1));
    mrb_define_method(mrb, rclass, "link", ruby_cocos2dx_GLProgram_link, ARGS_NONE());
    mrb_define_class_method(mrb, rclass, "create_with_byte_arrays", ruby_cocos2dx_GLProgram_createWithByteArrays_static, ARGS_REQ(2));
    mrb_define_class_method(mrb, rclass, "create_with_filenames", ruby_cocos2dx_GLProgram_createWithFilenames_static, ARGS_REQ(2));
    ruby_cocos2dx_GLProgram_constants_init(mrb, rclass);
    mrb_define_class_method(mrb, rclass, "SHADER_NAME_POSITION_TEXTURE_COLOR", ruby_cocos2dx_constant_get, ARGS_NONE());
    mrb_define_class_method(mrb, rclass, "SHADER_NAME_POSITION_TEXTURE_COLOR_NO_MVP", ruby_cocos2dx_constant_get, ARGS_NONE());
    mrb_define_class_method(mrb, rclass, "SHADER_NAME_POSITION_TEXTURE_ALPHA_TEST", ruby_cocos2dx_constant_get, ARGS_NONE());
    mrb_define_class_method(mrb, rclass, "SHADER_NAME_POSITION_TEXTURE_ALPHA_TEST_NO_MV", ruby_cocos2dx_constant_get, ARGS_NONE());
    mrb_define_class_method(mrb, rclass, "SHADER_NAME_POSITION_COLOR", ruby_cocos2dx_constant_get, ARGS_NONE());
    mrb_define_class_method(mrb, rclass, "SHADER_NAME_POSITION_COLOR_TEXASPOINTSIZE", ruby_cocos2dx_constant_get, ARGS_NONE());
    mrb_define_class_method(mrb, rclass, "SHADER_NAME_POSITION_COLOR_NO_MVP", ruby_cocos2dx_constant_get, ARGS_NONE());
    mrb_define_class_method(mrb, rclass, "SHADER_NAME_POSITION_TEXTURE", ruby_cocos2dx_constant_get, ARGS_NONE());
    mrb_define_class_method(mrb, rclass, "SHADER_NAME_POSITION_TEXTURE_U_COLOR", ruby_cocos2dx_constant_get, ARGS_NONE());
    mrb_define_class_method(mrb, rclass, "SHADER_NAME_POSITION_TEXTURE_A8_COLOR", ruby_cocos2dx_constant_get, ARGS_NONE());
    mrb_define_class_method(mrb, rclass, "SHADER_NAME_POSITION_U_COLOR", ruby_cocos2dx_constant_get, ARGS_NONE());
    mrb_define_class_method(mrb, rclass, "SHADER_NAME_POSITION_LENGTH_TEXTURE_COLOR", ruby_cocos2dx_constant_get, ARGS_NONE());
    mrb_define_class_method(mrb, rclass, "SHADER_NAME_LABEL_NORMAL", ruby_cocos2dx_constant_get, ARGS_NONE());
    mrb_define_class_method(mrb, rclass, "SHADER_NAME_LABEL_OUTLINE", ruby_cocos2dx_constant_get, ARGS_NONE());
    mrb_define_class_method(mrb, rclass, "SHADER_NAME_LABEL_DISTANCEFIELD_NORMAL", ruby_cocos2dx_constant_get, ARGS_NONE());
    mrb_define_class_method(mrb, rclass, "SHADER_NAME_LABEL_DISTANCEFIELD_GLOW", ruby_cocos2dx_constant_get, ARGS_NONE());
    mrb_define_class_method(mrb, rclass, "SHADER_3D_POSITION", ruby_cocos2dx_constant_get, ARGS_NONE());
    mrb_define_class_method(mrb, rclass, "SHADER_3D_POSITION_TEXTURE", ruby_cocos2dx_constant_get, ARGS_NONE());
    mrb_define_class_method(mrb, rclass, "SHADER_3D_SKINPOSITION_TEXTURE", ruby_cocos2dx_constant_get, ARGS_NONE());
    mrb_define_class_method(mrb, rclass, "SHADER_3D_POSITION_NORMAL", ruby_cocos2dx_constant_get, ARGS_NONE());
    mrb_define_class_method(mrb, rclass, "SHADER_3D_POSITION_NORMAL_TEXTURE", ruby_cocos2dx_constant_get, ARGS_NONE());
    mrb_define_class_method(mrb, rclass, "SHADER_3D_SKINPOSITION_NORMAL_TEXTURE", ruby_cocos2dx_constant_get, ARGS_NONE());
    mrb_define_class_method(mrb, rclass, "UNIFORM_NAME_AMBIENT_COLOR", ruby_cocos2dx_constant_get, ARGS_NONE());
    mrb_define_class_method(mrb, rclass, "UNIFORM_NAME_P_MATRIX", ruby_cocos2dx_constant_get, ARGS_NONE());
    mrb_define_class_method(mrb, rclass, "UNIFORM_NAME_MV_MATRIX", ruby_cocos2dx_constant_get, ARGS_NONE());
    mrb_define_class_method(mrb, rclass, "UNIFORM_NAME_MVP_MATRIX", ruby_cocos2dx_constant_get, ARGS_NONE());
    mrb_define_class_method(mrb, rclass, "UNIFORM_NAME_NORMAL_MATRIX", ruby_cocos2dx_constant_get, ARGS_NONE());
    mrb_define_class_method(mrb, rclass, "UNIFORM_NAME_TIME", ruby_cocos2dx_constant_get, ARGS_NONE());
    mrb_define_class_method(mrb, rclass, "UNIFORM_NAME_SIN_TIME", ruby_cocos2dx_constant_get, ARGS_NONE());
    mrb_define_class_method(mrb, rclass, "UNIFORM_NAME_COS_TIME", ruby_cocos2dx_constant_get, ARGS_NONE());
    mrb_define_class_method(mrb, rclass, "UNIFORM_NAME_RANDOM01", ruby_cocos2dx_constant_get, ARGS_NONE());
    mrb_define_class_method(mrb, rclass, "UNIFORM_NAME_SAMPLER0", ruby_cocos2dx_constant_get, ARGS_NONE());
    mrb_define_class_method(mrb, rclass, "UNIFORM_NAME_SAMPLER1", ruby_cocos2dx_constant_get, ARGS_NONE());
    mrb_define_class_method(mrb, rclass, "UNIFORM_NAME_SAMPLER2", ruby_cocos2dx_constant_get, ARGS_NONE());
    mrb_define_class_method(mrb, rclass, "UNIFORM_NAME_SAMPLER3", ruby_cocos2dx_constant_get, ARGS_NONE());
    mrb_define_class_method(mrb, rclass, "UNIFORM_NAME_ALPHA_TEST_VALUE", ruby_cocos2dx_constant_get, ARGS_NONE());
    mrb_define_class_method(mrb, rclass, "ATTRIBUTE_NAME_COLOR", ruby_cocos2dx_constant_get, ARGS_NONE());
    mrb_define_class_method(mrb, rclass, "ATTRIBUTE_NAME_POSITION", ruby_cocos2dx_constant_get, ARGS_NONE());
    mrb_define_class_method(mrb, rclass, "ATTRIBUTE_NAME_TEX_COORD", ruby_cocos2dx_constant_get, ARGS_NONE());
    mrb_define_class_method(mrb, rclass, "ATTRIBUTE_NAME_TEX_COORD1", ruby_cocos2dx_constant_get, ARGS_NONE());
    mrb_define_class_method(mrb, rclass, "ATTRIBUTE_NAME_TEX_COORD2", ruby_cocos2dx_constant_get, ARGS_NONE());
    mrb_define_class_method(mrb, rclass, "ATTRIBUTE_NAME_TEX_COORD3", ruby_cocos2dx_constant_get, ARGS_NONE());
    mrb_define_class_method(mrb, rclass, "ATTRIBUTE_NAME_NORMAL", ruby_cocos2dx_constant_get, ARGS_NONE());
    mrb_define_class_method(mrb, rclass, "ATTRIBUTE_NAME_BLEND_WEIGHT", ruby_cocos2dx_constant_get, ARGS_NONE());
    mrb_define_class_method(mrb, rclass, "ATTRIBUTE_NAME_BLEND_INDEX", ruby_cocos2dx_constant_get, ARGS_NONE());
    ruby_cocos2dx_GLProgram_N_enum_init(mrb, rclass);
    mrb_define_class_method(mrb, rclass, "VERTEX_ATTRIB_POSITION", ruby_cocos2dx_constant_get, ARGS_NONE());
    mrb_define_class_method(mrb, rclass, "VERTEX_ATTRIB_COLOR", ruby_cocos2dx_constant_get, ARGS_NONE());
    mrb_define_class_method(mrb, rclass, "VERTEX_ATTRIB_TEX_COORD", ruby_cocos2dx_constant_get, ARGS_NONE());
    mrb_define_class_method(mrb, rclass, "VERTEX_ATTRIB_TEX_COORD1", ruby_cocos2dx_constant_get, ARGS_NONE());
    mrb_define_class_method(mrb, rclass, "VERTEX_ATTRIB_TEX_COORD2", ruby_cocos2dx_constant_get, ARGS_NONE());
    mrb_define_class_method(mrb, rclass, "VERTEX_ATTRIB_TEX_COORD3", ruby_cocos2dx_constant_get, ARGS_NONE());
    mrb_define_class_method(mrb, rclass, "VERTEX_ATTRIB_NORMAL", ruby_cocos2dx_constant_get, ARGS_NONE());
    mrb_define_class_method(mrb, rclass, "VERTEX_ATTRIB_BLEND_WEIGHT", ruby_cocos2dx_constant_get, ARGS_NONE());
    mrb_define_class_method(mrb, rclass, "VERTEX_ATTRIB_BLEND_INDEX", ruby_cocos2dx_constant_get, ARGS_NONE());
    mrb_define_class_method(mrb, rclass, "VERTEX_ATTRIB_MAX", ruby_cocos2dx_constant_get, ARGS_NONE());
    mrb_define_class_method(mrb, rclass, "VERTEX_ATTRIB_TEX_COORDS", ruby_cocos2dx_constant_get, ARGS_NONE());
    mrb_define_class_method(mrb, rclass, "UNIFORM_AMBIENT_COLOR", ruby_cocos2dx_constant_get, ARGS_NONE());
    mrb_define_class_method(mrb, rclass, "UNIFORM_P_MATRIX", ruby_cocos2dx_constant_get, ARGS_NONE());
    mrb_define_class_method(mrb, rclass, "UNIFORM_MV_MATRIX", ruby_cocos2dx_constant_get, ARGS_NONE());
    mrb_define_class_method(mrb, rclass, "UNIFORM_MVP_MATRIX", ruby_cocos2dx_constant_get, ARGS_NONE());
    mrb_define_class_method(mrb, rclass, "UNIFORM_NORMAL_MATRIX", ruby_cocos2dx_constant_get, ARGS_NONE());
    mrb_define_class_method(mrb, rclass, "UNIFORM_TIME", ruby_cocos2dx_constant_get, ARGS_NONE());
    mrb_define_class_method(mrb, rclass, "UNIFORM_SIN_TIME", ruby_cocos2dx_constant_get, ARGS_NONE());
    mrb_define_class_method(mrb, rclass, "UNIFORM_COS_TIME", ruby_cocos2dx_constant_get, ARGS_NONE());
    mrb_define_class_method(mrb, rclass, "UNIFORM_RANDOM01", ruby_cocos2dx_constant_get, ARGS_NONE());
    mrb_define_class_method(mrb, rclass, "UNIFORM_SAMPLER0", ruby_cocos2dx_constant_get, ARGS_NONE());
    mrb_define_class_method(mrb, rclass, "UNIFORM_SAMPLER1", ruby_cocos2dx_constant_get, ARGS_NONE());
    mrb_define_class_method(mrb, rclass, "UNIFORM_SAMPLER2", ruby_cocos2dx_constant_get, ARGS_NONE());
    mrb_define_class_method(mrb, rclass, "UNIFORM_SAMPLER3", ruby_cocos2dx_constant_get, ARGS_NONE());
    mrb_define_class_method(mrb, rclass, "UNIFORM_MAX", ruby_cocos2dx_constant_get, ARGS_NONE());
}
mrb_value ruby_cocos2dx_GLProgramCache_addGLProgram(mrb_state* mrb, mrb_value self)
{
    cocos2d::GLProgramCache* cobj = static_cast<cocos2d::GLProgramCache*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 2) {
            cocos2d::GLProgram* arg0;
            ok = rubyval_to_object<cocos2d::GLProgram>(mrb, argv[0], "CC::GLProgram", &arg0);
            if (!ok) { break; }
            std::string arg1;
            ok = rubyval_to_std_string(mrb, argv[1], &arg1, "CC::GLProgramCache.addGLProgram");
            if (!ok) { break; }
            cobj->addGLProgram(arg0, arg1);
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::GLProgramCache#addGLProgram");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_GLProgramCache_getGLProgram(mrb_state* mrb, mrb_value self)
{
    cocos2d::GLProgramCache* cobj = static_cast<cocos2d::GLProgramCache*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            std::string arg0;
            ok = rubyval_to_std_string(mrb, argv[0], &arg0, "CC::GLProgramCache.getGLProgram");
            if (!ok) { break; }
            cocos2d::GLProgram* retval = cobj->getGLProgram(arg0);
            mrb_value ret;
            ret = object_to_rubyval<cocos2d::GLProgram>(mrb, "CC::GLProgram", (cocos2d::GLProgram*)retval, nullptr);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::GLProgramCache#getGLProgram");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_GLProgramCache_reloadDefaultGLPrograms(mrb_state* mrb, mrb_value self)
{
    cocos2d::GLProgramCache* cobj = static_cast<cocos2d::GLProgramCache*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            cobj->reloadDefaultGLPrograms();
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::GLProgramCache#reloadDefaultGLPrograms");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_GLProgramCache_loadDefaultGLPrograms(mrb_state* mrb, mrb_value self)
{
    cocos2d::GLProgramCache* cobj = static_cast<cocos2d::GLProgramCache*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            cobj->loadDefaultGLPrograms();
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::GLProgramCache#loadDefaultGLPrograms");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_GLProgramCache_destroyInstance_static(mrb_state* mrb, mrb_value self)
{
    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            cocos2d::GLProgramCache::destroyInstance();
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined static method : cocos2d::GLProgramCache#destroyInstance");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_GLProgramCache_getInstance_static(mrb_state* mrb, mrb_value self)
{
    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            cocos2d::GLProgramCache* retval = cocos2d::GLProgramCache::getInstance();
            mrb_value ret;
            ret = object_to_rubyval<cocos2d::GLProgramCache>(mrb, "CC::GLProgramCache", (cocos2d::GLProgramCache*)retval, nullptr);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined static method : cocos2d::GLProgramCache#getInstance");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_GLProgramCache_constructor(mrb_state* mrb, mrb_value self)
{

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            cocos2d::GLProgramCache* cobj = new cocos2d::GLProgramCache();
            DATA_TYPE(self) = &ruby_cocos2dx_Ref_type;
            DATA_PTR(self) = cobj;
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::GLProgramCache#GLProgramCache");

    return mrb_nil_value();
}


void ruby_register_cocos2dx_GLProgramCache(mrb_state* mrb, struct RClass* rmodule)
{
    std::string typeName = typeid(cocos2d::GLProgramCache).name();
    g_rubyType[typeName] = "CC::GLProgramCache";
    g_rubyDataType[typeName] = &ruby_cocos2dx_Ref_type;

    struct RClass* p_rmodule = mrb->object_class;
    p_rmodule = mrb_module_get_under(mrb, p_rmodule, "CC");
    struct RClass* p_rclass = mrb_class_get_under(mrb, p_rmodule, "Ref");
    struct RClass *rclass = mrb_define_class_under(mrb, rmodule, "GLProgramCache", p_rclass);
    MRB_SET_INSTANCE_TT(rclass, MRB_TT_DATA);

    mrb_define_method(mrb, rclass, "initialize", ruby_cocos2dx_GLProgramCache_constructor, ARGS_NONE());
    mrb_define_method(mrb, rclass, "add_glprogram", ruby_cocos2dx_GLProgramCache_addGLProgram, ARGS_REQ(2));
    mrb_define_method(mrb, rclass, "get_glprogram", ruby_cocos2dx_GLProgramCache_getGLProgram, ARGS_REQ(1));
    mrb_define_method(mrb, rclass, "reload_default_glprograms", ruby_cocos2dx_GLProgramCache_reloadDefaultGLPrograms, ARGS_NONE());
    mrb_define_method(mrb, rclass, "load_default_glprograms", ruby_cocos2dx_GLProgramCache_loadDefaultGLPrograms, ARGS_NONE());
    mrb_define_class_method(mrb, rclass, "destroy_instance", ruby_cocos2dx_GLProgramCache_destroyInstance_static, ARGS_NONE());
    mrb_define_class_method(mrb, rclass, "get_instance", ruby_cocos2dx_GLProgramCache_getInstance_static, ARGS_NONE());
}
mrb_value ruby_cocos2dx_TextureCache_reloadTexture(mrb_state* mrb, mrb_value self)
{
    cocos2d::TextureCache* cobj = static_cast<cocos2d::TextureCache*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            std::string arg0;
            ok = rubyval_to_std_string(mrb, argv[0], &arg0, "CC::TextureCache.reloadTexture");
            if (!ok) { break; }
            bool retval = cobj->reloadTexture(arg0);
            mrb_value ret;
            ret = mrb_bool_value((mrb_bool)retval);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::TextureCache#reloadTexture");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_TextureCache_unbindAllImageAsync(mrb_state* mrb, mrb_value self)
{
    cocos2d::TextureCache* cobj = static_cast<cocos2d::TextureCache*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            cobj->unbindAllImageAsync();
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::TextureCache#unbindAllImageAsync");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_TextureCache_removeTextureForKey(mrb_state* mrb, mrb_value self)
{
    cocos2d::TextureCache* cobj = static_cast<cocos2d::TextureCache*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            std::string arg0;
            ok = rubyval_to_std_string(mrb, argv[0], &arg0, "CC::TextureCache.removeTextureForKey");
            if (!ok) { break; }
            cobj->removeTextureForKey(arg0);
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::TextureCache#removeTextureForKey");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_TextureCache_removeAllTextures(mrb_state* mrb, mrb_value self)
{
    cocos2d::TextureCache* cobj = static_cast<cocos2d::TextureCache*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            cobj->removeAllTextures();
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::TextureCache#removeAllTextures");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_TextureCache_getDescription(mrb_state* mrb, mrb_value self)
{
    cocos2d::TextureCache* cobj = static_cast<cocos2d::TextureCache*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            std::string retval = cobj->getDescription();
            mrb_value ret;
            ret = mrb_str_new_cstr(mrb, retval.c_str());
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::TextureCache#getDescription");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_TextureCache_getCachedTextureInfo(mrb_state* mrb, mrb_value self)
{
    cocos2d::TextureCache* cobj = static_cast<cocos2d::TextureCache*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            std::string retval = cobj->getCachedTextureInfo();
            mrb_value ret;
            ret = mrb_str_new_cstr(mrb, retval.c_str());
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::TextureCache#getCachedTextureInfo");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_TextureCache_addImage(mrb_state* mrb, mrb_value self)
{
    cocos2d::TextureCache* cobj = static_cast<cocos2d::TextureCache*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 2) {
            cocos2d::Image* arg0;
            ok = rubyval_to_object<cocos2d::Image>(mrb, argv[0], "CC::Image", &arg0);
            if (!ok) { break; }
            std::string arg1;
            ok = rubyval_to_std_string(mrb, argv[1], &arg1, "CC::TextureCache.addImage");
            if (!ok) { break; }
            cocos2d::Texture2D* retval = cobj->addImage(arg0, arg1);
            mrb_value ret;
            ret = object_to_rubyval<cocos2d::Texture2D>(mrb, "CC::Texture2D", (cocos2d::Texture2D*)retval, nullptr);
            return ret;
        }
    } while (0);
    do {
        if (argc == 1) {
            std::string arg0;
            ok = rubyval_to_std_string(mrb, argv[0], &arg0, "CC::TextureCache.addImage");
            if (!ok) { break; }
            cocos2d::Texture2D* retval = cobj->addImage(arg0);
            mrb_value ret;
            ret = object_to_rubyval<cocos2d::Texture2D>(mrb, "CC::Texture2D", (cocos2d::Texture2D*)retval, nullptr);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::TextureCache#addImage");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_TextureCache_unbindImageAsync(mrb_state* mrb, mrb_value self)
{
    cocos2d::TextureCache* cobj = static_cast<cocos2d::TextureCache*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            std::string arg0;
            ok = rubyval_to_std_string(mrb, argv[0], &arg0, "CC::TextureCache.unbindImageAsync");
            if (!ok) { break; }
            cobj->unbindImageAsync(arg0);
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::TextureCache#unbindImageAsync");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_TextureCache_getTextureForKey(mrb_state* mrb, mrb_value self)
{
    cocos2d::TextureCache* cobj = static_cast<cocos2d::TextureCache*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            std::string arg0;
            ok = rubyval_to_std_string(mrb, argv[0], &arg0, "CC::TextureCache.getTextureForKey");
            if (!ok) { break; }
            cocos2d::Texture2D* retval = cobj->getTextureForKey(arg0);
            mrb_value ret;
            ret = object_to_rubyval<cocos2d::Texture2D>(mrb, "CC::Texture2D", (cocos2d::Texture2D*)retval, nullptr);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::TextureCache#getTextureForKey");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_TextureCache_removeUnusedTextures(mrb_state* mrb, mrb_value self)
{
    cocos2d::TextureCache* cobj = static_cast<cocos2d::TextureCache*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            cobj->removeUnusedTextures();
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::TextureCache#removeUnusedTextures");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_TextureCache_removeTexture(mrb_state* mrb, mrb_value self)
{
    cocos2d::TextureCache* cobj = static_cast<cocos2d::TextureCache*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            cocos2d::Texture2D* arg0;
            ok = rubyval_to_object<cocos2d::Texture2D>(mrb, argv[0], "CC::Texture2D", &arg0);
            if (!ok) { break; }
            cobj->removeTexture(arg0);
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::TextureCache#removeTexture");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_TextureCache_waitForQuit(mrb_state* mrb, mrb_value self)
{
    cocos2d::TextureCache* cobj = static_cast<cocos2d::TextureCache*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            cobj->waitForQuit();
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::TextureCache#waitForQuit");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_TextureCache_constructor(mrb_state* mrb, mrb_value self)
{

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            cocos2d::TextureCache* cobj = new cocos2d::TextureCache();
            DATA_TYPE(self) = &ruby_cocos2dx_Ref_type;
            DATA_PTR(self) = cobj;
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::TextureCache#TextureCache");

    return mrb_nil_value();
}


void ruby_register_cocos2dx_TextureCache(mrb_state* mrb, struct RClass* rmodule)
{
    std::string typeName = typeid(cocos2d::TextureCache).name();
    g_rubyType[typeName] = "CC::TextureCache";
    g_rubyDataType[typeName] = &ruby_cocos2dx_Ref_type;

    struct RClass* p_rmodule = mrb->object_class;
    p_rmodule = mrb_module_get_under(mrb, p_rmodule, "CC");
    struct RClass* p_rclass = mrb_class_get_under(mrb, p_rmodule, "Ref");
    struct RClass *rclass = mrb_define_class_under(mrb, rmodule, "TextureCache", p_rclass);
    MRB_SET_INSTANCE_TT(rclass, MRB_TT_DATA);

    mrb_define_method(mrb, rclass, "initialize", ruby_cocos2dx_TextureCache_constructor, ARGS_NONE());
    mrb_define_method(mrb, rclass, "reload_texture", ruby_cocos2dx_TextureCache_reloadTexture, ARGS_REQ(1));
    mrb_define_method(mrb, rclass, "unbind_all_image_async", ruby_cocos2dx_TextureCache_unbindAllImageAsync, ARGS_NONE());
    mrb_define_method(mrb, rclass, "remove_texture_for_key", ruby_cocos2dx_TextureCache_removeTextureForKey, ARGS_REQ(1));
    mrb_define_method(mrb, rclass, "remove_all_textures", ruby_cocos2dx_TextureCache_removeAllTextures, ARGS_NONE());
    mrb_define_method(mrb, rclass, "get_description", ruby_cocos2dx_TextureCache_getDescription, ARGS_NONE());
    mrb_define_method(mrb, rclass, "get_cached_texture_info", ruby_cocos2dx_TextureCache_getCachedTextureInfo, ARGS_NONE());
    mrb_define_method(mrb, rclass, "add_image", ruby_cocos2dx_TextureCache_addImage, ARGS_REQ(1)|ARGS_OPT(1));
    mrb_define_method(mrb, rclass, "unbind_image_async", ruby_cocos2dx_TextureCache_unbindImageAsync, ARGS_REQ(1));
    mrb_define_method(mrb, rclass, "get_texture_for_key", ruby_cocos2dx_TextureCache_getTextureForKey, ARGS_REQ(1));
    mrb_define_method(mrb, rclass, "remove_unused_textures", ruby_cocos2dx_TextureCache_removeUnusedTextures, ARGS_NONE());
    mrb_define_method(mrb, rclass, "remove_texture", ruby_cocos2dx_TextureCache_removeTexture, ARGS_REQ(1));
    mrb_define_method(mrb, rclass, "wait_for_quit", ruby_cocos2dx_TextureCache_waitForQuit, ARGS_NONE());
}
mrb_value ruby_cocos2dx_Device_setAccelerometerEnabled_static(mrb_state* mrb, mrb_value self)
{
    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            bool arg0;
            ok = rubyval_to_boolean(mrb, argv[0], &arg0, "CC::Device.setAccelerometerEnabled");
            if (!ok) { break; }

            cocos2d::Device::setAccelerometerEnabled(arg0);
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined static method : cocos2d::Device#setAccelerometerEnabled");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Device_setKeepScreenOn_static(mrb_state* mrb, mrb_value self)
{
    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            bool arg0;
            ok = rubyval_to_boolean(mrb, argv[0], &arg0, "CC::Device.setKeepScreenOn");
            if (!ok) { break; }

            cocos2d::Device::setKeepScreenOn(arg0);
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined static method : cocos2d::Device#setKeepScreenOn");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Device_setAccelerometerInterval_static(mrb_state* mrb, mrb_value self)
{
    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            double arg0;
            ok = rubyval_to_number(mrb, argv[0], (double*)&arg0, "CC::Device.setAccelerometerInterval");
            if (!ok) { break; }

            cocos2d::Device::setAccelerometerInterval(arg0);
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined static method : cocos2d::Device#setAccelerometerInterval");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Device_getDPI_static(mrb_state* mrb, mrb_value self)
{
    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            int retval = cocos2d::Device::getDPI();
            mrb_value ret;
            ret = mrb_fixnum_value((mrb_int)retval);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined static method : cocos2d::Device#getDPI");

    return mrb_nil_value();
}

void ruby_cocos2dx_Device_TextAlign_enum_init(mrb_state* mrb, struct RClass* renum)
{
    do {
        mrb_value ev = mrb_fixnum_value((mrb_int)cocos2d::Device::TextAlign::CENTER);
        mrb_mod_cv_set(mrb, renum, mrb_intern_cstr(mrb, "CENTER"), ev);
    } while (0);

    do {
        mrb_value ev = mrb_fixnum_value((mrb_int)cocos2d::Device::TextAlign::TOP);
        mrb_mod_cv_set(mrb, renum, mrb_intern_cstr(mrb, "TOP"), ev);
    } while (0);

    do {
        mrb_value ev = mrb_fixnum_value((mrb_int)cocos2d::Device::TextAlign::TOP_RIGHT);
        mrb_mod_cv_set(mrb, renum, mrb_intern_cstr(mrb, "TOP_RIGHT"), ev);
    } while (0);

    do {
        mrb_value ev = mrb_fixnum_value((mrb_int)cocos2d::Device::TextAlign::RIGHT);
        mrb_mod_cv_set(mrb, renum, mrb_intern_cstr(mrb, "RIGHT"), ev);
    } while (0);

    do {
        mrb_value ev = mrb_fixnum_value((mrb_int)cocos2d::Device::TextAlign::BOTTOM_RIGHT);
        mrb_mod_cv_set(mrb, renum, mrb_intern_cstr(mrb, "BOTTOM_RIGHT"), ev);
    } while (0);

    do {
        mrb_value ev = mrb_fixnum_value((mrb_int)cocos2d::Device::TextAlign::BOTTOM);
        mrb_mod_cv_set(mrb, renum, mrb_intern_cstr(mrb, "BOTTOM"), ev);
    } while (0);

    do {
        mrb_value ev = mrb_fixnum_value((mrb_int)cocos2d::Device::TextAlign::BOTTOM_LEFT);
        mrb_mod_cv_set(mrb, renum, mrb_intern_cstr(mrb, "BOTTOM_LEFT"), ev);
    } while (0);

    do {
        mrb_value ev = mrb_fixnum_value((mrb_int)cocos2d::Device::TextAlign::LEFT);
        mrb_mod_cv_set(mrb, renum, mrb_intern_cstr(mrb, "LEFT"), ev);
    } while (0);

    do {
        mrb_value ev = mrb_fixnum_value((mrb_int)cocos2d::Device::TextAlign::TOP_LEFT);
        mrb_mod_cv_set(mrb, renum, mrb_intern_cstr(mrb, "TOP_LEFT"), ev);
    } while (0);

}

void ruby_register_cocos2dx_Device(mrb_state* mrb, struct RClass* rmodule)
{
    std::string typeName = typeid(cocos2d::Device).name();
    g_rubyType[typeName] = "CC::Device";
    g_rubyDataType[typeName] = &ruby_cocos2dx_Device_type;

    struct RClass *rclass = mrb_define_class_under(mrb, rmodule, "Device", mrb->object_class);
    MRB_SET_INSTANCE_TT(rclass, MRB_TT_DATA);

    mrb_define_class_method(mrb, rclass, "set_accelerometer_enabled", ruby_cocos2dx_Device_setAccelerometerEnabled_static, ARGS_REQ(1));
    mrb_define_class_method(mrb, rclass, "set_keep_screen_on", ruby_cocos2dx_Device_setKeepScreenOn_static, ARGS_REQ(1));
    mrb_define_class_method(mrb, rclass, "set_accelerometer_interval", ruby_cocos2dx_Device_setAccelerometerInterval_static, ARGS_REQ(1));
    mrb_define_class_method(mrb, rclass, "get_dpi", ruby_cocos2dx_Device_getDPI_static, ARGS_NONE());
    struct RClass* renum_TextAlign = mrb_define_module_under(mrb, rclass, "TextAlign");
    ruby_cocos2dx_Device_TextAlign_enum_init(mrb, renum_TextAlign);
    mrb_define_class_method(mrb, renum_TextAlign, "CENTER", ruby_cocos2dx_constant_get, ARGS_NONE());
    mrb_define_class_method(mrb, renum_TextAlign, "TOP", ruby_cocos2dx_constant_get, ARGS_NONE());
    mrb_define_class_method(mrb, renum_TextAlign, "TOP_RIGHT", ruby_cocos2dx_constant_get, ARGS_NONE());
    mrb_define_class_method(mrb, renum_TextAlign, "RIGHT", ruby_cocos2dx_constant_get, ARGS_NONE());
    mrb_define_class_method(mrb, renum_TextAlign, "BOTTOM_RIGHT", ruby_cocos2dx_constant_get, ARGS_NONE());
    mrb_define_class_method(mrb, renum_TextAlign, "BOTTOM", ruby_cocos2dx_constant_get, ARGS_NONE());
    mrb_define_class_method(mrb, renum_TextAlign, "BOTTOM_LEFT", ruby_cocos2dx_constant_get, ARGS_NONE());
    mrb_define_class_method(mrb, renum_TextAlign, "LEFT", ruby_cocos2dx_constant_get, ARGS_NONE());
    mrb_define_class_method(mrb, renum_TextAlign, "TOP_LEFT", ruby_cocos2dx_constant_get, ARGS_NONE());
}
mrb_value ruby_cocos2dx_Application_openURL(mrb_state* mrb, mrb_value self)
{
    cocos2d::Application* cobj = static_cast<cocos2d::Application*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Application_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            std::string arg0;
            ok = rubyval_to_std_string(mrb, argv[0], &arg0, "CC::Application.openURL");
            if (!ok) { break; }
            bool retval = cobj->openURL(arg0);
            mrb_value ret;
            ret = mrb_bool_value((mrb_bool)retval);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::Application#openURL");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Application_getTargetPlatform(mrb_state* mrb, mrb_value self)
{
    cocos2d::Application* cobj = static_cast<cocos2d::Application*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Application_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            int retval = (int)cobj->getTargetPlatform();
            mrb_value ret;
            ret = mrb_fixnum_value((mrb_int)retval);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::Application#getTargetPlatform");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Application_getCurrentLanguage(mrb_state* mrb, mrb_value self)
{
    cocos2d::Application* cobj = static_cast<cocos2d::Application*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Application_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            int retval = (int)cobj->getCurrentLanguage();
            mrb_value ret;
            ret = mrb_fixnum_value((mrb_int)retval);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::Application#getCurrentLanguage");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Application_getCurrentLanguageCode(mrb_state* mrb, mrb_value self)
{
    cocos2d::Application* cobj = static_cast<cocos2d::Application*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Application_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            const char* retval = cobj->getCurrentLanguageCode();
            mrb_value ret;
            ret = mrb_str_new_cstr(mrb, (const char*)retval);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::Application#getCurrentLanguageCode");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Application_setAnimationInterval(mrb_state* mrb, mrb_value self)
{
    cocos2d::Application* cobj = static_cast<cocos2d::Application*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Application_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            double arg0;
            ok = rubyval_to_number(mrb, argv[0], &arg0, "CC::Application.setAnimationInterval");
            if (!ok) { break; }
            cobj->setAnimationInterval(arg0);
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::Application#setAnimationInterval");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Application_getInstance_static(mrb_state* mrb, mrb_value self)
{
    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            cocos2d::Application* retval = cocos2d::Application::getInstance();
            mrb_value ret;
            ret = object_to_rubyval<cocos2d::Application>(mrb, "CC::Application", (cocos2d::Application*)retval, nullptr);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined static method : cocos2d::Application#getInstance");

    return mrb_nil_value();
}

void ruby_register_cocos2dx_Application(mrb_state* mrb, struct RClass* rmodule)
{
    std::string typeName = typeid(cocos2d::Application).name();
    g_rubyType[typeName] = "CC::Application";
    g_rubyDataType[typeName] = &ruby_cocos2dx_Application_type;

    struct RClass *rclass = mrb_define_class_under(mrb, rmodule, "Application", mrb->object_class);
    MRB_SET_INSTANCE_TT(rclass, MRB_TT_DATA);

    mrb_define_method(mrb, rclass, "open_url", ruby_cocos2dx_Application_openURL, ARGS_REQ(1));
    mrb_define_method(mrb, rclass, "get_target_platform", ruby_cocos2dx_Application_getTargetPlatform, ARGS_NONE());
    mrb_define_method(mrb, rclass, "get_current_language", ruby_cocos2dx_Application_getCurrentLanguage, ARGS_NONE());
    mrb_define_method(mrb, rclass, "get_current_language_code", ruby_cocos2dx_Application_getCurrentLanguageCode, ARGS_NONE());
    mrb_define_method(mrb, rclass, "set_animation_interval", ruby_cocos2dx_Application_setAnimationInterval, ARGS_REQ(1));
    mrb_define_class_method(mrb, rclass, "get_instance", ruby_cocos2dx_Application_getInstance_static, ARGS_NONE());
}
mrb_value ruby_cocos2dx_GLViewImpl_createWithRect_static(mrb_state* mrb, mrb_value self)
{
    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 2) {
            std::map<std::string, mrb_value> callbacks;
            std::string arg0;
            ok = rubyval_to_std_string(mrb, argv[0], &arg0, "CC::GLViewImpl.createWithRect");
            if (!ok) { break; }

            cocos2d::Rect* arg1;
            ok = rubyval_to_object<cocos2d::Rect>(mrb, argv[1], "CC::Rect", &arg1);
            if (!ok) { break; }

            cocos2d::GLViewImpl* retval = cocos2d::GLViewImpl::createWithRect(arg0, *arg1);
            mrb_value ret;
            RClass* rclass = mrb_class_ptr(self);
            ret = object_to_rubyval<cocos2d::GLViewImpl>(mrb, "CC::GLViewImpl", (cocos2d::GLViewImpl*)retval, rclass);
            if (callbacks.size() > 0) {
                mrb_value hash = mrb_iv_get(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"));
                if (!mrb_hash_p(hash)) {
                    hash = mrb_hash_new(mrb);
                }
                for (auto elm : callbacks) {
                    mrb_hash_set(mrb, hash, mrb_str_new_cstr(mrb, elm.first.c_str()), elm.second);
                    mrb_iv_set(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"), hash);
                }
            }
            g_rubyValue.push_back(ret);
            mrb_funcall(mrb, ret, "initialize", 0);
            return ret;
        }
    } while (0);
    do {
        if (argc == 3) {
            std::map<std::string, mrb_value> callbacks;
            std::string arg0;
            ok = rubyval_to_std_string(mrb, argv[0], &arg0, "CC::GLViewImpl.createWithRect");
            if (!ok) { break; }

            cocos2d::Rect* arg1;
            ok = rubyval_to_object<cocos2d::Rect>(mrb, argv[1], "CC::Rect", &arg1);
            if (!ok) { break; }

            double arg2;
            ok = rubyval_to_number(mrb, argv[2], (double*)&arg2, "CC::GLViewImpl.createWithRect");
            if (!ok) { break; }

            cocos2d::GLViewImpl* retval = cocos2d::GLViewImpl::createWithRect(arg0, *arg1, arg2);
            mrb_value ret;
            RClass* rclass = mrb_class_ptr(self);
            ret = object_to_rubyval<cocos2d::GLViewImpl>(mrb, "CC::GLViewImpl", (cocos2d::GLViewImpl*)retval, rclass);
            if (callbacks.size() > 0) {
                mrb_value hash = mrb_iv_get(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"));
                if (!mrb_hash_p(hash)) {
                    hash = mrb_hash_new(mrb);
                }
                for (auto elm : callbacks) {
                    mrb_hash_set(mrb, hash, mrb_str_new_cstr(mrb, elm.first.c_str()), elm.second);
                    mrb_iv_set(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"), hash);
                }
            }
            g_rubyValue.push_back(ret);
            mrb_funcall(mrb, ret, "initialize", 0);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined static method : cocos2d::GLViewImpl#createWithRect");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_GLViewImpl_create_static(mrb_state* mrb, mrb_value self)
{
    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            std::map<std::string, mrb_value> callbacks;
            std::string arg0;
            ok = rubyval_to_std_string(mrb, argv[0], &arg0, "CC::GLViewImpl.create");
            if (!ok) { break; }

            cocos2d::GLViewImpl* retval = cocos2d::GLViewImpl::create(arg0);
            mrb_value ret;
            RClass* rclass = mrb_class_ptr(self);
            ret = object_to_rubyval<cocos2d::GLViewImpl>(mrb, "CC::GLViewImpl", (cocos2d::GLViewImpl*)retval, rclass);
            if (callbacks.size() > 0) {
                mrb_value hash = mrb_iv_get(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"));
                if (!mrb_hash_p(hash)) {
                    hash = mrb_hash_new(mrb);
                }
                for (auto elm : callbacks) {
                    mrb_hash_set(mrb, hash, mrb_str_new_cstr(mrb, elm.first.c_str()), elm.second);
                    mrb_iv_set(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"), hash);
                }
            }
            g_rubyValue.push_back(ret);
            mrb_funcall(mrb, ret, "initialize", 0);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined static method : cocos2d::GLViewImpl#create");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_GLViewImpl_createWithFullScreen_static(mrb_state* mrb, mrb_value self)
{
    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            std::map<std::string, mrb_value> callbacks;
            std::string arg0;
            ok = rubyval_to_std_string(mrb, argv[0], &arg0, "CC::GLViewImpl.createWithFullScreen");
            if (!ok) { break; }

            cocos2d::GLViewImpl* retval = cocos2d::GLViewImpl::createWithFullScreen(arg0);
            mrb_value ret;
            RClass* rclass = mrb_class_ptr(self);
            ret = object_to_rubyval<cocos2d::GLViewImpl>(mrb, "CC::GLViewImpl", (cocos2d::GLViewImpl*)retval, rclass);
            if (callbacks.size() > 0) {
                mrb_value hash = mrb_iv_get(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"));
                if (!mrb_hash_p(hash)) {
                    hash = mrb_hash_new(mrb);
                }
                for (auto elm : callbacks) {
                    mrb_hash_set(mrb, hash, mrb_str_new_cstr(mrb, elm.first.c_str()), elm.second);
                    mrb_iv_set(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"), hash);
                }
            }
            g_rubyValue.push_back(ret);
            mrb_funcall(mrb, ret, "initialize", 0);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined static method : cocos2d::GLViewImpl#createWithFullScreen");

    return mrb_nil_value();
}

void ruby_register_cocos2dx_GLViewImpl(mrb_state* mrb, struct RClass* rmodule)
{
    std::string typeName = typeid(cocos2d::GLViewImpl).name();
    g_rubyType[typeName] = "CC::GLViewImpl";
    g_rubyDataType[typeName] = &ruby_cocos2dx_Ref_type;

    struct RClass* p_rmodule = mrb->object_class;
    p_rmodule = mrb_module_get_under(mrb, p_rmodule, "CC");
    struct RClass* p_rclass = mrb_class_get_under(mrb, p_rmodule, "GLView");
    struct RClass *rclass = mrb_define_class_under(mrb, rmodule, "GLViewImpl", p_rclass);
    MRB_SET_INSTANCE_TT(rclass, MRB_TT_DATA);

    mrb_define_class_method(mrb, rclass, "create_with_rect", ruby_cocos2dx_GLViewImpl_createWithRect_static, ARGS_REQ(3));
    mrb_define_class_method(mrb, rclass, "create", ruby_cocos2dx_GLViewImpl_create_static, ARGS_REQ(1));
    mrb_define_class_method(mrb, rclass, "create_with_full_screen", ruby_cocos2dx_GLViewImpl_createWithFullScreen_static, ARGS_REQ(1));
}
mrb_value ruby_cocos2dx_AnimationCache_getAnimation(mrb_state* mrb, mrb_value self)
{
    cocos2d::AnimationCache* cobj = static_cast<cocos2d::AnimationCache*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            std::string arg0;
            ok = rubyval_to_std_string(mrb, argv[0], &arg0, "CC::AnimationCache.getAnimation");
            if (!ok) { break; }
            cocos2d::Animation* retval = cobj->getAnimation(arg0);
            mrb_value ret;
            ret = object_to_rubyval<cocos2d::Animation>(mrb, "CC::Animation", (cocos2d::Animation*)retval, nullptr);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::AnimationCache#getAnimation");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_AnimationCache_addAnimation(mrb_state* mrb, mrb_value self)
{
    cocos2d::AnimationCache* cobj = static_cast<cocos2d::AnimationCache*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 2) {
            cocos2d::Animation* arg0;
            ok = rubyval_to_object<cocos2d::Animation>(mrb, argv[0], "CC::Animation", &arg0);
            if (!ok) { break; }
            std::string arg1;
            ok = rubyval_to_std_string(mrb, argv[1], &arg1, "CC::AnimationCache.addAnimation");
            if (!ok) { break; }
            cobj->addAnimation(arg0, arg1);
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::AnimationCache#addAnimation");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_AnimationCache_init(mrb_state* mrb, mrb_value self)
{
    cocos2d::AnimationCache* cobj = static_cast<cocos2d::AnimationCache*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            bool retval = cobj->init();
            mrb_value ret;
            ret = mrb_bool_value((mrb_bool)retval);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::AnimationCache#init");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_AnimationCache_addAnimationsWithDictionary(mrb_state* mrb, mrb_value self)
{
    cocos2d::AnimationCache* cobj = static_cast<cocos2d::AnimationCache*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 2) {
            cocos2d::ValueMap arg0;
            ok = rubyval_to_ccvaluemap(mrb, argv[0], &arg0, "CC::AnimationCache.addAnimationsWithDictionary");
            if (!ok) { break; }
            std::string arg1;
            ok = rubyval_to_std_string(mrb, argv[1], &arg1, "CC::AnimationCache.addAnimationsWithDictionary");
            if (!ok) { break; }
            cobj->addAnimationsWithDictionary(arg0, arg1);
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::AnimationCache#addAnimationsWithDictionary");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_AnimationCache_removeAnimation(mrb_state* mrb, mrb_value self)
{
    cocos2d::AnimationCache* cobj = static_cast<cocos2d::AnimationCache*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            std::string arg0;
            ok = rubyval_to_std_string(mrb, argv[0], &arg0, "CC::AnimationCache.removeAnimation");
            if (!ok) { break; }
            cobj->removeAnimation(arg0);
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::AnimationCache#removeAnimation");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_AnimationCache_addAnimationsWithFile(mrb_state* mrb, mrb_value self)
{
    cocos2d::AnimationCache* cobj = static_cast<cocos2d::AnimationCache*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            std::string arg0;
            ok = rubyval_to_std_string(mrb, argv[0], &arg0, "CC::AnimationCache.addAnimationsWithFile");
            if (!ok) { break; }
            cobj->addAnimationsWithFile(arg0);
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::AnimationCache#addAnimationsWithFile");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_AnimationCache_destroyInstance_static(mrb_state* mrb, mrb_value self)
{
    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            cocos2d::AnimationCache::destroyInstance();
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined static method : cocos2d::AnimationCache#destroyInstance");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_AnimationCache_getInstance_static(mrb_state* mrb, mrb_value self)
{
    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            cocos2d::AnimationCache* retval = cocos2d::AnimationCache::getInstance();
            mrb_value ret;
            ret = object_to_rubyval<cocos2d::AnimationCache>(mrb, "CC::AnimationCache", (cocos2d::AnimationCache*)retval, nullptr);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined static method : cocos2d::AnimationCache#getInstance");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_AnimationCache_constructor(mrb_state* mrb, mrb_value self)
{

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            cocos2d::AnimationCache* cobj = new cocos2d::AnimationCache();
            DATA_TYPE(self) = &ruby_cocos2dx_Ref_type;
            DATA_PTR(self) = cobj;
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::AnimationCache#AnimationCache");

    return mrb_nil_value();
}


void ruby_register_cocos2dx_AnimationCache(mrb_state* mrb, struct RClass* rmodule)
{
    std::string typeName = typeid(cocos2d::AnimationCache).name();
    g_rubyType[typeName] = "CC::AnimationCache";
    g_rubyDataType[typeName] = &ruby_cocos2dx_Ref_type;

    struct RClass* p_rmodule = mrb->object_class;
    p_rmodule = mrb_module_get_under(mrb, p_rmodule, "CC");
    struct RClass* p_rclass = mrb_class_get_under(mrb, p_rmodule, "Ref");
    struct RClass *rclass = mrb_define_class_under(mrb, rmodule, "AnimationCache", p_rclass);
    MRB_SET_INSTANCE_TT(rclass, MRB_TT_DATA);

    mrb_define_method(mrb, rclass, "initialize", ruby_cocos2dx_AnimationCache_constructor, ARGS_NONE());
    mrb_define_method(mrb, rclass, "get_animation", ruby_cocos2dx_AnimationCache_getAnimation, ARGS_REQ(1));
    mrb_define_method(mrb, rclass, "add_animation", ruby_cocos2dx_AnimationCache_addAnimation, ARGS_REQ(2));
    mrb_define_method(mrb, rclass, "init", ruby_cocos2dx_AnimationCache_init, ARGS_NONE());
    mrb_define_method(mrb, rclass, "add_animations_with_dictionary", ruby_cocos2dx_AnimationCache_addAnimationsWithDictionary, ARGS_REQ(2));
    mrb_define_method(mrb, rclass, "remove_animation", ruby_cocos2dx_AnimationCache_removeAnimation, ARGS_REQ(1));
    mrb_define_method(mrb, rclass, "add_animations", ruby_cocos2dx_AnimationCache_addAnimationsWithFile, ARGS_REQ(1));
    mrb_define_class_method(mrb, rclass, "destroy_instance", ruby_cocos2dx_AnimationCache_destroyInstance_static, ARGS_NONE());
    mrb_define_class_method(mrb, rclass, "get_instance", ruby_cocos2dx_AnimationCache_getInstance_static, ARGS_NONE());
}
mrb_value ruby_cocos2dx_SpriteFrameCache_addSpriteFramesWithFileContent(mrb_state* mrb, mrb_value self)
{
    cocos2d::SpriteFrameCache* cobj = static_cast<cocos2d::SpriteFrameCache*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 2) {
            std::string arg0;
            ok = rubyval_to_std_string(mrb, argv[0], &arg0, "CC::SpriteFrameCache.addSpriteFramesWithFileContent");
            if (!ok) { break; }
            cocos2d::Texture2D* arg1;
            ok = rubyval_to_object<cocos2d::Texture2D>(mrb, argv[1], "CC::Texture2D", &arg1);
            if (!ok) { break; }
            cobj->addSpriteFramesWithFileContent(arg0, arg1);
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::SpriteFrameCache#addSpriteFramesWithFileContent");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_SpriteFrameCache_addSpriteFramesWithFile(mrb_state* mrb, mrb_value self)
{
    cocos2d::SpriteFrameCache* cobj = static_cast<cocos2d::SpriteFrameCache*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 2) {
            std::string arg0;
            ok = rubyval_to_std_string(mrb, argv[0], &arg0, "CC::SpriteFrameCache.addSpriteFramesWithFile");
            if (!ok) { break; }
            std::string arg1;
            ok = rubyval_to_std_string(mrb, argv[1], &arg1, "CC::SpriteFrameCache.addSpriteFramesWithFile");
            if (!ok) { break; }
            cobj->addSpriteFramesWithFile(arg0, arg1);
            return self;
        }
    } while (0);
    do {
        if (argc == 1) {
            std::string arg0;
            ok = rubyval_to_std_string(mrb, argv[0], &arg0, "CC::SpriteFrameCache.addSpriteFramesWithFile");
            if (!ok) { break; }
            cobj->addSpriteFramesWithFile(arg0);
            return self;
        }
    } while (0);
    do {
        if (argc == 2) {
            std::string arg0;
            ok = rubyval_to_std_string(mrb, argv[0], &arg0, "CC::SpriteFrameCache.addSpriteFramesWithFile");
            if (!ok) { break; }
            cocos2d::Texture2D* arg1;
            ok = rubyval_to_object<cocos2d::Texture2D>(mrb, argv[1], "CC::Texture2D", &arg1);
            if (!ok) { break; }
            cobj->addSpriteFramesWithFile(arg0, arg1);
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::SpriteFrameCache#addSpriteFramesWithFile");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_SpriteFrameCache_addSpriteFrame(mrb_state* mrb, mrb_value self)
{
    cocos2d::SpriteFrameCache* cobj = static_cast<cocos2d::SpriteFrameCache*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 2) {
            cocos2d::SpriteFrame* arg0;
            ok = rubyval_to_object<cocos2d::SpriteFrame>(mrb, argv[0], "CC::SpriteFrame", &arg0);
            if (!ok) { break; }
            std::string arg1;
            ok = rubyval_to_std_string(mrb, argv[1], &arg1, "CC::SpriteFrameCache.addSpriteFrame");
            if (!ok) { break; }
            cobj->addSpriteFrame(arg0, arg1);
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::SpriteFrameCache#addSpriteFrame");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_SpriteFrameCache_removeUnusedSpriteFrames(mrb_state* mrb, mrb_value self)
{
    cocos2d::SpriteFrameCache* cobj = static_cast<cocos2d::SpriteFrameCache*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            cobj->removeUnusedSpriteFrames();
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::SpriteFrameCache#removeUnusedSpriteFrames");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_SpriteFrameCache_getSpriteFrameByName(mrb_state* mrb, mrb_value self)
{
    cocos2d::SpriteFrameCache* cobj = static_cast<cocos2d::SpriteFrameCache*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            std::string arg0;
            ok = rubyval_to_std_string(mrb, argv[0], &arg0, "CC::SpriteFrameCache.getSpriteFrameByName");
            if (!ok) { break; }
            cocos2d::SpriteFrame* retval = cobj->getSpriteFrameByName(arg0);
            mrb_value ret;
            ret = object_to_rubyval<cocos2d::SpriteFrame>(mrb, "CC::SpriteFrame", (cocos2d::SpriteFrame*)retval, nullptr);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::SpriteFrameCache#getSpriteFrameByName");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_SpriteFrameCache_removeSpriteFramesFromFile(mrb_state* mrb, mrb_value self)
{
    cocos2d::SpriteFrameCache* cobj = static_cast<cocos2d::SpriteFrameCache*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            std::string arg0;
            ok = rubyval_to_std_string(mrb, argv[0], &arg0, "CC::SpriteFrameCache.removeSpriteFramesFromFile");
            if (!ok) { break; }
            cobj->removeSpriteFramesFromFile(arg0);
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::SpriteFrameCache#removeSpriteFramesFromFile");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_SpriteFrameCache_init(mrb_state* mrb, mrb_value self)
{
    cocos2d::SpriteFrameCache* cobj = static_cast<cocos2d::SpriteFrameCache*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            bool retval = cobj->init();
            mrb_value ret;
            ret = mrb_bool_value((mrb_bool)retval);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::SpriteFrameCache#init");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_SpriteFrameCache_removeSpriteFrames(mrb_state* mrb, mrb_value self)
{
    cocos2d::SpriteFrameCache* cobj = static_cast<cocos2d::SpriteFrameCache*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            cobj->removeSpriteFrames();
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::SpriteFrameCache#removeSpriteFrames");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_SpriteFrameCache_removeSpriteFramesFromTexture(mrb_state* mrb, mrb_value self)
{
    cocos2d::SpriteFrameCache* cobj = static_cast<cocos2d::SpriteFrameCache*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            cocos2d::Texture2D* arg0;
            ok = rubyval_to_object<cocos2d::Texture2D>(mrb, argv[0], "CC::Texture2D", &arg0);
            if (!ok) { break; }
            cobj->removeSpriteFramesFromTexture(arg0);
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::SpriteFrameCache#removeSpriteFramesFromTexture");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_SpriteFrameCache_removeSpriteFramesFromFileContent(mrb_state* mrb, mrb_value self)
{
    cocos2d::SpriteFrameCache* cobj = static_cast<cocos2d::SpriteFrameCache*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            std::string arg0;
            ok = rubyval_to_std_string(mrb, argv[0], &arg0, "CC::SpriteFrameCache.removeSpriteFramesFromFileContent");
            if (!ok) { break; }
            cobj->removeSpriteFramesFromFileContent(arg0);
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::SpriteFrameCache#removeSpriteFramesFromFileContent");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_SpriteFrameCache_removeSpriteFrameByName(mrb_state* mrb, mrb_value self)
{
    cocos2d::SpriteFrameCache* cobj = static_cast<cocos2d::SpriteFrameCache*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            std::string arg0;
            ok = rubyval_to_std_string(mrb, argv[0], &arg0, "CC::SpriteFrameCache.removeSpriteFrameByName");
            if (!ok) { break; }
            cobj->removeSpriteFrameByName(arg0);
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::SpriteFrameCache#removeSpriteFrameByName");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_SpriteFrameCache_destroyInstance_static(mrb_state* mrb, mrb_value self)
{
    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            cocos2d::SpriteFrameCache::destroyInstance();
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined static method : cocos2d::SpriteFrameCache#destroyInstance");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_SpriteFrameCache_getInstance_static(mrb_state* mrb, mrb_value self)
{
    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            cocos2d::SpriteFrameCache* retval = cocos2d::SpriteFrameCache::getInstance();
            mrb_value ret;
            ret = object_to_rubyval<cocos2d::SpriteFrameCache>(mrb, "CC::SpriteFrameCache", (cocos2d::SpriteFrameCache*)retval, nullptr);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined static method : cocos2d::SpriteFrameCache#getInstance");

    return mrb_nil_value();
}

void ruby_register_cocos2dx_SpriteFrameCache(mrb_state* mrb, struct RClass* rmodule)
{
    std::string typeName = typeid(cocos2d::SpriteFrameCache).name();
    g_rubyType[typeName] = "CC::SpriteFrameCache";
    g_rubyDataType[typeName] = &ruby_cocos2dx_Ref_type;

    struct RClass* p_rmodule = mrb->object_class;
    p_rmodule = mrb_module_get_under(mrb, p_rmodule, "CC");
    struct RClass* p_rclass = mrb_class_get_under(mrb, p_rmodule, "Ref");
    struct RClass *rclass = mrb_define_class_under(mrb, rmodule, "SpriteFrameCache", p_rclass);
    MRB_SET_INSTANCE_TT(rclass, MRB_TT_DATA);

    mrb_define_method(mrb, rclass, "add_sprite_frames_with_file_content", ruby_cocos2dx_SpriteFrameCache_addSpriteFramesWithFileContent, ARGS_REQ(2));
    mrb_define_method(mrb, rclass, "add_sprite_frames", ruby_cocos2dx_SpriteFrameCache_addSpriteFramesWithFile, ARGS_REQ(1)|ARGS_OPT(1));
    mrb_define_method(mrb, rclass, "add_sprite_frame", ruby_cocos2dx_SpriteFrameCache_addSpriteFrame, ARGS_REQ(2));
    mrb_define_method(mrb, rclass, "remove_unused_sprite_frames", ruby_cocos2dx_SpriteFrameCache_removeUnusedSpriteFrames, ARGS_NONE());
    mrb_define_method(mrb, rclass, "get_sprite_frame", ruby_cocos2dx_SpriteFrameCache_getSpriteFrameByName, ARGS_REQ(1));
    mrb_define_method(mrb, rclass, "remove_sprite_frames_from_file", ruby_cocos2dx_SpriteFrameCache_removeSpriteFramesFromFile, ARGS_REQ(1));
    mrb_define_method(mrb, rclass, "init", ruby_cocos2dx_SpriteFrameCache_init, ARGS_NONE());
    mrb_define_method(mrb, rclass, "remove_sprite_frames", ruby_cocos2dx_SpriteFrameCache_removeSpriteFrames, ARGS_NONE());
    mrb_define_method(mrb, rclass, "remove_sprite_frames_from_texture", ruby_cocos2dx_SpriteFrameCache_removeSpriteFramesFromTexture, ARGS_REQ(1));
    mrb_define_method(mrb, rclass, "remove_sprite_frames_from_file_content", ruby_cocos2dx_SpriteFrameCache_removeSpriteFramesFromFileContent, ARGS_REQ(1));
    mrb_define_method(mrb, rclass, "remove_sprite_frame_by_name", ruby_cocos2dx_SpriteFrameCache_removeSpriteFrameByName, ARGS_REQ(1));
    mrb_define_class_method(mrb, rclass, "destroy_instance", ruby_cocos2dx_SpriteFrameCache_destroyInstance_static, ARGS_NONE());
    mrb_define_class_method(mrb, rclass, "get_instance", ruby_cocos2dx_SpriteFrameCache_getInstance_static, ARGS_NONE());
}
mrb_value ruby_cocos2dx_ParallaxNode_addChild(mrb_state* mrb, mrb_value self)
{
    cocos2d::ParallaxNode* cobj = static_cast<cocos2d::ParallaxNode*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 4) {
            cocos2d::Node* arg0;
            ok = rubyval_to_object<cocos2d::Node>(mrb, argv[0], "CC::Node", &arg0);
            if (!ok) { break; }
            int arg1;
            ok = rubyval_to_int32(mrb, argv[1], (int*)&arg1, "CC::ParallaxNode.addChild");
            if (!ok) { break; }
            cocos2d::Vec2* arg2;
            ok = rubyval_to_object<cocos2d::Vec2>(mrb, argv[2], "CC::Vec2", &arg2);
            if (!ok) { break; }
            cocos2d::Vec2* arg3;
            ok = rubyval_to_object<cocos2d::Vec2>(mrb, argv[3], "CC::Vec2", &arg3);
            if (!ok) { break; }
            cobj->addChild(arg0, arg1, *arg2, *arg3);
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::ParallaxNode#addChild");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_ParallaxNode_removeAllChildrenWithCleanup(mrb_state* mrb, mrb_value self)
{
    cocos2d::ParallaxNode* cobj = static_cast<cocos2d::ParallaxNode*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            bool arg0;
            ok = rubyval_to_boolean(mrb, argv[0], &arg0, "CC::ParallaxNode.removeAllChildrenWithCleanup");
            if (!ok) { break; }
            cobj->removeAllChildrenWithCleanup(arg0);
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::ParallaxNode#removeAllChildrenWithCleanup");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_ParallaxNode_create_static(mrb_state* mrb, mrb_value self)
{
    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            std::map<std::string, mrb_value> callbacks;
            cocos2d::ParallaxNode* retval = cocos2d::ParallaxNode::create();
            mrb_value ret;
            RClass* rclass = mrb_class_ptr(self);
            ret = object_to_rubyval<cocos2d::ParallaxNode>(mrb, "CC::ParallaxNode", (cocos2d::ParallaxNode*)retval, rclass);
            if (callbacks.size() > 0) {
                mrb_value hash = mrb_iv_get(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"));
                if (!mrb_hash_p(hash)) {
                    hash = mrb_hash_new(mrb);
                }
                for (auto elm : callbacks) {
                    mrb_hash_set(mrb, hash, mrb_str_new_cstr(mrb, elm.first.c_str()), elm.second);
                    mrb_iv_set(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"), hash);
                }
            }
            g_rubyValue.push_back(ret);
            mrb_funcall(mrb, ret, "initialize", 0);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined static method : cocos2d::ParallaxNode#create");

    return mrb_nil_value();
}

void ruby_register_cocos2dx_ParallaxNode(mrb_state* mrb, struct RClass* rmodule)
{
    std::string typeName = typeid(cocos2d::ParallaxNode).name();
    g_rubyType[typeName] = "CC::ParallaxNode";
    g_rubyDataType[typeName] = &ruby_cocos2dx_Ref_type;

    struct RClass* p_rmodule = mrb->object_class;
    p_rmodule = mrb_module_get_under(mrb, p_rmodule, "CC");
    struct RClass* p_rclass = mrb_class_get_under(mrb, p_rmodule, "Node");
    struct RClass *rclass = mrb_define_class_under(mrb, rmodule, "ParallaxNode", p_rclass);
    MRB_SET_INSTANCE_TT(rclass, MRB_TT_DATA);

    mrb_define_method(mrb, rclass, "add_child", ruby_cocos2dx_ParallaxNode_addChild, ARGS_REQ(4));
    mrb_define_method(mrb, rclass, "remove_all_children_with_cleanup", ruby_cocos2dx_ParallaxNode_removeAllChildrenWithCleanup, ARGS_REQ(1));
    mrb_define_class_method(mrb, rclass, "create", ruby_cocos2dx_ParallaxNode_create_static, ARGS_NONE());
}
mrb_value ruby_cocos2dx_TMXObjectGroup_setPositionOffset(mrb_state* mrb, mrb_value self)
{
    cocos2d::TMXObjectGroup* cobj = static_cast<cocos2d::TMXObjectGroup*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            cocos2d::Vec2* arg0;
            ok = rubyval_to_object<cocos2d::Vec2>(mrb, argv[0], "CC::Vec2", &arg0);
            if (!ok) { break; }
            cobj->setPositionOffset(*arg0);
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::TMXObjectGroup#setPositionOffset");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_TMXObjectGroup_getProperty(mrb_state* mrb, mrb_value self)
{
    cocos2d::TMXObjectGroup* cobj = static_cast<cocos2d::TMXObjectGroup*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            std::string arg0;
            ok = rubyval_to_std_string(mrb, argv[0], &arg0, "CC::TMXObjectGroup.getProperty");
            if (!ok) { break; }
            cocos2d::Value retval = cobj->getProperty(arg0);
            mrb_value ret;
            ret = ccvalue_to_rubyval(mrb, retval);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::TMXObjectGroup#getProperty");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_TMXObjectGroup_getPositionOffset(mrb_state* mrb, mrb_value self)
{
    cocos2d::TMXObjectGroup* cobj = static_cast<cocos2d::TMXObjectGroup*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            cocos2d::Vec2 retval = cobj->getPositionOffset();
            cocos2d::Vec2* retval_ptr = new cocos2d::Vec2(retval);
            mrb_value ret;
            ret = object_to_rubyval<cocos2d::Vec2>(mrb, "CC::Vec2", (cocos2d::Vec2*)retval_ptr, nullptr);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::TMXObjectGroup#getPositionOffset");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_TMXObjectGroup_getObject(mrb_state* mrb, mrb_value self)
{
    cocos2d::TMXObjectGroup* cobj = static_cast<cocos2d::TMXObjectGroup*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            std::string arg0;
            ok = rubyval_to_std_string(mrb, argv[0], &arg0, "CC::TMXObjectGroup.getObject");
            if (!ok) { break; }
            cocos2d::ValueMap retval = cobj->getObject(arg0);
            mrb_value ret;
            ret = ccvaluemap_to_rubyval(mrb, retval);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::TMXObjectGroup#getObject");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_TMXObjectGroup_getObjects(mrb_state* mrb, mrb_value self)
{
    cocos2d::TMXObjectGroup* cobj = static_cast<cocos2d::TMXObjectGroup*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            cocos2d::ValueVector retval = cobj->getObjects();
            mrb_value ret;
            ret = ccvaluevector_to_rubyval(mrb, retval);
            return ret;
        }
    } while (0);
    do {
        if (argc == 0) {
            cocos2d::ValueVector retval = cobj->getObjects();
            mrb_value ret;
            ret = ccvaluevector_to_rubyval(mrb, retval);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::TMXObjectGroup#getObjects");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_TMXObjectGroup_setGroupName(mrb_state* mrb, mrb_value self)
{
    cocos2d::TMXObjectGroup* cobj = static_cast<cocos2d::TMXObjectGroup*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            std::string arg0;
            ok = rubyval_to_std_string(mrb, argv[0], &arg0, "CC::TMXObjectGroup.setGroupName");
            if (!ok) { break; }
            cobj->setGroupName(arg0);
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::TMXObjectGroup#setGroupName");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_TMXObjectGroup_getProperties(mrb_state* mrb, mrb_value self)
{
    cocos2d::TMXObjectGroup* cobj = static_cast<cocos2d::TMXObjectGroup*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            cocos2d::ValueMap retval = cobj->getProperties();
            mrb_value ret;
            ret = ccvaluemap_to_rubyval(mrb, retval);
            return ret;
        }
    } while (0);
    do {
        if (argc == 0) {
            cocos2d::ValueMap retval = cobj->getProperties();
            mrb_value ret;
            ret = ccvaluemap_to_rubyval(mrb, retval);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::TMXObjectGroup#getProperties");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_TMXObjectGroup_getGroupName(mrb_state* mrb, mrb_value self)
{
    cocos2d::TMXObjectGroup* cobj = static_cast<cocos2d::TMXObjectGroup*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            std::string retval = cobj->getGroupName();
            mrb_value ret;
            ret = mrb_str_new_cstr(mrb, retval.c_str());
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::TMXObjectGroup#getGroupName");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_TMXObjectGroup_setProperties(mrb_state* mrb, mrb_value self)
{
    cocos2d::TMXObjectGroup* cobj = static_cast<cocos2d::TMXObjectGroup*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            cocos2d::ValueMap arg0;
            ok = rubyval_to_ccvaluemap(mrb, argv[0], &arg0, "CC::TMXObjectGroup.setProperties");
            if (!ok) { break; }
            cobj->setProperties(arg0);
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::TMXObjectGroup#setProperties");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_TMXObjectGroup_setObjects(mrb_state* mrb, mrb_value self)
{
    cocos2d::TMXObjectGroup* cobj = static_cast<cocos2d::TMXObjectGroup*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            cocos2d::ValueVector arg0;
            ok = rubyval_to_ccvaluevector(mrb, argv[0], &arg0, "CC::TMXObjectGroup.setObjects");
            if (!ok) { break; }
            cobj->setObjects(arg0);
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::TMXObjectGroup#setObjects");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_TMXObjectGroup_constructor(mrb_state* mrb, mrb_value self)
{

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            cocos2d::TMXObjectGroup* cobj = new cocos2d::TMXObjectGroup();
            DATA_TYPE(self) = &ruby_cocos2dx_Ref_type;
            DATA_PTR(self) = cobj;
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::TMXObjectGroup#TMXObjectGroup");

    return mrb_nil_value();
}


void ruby_register_cocos2dx_TMXObjectGroup(mrb_state* mrb, struct RClass* rmodule)
{
    std::string typeName = typeid(cocos2d::TMXObjectGroup).name();
    g_rubyType[typeName] = "CC::TMXObjectGroup";
    g_rubyDataType[typeName] = &ruby_cocos2dx_Ref_type;

    struct RClass* p_rmodule = mrb->object_class;
    p_rmodule = mrb_module_get_under(mrb, p_rmodule, "CC");
    struct RClass* p_rclass = mrb_class_get_under(mrb, p_rmodule, "Ref");
    struct RClass *rclass = mrb_define_class_under(mrb, rmodule, "TMXObjectGroup", p_rclass);
    MRB_SET_INSTANCE_TT(rclass, MRB_TT_DATA);

    mrb_define_method(mrb, rclass, "initialize", ruby_cocos2dx_TMXObjectGroup_constructor, ARGS_NONE());
    mrb_define_method(mrb, rclass, "set_position_offset", ruby_cocos2dx_TMXObjectGroup_setPositionOffset, ARGS_REQ(1));
    mrb_define_method(mrb, rclass, "get_property", ruby_cocos2dx_TMXObjectGroup_getProperty, ARGS_REQ(1));
    mrb_define_method(mrb, rclass, "get_position_offset", ruby_cocos2dx_TMXObjectGroup_getPositionOffset, ARGS_NONE());
    mrb_define_method(mrb, rclass, "get_object", ruby_cocos2dx_TMXObjectGroup_getObject, ARGS_REQ(1));
    mrb_define_method(mrb, rclass, "get_objects", ruby_cocos2dx_TMXObjectGroup_getObjects, ARGS_NONE());
    mrb_define_method(mrb, rclass, "set_group_name", ruby_cocos2dx_TMXObjectGroup_setGroupName, ARGS_REQ(1));
    mrb_define_method(mrb, rclass, "get_properties", ruby_cocos2dx_TMXObjectGroup_getProperties, ARGS_NONE());
    mrb_define_method(mrb, rclass, "get_group_name", ruby_cocos2dx_TMXObjectGroup_getGroupName, ARGS_NONE());
    mrb_define_method(mrb, rclass, "set_properties", ruby_cocos2dx_TMXObjectGroup_setProperties, ARGS_REQ(1));
    mrb_define_method(mrb, rclass, "set_objects", ruby_cocos2dx_TMXObjectGroup_setObjects, ARGS_REQ(1));
}
mrb_value ruby_cocos2dx_TMXLayerInfo_setProperties(mrb_state* mrb, mrb_value self)
{
    cocos2d::TMXLayerInfo* cobj = static_cast<cocos2d::TMXLayerInfo*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            cocos2d::ValueMap arg0;
            ok = rubyval_to_ccvaluemap(mrb, argv[0], &arg0, "CC::TMXLayerInfo.setProperties");
            if (!ok) { break; }
            cobj->setProperties(arg0);
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::TMXLayerInfo#setProperties");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_TMXLayerInfo_getProperties(mrb_state* mrb, mrb_value self)
{
    cocos2d::TMXLayerInfo* cobj = static_cast<cocos2d::TMXLayerInfo*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            cocos2d::ValueMap retval = cobj->getProperties();
            mrb_value ret;
            ret = ccvaluemap_to_rubyval(mrb, retval);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::TMXLayerInfo#getProperties");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_TMXLayerInfo_constructor(mrb_state* mrb, mrb_value self)
{

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            cocos2d::TMXLayerInfo* cobj = new cocos2d::TMXLayerInfo();
            DATA_TYPE(self) = &ruby_cocos2dx_Ref_type;
            DATA_PTR(self) = cobj;
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::TMXLayerInfo#TMXLayerInfo");

    return mrb_nil_value();
}


void ruby_register_cocos2dx_TMXLayerInfo(mrb_state* mrb, struct RClass* rmodule)
{
    std::string typeName = typeid(cocos2d::TMXLayerInfo).name();
    g_rubyType[typeName] = "CC::TMXLayerInfo";
    g_rubyDataType[typeName] = &ruby_cocos2dx_Ref_type;

    struct RClass* p_rmodule = mrb->object_class;
    p_rmodule = mrb_module_get_under(mrb, p_rmodule, "CC");
    struct RClass* p_rclass = mrb_class_get_under(mrb, p_rmodule, "Ref");
    struct RClass *rclass = mrb_define_class_under(mrb, rmodule, "TMXLayerInfo", p_rclass);
    MRB_SET_INSTANCE_TT(rclass, MRB_TT_DATA);

    mrb_define_method(mrb, rclass, "initialize", ruby_cocos2dx_TMXLayerInfo_constructor, ARGS_NONE());
    mrb_define_method(mrb, rclass, "set_properties", ruby_cocos2dx_TMXLayerInfo_setProperties, ARGS_REQ(1));
    mrb_define_method(mrb, rclass, "get_properties", ruby_cocos2dx_TMXLayerInfo_getProperties, ARGS_NONE());
}
mrb_value ruby_cocos2dx_TMXTilesetInfo_getRectForGID(mrb_state* mrb, mrb_value self)
{
    cocos2d::TMXTilesetInfo* cobj = static_cast<cocos2d::TMXTilesetInfo*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            unsigned int arg0;
            ok = rubyval_to_uint32(mrb, argv[0], &arg0, "CC::TMXTilesetInfo.getRectForGID");
            if (!ok) { break; }
            cocos2d::Rect retval = cobj->getRectForGID(arg0);
            cocos2d::Rect* retval_ptr = new cocos2d::Rect(retval);
            mrb_value ret;
            ret = object_to_rubyval<cocos2d::Rect>(mrb, "CC::Rect", (cocos2d::Rect*)retval_ptr, nullptr);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::TMXTilesetInfo#getRectForGID");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_TMXTilesetInfo_constructor(mrb_state* mrb, mrb_value self)
{

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            cocos2d::TMXTilesetInfo* cobj = new cocos2d::TMXTilesetInfo();
            DATA_TYPE(self) = &ruby_cocos2dx_Ref_type;
            DATA_PTR(self) = cobj;
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::TMXTilesetInfo#TMXTilesetInfo");

    return mrb_nil_value();
}


void ruby_register_cocos2dx_TMXTilesetInfo(mrb_state* mrb, struct RClass* rmodule)
{
    std::string typeName = typeid(cocos2d::TMXTilesetInfo).name();
    g_rubyType[typeName] = "CC::TMXTilesetInfo";
    g_rubyDataType[typeName] = &ruby_cocos2dx_Ref_type;

    struct RClass* p_rmodule = mrb->object_class;
    p_rmodule = mrb_module_get_under(mrb, p_rmodule, "CC");
    struct RClass* p_rclass = mrb_class_get_under(mrb, p_rmodule, "Ref");
    struct RClass *rclass = mrb_define_class_under(mrb, rmodule, "TMXTilesetInfo", p_rclass);
    MRB_SET_INSTANCE_TT(rclass, MRB_TT_DATA);

    mrb_define_method(mrb, rclass, "initialize", ruby_cocos2dx_TMXTilesetInfo_constructor, ARGS_NONE());
    mrb_define_method(mrb, rclass, "get_rect_for_gid", ruby_cocos2dx_TMXTilesetInfo_getRectForGID, ARGS_REQ(1));
}
mrb_value ruby_cocos2dx_TMXMapInfo_setObjectGroups(mrb_state* mrb, mrb_value self)
{
    cocos2d::TMXMapInfo* cobj = static_cast<cocos2d::TMXMapInfo*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            cocos2d::Vector<cocos2d::TMXObjectGroup *> arg0;
            ok = rubyval_to_ccvector(mrb, argv[0], &arg0, "CC::TMXMapInfo.setObjectGroups");
            if (!ok) { break; }
            cobj->setObjectGroups(arg0);
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::TMXMapInfo#setObjectGroups");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_TMXMapInfo_setTileSize(mrb_state* mrb, mrb_value self)
{
    cocos2d::TMXMapInfo* cobj = static_cast<cocos2d::TMXMapInfo*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            cocos2d::Size* arg0;
            ok = rubyval_to_object<cocos2d::Size>(mrb, argv[0], "CC::Size", &arg0);
            if (!ok) { break; }
            cobj->setTileSize(*arg0);
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::TMXMapInfo#setTileSize");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_TMXMapInfo_initWithTMXFile(mrb_state* mrb, mrb_value self)
{
    cocos2d::TMXMapInfo* cobj = static_cast<cocos2d::TMXMapInfo*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            std::string arg0;
            ok = rubyval_to_std_string(mrb, argv[0], &arg0, "CC::TMXMapInfo.initWithTMXFile");
            if (!ok) { break; }
            bool retval = cobj->initWithTMXFile(arg0);
            mrb_value ret;
            ret = mrb_bool_value((mrb_bool)retval);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::TMXMapInfo#initWithTMXFile");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_TMXMapInfo_getOrientation(mrb_state* mrb, mrb_value self)
{
    cocos2d::TMXMapInfo* cobj = static_cast<cocos2d::TMXMapInfo*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            int retval = cobj->getOrientation();
            mrb_value ret;
            ret = mrb_fixnum_value((mrb_int)retval);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::TMXMapInfo#getOrientation");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_TMXMapInfo_isStoringCharacters(mrb_state* mrb, mrb_value self)
{
    cocos2d::TMXMapInfo* cobj = static_cast<cocos2d::TMXMapInfo*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            bool retval = cobj->isStoringCharacters();
            mrb_value ret;
            ret = mrb_bool_value((mrb_bool)retval);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::TMXMapInfo#isStoringCharacters");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_TMXMapInfo_setLayers(mrb_state* mrb, mrb_value self)
{
    cocos2d::TMXMapInfo* cobj = static_cast<cocos2d::TMXMapInfo*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            cocos2d::Vector<cocos2d::TMXLayerInfo *> arg0;
            ok = rubyval_to_ccvector(mrb, argv[0], &arg0, "CC::TMXMapInfo.setLayers");
            if (!ok) { break; }
            cobj->setLayers(arg0);
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::TMXMapInfo#setLayers");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_TMXMapInfo_parseXMLFile(mrb_state* mrb, mrb_value self)
{
    cocos2d::TMXMapInfo* cobj = static_cast<cocos2d::TMXMapInfo*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            std::string arg0;
            ok = rubyval_to_std_string(mrb, argv[0], &arg0, "CC::TMXMapInfo.parseXMLFile");
            if (!ok) { break; }
            bool retval = cobj->parseXMLFile(arg0);
            mrb_value ret;
            ret = mrb_bool_value((mrb_bool)retval);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::TMXMapInfo#parseXMLFile");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_TMXMapInfo_getParentElement(mrb_state* mrb, mrb_value self)
{
    cocos2d::TMXMapInfo* cobj = static_cast<cocos2d::TMXMapInfo*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            int retval = cobj->getParentElement();
            mrb_value ret;
            ret = mrb_fixnum_value((mrb_int)retval);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::TMXMapInfo#getParentElement");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_TMXMapInfo_setTMXFileName(mrb_state* mrb, mrb_value self)
{
    cocos2d::TMXMapInfo* cobj = static_cast<cocos2d::TMXMapInfo*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            std::string arg0;
            ok = rubyval_to_std_string(mrb, argv[0], &arg0, "CC::TMXMapInfo.setTMXFileName");
            if (!ok) { break; }
            cobj->setTMXFileName(arg0);
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::TMXMapInfo#setTMXFileName");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_TMXMapInfo_parseXMLString(mrb_state* mrb, mrb_value self)
{
    cocos2d::TMXMapInfo* cobj = static_cast<cocos2d::TMXMapInfo*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            std::string arg0;
            ok = rubyval_to_std_string(mrb, argv[0], &arg0, "CC::TMXMapInfo.parseXMLString");
            if (!ok) { break; }
            bool retval = cobj->parseXMLString(arg0);
            mrb_value ret;
            ret = mrb_bool_value((mrb_bool)retval);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::TMXMapInfo#parseXMLString");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_TMXMapInfo_getLayers(mrb_state* mrb, mrb_value self)
{
    cocos2d::TMXMapInfo* cobj = static_cast<cocos2d::TMXMapInfo*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            cocos2d::Vector<cocos2d::TMXLayerInfo *> retval = cobj->getLayers();
            mrb_value ret;
            ret = ccvector_to_rubyval(mrb, retval);
            return ret;
        }
    } while (0);
    do {
        if (argc == 0) {
            cocos2d::Vector<cocos2d::TMXLayerInfo *> retval = cobj->getLayers();
            mrb_value ret;
            ret = ccvector_to_rubyval(mrb, retval);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::TMXMapInfo#getLayers");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_TMXMapInfo_getTilesets(mrb_state* mrb, mrb_value self)
{
    cocos2d::TMXMapInfo* cobj = static_cast<cocos2d::TMXMapInfo*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            cocos2d::Vector<cocos2d::TMXTilesetInfo *> retval = cobj->getTilesets();
            mrb_value ret;
            ret = ccvector_to_rubyval(mrb, retval);
            return ret;
        }
    } while (0);
    do {
        if (argc == 0) {
            cocos2d::Vector<cocos2d::TMXTilesetInfo *> retval = cobj->getTilesets();
            mrb_value ret;
            ret = ccvector_to_rubyval(mrb, retval);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::TMXMapInfo#getTilesets");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_TMXMapInfo_getParentGID(mrb_state* mrb, mrb_value self)
{
    cocos2d::TMXMapInfo* cobj = static_cast<cocos2d::TMXMapInfo*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            int retval = cobj->getParentGID();
            mrb_value ret;
            ret = mrb_fixnum_value((mrb_int)retval);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::TMXMapInfo#getParentGID");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_TMXMapInfo_setParentElement(mrb_state* mrb, mrb_value self)
{
    cocos2d::TMXMapInfo* cobj = static_cast<cocos2d::TMXMapInfo*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            int arg0;
            ok = rubyval_to_int32(mrb, argv[0], (int*)&arg0, "CC::TMXMapInfo.setParentElement");
            if (!ok) { break; }
            cobj->setParentElement(arg0);
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::TMXMapInfo#setParentElement");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_TMXMapInfo_initWithXML(mrb_state* mrb, mrb_value self)
{
    cocos2d::TMXMapInfo* cobj = static_cast<cocos2d::TMXMapInfo*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 2) {
            std::string arg0;
            ok = rubyval_to_std_string(mrb, argv[0], &arg0, "CC::TMXMapInfo.initWithXML");
            if (!ok) { break; }
            std::string arg1;
            ok = rubyval_to_std_string(mrb, argv[1], &arg1, "CC::TMXMapInfo.initWithXML");
            if (!ok) { break; }
            bool retval = cobj->initWithXML(arg0, arg1);
            mrb_value ret;
            ret = mrb_bool_value((mrb_bool)retval);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::TMXMapInfo#initWithXML");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_TMXMapInfo_setParentGID(mrb_state* mrb, mrb_value self)
{
    cocos2d::TMXMapInfo* cobj = static_cast<cocos2d::TMXMapInfo*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            int arg0;
            ok = rubyval_to_int32(mrb, argv[0], (int*)&arg0, "CC::TMXMapInfo.setParentGID");
            if (!ok) { break; }
            cobj->setParentGID(arg0);
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::TMXMapInfo#setParentGID");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_TMXMapInfo_getLayerAttribs(mrb_state* mrb, mrb_value self)
{
    cocos2d::TMXMapInfo* cobj = static_cast<cocos2d::TMXMapInfo*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            int retval = cobj->getLayerAttribs();
            mrb_value ret;
            ret = mrb_fixnum_value((mrb_int)retval);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::TMXMapInfo#getLayerAttribs");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_TMXMapInfo_getTileSize(mrb_state* mrb, mrb_value self)
{
    cocos2d::TMXMapInfo* cobj = static_cast<cocos2d::TMXMapInfo*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            cocos2d::Size retval = cobj->getTileSize();
            cocos2d::Size* retval_ptr = new cocos2d::Size(retval);
            mrb_value ret;
            ret = object_to_rubyval<cocos2d::Size>(mrb, "CC::Size", (cocos2d::Size*)retval_ptr, nullptr);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::TMXMapInfo#getTileSize");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_TMXMapInfo_getTileProperties(mrb_state* mrb, mrb_value self)
{
    cocos2d::TMXMapInfo* cobj = static_cast<cocos2d::TMXMapInfo*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            cocos2d::ValueMapIntKey retval = cobj->getTileProperties();
            mrb_value ret;
            ret = ccvaluemapintkey_to_rubyval(mrb, retval);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::TMXMapInfo#getTileProperties");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_TMXMapInfo_getObjectGroups(mrb_state* mrb, mrb_value self)
{
    cocos2d::TMXMapInfo* cobj = static_cast<cocos2d::TMXMapInfo*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            cocos2d::Vector<cocos2d::TMXObjectGroup *> retval = cobj->getObjectGroups();
            mrb_value ret;
            ret = ccvector_to_rubyval(mrb, retval);
            return ret;
        }
    } while (0);
    do {
        if (argc == 0) {
            cocos2d::Vector<cocos2d::TMXObjectGroup *> retval = cobj->getObjectGroups();
            mrb_value ret;
            ret = ccvector_to_rubyval(mrb, retval);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::TMXMapInfo#getObjectGroups");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_TMXMapInfo_getTMXFileName(mrb_state* mrb, mrb_value self)
{
    cocos2d::TMXMapInfo* cobj = static_cast<cocos2d::TMXMapInfo*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            std::string retval = cobj->getTMXFileName();
            mrb_value ret;
            ret = mrb_str_new_cstr(mrb, retval.c_str());
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::TMXMapInfo#getTMXFileName");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_TMXMapInfo_setCurrentString(mrb_state* mrb, mrb_value self)
{
    cocos2d::TMXMapInfo* cobj = static_cast<cocos2d::TMXMapInfo*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            std::string arg0;
            ok = rubyval_to_std_string(mrb, argv[0], &arg0, "CC::TMXMapInfo.setCurrentString");
            if (!ok) { break; }
            cobj->setCurrentString(arg0);
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::TMXMapInfo#setCurrentString");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_TMXMapInfo_setProperties(mrb_state* mrb, mrb_value self)
{
    cocos2d::TMXMapInfo* cobj = static_cast<cocos2d::TMXMapInfo*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            cocos2d::ValueMap arg0;
            ok = rubyval_to_ccvaluemap(mrb, argv[0], &arg0, "CC::TMXMapInfo.setProperties");
            if (!ok) { break; }
            cobj->setProperties(arg0);
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::TMXMapInfo#setProperties");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_TMXMapInfo_setOrientation(mrb_state* mrb, mrb_value self)
{
    cocos2d::TMXMapInfo* cobj = static_cast<cocos2d::TMXMapInfo*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            int arg0;
            ok = rubyval_to_int32(mrb, argv[0], (int*)&arg0, "CC::TMXMapInfo.setOrientation");
            if (!ok) { break; }
            cobj->setOrientation(arg0);
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::TMXMapInfo#setOrientation");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_TMXMapInfo_setTileProperties(mrb_state* mrb, mrb_value self)
{
    cocos2d::TMXMapInfo* cobj = static_cast<cocos2d::TMXMapInfo*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            cocos2d::ValueMapIntKey arg0;
            ok = rubyval_to_ccvaluemapintkey(mrb, argv[0], &arg0, "CC::TMXMapInfo.setTileProperties");
            if (!ok) { break; }
            cobj->setTileProperties(arg0);
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::TMXMapInfo#setTileProperties");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_TMXMapInfo_setMapSize(mrb_state* mrb, mrb_value self)
{
    cocos2d::TMXMapInfo* cobj = static_cast<cocos2d::TMXMapInfo*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            cocos2d::Size* arg0;
            ok = rubyval_to_object<cocos2d::Size>(mrb, argv[0], "CC::Size", &arg0);
            if (!ok) { break; }
            cobj->setMapSize(*arg0);
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::TMXMapInfo#setMapSize");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_TMXMapInfo_setStoringCharacters(mrb_state* mrb, mrb_value self)
{
    cocos2d::TMXMapInfo* cobj = static_cast<cocos2d::TMXMapInfo*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            bool arg0;
            ok = rubyval_to_boolean(mrb, argv[0], &arg0, "CC::TMXMapInfo.setStoringCharacters");
            if (!ok) { break; }
            cobj->setStoringCharacters(arg0);
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::TMXMapInfo#setStoringCharacters");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_TMXMapInfo_getMapSize(mrb_state* mrb, mrb_value self)
{
    cocos2d::TMXMapInfo* cobj = static_cast<cocos2d::TMXMapInfo*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            cocos2d::Size retval = cobj->getMapSize();
            cocos2d::Size* retval_ptr = new cocos2d::Size(retval);
            mrb_value ret;
            ret = object_to_rubyval<cocos2d::Size>(mrb, "CC::Size", (cocos2d::Size*)retval_ptr, nullptr);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::TMXMapInfo#getMapSize");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_TMXMapInfo_setTilesets(mrb_state* mrb, mrb_value self)
{
    cocos2d::TMXMapInfo* cobj = static_cast<cocos2d::TMXMapInfo*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            cocos2d::Vector<cocos2d::TMXTilesetInfo *> arg0;
            ok = rubyval_to_ccvector(mrb, argv[0], &arg0, "CC::TMXMapInfo.setTilesets");
            if (!ok) { break; }
            cobj->setTilesets(arg0);
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::TMXMapInfo#setTilesets");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_TMXMapInfo_getProperties(mrb_state* mrb, mrb_value self)
{
    cocos2d::TMXMapInfo* cobj = static_cast<cocos2d::TMXMapInfo*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            cocos2d::ValueMap retval = cobj->getProperties();
            mrb_value ret;
            ret = ccvaluemap_to_rubyval(mrb, retval);
            return ret;
        }
    } while (0);
    do {
        if (argc == 0) {
            cocos2d::ValueMap retval = cobj->getProperties();
            mrb_value ret;
            ret = ccvaluemap_to_rubyval(mrb, retval);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::TMXMapInfo#getProperties");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_TMXMapInfo_getCurrentString(mrb_state* mrb, mrb_value self)
{
    cocos2d::TMXMapInfo* cobj = static_cast<cocos2d::TMXMapInfo*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            std::string retval = cobj->getCurrentString();
            mrb_value ret;
            ret = mrb_str_new_cstr(mrb, retval.c_str());
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::TMXMapInfo#getCurrentString");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_TMXMapInfo_setLayerAttribs(mrb_state* mrb, mrb_value self)
{
    cocos2d::TMXMapInfo* cobj = static_cast<cocos2d::TMXMapInfo*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            int arg0;
            ok = rubyval_to_int32(mrb, argv[0], (int*)&arg0, "CC::TMXMapInfo.setLayerAttribs");
            if (!ok) { break; }
            cobj->setLayerAttribs(arg0);
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::TMXMapInfo#setLayerAttribs");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_TMXMapInfo_create_static(mrb_state* mrb, mrb_value self)
{
    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            std::map<std::string, mrb_value> callbacks;
            std::string arg0;
            ok = rubyval_to_std_string(mrb, argv[0], &arg0, "CC::TMXMapInfo.create");
            if (!ok) { break; }

            cocos2d::TMXMapInfo* retval = cocos2d::TMXMapInfo::create(arg0);
            mrb_value ret;
            RClass* rclass = mrb_class_ptr(self);
            ret = object_to_rubyval<cocos2d::TMXMapInfo>(mrb, "CC::TMXMapInfo", (cocos2d::TMXMapInfo*)retval, rclass);
            if (callbacks.size() > 0) {
                mrb_value hash = mrb_iv_get(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"));
                if (!mrb_hash_p(hash)) {
                    hash = mrb_hash_new(mrb);
                }
                for (auto elm : callbacks) {
                    mrb_hash_set(mrb, hash, mrb_str_new_cstr(mrb, elm.first.c_str()), elm.second);
                    mrb_iv_set(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"), hash);
                }
            }
            g_rubyValue.push_back(ret);
            mrb_funcall(mrb, ret, "initialize", 0);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined static method : cocos2d::TMXMapInfo#create");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_TMXMapInfo_createWithXML_static(mrb_state* mrb, mrb_value self)
{
    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 2) {
            std::map<std::string, mrb_value> callbacks;
            std::string arg0;
            ok = rubyval_to_std_string(mrb, argv[0], &arg0, "CC::TMXMapInfo.createWithXML");
            if (!ok) { break; }

            std::string arg1;
            ok = rubyval_to_std_string(mrb, argv[1], &arg1, "CC::TMXMapInfo.createWithXML");
            if (!ok) { break; }

            cocos2d::TMXMapInfo* retval = cocos2d::TMXMapInfo::createWithXML(arg0, arg1);
            mrb_value ret;
            RClass* rclass = mrb_class_ptr(self);
            ret = object_to_rubyval<cocos2d::TMXMapInfo>(mrb, "CC::TMXMapInfo", (cocos2d::TMXMapInfo*)retval, rclass);
            if (callbacks.size() > 0) {
                mrb_value hash = mrb_iv_get(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"));
                if (!mrb_hash_p(hash)) {
                    hash = mrb_hash_new(mrb);
                }
                for (auto elm : callbacks) {
                    mrb_hash_set(mrb, hash, mrb_str_new_cstr(mrb, elm.first.c_str()), elm.second);
                    mrb_iv_set(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"), hash);
                }
            }
            g_rubyValue.push_back(ret);
            mrb_funcall(mrb, ret, "initialize", 0);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined static method : cocos2d::TMXMapInfo#createWithXML");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_TMXMapInfo_constructor(mrb_state* mrb, mrb_value self)
{

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            cocos2d::TMXMapInfo* cobj = new cocos2d::TMXMapInfo();
            DATA_TYPE(self) = &ruby_cocos2dx_Ref_type;
            DATA_PTR(self) = cobj;
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::TMXMapInfo#TMXMapInfo");

    return mrb_nil_value();
}


void ruby_register_cocos2dx_TMXMapInfo(mrb_state* mrb, struct RClass* rmodule)
{
    std::string typeName = typeid(cocos2d::TMXMapInfo).name();
    g_rubyType[typeName] = "CC::TMXMapInfo";
    g_rubyDataType[typeName] = &ruby_cocos2dx_Ref_type;

    struct RClass *rclass = mrb_define_class_under(mrb, rmodule, "TMXMapInfo", mrb->object_class);
    MRB_SET_INSTANCE_TT(rclass, MRB_TT_DATA);

    mrb_define_method(mrb, rclass, "initialize", ruby_cocos2dx_TMXMapInfo_constructor, ARGS_NONE());
    mrb_define_method(mrb, rclass, "set_object_groups", ruby_cocos2dx_TMXMapInfo_setObjectGroups, ARGS_REQ(1));
    mrb_define_method(mrb, rclass, "set_tile_size", ruby_cocos2dx_TMXMapInfo_setTileSize, ARGS_REQ(1));
    mrb_define_method(mrb, rclass, "init_with_tmxfile", ruby_cocos2dx_TMXMapInfo_initWithTMXFile, ARGS_REQ(1));
    mrb_define_method(mrb, rclass, "get_orientation", ruby_cocos2dx_TMXMapInfo_getOrientation, ARGS_NONE());
    mrb_define_method(mrb, rclass, "storing_characters?", ruby_cocos2dx_TMXMapInfo_isStoringCharacters, ARGS_NONE());
    mrb_define_method(mrb, rclass, "set_layers", ruby_cocos2dx_TMXMapInfo_setLayers, ARGS_REQ(1));
    mrb_define_method(mrb, rclass, "parse_xmlfile", ruby_cocos2dx_TMXMapInfo_parseXMLFile, ARGS_REQ(1));
    mrb_define_method(mrb, rclass, "get_parent_element", ruby_cocos2dx_TMXMapInfo_getParentElement, ARGS_NONE());
    mrb_define_method(mrb, rclass, "set_tmxfile_name", ruby_cocos2dx_TMXMapInfo_setTMXFileName, ARGS_REQ(1));
    mrb_define_method(mrb, rclass, "parse_xmlstring", ruby_cocos2dx_TMXMapInfo_parseXMLString, ARGS_REQ(1));
    mrb_define_method(mrb, rclass, "get_layers", ruby_cocos2dx_TMXMapInfo_getLayers, ARGS_NONE());
    mrb_define_method(mrb, rclass, "get_tilesets", ruby_cocos2dx_TMXMapInfo_getTilesets, ARGS_NONE());
    mrb_define_method(mrb, rclass, "get_parent_gid", ruby_cocos2dx_TMXMapInfo_getParentGID, ARGS_NONE());
    mrb_define_method(mrb, rclass, "set_parent_element", ruby_cocos2dx_TMXMapInfo_setParentElement, ARGS_REQ(1));
    mrb_define_method(mrb, rclass, "init_with_xml", ruby_cocos2dx_TMXMapInfo_initWithXML, ARGS_REQ(2));
    mrb_define_method(mrb, rclass, "set_parent_gid", ruby_cocos2dx_TMXMapInfo_setParentGID, ARGS_REQ(1));
    mrb_define_method(mrb, rclass, "get_layer_attribs", ruby_cocos2dx_TMXMapInfo_getLayerAttribs, ARGS_NONE());
    mrb_define_method(mrb, rclass, "get_tile_size", ruby_cocos2dx_TMXMapInfo_getTileSize, ARGS_NONE());
    mrb_define_method(mrb, rclass, "get_tile_properties", ruby_cocos2dx_TMXMapInfo_getTileProperties, ARGS_NONE());
    mrb_define_method(mrb, rclass, "get_object_groups", ruby_cocos2dx_TMXMapInfo_getObjectGroups, ARGS_NONE());
    mrb_define_method(mrb, rclass, "get_tmxfile_name", ruby_cocos2dx_TMXMapInfo_getTMXFileName, ARGS_NONE());
    mrb_define_method(mrb, rclass, "set_current_string", ruby_cocos2dx_TMXMapInfo_setCurrentString, ARGS_REQ(1));
    mrb_define_method(mrb, rclass, "set_properties", ruby_cocos2dx_TMXMapInfo_setProperties, ARGS_REQ(1));
    mrb_define_method(mrb, rclass, "set_orientation", ruby_cocos2dx_TMXMapInfo_setOrientation, ARGS_REQ(1));
    mrb_define_method(mrb, rclass, "set_tile_properties", ruby_cocos2dx_TMXMapInfo_setTileProperties, ARGS_REQ(1));
    mrb_define_method(mrb, rclass, "set_map_size", ruby_cocos2dx_TMXMapInfo_setMapSize, ARGS_REQ(1));
    mrb_define_method(mrb, rclass, "set_storing_characters", ruby_cocos2dx_TMXMapInfo_setStoringCharacters, ARGS_REQ(1));
    mrb_define_method(mrb, rclass, "get_map_size", ruby_cocos2dx_TMXMapInfo_getMapSize, ARGS_NONE());
    mrb_define_method(mrb, rclass, "set_tilesets", ruby_cocos2dx_TMXMapInfo_setTilesets, ARGS_REQ(1));
    mrb_define_method(mrb, rclass, "get_properties", ruby_cocos2dx_TMXMapInfo_getProperties, ARGS_NONE());
    mrb_define_method(mrb, rclass, "get_current_string", ruby_cocos2dx_TMXMapInfo_getCurrentString, ARGS_NONE());
    mrb_define_method(mrb, rclass, "set_layer_attribs", ruby_cocos2dx_TMXMapInfo_setLayerAttribs, ARGS_REQ(1));
    mrb_define_class_method(mrb, rclass, "create", ruby_cocos2dx_TMXMapInfo_create_static, ARGS_REQ(1));
    mrb_define_class_method(mrb, rclass, "create_with_xml", ruby_cocos2dx_TMXMapInfo_createWithXML_static, ARGS_REQ(2));
}
mrb_value ruby_cocos2dx_TMXLayer_getPositionAt(mrb_state* mrb, mrb_value self)
{
    cocos2d::TMXLayer* cobj = static_cast<cocos2d::TMXLayer*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            cocos2d::Vec2* arg0;
            ok = rubyval_to_object<cocos2d::Vec2>(mrb, argv[0], "CC::Vec2", &arg0);
            if (!ok) { break; }
            cocos2d::Vec2 retval = cobj->getPositionAt(*arg0);
            cocos2d::Vec2* retval_ptr = new cocos2d::Vec2(retval);
            mrb_value ret;
            ret = object_to_rubyval<cocos2d::Vec2>(mrb, "CC::Vec2", (cocos2d::Vec2*)retval_ptr, nullptr);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::TMXLayer#getPositionAt");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_TMXLayer_setLayerOrientation(mrb_state* mrb, mrb_value self)
{
    cocos2d::TMXLayer* cobj = static_cast<cocos2d::TMXLayer*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            int arg0;
            ok = rubyval_to_int32(mrb, argv[0], (int*)&arg0, "CC::TMXLayer.setLayerOrientation");
            if (!ok) { break; }
            cobj->setLayerOrientation(arg0);
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::TMXLayer#setLayerOrientation");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_TMXLayer_releaseMap(mrb_state* mrb, mrb_value self)
{
    cocos2d::TMXLayer* cobj = static_cast<cocos2d::TMXLayer*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            cobj->releaseMap();
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::TMXLayer#releaseMap");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_TMXLayer_getLayerSize(mrb_state* mrb, mrb_value self)
{
    cocos2d::TMXLayer* cobj = static_cast<cocos2d::TMXLayer*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            cocos2d::Size retval = cobj->getLayerSize();
            cocos2d::Size* retval_ptr = new cocos2d::Size(retval);
            mrb_value ret;
            ret = object_to_rubyval<cocos2d::Size>(mrb, "CC::Size", (cocos2d::Size*)retval_ptr, nullptr);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::TMXLayer#getLayerSize");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_TMXLayer_setMapTileSize(mrb_state* mrb, mrb_value self)
{
    cocos2d::TMXLayer* cobj = static_cast<cocos2d::TMXLayer*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            cocos2d::Size* arg0;
            ok = rubyval_to_object<cocos2d::Size>(mrb, argv[0], "CC::Size", &arg0);
            if (!ok) { break; }
            cobj->setMapTileSize(*arg0);
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::TMXLayer#setMapTileSize");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_TMXLayer_getLayerOrientation(mrb_state* mrb, mrb_value self)
{
    cocos2d::TMXLayer* cobj = static_cast<cocos2d::TMXLayer*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            int retval = cobj->getLayerOrientation();
            mrb_value ret;
            ret = mrb_fixnum_value((mrb_int)retval);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::TMXLayer#getLayerOrientation");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_TMXLayer_setProperties(mrb_state* mrb, mrb_value self)
{
    cocos2d::TMXLayer* cobj = static_cast<cocos2d::TMXLayer*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            cocos2d::ValueMap arg0;
            ok = rubyval_to_ccvaluemap(mrb, argv[0], &arg0, "CC::TMXLayer.setProperties");
            if (!ok) { break; }
            cobj->setProperties(arg0);
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::TMXLayer#setProperties");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_TMXLayer_setLayerName(mrb_state* mrb, mrb_value self)
{
    cocos2d::TMXLayer* cobj = static_cast<cocos2d::TMXLayer*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            std::string arg0;
            ok = rubyval_to_std_string(mrb, argv[0], &arg0, "CC::TMXLayer.setLayerName");
            if (!ok) { break; }
            cobj->setLayerName(arg0);
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::TMXLayer#setLayerName");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_TMXLayer_removeTileAt(mrb_state* mrb, mrb_value self)
{
    cocos2d::TMXLayer* cobj = static_cast<cocos2d::TMXLayer*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            cocos2d::Vec2* arg0;
            ok = rubyval_to_object<cocos2d::Vec2>(mrb, argv[0], "CC::Vec2", &arg0);
            if (!ok) { break; }
            cobj->removeTileAt(*arg0);
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::TMXLayer#removeTileAt");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_TMXLayer_initWithTilesetInfo(mrb_state* mrb, mrb_value self)
{
    cocos2d::TMXLayer* cobj = static_cast<cocos2d::TMXLayer*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 3) {
            cocos2d::TMXTilesetInfo* arg0;
            ok = rubyval_to_object<cocos2d::TMXTilesetInfo>(mrb, argv[0], "CC::TMXTilesetInfo", &arg0);
            if (!ok) { break; }
            cocos2d::TMXLayerInfo* arg1;
            ok = rubyval_to_object<cocos2d::TMXLayerInfo>(mrb, argv[1], "CC::TMXLayerInfo", &arg1);
            if (!ok) { break; }
            cocos2d::TMXMapInfo* arg2;
            ok = rubyval_to_object<cocos2d::TMXMapInfo>(mrb, argv[2], "CC::TMXMapInfo", &arg2);
            if (!ok) { break; }
            bool retval = cobj->initWithTilesetInfo(arg0, arg1, arg2);
            mrb_value ret;
            ret = mrb_bool_value((mrb_bool)retval);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::TMXLayer#initWithTilesetInfo");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_TMXLayer_setupTiles(mrb_state* mrb, mrb_value self)
{
    cocos2d::TMXLayer* cobj = static_cast<cocos2d::TMXLayer*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            cobj->setupTiles();
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::TMXLayer#setupTiles");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_TMXLayer_setTileGID(mrb_state* mrb, mrb_value self)
{
    cocos2d::TMXLayer* cobj = static_cast<cocos2d::TMXLayer*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 3) {
            unsigned int arg0;
            ok = rubyval_to_uint32(mrb, argv[0], &arg0, "CC::TMXLayer.setTileGID");
            if (!ok) { break; }
            cocos2d::Vec2* arg1;
            ok = rubyval_to_object<cocos2d::Vec2>(mrb, argv[1], "CC::Vec2", &arg1);
            if (!ok) { break; }
            cocos2d::TMXTileFlags_ arg2;
            ok = rubyval_to_int32(mrb, argv[2], (int*)&arg2, "CC::TMXLayer.setTileGID");
            if (!ok) { break; }
            cobj->setTileGID(arg0, *arg1, arg2);
            return self;
        }
    } while (0);
    do {
        if (argc == 2) {
            unsigned int arg0;
            ok = rubyval_to_uint32(mrb, argv[0], &arg0, "CC::TMXLayer.setTileGID");
            if (!ok) { break; }
            cocos2d::Vec2* arg1;
            ok = rubyval_to_object<cocos2d::Vec2>(mrb, argv[1], "CC::Vec2", &arg1);
            if (!ok) { break; }
            cobj->setTileGID(arg0, *arg1);
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::TMXLayer#setTileGID");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_TMXLayer_getMapTileSize(mrb_state* mrb, mrb_value self)
{
    cocos2d::TMXLayer* cobj = static_cast<cocos2d::TMXLayer*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            cocos2d::Size retval = cobj->getMapTileSize();
            cocos2d::Size* retval_ptr = new cocos2d::Size(retval);
            mrb_value ret;
            ret = object_to_rubyval<cocos2d::Size>(mrb, "CC::Size", (cocos2d::Size*)retval_ptr, nullptr);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::TMXLayer#getMapTileSize");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_TMXLayer_getProperty(mrb_state* mrb, mrb_value self)
{
    cocos2d::TMXLayer* cobj = static_cast<cocos2d::TMXLayer*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            std::string arg0;
            ok = rubyval_to_std_string(mrb, argv[0], &arg0, "CC::TMXLayer.getProperty");
            if (!ok) { break; }
            cocos2d::Value retval = cobj->getProperty(arg0);
            mrb_value ret;
            ret = ccvalue_to_rubyval(mrb, retval);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::TMXLayer#getProperty");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_TMXLayer_setLayerSize(mrb_state* mrb, mrb_value self)
{
    cocos2d::TMXLayer* cobj = static_cast<cocos2d::TMXLayer*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            cocos2d::Size* arg0;
            ok = rubyval_to_object<cocos2d::Size>(mrb, argv[0], "CC::Size", &arg0);
            if (!ok) { break; }
            cobj->setLayerSize(*arg0);
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::TMXLayer#setLayerSize");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_TMXLayer_getLayerName(mrb_state* mrb, mrb_value self)
{
    cocos2d::TMXLayer* cobj = static_cast<cocos2d::TMXLayer*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            std::string retval = cobj->getLayerName();
            mrb_value ret;
            ret = mrb_str_new_cstr(mrb, retval.c_str());
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::TMXLayer#getLayerName");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_TMXLayer_setTileSet(mrb_state* mrb, mrb_value self)
{
    cocos2d::TMXLayer* cobj = static_cast<cocos2d::TMXLayer*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            cocos2d::TMXTilesetInfo* arg0;
            ok = rubyval_to_object<cocos2d::TMXTilesetInfo>(mrb, argv[0], "CC::TMXTilesetInfo", &arg0);
            if (!ok) { break; }
            cobj->setTileSet(arg0);
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::TMXLayer#setTileSet");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_TMXLayer_getTileSet(mrb_state* mrb, mrb_value self)
{
    cocos2d::TMXLayer* cobj = static_cast<cocos2d::TMXLayer*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            cocos2d::TMXTilesetInfo* retval = cobj->getTileSet();
            mrb_value ret;
            ret = object_to_rubyval<cocos2d::TMXTilesetInfo>(mrb, "CC::TMXTilesetInfo", (cocos2d::TMXTilesetInfo*)retval, nullptr);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::TMXLayer#getTileSet");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_TMXLayer_getProperties(mrb_state* mrb, mrb_value self)
{
    cocos2d::TMXLayer* cobj = static_cast<cocos2d::TMXLayer*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            cocos2d::ValueMap retval = cobj->getProperties();
            mrb_value ret;
            ret = ccvaluemap_to_rubyval(mrb, retval);
            return ret;
        }
    } while (0);
    do {
        if (argc == 0) {
            cocos2d::ValueMap retval = cobj->getProperties();
            mrb_value ret;
            ret = ccvaluemap_to_rubyval(mrb, retval);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::TMXLayer#getProperties");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_TMXLayer_getTileAt(mrb_state* mrb, mrb_value self)
{
    cocos2d::TMXLayer* cobj = static_cast<cocos2d::TMXLayer*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            cocos2d::Vec2* arg0;
            ok = rubyval_to_object<cocos2d::Vec2>(mrb, argv[0], "CC::Vec2", &arg0);
            if (!ok) { break; }
            cocos2d::Sprite* retval = cobj->getTileAt(*arg0);
            mrb_value ret;
            ret = object_to_rubyval<cocos2d::Sprite>(mrb, "CC::Sprite", (cocos2d::Sprite*)retval, nullptr);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::TMXLayer#getTileAt");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_TMXLayer_create_static(mrb_state* mrb, mrb_value self)
{
    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 3) {
            std::map<std::string, mrb_value> callbacks;
            cocos2d::TMXTilesetInfo* arg0;
            ok = rubyval_to_object<cocos2d::TMXTilesetInfo>(mrb, argv[0], "CC::TMXTilesetInfo", &arg0);
            if (!ok) { break; }

            cocos2d::TMXLayerInfo* arg1;
            ok = rubyval_to_object<cocos2d::TMXLayerInfo>(mrb, argv[1], "CC::TMXLayerInfo", &arg1);
            if (!ok) { break; }

            cocos2d::TMXMapInfo* arg2;
            ok = rubyval_to_object<cocos2d::TMXMapInfo>(mrb, argv[2], "CC::TMXMapInfo", &arg2);
            if (!ok) { break; }

            cocos2d::TMXLayer* retval = cocos2d::TMXLayer::create(arg0, arg1, arg2);
            mrb_value ret;
            RClass* rclass = mrb_class_ptr(self);
            ret = object_to_rubyval<cocos2d::TMXLayer>(mrb, "CC::TMXLayer", (cocos2d::TMXLayer*)retval, rclass);
            if (callbacks.size() > 0) {
                mrb_value hash = mrb_iv_get(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"));
                if (!mrb_hash_p(hash)) {
                    hash = mrb_hash_new(mrb);
                }
                for (auto elm : callbacks) {
                    mrb_hash_set(mrb, hash, mrb_str_new_cstr(mrb, elm.first.c_str()), elm.second);
                    mrb_iv_set(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"), hash);
                }
            }
            g_rubyValue.push_back(ret);
            mrb_funcall(mrb, ret, "initialize", 0);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined static method : cocos2d::TMXLayer#create");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_TMXLayer_constructor(mrb_state* mrb, mrb_value self)
{

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            cocos2d::TMXLayer* cobj = new cocos2d::TMXLayer();
            DATA_TYPE(self) = &ruby_cocos2dx_Ref_type;
            DATA_PTR(self) = cobj;
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::TMXLayer#TMXLayer");

    return mrb_nil_value();
}


void ruby_register_cocos2dx_TMXLayer(mrb_state* mrb, struct RClass* rmodule)
{
    std::string typeName = typeid(cocos2d::TMXLayer).name();
    g_rubyType[typeName] = "CC::TMXLayer";
    g_rubyDataType[typeName] = &ruby_cocos2dx_Ref_type;

    struct RClass* p_rmodule = mrb->object_class;
    p_rmodule = mrb_module_get_under(mrb, p_rmodule, "CC");
    struct RClass* p_rclass = mrb_class_get_under(mrb, p_rmodule, "SpriteBatchNode");
    struct RClass *rclass = mrb_define_class_under(mrb, rmodule, "TMXLayer", p_rclass);
    MRB_SET_INSTANCE_TT(rclass, MRB_TT_DATA);

    mrb_define_method(mrb, rclass, "initialize", ruby_cocos2dx_TMXLayer_constructor, ARGS_NONE());
    mrb_define_method(mrb, rclass, "get_position_at", ruby_cocos2dx_TMXLayer_getPositionAt, ARGS_REQ(1));
    mrb_define_method(mrb, rclass, "set_layer_orientation", ruby_cocos2dx_TMXLayer_setLayerOrientation, ARGS_REQ(1));
    mrb_define_method(mrb, rclass, "release_map", ruby_cocos2dx_TMXLayer_releaseMap, ARGS_NONE());
    mrb_define_method(mrb, rclass, "get_layer_size", ruby_cocos2dx_TMXLayer_getLayerSize, ARGS_NONE());
    mrb_define_method(mrb, rclass, "set_map_tile_size", ruby_cocos2dx_TMXLayer_setMapTileSize, ARGS_REQ(1));
    mrb_define_method(mrb, rclass, "get_layer_orientation", ruby_cocos2dx_TMXLayer_getLayerOrientation, ARGS_NONE());
    mrb_define_method(mrb, rclass, "set_properties", ruby_cocos2dx_TMXLayer_setProperties, ARGS_REQ(1));
    mrb_define_method(mrb, rclass, "set_layer_name", ruby_cocos2dx_TMXLayer_setLayerName, ARGS_REQ(1));
    mrb_define_method(mrb, rclass, "remove_tile_at", ruby_cocos2dx_TMXLayer_removeTileAt, ARGS_REQ(1));
    mrb_define_method(mrb, rclass, "init_with_tileset_info", ruby_cocos2dx_TMXLayer_initWithTilesetInfo, ARGS_REQ(3));
    mrb_define_method(mrb, rclass, "setup_tiles", ruby_cocos2dx_TMXLayer_setupTiles, ARGS_NONE());
    mrb_define_method(mrb, rclass, "set_tile_gid", ruby_cocos2dx_TMXLayer_setTileGID, ARGS_REQ(2)|ARGS_OPT(1));
    mrb_define_method(mrb, rclass, "get_map_tile_size", ruby_cocos2dx_TMXLayer_getMapTileSize, ARGS_NONE());
    mrb_define_method(mrb, rclass, "get_property", ruby_cocos2dx_TMXLayer_getProperty, ARGS_REQ(1));
    mrb_define_method(mrb, rclass, "set_layer_size", ruby_cocos2dx_TMXLayer_setLayerSize, ARGS_REQ(1));
    mrb_define_method(mrb, rclass, "get_layer_name", ruby_cocos2dx_TMXLayer_getLayerName, ARGS_NONE());
    mrb_define_method(mrb, rclass, "set_tile_set", ruby_cocos2dx_TMXLayer_setTileSet, ARGS_REQ(1));
    mrb_define_method(mrb, rclass, "get_tile_set", ruby_cocos2dx_TMXLayer_getTileSet, ARGS_NONE());
    mrb_define_method(mrb, rclass, "get_properties", ruby_cocos2dx_TMXLayer_getProperties, ARGS_NONE());
    mrb_define_method(mrb, rclass, "get_tile_at", ruby_cocos2dx_TMXLayer_getTileAt, ARGS_REQ(1));
    mrb_define_class_method(mrb, rclass, "create", ruby_cocos2dx_TMXLayer_create_static, ARGS_REQ(3));
}
mrb_value ruby_cocos2dx_TMXTiledMap_setObjectGroups(mrb_state* mrb, mrb_value self)
{
    cocos2d::TMXTiledMap* cobj = static_cast<cocos2d::TMXTiledMap*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            cocos2d::Vector<cocos2d::TMXObjectGroup *> arg0;
            ok = rubyval_to_ccvector(mrb, argv[0], &arg0, "CC::TMXTiledMap.setObjectGroups");
            if (!ok) { break; }
            cobj->setObjectGroups(arg0);
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::TMXTiledMap#setObjectGroups");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_TMXTiledMap_getProperty(mrb_state* mrb, mrb_value self)
{
    cocos2d::TMXTiledMap* cobj = static_cast<cocos2d::TMXTiledMap*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            std::string arg0;
            ok = rubyval_to_std_string(mrb, argv[0], &arg0, "CC::TMXTiledMap.getProperty");
            if (!ok) { break; }
            cocos2d::Value retval = cobj->getProperty(arg0);
            mrb_value ret;
            ret = ccvalue_to_rubyval(mrb, retval);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::TMXTiledMap#getProperty");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_TMXTiledMap_setMapSize(mrb_state* mrb, mrb_value self)
{
    cocos2d::TMXTiledMap* cobj = static_cast<cocos2d::TMXTiledMap*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            cocos2d::Size* arg0;
            ok = rubyval_to_object<cocos2d::Size>(mrb, argv[0], "CC::Size", &arg0);
            if (!ok) { break; }
            cobj->setMapSize(*arg0);
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::TMXTiledMap#setMapSize");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_TMXTiledMap_getObjectGroup(mrb_state* mrb, mrb_value self)
{
    cocos2d::TMXTiledMap* cobj = static_cast<cocos2d::TMXTiledMap*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            std::string arg0;
            ok = rubyval_to_std_string(mrb, argv[0], &arg0, "CC::TMXTiledMap.getObjectGroup");
            if (!ok) { break; }
            cocos2d::TMXObjectGroup* retval = cobj->getObjectGroup(arg0);
            mrb_value ret;
            ret = object_to_rubyval<cocos2d::TMXObjectGroup>(mrb, "CC::TMXObjectGroup", (cocos2d::TMXObjectGroup*)retval, nullptr);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::TMXTiledMap#getObjectGroup");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_TMXTiledMap_getObjectGroups(mrb_state* mrb, mrb_value self)
{
    cocos2d::TMXTiledMap* cobj = static_cast<cocos2d::TMXTiledMap*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            cocos2d::Vector<cocos2d::TMXObjectGroup *> retval = cobj->getObjectGroups();
            mrb_value ret;
            ret = ccvector_to_rubyval(mrb, retval);
            return ret;
        }
    } while (0);
    do {
        if (argc == 0) {
            cocos2d::Vector<cocos2d::TMXObjectGroup *> retval = cobj->getObjectGroups();
            mrb_value ret;
            ret = ccvector_to_rubyval(mrb, retval);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::TMXTiledMap#getObjectGroups");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_TMXTiledMap_getTileSize(mrb_state* mrb, mrb_value self)
{
    cocos2d::TMXTiledMap* cobj = static_cast<cocos2d::TMXTiledMap*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            cocos2d::Size retval = cobj->getTileSize();
            cocos2d::Size* retval_ptr = new cocos2d::Size(retval);
            mrb_value ret;
            ret = object_to_rubyval<cocos2d::Size>(mrb, "CC::Size", (cocos2d::Size*)retval_ptr, nullptr);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::TMXTiledMap#getTileSize");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_TMXTiledMap_getMapSize(mrb_state* mrb, mrb_value self)
{
    cocos2d::TMXTiledMap* cobj = static_cast<cocos2d::TMXTiledMap*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            cocos2d::Size retval = cobj->getMapSize();
            cocos2d::Size* retval_ptr = new cocos2d::Size(retval);
            mrb_value ret;
            ret = object_to_rubyval<cocos2d::Size>(mrb, "CC::Size", (cocos2d::Size*)retval_ptr, nullptr);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::TMXTiledMap#getMapSize");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_TMXTiledMap_getProperties(mrb_state* mrb, mrb_value self)
{
    cocos2d::TMXTiledMap* cobj = static_cast<cocos2d::TMXTiledMap*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            cocos2d::ValueMap retval = cobj->getProperties();
            mrb_value ret;
            ret = ccvaluemap_to_rubyval(mrb, retval);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::TMXTiledMap#getProperties");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_TMXTiledMap_setTileSize(mrb_state* mrb, mrb_value self)
{
    cocos2d::TMXTiledMap* cobj = static_cast<cocos2d::TMXTiledMap*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            cocos2d::Size* arg0;
            ok = rubyval_to_object<cocos2d::Size>(mrb, argv[0], "CC::Size", &arg0);
            if (!ok) { break; }
            cobj->setTileSize(*arg0);
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::TMXTiledMap#setTileSize");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_TMXTiledMap_setProperties(mrb_state* mrb, mrb_value self)
{
    cocos2d::TMXTiledMap* cobj = static_cast<cocos2d::TMXTiledMap*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            cocos2d::ValueMap arg0;
            ok = rubyval_to_ccvaluemap(mrb, argv[0], &arg0, "CC::TMXTiledMap.setProperties");
            if (!ok) { break; }
            cobj->setProperties(arg0);
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::TMXTiledMap#setProperties");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_TMXTiledMap_getLayer(mrb_state* mrb, mrb_value self)
{
    cocos2d::TMXTiledMap* cobj = static_cast<cocos2d::TMXTiledMap*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            std::string arg0;
            ok = rubyval_to_std_string(mrb, argv[0], &arg0, "CC::TMXTiledMap.getLayer");
            if (!ok) { break; }
            cocos2d::TMXLayer* retval = cobj->getLayer(arg0);
            mrb_value ret;
            ret = object_to_rubyval<cocos2d::TMXLayer>(mrb, "CC::TMXLayer", (cocos2d::TMXLayer*)retval, nullptr);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::TMXTiledMap#getLayer");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_TMXTiledMap_getMapOrientation(mrb_state* mrb, mrb_value self)
{
    cocos2d::TMXTiledMap* cobj = static_cast<cocos2d::TMXTiledMap*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            int retval = cobj->getMapOrientation();
            mrb_value ret;
            ret = mrb_fixnum_value((mrb_int)retval);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::TMXTiledMap#getMapOrientation");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_TMXTiledMap_setMapOrientation(mrb_state* mrb, mrb_value self)
{
    cocos2d::TMXTiledMap* cobj = static_cast<cocos2d::TMXTiledMap*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            int arg0;
            ok = rubyval_to_int32(mrb, argv[0], (int*)&arg0, "CC::TMXTiledMap.setMapOrientation");
            if (!ok) { break; }
            cobj->setMapOrientation(arg0);
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::TMXTiledMap#setMapOrientation");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_TMXTiledMap_create_static(mrb_state* mrb, mrb_value self)
{
    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            std::map<std::string, mrb_value> callbacks;
            std::string arg0;
            ok = rubyval_to_std_string(mrb, argv[0], &arg0, "CC::TMXTiledMap.create");
            if (!ok) { break; }

            cocos2d::TMXTiledMap* retval = cocos2d::TMXTiledMap::create(arg0);
            mrb_value ret;
            RClass* rclass = mrb_class_ptr(self);
            ret = object_to_rubyval<cocos2d::TMXTiledMap>(mrb, "CC::TMXTiledMap", (cocos2d::TMXTiledMap*)retval, rclass);
            if (callbacks.size() > 0) {
                mrb_value hash = mrb_iv_get(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"));
                if (!mrb_hash_p(hash)) {
                    hash = mrb_hash_new(mrb);
                }
                for (auto elm : callbacks) {
                    mrb_hash_set(mrb, hash, mrb_str_new_cstr(mrb, elm.first.c_str()), elm.second);
                    mrb_iv_set(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"), hash);
                }
            }
            g_rubyValue.push_back(ret);
            mrb_funcall(mrb, ret, "initialize", 0);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined static method : cocos2d::TMXTiledMap#create");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_TMXTiledMap_createWithXML_static(mrb_state* mrb, mrb_value self)
{
    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 2) {
            std::map<std::string, mrb_value> callbacks;
            std::string arg0;
            ok = rubyval_to_std_string(mrb, argv[0], &arg0, "CC::TMXTiledMap.createWithXML");
            if (!ok) { break; }

            std::string arg1;
            ok = rubyval_to_std_string(mrb, argv[1], &arg1, "CC::TMXTiledMap.createWithXML");
            if (!ok) { break; }

            cocos2d::TMXTiledMap* retval = cocos2d::TMXTiledMap::createWithXML(arg0, arg1);
            mrb_value ret;
            RClass* rclass = mrb_class_ptr(self);
            ret = object_to_rubyval<cocos2d::TMXTiledMap>(mrb, "CC::TMXTiledMap", (cocos2d::TMXTiledMap*)retval, rclass);
            if (callbacks.size() > 0) {
                mrb_value hash = mrb_iv_get(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"));
                if (!mrb_hash_p(hash)) {
                    hash = mrb_hash_new(mrb);
                }
                for (auto elm : callbacks) {
                    mrb_hash_set(mrb, hash, mrb_str_new_cstr(mrb, elm.first.c_str()), elm.second);
                    mrb_iv_set(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"), hash);
                }
            }
            g_rubyValue.push_back(ret);
            mrb_funcall(mrb, ret, "initialize", 0);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined static method : cocos2d::TMXTiledMap#createWithXML");

    return mrb_nil_value();
}

void ruby_register_cocos2dx_TMXTiledMap(mrb_state* mrb, struct RClass* rmodule)
{
    std::string typeName = typeid(cocos2d::TMXTiledMap).name();
    g_rubyType[typeName] = "CC::TMXTiledMap";
    g_rubyDataType[typeName] = &ruby_cocos2dx_Ref_type;

    struct RClass* p_rmodule = mrb->object_class;
    p_rmodule = mrb_module_get_under(mrb, p_rmodule, "CC");
    struct RClass* p_rclass = mrb_class_get_under(mrb, p_rmodule, "Node");
    struct RClass *rclass = mrb_define_class_under(mrb, rmodule, "TMXTiledMap", p_rclass);
    MRB_SET_INSTANCE_TT(rclass, MRB_TT_DATA);

    mrb_define_method(mrb, rclass, "set_object_groups", ruby_cocos2dx_TMXTiledMap_setObjectGroups, ARGS_REQ(1));
    mrb_define_method(mrb, rclass, "get_property", ruby_cocos2dx_TMXTiledMap_getProperty, ARGS_REQ(1));
    mrb_define_method(mrb, rclass, "set_map_size", ruby_cocos2dx_TMXTiledMap_setMapSize, ARGS_REQ(1));
    mrb_define_method(mrb, rclass, "get_object_group", ruby_cocos2dx_TMXTiledMap_getObjectGroup, ARGS_REQ(1));
    mrb_define_method(mrb, rclass, "get_object_groups", ruby_cocos2dx_TMXTiledMap_getObjectGroups, ARGS_NONE());
    mrb_define_method(mrb, rclass, "get_tile_size", ruby_cocos2dx_TMXTiledMap_getTileSize, ARGS_NONE());
    mrb_define_method(mrb, rclass, "get_map_size", ruby_cocos2dx_TMXTiledMap_getMapSize, ARGS_NONE());
    mrb_define_method(mrb, rclass, "get_properties", ruby_cocos2dx_TMXTiledMap_getProperties, ARGS_NONE());
    mrb_define_method(mrb, rclass, "set_tile_size", ruby_cocos2dx_TMXTiledMap_setTileSize, ARGS_REQ(1));
    mrb_define_method(mrb, rclass, "set_properties", ruby_cocos2dx_TMXTiledMap_setProperties, ARGS_REQ(1));
    mrb_define_method(mrb, rclass, "get_layer", ruby_cocos2dx_TMXTiledMap_getLayer, ARGS_REQ(1));
    mrb_define_method(mrb, rclass, "get_map_orientation", ruby_cocos2dx_TMXTiledMap_getMapOrientation, ARGS_NONE());
    mrb_define_method(mrb, rclass, "set_map_orientation", ruby_cocos2dx_TMXTiledMap_setMapOrientation, ARGS_REQ(1));
    mrb_define_class_method(mrb, rclass, "create", ruby_cocos2dx_TMXTiledMap_create_static, ARGS_REQ(1));
    mrb_define_class_method(mrb, rclass, "create_with_xml", ruby_cocos2dx_TMXTiledMap_createWithXML_static, ARGS_REQ(2));
}
mrb_value ruby_cocos2dx_TileMapAtlas_initWithTileFile(mrb_state* mrb, mrb_value self)
{
    cocos2d::TileMapAtlas* cobj = static_cast<cocos2d::TileMapAtlas*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 4) {
            std::string arg0;
            ok = rubyval_to_std_string(mrb, argv[0], &arg0, "CC::TileMapAtlas.initWithTileFile");
            if (!ok) { break; }
            std::string arg1;
            ok = rubyval_to_std_string(mrb, argv[1], &arg1, "CC::TileMapAtlas.initWithTileFile");
            if (!ok) { break; }
            int arg2;
            ok = rubyval_to_int32(mrb, argv[2], (int*)&arg2, "CC::TileMapAtlas.initWithTileFile");
            if (!ok) { break; }
            int arg3;
            ok = rubyval_to_int32(mrb, argv[3], (int*)&arg3, "CC::TileMapAtlas.initWithTileFile");
            if (!ok) { break; }
            bool retval = cobj->initWithTileFile(arg0, arg1, arg2, arg3);
            mrb_value ret;
            ret = mrb_bool_value((mrb_bool)retval);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::TileMapAtlas#initWithTileFile");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_TileMapAtlas_releaseMap(mrb_state* mrb, mrb_value self)
{
    cocos2d::TileMapAtlas* cobj = static_cast<cocos2d::TileMapAtlas*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            cobj->releaseMap();
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::TileMapAtlas#releaseMap");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_TileMapAtlas_getTileAt(mrb_state* mrb, mrb_value self)
{
    cocos2d::TileMapAtlas* cobj = static_cast<cocos2d::TileMapAtlas*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            cocos2d::Vec2* arg0;
            ok = rubyval_to_object<cocos2d::Vec2>(mrb, argv[0], "CC::Vec2", &arg0);
            if (!ok) { break; }
            cocos2d::Color3B retval = cobj->getTileAt(*arg0);
            cocos2d::Color3B* retval_ptr = new cocos2d::Color3B(retval);
            mrb_value ret;
            ret = object_to_rubyval<cocos2d::Color3B>(mrb, "CC::Color3B", (cocos2d::Color3B*)retval_ptr, nullptr);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::TileMapAtlas#getTileAt");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_TileMapAtlas_setTile(mrb_state* mrb, mrb_value self)
{
    cocos2d::TileMapAtlas* cobj = static_cast<cocos2d::TileMapAtlas*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 2) {
            cocos2d::Color3B* arg0;
            ok = rubyval_to_object<cocos2d::Color3B>(mrb, argv[0], "CC::Color3B", &arg0);
            if (!ok) { break; }
            cocos2d::Vec2* arg1;
            ok = rubyval_to_object<cocos2d::Vec2>(mrb, argv[1], "CC::Vec2", &arg1);
            if (!ok) { break; }
            cobj->setTile(*arg0, *arg1);
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::TileMapAtlas#setTile");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_TileMapAtlas_create_static(mrb_state* mrb, mrb_value self)
{
    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 4) {
            std::map<std::string, mrb_value> callbacks;
            std::string arg0;
            ok = rubyval_to_std_string(mrb, argv[0], &arg0, "CC::TileMapAtlas.create");
            if (!ok) { break; }

            std::string arg1;
            ok = rubyval_to_std_string(mrb, argv[1], &arg1, "CC::TileMapAtlas.create");
            if (!ok) { break; }

            int arg2;
            ok = rubyval_to_int32(mrb, argv[2], (int*)&arg2, "CC::TileMapAtlas.create");
            if (!ok) { break; }

            int arg3;
            ok = rubyval_to_int32(mrb, argv[3], (int*)&arg3, "CC::TileMapAtlas.create");
            if (!ok) { break; }

            cocos2d::TileMapAtlas* retval = cocos2d::TileMapAtlas::create(arg0, arg1, arg2, arg3);
            mrb_value ret;
            RClass* rclass = mrb_class_ptr(self);
            ret = object_to_rubyval<cocos2d::TileMapAtlas>(mrb, "CC::TileMapAtlas", (cocos2d::TileMapAtlas*)retval, rclass);
            if (callbacks.size() > 0) {
                mrb_value hash = mrb_iv_get(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"));
                if (!mrb_hash_p(hash)) {
                    hash = mrb_hash_new(mrb);
                }
                for (auto elm : callbacks) {
                    mrb_hash_set(mrb, hash, mrb_str_new_cstr(mrb, elm.first.c_str()), elm.second);
                    mrb_iv_set(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"), hash);
                }
            }
            g_rubyValue.push_back(ret);
            mrb_funcall(mrb, ret, "initialize", 0);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined static method : cocos2d::TileMapAtlas#create");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_TileMapAtlas_constructor(mrb_state* mrb, mrb_value self)
{

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            cocos2d::TileMapAtlas* cobj = new cocos2d::TileMapAtlas();
            DATA_TYPE(self) = &ruby_cocos2dx_Ref_type;
            DATA_PTR(self) = cobj;
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::TileMapAtlas#TileMapAtlas");

    return mrb_nil_value();
}


void ruby_register_cocos2dx_TileMapAtlas(mrb_state* mrb, struct RClass* rmodule)
{
    std::string typeName = typeid(cocos2d::TileMapAtlas).name();
    g_rubyType[typeName] = "CC::TileMapAtlas";
    g_rubyDataType[typeName] = &ruby_cocos2dx_Ref_type;

    struct RClass* p_rmodule = mrb->object_class;
    p_rmodule = mrb_module_get_under(mrb, p_rmodule, "CC");
    struct RClass* p_rclass = mrb_class_get_under(mrb, p_rmodule, "AtlasNode");
    struct RClass *rclass = mrb_define_class_under(mrb, rmodule, "TileMapAtlas", p_rclass);
    MRB_SET_INSTANCE_TT(rclass, MRB_TT_DATA);

    mrb_define_method(mrb, rclass, "initialize", ruby_cocos2dx_TileMapAtlas_constructor, ARGS_NONE());
    mrb_define_method(mrb, rclass, "init_with_tile_file", ruby_cocos2dx_TileMapAtlas_initWithTileFile, ARGS_REQ(4));
    mrb_define_method(mrb, rclass, "release_map", ruby_cocos2dx_TileMapAtlas_releaseMap, ARGS_NONE());
    mrb_define_method(mrb, rclass, "get_tile_at", ruby_cocos2dx_TileMapAtlas_getTileAt, ARGS_REQ(1));
    mrb_define_method(mrb, rclass, "set_tile", ruby_cocos2dx_TileMapAtlas_setTile, ARGS_REQ(2));
    mrb_define_class_method(mrb, rclass, "create", ruby_cocos2dx_TileMapAtlas_create_static, ARGS_REQ(4));
}
mrb_value ruby_cocos2dx_Component_setEnabled(mrb_state* mrb, mrb_value self)
{
    cocos2d::Component* cobj = static_cast<cocos2d::Component*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            bool arg0;
            ok = rubyval_to_boolean(mrb, argv[0], &arg0, "CC::Component.setEnabled");
            if (!ok) { break; }
            cobj->setEnabled(arg0);
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::Component#setEnabled");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Component_setName(mrb_state* mrb, mrb_value self)
{
    cocos2d::Component* cobj = static_cast<cocos2d::Component*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            std::string arg0;
            ok = rubyval_to_std_string(mrb, argv[0], &arg0, "CC::Component.setName");
            if (!ok) { break; }
            cobj->setName(arg0);
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::Component#setName");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Component_isEnabled(mrb_state* mrb, mrb_value self)
{
    cocos2d::Component* cobj = static_cast<cocos2d::Component*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            bool retval = cobj->isEnabled();
            mrb_value ret;
            ret = mrb_bool_value((mrb_bool)retval);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::Component#isEnabled");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Component_update(mrb_state* mrb, mrb_value self)
{
    cocos2d::Component* cobj = static_cast<cocos2d::Component*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            double arg0;
            ok = rubyval_to_number(mrb, argv[0], (double*)&arg0, "CC::Component.update");
            if (!ok) { break; }
            cobj->update(arg0);
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::Component#update");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Component_getOwner(mrb_state* mrb, mrb_value self)
{
    cocos2d::Component* cobj = static_cast<cocos2d::Component*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            cocos2d::Node* retval = cobj->getOwner();
            mrb_value ret;
            ret = object_to_rubyval<cocos2d::Node>(mrb, "CC::Node", (cocos2d::Node*)retval, nullptr);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::Component#getOwner");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Component_init(mrb_state* mrb, mrb_value self)
{
    cocos2d::Component* cobj = static_cast<cocos2d::Component*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            bool retval = cobj->init();
            mrb_value ret;
            ret = mrb_bool_value((mrb_bool)retval);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::Component#init");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Component_setOwner(mrb_state* mrb, mrb_value self)
{
    cocos2d::Component* cobj = static_cast<cocos2d::Component*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            cocos2d::Node* arg0;
            ok = rubyval_to_object<cocos2d::Node>(mrb, argv[0], "CC::Node", &arg0);
            if (!ok) { break; }
            cobj->setOwner(arg0);
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::Component#setOwner");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Component_getName(mrb_state* mrb, mrb_value self)
{
    cocos2d::Component* cobj = static_cast<cocos2d::Component*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Ref_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            std::string retval = cobj->getName();
            mrb_value ret;
            ret = mrb_str_new_cstr(mrb, retval.c_str());
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::Component#getName");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Component_create_static(mrb_state* mrb, mrb_value self)
{
    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            std::map<std::string, mrb_value> callbacks;
            cocos2d::Component* retval = cocos2d::Component::create();
            mrb_value ret;
            RClass* rclass = mrb_class_ptr(self);
            ret = object_to_rubyval<cocos2d::Component>(mrb, "CC::Component", (cocos2d::Component*)retval, rclass);
            if (callbacks.size() > 0) {
                mrb_value hash = mrb_iv_get(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"));
                if (!mrb_hash_p(hash)) {
                    hash = mrb_hash_new(mrb);
                }
                for (auto elm : callbacks) {
                    mrb_hash_set(mrb, hash, mrb_str_new_cstr(mrb, elm.first.c_str()), elm.second);
                    mrb_iv_set(mrb, ret, mrb_intern_cstr(mrb, "__callback_hash"), hash);
                }
            }
            g_rubyValue.push_back(ret);
            mrb_funcall(mrb, ret, "initialize", 0);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined static method : cocos2d::Component#create");

    return mrb_nil_value();
}

void ruby_register_cocos2dx_Component(mrb_state* mrb, struct RClass* rmodule)
{
    std::string typeName = typeid(cocos2d::Component).name();
    g_rubyType[typeName] = "CC::Component";
    g_rubyDataType[typeName] = &ruby_cocos2dx_Ref_type;

    struct RClass* p_rmodule = mrb->object_class;
    p_rmodule = mrb_module_get_under(mrb, p_rmodule, "CC");
    struct RClass* p_rclass = mrb_class_get_under(mrb, p_rmodule, "Ref");
    struct RClass *rclass = mrb_define_class_under(mrb, rmodule, "Component", p_rclass);
    MRB_SET_INSTANCE_TT(rclass, MRB_TT_DATA);

    mrb_define_method(mrb, rclass, "set_enabled", ruby_cocos2dx_Component_setEnabled, ARGS_REQ(1));
    mrb_define_method(mrb, rclass, "set_name", ruby_cocos2dx_Component_setName, ARGS_REQ(1));
    mrb_define_method(mrb, rclass, "enabled?", ruby_cocos2dx_Component_isEnabled, ARGS_NONE());
    mrb_define_method(mrb, rclass, "update", ruby_cocos2dx_Component_update, ARGS_REQ(1));
    mrb_define_method(mrb, rclass, "get_owner", ruby_cocos2dx_Component_getOwner, ARGS_NONE());
    mrb_define_method(mrb, rclass, "init", ruby_cocos2dx_Component_init, ARGS_NONE());
    mrb_define_method(mrb, rclass, "set_owner", ruby_cocos2dx_Component_setOwner, ARGS_REQ(1));
    mrb_define_method(mrb, rclass, "get_name", ruby_cocos2dx_Component_getName, ARGS_NONE());
    mrb_define_class_method(mrb, rclass, "create", ruby_cocos2dx_Component_create_static, ARGS_NONE());
}
mrb_value ruby_cocos2dx_NodeData_resetData(mrb_state* mrb, mrb_value self)
{
    cocos2d::NodeData* cobj = static_cast<cocos2d::NodeData*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_NodeData_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            cobj->resetData();
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::NodeData#resetData");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_NodeData_property_id_get(mrb_state* mrb, mrb_value self)
{
    cocos2d::NodeData* cobj = static_cast<cocos2d::NodeData*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_NodeData_type));

    mrb_value ret;
    ret = mrb_str_new_cstr(mrb, cobj->id.c_str());
    return ret;
}

mrb_value ruby_cocos2dx_NodeData_property_id_set(mrb_state* mrb, mrb_value self)
{
    cocos2d::NodeData* cobj = static_cast<cocos2d::NodeData*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_NodeData_type));

    mrb_value argv;
    mrb_get_args(mrb, "o", &argv);

    bool ok = true;
    std::string val;
    ok = rubyval_to_std_string(mrb, argv, &val, "CC::NodeData.id");
    if (! ok) {
        mrb_raise(mrb, E_RUNTIME_ERROR, "convert to native failed : NodeData#id");
    }
    cobj->id = val;

    return self;
}

mrb_value ruby_cocos2dx_NodeData_property_transform_get(mrb_state* mrb, mrb_value self)
{
    cocos2d::NodeData* cobj = static_cast<cocos2d::NodeData*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_NodeData_type));

    cocos2d::Mat4* retval_ptr = new cocos2d::Mat4(cobj->transform);
    mrb_value ret;
    ret = object_to_rubyval<cocos2d::Mat4>(mrb, "CC::Mat4", (cocos2d::Mat4*)retval_ptr, nullptr);
    return ret;
}

mrb_value ruby_cocos2dx_NodeData_property_transform_set(mrb_state* mrb, mrb_value self)
{
    cocos2d::NodeData* cobj = static_cast<cocos2d::NodeData*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_NodeData_type));

    mrb_value argv;
    mrb_get_args(mrb, "o", &argv);

    bool ok = true;
    cocos2d::Mat4* val;
    ok = rubyval_to_object<cocos2d::Mat4>(mrb, argv, "CC::Mat4", &val);
    if (! ok) {
        mrb_raise(mrb, E_RUNTIME_ERROR, "convert to native failed : NodeData#transform");
    }
    cobj->transform = *val;

    return self;
}

mrb_value ruby_cocos2dx_NodeData_property_modelNodeDatas_get(mrb_state* mrb, mrb_value self)
{
    cocos2d::NodeData* cobj = static_cast<cocos2d::NodeData*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_NodeData_type));

    mrb_value ret;
    ret = std_vector_object_to_rubyval(mrb, cobj->modelNodeDatas, "CC::ModelData");
    return ret;
}

mrb_value ruby_cocos2dx_NodeData_property_modelNodeDatas_set(mrb_state* mrb, mrb_value self)
{
    cocos2d::NodeData* cobj = static_cast<cocos2d::NodeData*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_NodeData_type));

    mrb_value argv;
    mrb_get_args(mrb, "o", &argv);

    bool ok = true;
    std::vector<cocos2d::ModelData *> val;
    ok = rubyval_to_std_vector_object(mrb, argv, &val, "CC::ModelData", "CC::NodeData.modelNodeDatas");
    if (! ok) {
        mrb_raise(mrb, E_RUNTIME_ERROR, "convert to native failed : NodeData#modelNodeDatas");
    }
    cobj->modelNodeDatas = val;

    return self;
}

mrb_value ruby_cocos2dx_NodeData_property_children_get(mrb_state* mrb, mrb_value self)
{
    cocos2d::NodeData* cobj = static_cast<cocos2d::NodeData*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_NodeData_type));

    mrb_value ret;
    ret = std_vector_object_to_rubyval(mrb, cobj->children, "CC::NodeData");
    return ret;
}

mrb_value ruby_cocos2dx_NodeData_property_children_set(mrb_state* mrb, mrb_value self)
{
    cocos2d::NodeData* cobj = static_cast<cocos2d::NodeData*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_NodeData_type));

    mrb_value argv;
    mrb_get_args(mrb, "o", &argv);

    bool ok = true;
    std::vector<cocos2d::NodeData *> val;
    ok = rubyval_to_std_vector_object(mrb, argv, &val, "CC::NodeData", "CC::NodeData.children");
    if (! ok) {
        mrb_raise(mrb, E_RUNTIME_ERROR, "convert to native failed : NodeData#children");
    }
    cobj->children = val;

    return self;
}

mrb_value ruby_cocos2dx_NodeData_constructor(mrb_state* mrb, mrb_value self)
{
    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    cocos2d::NodeData* cobj = new cocos2d::NodeData();
    DATA_TYPE(self) = &ruby_cocos2dx_NodeData_type;
    DATA_PTR(self) = cobj;

    if (argc == 1) {
        if (mrb_hash_p(argv[0])) {
            mrb_value keys = mrb_hash_keys(mrb, argv[0]);
            mrb_int len = mrb_ary_len(mrb, keys);
            for (mrb_int i = 0; i < len; i++) {
                mrb_value hk = mrb_ary_ref(mrb, keys, i);
                mrb_value kv = mrb_hash_get(mrb, argv[0], hk);
                const char* str = nullptr;
                if (mrb_symbol_p(hk)) {
                    str = mrb_sym2name(mrb, mrb_symbol(hk));
                } else if (mrb_string_p(hk)) {
                    str = mrb_string_value_ptr(mrb, hk);
                }
                if (strcmp(str, "id") == 0) {
                    bool ok = true;
                    std::string val;
                    ok = rubyval_to_std_string(mrb, kv, &val, "CC::NodeData.id");
                    if (ok) {
                        cobj->id = val;
                    }
                }
                if (strcmp(str, "transform") == 0) {
                    bool ok = true;
                    cocos2d::Mat4* val;
                    ok = rubyval_to_object<cocos2d::Mat4>(mrb, kv, "CC::Mat4", &val);
                    if (ok) {
                        cobj->transform = *val;
                    }
                }
                if (strcmp(str, "modelNodeDatas") == 0) {
                    bool ok = true;
                    std::vector<cocos2d::ModelData *> val;
                    ok = rubyval_to_std_vector_object(mrb, kv, &val, "CC::ModelData", "CC::NodeData.modelNodeDatas");
                    if (ok) {
                        cobj->modelNodeDatas = val;
                    }
                }
                if (strcmp(str, "children") == 0) {
                    bool ok = true;
                    std::vector<cocos2d::NodeData *> val;
                    ok = rubyval_to_std_vector_object(mrb, kv, &val, "CC::NodeData", "CC::NodeData.children");
                    if (ok) {
                        cobj->children = val;
                    }
                }
            }
        }
    }

    if (argc > 1) {
        mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::NodeData#constructor");
    }

    return self;
}

void ruby_register_cocos2dx_NodeData(mrb_state* mrb, struct RClass* rmodule)
{
    std::string typeName = typeid(cocos2d::NodeData).name();
    g_rubyType[typeName] = "CC::NodeData";
    g_rubyDataType[typeName] = &ruby_cocos2dx_NodeData_type;

    struct RClass *rclass = mrb_define_class_under(mrb, rmodule, "NodeData", mrb->object_class);
    MRB_SET_INSTANCE_TT(rclass, MRB_TT_DATA);

    mrb_define_method(mrb, rclass, "initialize", ruby_cocos2dx_NodeData_constructor, ARGS_NONE());
    mrb_define_method(mrb, rclass, "reset_data", ruby_cocos2dx_NodeData_resetData, ARGS_NONE());
    mrb_define_method(mrb, rclass, "id", ruby_cocos2dx_NodeData_property_id_get, ARGS_NONE());
    mrb_define_method(mrb, rclass, "id=", ruby_cocos2dx_NodeData_property_id_set, ARGS_REQ(1));
    mrb_define_method(mrb, rclass, "transform", ruby_cocos2dx_NodeData_property_transform_get, ARGS_NONE());
    mrb_define_method(mrb, rclass, "transform=", ruby_cocos2dx_NodeData_property_transform_set, ARGS_REQ(1));
    mrb_define_method(mrb, rclass, "model_node_datas", ruby_cocos2dx_NodeData_property_modelNodeDatas_get, ARGS_NONE());
    mrb_define_method(mrb, rclass, "model_node_datas=", ruby_cocos2dx_NodeData_property_modelNodeDatas_set, ARGS_REQ(1));
    mrb_define_method(mrb, rclass, "children", ruby_cocos2dx_NodeData_property_children_get, ARGS_NONE());
    mrb_define_method(mrb, rclass, "children=", ruby_cocos2dx_NodeData_property_children_set, ARGS_REQ(1));
}
mrb_value ruby_cocos2dx_NodeDatas_resetData(mrb_state* mrb, mrb_value self)
{
    cocos2d::NodeDatas* cobj = static_cast<cocos2d::NodeDatas*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_NodeDatas_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            cobj->resetData();
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::NodeDatas#resetData");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_NodeDatas_property_skeleton_get(mrb_state* mrb, mrb_value self)
{
    cocos2d::NodeDatas* cobj = static_cast<cocos2d::NodeDatas*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_NodeDatas_type));

    mrb_value ret;
    ret = std_vector_object_to_rubyval(mrb, cobj->skeleton, "CC::NodeData");
    return ret;
}

mrb_value ruby_cocos2dx_NodeDatas_property_skeleton_set(mrb_state* mrb, mrb_value self)
{
    cocos2d::NodeDatas* cobj = static_cast<cocos2d::NodeDatas*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_NodeDatas_type));

    mrb_value argv;
    mrb_get_args(mrb, "o", &argv);

    bool ok = true;
    std::vector<cocos2d::NodeData *> val;
    ok = rubyval_to_std_vector_object(mrb, argv, &val, "CC::NodeData", "CC::NodeDatas.skeleton");
    if (! ok) {
        mrb_raise(mrb, E_RUNTIME_ERROR, "convert to native failed : NodeDatas#skeleton");
    }
    cobj->skeleton = val;

    return self;
}

mrb_value ruby_cocos2dx_NodeDatas_property_nodes_get(mrb_state* mrb, mrb_value self)
{
    cocos2d::NodeDatas* cobj = static_cast<cocos2d::NodeDatas*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_NodeDatas_type));

    mrb_value ret;
    ret = std_vector_object_to_rubyval(mrb, cobj->nodes, "CC::NodeData");
    return ret;
}

mrb_value ruby_cocos2dx_NodeDatas_property_nodes_set(mrb_state* mrb, mrb_value self)
{
    cocos2d::NodeDatas* cobj = static_cast<cocos2d::NodeDatas*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_NodeDatas_type));

    mrb_value argv;
    mrb_get_args(mrb, "o", &argv);

    bool ok = true;
    std::vector<cocos2d::NodeData *> val;
    ok = rubyval_to_std_vector_object(mrb, argv, &val, "CC::NodeData", "CC::NodeDatas.nodes");
    if (! ok) {
        mrb_raise(mrb, E_RUNTIME_ERROR, "convert to native failed : NodeDatas#nodes");
    }
    cobj->nodes = val;

    return self;
}

mrb_value ruby_cocos2dx_NodeDatas_constructor(mrb_state* mrb, mrb_value self)
{
    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    cocos2d::NodeDatas* cobj = new cocos2d::NodeDatas();
    DATA_TYPE(self) = &ruby_cocos2dx_NodeDatas_type;
    DATA_PTR(self) = cobj;

    if (argc == 1) {
        if (mrb_hash_p(argv[0])) {
            mrb_value keys = mrb_hash_keys(mrb, argv[0]);
            mrb_int len = mrb_ary_len(mrb, keys);
            for (mrb_int i = 0; i < len; i++) {
                mrb_value hk = mrb_ary_ref(mrb, keys, i);
                mrb_value kv = mrb_hash_get(mrb, argv[0], hk);
                const char* str = nullptr;
                if (mrb_symbol_p(hk)) {
                    str = mrb_sym2name(mrb, mrb_symbol(hk));
                } else if (mrb_string_p(hk)) {
                    str = mrb_string_value_ptr(mrb, hk);
                }
                if (strcmp(str, "skeleton") == 0) {
                    bool ok = true;
                    std::vector<cocos2d::NodeData *> val;
                    ok = rubyval_to_std_vector_object(mrb, kv, &val, "CC::NodeData", "CC::NodeDatas.skeleton");
                    if (ok) {
                        cobj->skeleton = val;
                    }
                }
                if (strcmp(str, "nodes") == 0) {
                    bool ok = true;
                    std::vector<cocos2d::NodeData *> val;
                    ok = rubyval_to_std_vector_object(mrb, kv, &val, "CC::NodeData", "CC::NodeDatas.nodes");
                    if (ok) {
                        cobj->nodes = val;
                    }
                }
            }
        }
    }

    if (argc > 1) {
        mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::NodeDatas#constructor");
    }

    return self;
}

void ruby_register_cocos2dx_NodeDatas(mrb_state* mrb, struct RClass* rmodule)
{
    std::string typeName = typeid(cocos2d::NodeDatas).name();
    g_rubyType[typeName] = "CC::NodeDatas";
    g_rubyDataType[typeName] = &ruby_cocos2dx_NodeDatas_type;

    struct RClass *rclass = mrb_define_class_under(mrb, rmodule, "NodeDatas", mrb->object_class);
    MRB_SET_INSTANCE_TT(rclass, MRB_TT_DATA);

    mrb_define_method(mrb, rclass, "initialize", ruby_cocos2dx_NodeDatas_constructor, ARGS_NONE());
    mrb_define_method(mrb, rclass, "reset_data", ruby_cocos2dx_NodeDatas_resetData, ARGS_NONE());
    mrb_define_method(mrb, rclass, "skeleton", ruby_cocos2dx_NodeDatas_property_skeleton_get, ARGS_NONE());
    mrb_define_method(mrb, rclass, "skeleton=", ruby_cocos2dx_NodeDatas_property_skeleton_set, ARGS_REQ(1));
    mrb_define_method(mrb, rclass, "nodes", ruby_cocos2dx_NodeDatas_property_nodes_get, ARGS_NONE());
    mrb_define_method(mrb, rclass, "nodes=", ruby_cocos2dx_NodeDatas_property_nodes_set, ARGS_REQ(1));
}
mrb_value ruby_cocos2dx_Animation3DData_resetData(mrb_state* mrb, mrb_value self)
{
    cocos2d::Animation3DData* cobj = static_cast<cocos2d::Animation3DData*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Animation3DData_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            cobj->resetData();
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::Animation3DData#resetData");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_Animation3DData_constructor(mrb_state* mrb, mrb_value self)
{

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            cocos2d::Animation3DData* arg0;
            ok = rubyval_to_object<cocos2d::Animation3DData>(mrb, argv[0], "CC::Animation3DData", &arg0);
            if (!ok) { break; }
            cocos2d::Animation3DData* cobj = new cocos2d::Animation3DData(*arg0);
            DATA_TYPE(self) = &ruby_cocos2dx_Animation3DData_type;
            DATA_PTR(self) = cobj;
            return self;
        }
    } while (0);
    do {
        if (argc == 0) {
            cocos2d::Animation3DData* cobj = new cocos2d::Animation3DData();
            DATA_TYPE(self) = &ruby_cocos2dx_Animation3DData_type;
            DATA_PTR(self) = cobj;
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::Animation3DData#Animation3DData");

    return mrb_nil_value();
}


void ruby_register_cocos2dx_Animation3DData(mrb_state* mrb, struct RClass* rmodule)
{
    std::string typeName = typeid(cocos2d::Animation3DData).name();
    g_rubyType[typeName] = "CC::Animation3DData";
    g_rubyDataType[typeName] = &ruby_cocos2dx_Animation3DData_type;

    struct RClass *rclass = mrb_define_class_under(mrb, rmodule, "Animation3DData", mrb->object_class);
    MRB_SET_INSTANCE_TT(rclass, MRB_TT_DATA);

    mrb_define_method(mrb, rclass, "initialize", ruby_cocos2dx_Animation3DData_constructor, ARGS_REQ(0)|ARGS_OPT(1));
    mrb_define_method(mrb, rclass, "reset_data", ruby_cocos2dx_Animation3DData_resetData, ARGS_NONE());
}
mrb_value ruby_cocos2dx_Sprite3DData_property_meshVertexDatas_get(mrb_state* mrb, mrb_value self)
{
    cocos2d::Sprite3DCache::Sprite3DData* cobj = static_cast<cocos2d::Sprite3DCache::Sprite3DData*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Sprite3DData_type));

    mrb_value ret;
    ret = ccvector_to_rubyval(mrb, cobj->meshVertexDatas);
    return ret;
}

mrb_value ruby_cocos2dx_Sprite3DData_property_meshVertexDatas_set(mrb_state* mrb, mrb_value self)
{
    cocos2d::Sprite3DCache::Sprite3DData* cobj = static_cast<cocos2d::Sprite3DCache::Sprite3DData*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Sprite3DData_type));

    mrb_value argv;
    mrb_get_args(mrb, "o", &argv);

    bool ok = true;
    cocos2d::Vector<cocos2d::MeshVertexData *> val;
    ok = rubyval_to_ccvector(mrb, argv, &val, "CC::Sprite3DCache::Sprite3DData.meshVertexDatas");
    if (! ok) {
        mrb_raise(mrb, E_RUNTIME_ERROR, "convert to native failed : Sprite3DData#meshVertexDatas");
    }
    cobj->meshVertexDatas = val;

    return self;
}

mrb_value ruby_cocos2dx_Sprite3DData_property_glProgramStates_get(mrb_state* mrb, mrb_value self)
{
    cocos2d::Sprite3DCache::Sprite3DData* cobj = static_cast<cocos2d::Sprite3DCache::Sprite3DData*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Sprite3DData_type));

    mrb_value ret;
    ret = ccvector_to_rubyval(mrb, cobj->glProgramStates);
    return ret;
}

mrb_value ruby_cocos2dx_Sprite3DData_property_glProgramStates_set(mrb_state* mrb, mrb_value self)
{
    cocos2d::Sprite3DCache::Sprite3DData* cobj = static_cast<cocos2d::Sprite3DCache::Sprite3DData*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Sprite3DData_type));

    mrb_value argv;
    mrb_get_args(mrb, "o", &argv);

    bool ok = true;
    cocos2d::Vector<cocos2d::GLProgramState *> val;
    ok = rubyval_to_ccvector(mrb, argv, &val, "CC::Sprite3DCache::Sprite3DData.glProgramStates");
    if (! ok) {
        mrb_raise(mrb, E_RUNTIME_ERROR, "convert to native failed : Sprite3DData#glProgramStates");
    }
    cobj->glProgramStates = val;

    return self;
}

mrb_value ruby_cocos2dx_Sprite3DData_property_nodedatas_get(mrb_state* mrb, mrb_value self)
{
    cocos2d::Sprite3DCache::Sprite3DData* cobj = static_cast<cocos2d::Sprite3DCache::Sprite3DData*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Sprite3DData_type));

    mrb_value ret;
    ret = object_to_rubyval<cocos2d::NodeDatas>(mrb, "CC::NodeDatas", (cocos2d::NodeDatas*)cobj->nodedatas, nullptr);
    return ret;
}

mrb_value ruby_cocos2dx_Sprite3DData_property_nodedatas_set(mrb_state* mrb, mrb_value self)
{
    cocos2d::Sprite3DCache::Sprite3DData* cobj = static_cast<cocos2d::Sprite3DCache::Sprite3DData*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Sprite3DData_type));

    mrb_value argv;
    mrb_get_args(mrb, "o", &argv);

    bool ok = true;
    cocos2d::NodeDatas* val;
    ok = rubyval_to_object<cocos2d::NodeDatas>(mrb, argv, "CC::NodeDatas", &val);
    if (! ok) {
        mrb_raise(mrb, E_RUNTIME_ERROR, "convert to native failed : Sprite3DData#nodedatas");
    }
    cobj->nodedatas = val;

    return self;
}

mrb_value ruby_cocos2dx_Sprite3DData_property_materialdatas_get(mrb_state* mrb, mrb_value self)
{
    cocos2d::Sprite3DCache::Sprite3DData* cobj = static_cast<cocos2d::Sprite3DCache::Sprite3DData*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Sprite3DData_type));

    mrb_value ret;
    ret = object_to_rubyval<cocos2d::MaterialDatas>(mrb, "CC::MaterialDatas", (cocos2d::MaterialDatas*)cobj->materialdatas, nullptr);
    return ret;
}

mrb_value ruby_cocos2dx_Sprite3DData_property_materialdatas_set(mrb_state* mrb, mrb_value self)
{
    cocos2d::Sprite3DCache::Sprite3DData* cobj = static_cast<cocos2d::Sprite3DCache::Sprite3DData*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_Sprite3DData_type));

    mrb_value argv;
    mrb_get_args(mrb, "o", &argv);

    bool ok = true;
    cocos2d::MaterialDatas* val;
    ok = rubyval_to_object<cocos2d::MaterialDatas>(mrb, argv, "CC::MaterialDatas", &val);
    if (! ok) {
        mrb_raise(mrb, E_RUNTIME_ERROR, "convert to native failed : Sprite3DData#materialdatas");
    }
    cobj->materialdatas = val;

    return self;
}

mrb_value ruby_cocos2dx_Sprite3DData_constructor(mrb_state* mrb, mrb_value self)
{
    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    cocos2d::Sprite3DCache::Sprite3DData* cobj = new cocos2d::Sprite3DCache::Sprite3DData();
    DATA_TYPE(self) = &ruby_cocos2dx_Sprite3DData_type;
    DATA_PTR(self) = cobj;

    if (argc == 1) {
        if (mrb_hash_p(argv[0])) {
            mrb_value keys = mrb_hash_keys(mrb, argv[0]);
            mrb_int len = mrb_ary_len(mrb, keys);
            for (mrb_int i = 0; i < len; i++) {
                mrb_value hk = mrb_ary_ref(mrb, keys, i);
                mrb_value kv = mrb_hash_get(mrb, argv[0], hk);
                const char* str = nullptr;
                if (mrb_symbol_p(hk)) {
                    str = mrb_sym2name(mrb, mrb_symbol(hk));
                } else if (mrb_string_p(hk)) {
                    str = mrb_string_value_ptr(mrb, hk);
                }
                if (strcmp(str, "meshVertexDatas") == 0) {
                    bool ok = true;
                    cocos2d::Vector<cocos2d::MeshVertexData *> val;
                    ok = rubyval_to_ccvector(mrb, kv, &val, "CC::Sprite3DCache::Sprite3DData.meshVertexDatas");
                    if (ok) {
                        cobj->meshVertexDatas = val;
                    }
                }
                if (strcmp(str, "glProgramStates") == 0) {
                    bool ok = true;
                    cocos2d::Vector<cocos2d::GLProgramState *> val;
                    ok = rubyval_to_ccvector(mrb, kv, &val, "CC::Sprite3DCache::Sprite3DData.glProgramStates");
                    if (ok) {
                        cobj->glProgramStates = val;
                    }
                }
                if (strcmp(str, "nodedatas") == 0) {
                    bool ok = true;
                    cocos2d::NodeDatas* val;
                    ok = rubyval_to_object<cocos2d::NodeDatas>(mrb, kv, "CC::NodeDatas", &val);
                    if (ok) {
                        cobj->nodedatas = val;
                    }
                }
                if (strcmp(str, "materialdatas") == 0) {
                    bool ok = true;
                    cocos2d::MaterialDatas* val;
                    ok = rubyval_to_object<cocos2d::MaterialDatas>(mrb, kv, "CC::MaterialDatas", &val);
                    if (ok) {
                        cobj->materialdatas = val;
                    }
                }
            }
        }
    }

    if (argc > 1) {
        mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::Sprite3DCache::Sprite3DData#constructor");
    }

    return self;
}

void ruby_register_cocos2dx_Sprite3DData(mrb_state* mrb, struct RClass* rmodule)
{
    std::string typeName = typeid(cocos2d::Sprite3DCache::Sprite3DData).name();
    g_rubyType[typeName] = "CC::Sprite3DCache::Sprite3DData";
    g_rubyDataType[typeName] = &ruby_cocos2dx_Sprite3DData_type;

    struct RClass *rclass = mrb_define_class_under(mrb, rmodule, "Sprite3DData", mrb->object_class);
    MRB_SET_INSTANCE_TT(rclass, MRB_TT_DATA);

    mrb_define_method(mrb, rclass, "initialize", ruby_cocos2dx_Sprite3DData_constructor, ARGS_NONE());
    mrb_define_method(mrb, rclass, "mesh_vertex_datas", ruby_cocos2dx_Sprite3DData_property_meshVertexDatas_get, ARGS_NONE());
    mrb_define_method(mrb, rclass, "mesh_vertex_datas=", ruby_cocos2dx_Sprite3DData_property_meshVertexDatas_set, ARGS_REQ(1));
    mrb_define_method(mrb, rclass, "gl_program_states", ruby_cocos2dx_Sprite3DData_property_glProgramStates_get, ARGS_NONE());
    mrb_define_method(mrb, rclass, "gl_program_states=", ruby_cocos2dx_Sprite3DData_property_glProgramStates_set, ARGS_REQ(1));
    mrb_define_method(mrb, rclass, "nodedatas", ruby_cocos2dx_Sprite3DData_property_nodedatas_get, ARGS_NONE());
    mrb_define_method(mrb, rclass, "nodedatas=", ruby_cocos2dx_Sprite3DData_property_nodedatas_set, ARGS_REQ(1));
    mrb_define_method(mrb, rclass, "materialdatas", ruby_cocos2dx_Sprite3DData_property_materialdatas_get, ARGS_NONE());
    mrb_define_method(mrb, rclass, "materialdatas=", ruby_cocos2dx_Sprite3DData_property_materialdatas_set, ARGS_REQ(1));
}
void ruby_cocos2dx_global_EvaluateType_enum_init(mrb_state* mrb)
{
    do {
        mrb_value ev = mrb_fixnum_value((mrb_int)EvaluateType::INT_LINEAR);
        mrb_gv_set(mrb, mrb_intern_cstr(mrb, "INT_LINEAR"), ev);
    } while (0);

    do {
        mrb_value ev = mrb_fixnum_value((mrb_int)EvaluateType::INT_NEAR);
        mrb_gv_set(mrb, mrb_intern_cstr(mrb, "INT_NEAR"), ev);
    } while (0);

    do {
        mrb_value ev = mrb_fixnum_value((mrb_int)EvaluateType::INT_QUAT_SLERP);
        mrb_gv_set(mrb, mrb_intern_cstr(mrb, "INT_QUAT_SLERP"), ev);
    } while (0);

    do {
        mrb_value ev = mrb_fixnum_value((mrb_int)EvaluateType::INT_USER_FUNCTION);
        mrb_gv_set(mrb, mrb_intern_cstr(mrb, "INT_USER_FUNCTION"), ev);
    } while (0);

}
mrb_value ruby_cocos2dx_AsyncTaskPool_stopTasks(mrb_state* mrb, mrb_value self)
{
    cocos2d::AsyncTaskPool* cobj = static_cast<cocos2d::AsyncTaskPool*>(mrb_get_datatype(mrb, self, &ruby_cocos2dx_AsyncTaskPool_type));

    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    bool ok = true;
    do {
        if (argc == 1) {
            cocos2d::AsyncTaskPool::TaskType arg0;
            ok = rubyval_to_int32(mrb, argv[0], (int*)&arg0, "CC::AsyncTaskPool.stopTasks");
            if (!ok) { break; }
            cobj->stopTasks(arg0);
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined method : cocos2d::AsyncTaskPool#stopTasks");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_AsyncTaskPool_destoryInstance_static(mrb_state* mrb, mrb_value self)
{
    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            cocos2d::AsyncTaskPool::destoryInstance();
            return self;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined static method : cocos2d::AsyncTaskPool#destoryInstance");

    return mrb_nil_value();
}

mrb_value ruby_cocos2dx_AsyncTaskPool_getInstance_static(mrb_state* mrb, mrb_value self)
{
    mrb_value* argv;
    mrb_int argc;
    mrb_get_args(mrb, "*", &argv, &argc);

    do {
        if (argc == 0) {
            cocos2d::AsyncTaskPool* retval = cocos2d::AsyncTaskPool::getInstance();
            mrb_value ret;
            ret = object_to_rubyval<cocos2d::AsyncTaskPool>(mrb, "CC::AsyncTaskPool", (cocos2d::AsyncTaskPool*)retval, nullptr);
            return ret;
        }
    } while (0);

    mrb_raise(mrb, E_RUNTIME_ERROR, "undefined static method : cocos2d::AsyncTaskPool#getInstance");

    return mrb_nil_value();
}

void ruby_cocos2dx_AsyncTaskPool_TaskType_enum_init(mrb_state* mrb, struct RClass* renum)
{
    do {
        mrb_value ev = mrb_fixnum_value((mrb_int)cocos2d::AsyncTaskPool::TaskType::TASK_IO);
        mrb_mod_cv_set(mrb, renum, mrb_intern_cstr(mrb, "TASK_IO"), ev);
    } while (0);

    do {
        mrb_value ev = mrb_fixnum_value((mrb_int)cocos2d::AsyncTaskPool::TaskType::TASK_NETWORK);
        mrb_mod_cv_set(mrb, renum, mrb_intern_cstr(mrb, "TASK_NETWORK"), ev);
    } while (0);

    do {
        mrb_value ev = mrb_fixnum_value((mrb_int)cocos2d::AsyncTaskPool::TaskType::TASK_OTHER);
        mrb_mod_cv_set(mrb, renum, mrb_intern_cstr(mrb, "TASK_OTHER"), ev);
    } while (0);

    do {
        mrb_value ev = mrb_fixnum_value((mrb_int)cocos2d::AsyncTaskPool::TaskType::TASK_MAX_TYPE);
        mrb_mod_cv_set(mrb, renum, mrb_intern_cstr(mrb, "TASK_MAX_TYPE"), ev);
    } while (0);

}

void ruby_register_cocos2dx_AsyncTaskPool(mrb_state* mrb, struct RClass* rmodule)
{
    std::string typeName = typeid(cocos2d::AsyncTaskPool).name();
    g_rubyType[typeName] = "CC::AsyncTaskPool";
    g_rubyDataType[typeName] = &ruby_cocos2dx_AsyncTaskPool_type;

    struct RClass *rclass = mrb_define_class_under(mrb, rmodule, "AsyncTaskPool", mrb->object_class);
    MRB_SET_INSTANCE_TT(rclass, MRB_TT_DATA);

    mrb_define_method(mrb, rclass, "stop_tasks", ruby_cocos2dx_AsyncTaskPool_stopTasks, ARGS_REQ(1));
    mrb_define_class_method(mrb, rclass, "destory_instance", ruby_cocos2dx_AsyncTaskPool_destoryInstance_static, ARGS_NONE());
    mrb_define_class_method(mrb, rclass, "get_instance", ruby_cocos2dx_AsyncTaskPool_getInstance_static, ARGS_NONE());
    struct RClass* renum_TaskType = mrb_define_module_under(mrb, rclass, "TaskType");
    ruby_cocos2dx_AsyncTaskPool_TaskType_enum_init(mrb, renum_TaskType);
    mrb_define_class_method(mrb, renum_TaskType, "TASK_IO", ruby_cocos2dx_constant_get, ARGS_NONE());
    mrb_define_class_method(mrb, renum_TaskType, "TASK_NETWORK", ruby_cocos2dx_constant_get, ARGS_NONE());
    mrb_define_class_method(mrb, renum_TaskType, "TASK_OTHER", ruby_cocos2dx_constant_get, ARGS_NONE());
    mrb_define_class_method(mrb, renum_TaskType, "TASK_MAX_TYPE", ruby_cocos2dx_constant_get, ARGS_NONE());
}
void register_all_cocos2dx_enums(mrb_state* mrb)
{
    struct RClass* renum_LanguageType = mrb_define_module(mrb, "LanguageType");
    ruby_cocos2dx_global_LanguageType_enum_init(mrb);
    mrb_define_class_method(mrb, renum_LanguageType, "ENGLISH", ruby_cocos2dx_global_constant_get, ARGS_NONE());
    mrb_define_class_method(mrb, renum_LanguageType, "CHINESE", ruby_cocos2dx_global_constant_get, ARGS_NONE());
    mrb_define_class_method(mrb, renum_LanguageType, "FRENCH", ruby_cocos2dx_global_constant_get, ARGS_NONE());
    mrb_define_class_method(mrb, renum_LanguageType, "ITALIAN", ruby_cocos2dx_global_constant_get, ARGS_NONE());
    mrb_define_class_method(mrb, renum_LanguageType, "GERMAN", ruby_cocos2dx_global_constant_get, ARGS_NONE());
    mrb_define_class_method(mrb, renum_LanguageType, "SPANISH", ruby_cocos2dx_global_constant_get, ARGS_NONE());
    mrb_define_class_method(mrb, renum_LanguageType, "DUTCH", ruby_cocos2dx_global_constant_get, ARGS_NONE());
    mrb_define_class_method(mrb, renum_LanguageType, "RUSSIAN", ruby_cocos2dx_global_constant_get, ARGS_NONE());
    mrb_define_class_method(mrb, renum_LanguageType, "KOREAN", ruby_cocos2dx_global_constant_get, ARGS_NONE());
    mrb_define_class_method(mrb, renum_LanguageType, "JAPANESE", ruby_cocos2dx_global_constant_get, ARGS_NONE());
    mrb_define_class_method(mrb, renum_LanguageType, "HUNGARIAN", ruby_cocos2dx_global_constant_get, ARGS_NONE());
    mrb_define_class_method(mrb, renum_LanguageType, "PORTUGUESE", ruby_cocos2dx_global_constant_get, ARGS_NONE());
    mrb_define_class_method(mrb, renum_LanguageType, "ARABIC", ruby_cocos2dx_global_constant_get, ARGS_NONE());
    mrb_define_class_method(mrb, renum_LanguageType, "NORWEGIAN", ruby_cocos2dx_global_constant_get, ARGS_NONE());
    mrb_define_class_method(mrb, renum_LanguageType, "POLISH", ruby_cocos2dx_global_constant_get, ARGS_NONE());
    mrb_define_class_method(mrb, renum_LanguageType, "TURKISH", ruby_cocos2dx_global_constant_get, ARGS_NONE());
    mrb_define_class_method(mrb, renum_LanguageType, "UKRAINIAN", ruby_cocos2dx_global_constant_get, ARGS_NONE());

    struct RClass* renum_EvaluateType = mrb_define_module(mrb, "EvaluateType");
    ruby_cocos2dx_global_EvaluateType_enum_init(mrb);
    mrb_define_class_method(mrb, renum_EvaluateType, "INT_LINEAR", ruby_cocos2dx_global_constant_get, ARGS_NONE());
    mrb_define_class_method(mrb, renum_EvaluateType, "INT_NEAR", ruby_cocos2dx_global_constant_get, ARGS_NONE());
    mrb_define_class_method(mrb, renum_EvaluateType, "INT_QUAT_SLERP", ruby_cocos2dx_global_constant_get, ARGS_NONE());
    mrb_define_class_method(mrb, renum_EvaluateType, "INT_USER_FUNCTION", ruby_cocos2dx_global_constant_get, ARGS_NONE());

    struct RClass* renum_TextHAlignment = mrb_define_module(mrb, "TextHAlignment");
    ruby_cocos2dx_global_TextHAlignment_enum_init(mrb);
    mrb_define_class_method(mrb, renum_TextHAlignment, "LEFT", ruby_cocos2dx_global_constant_get, ARGS_NONE());
    mrb_define_class_method(mrb, renum_TextHAlignment, "CENTER", ruby_cocos2dx_global_constant_get, ARGS_NONE());
    mrb_define_class_method(mrb, renum_TextHAlignment, "RIGHT", ruby_cocos2dx_global_constant_get, ARGS_NONE());

    struct RClass* renum_TextVAlignment = mrb_define_module(mrb, "TextVAlignment");
    ruby_cocos2dx_global_TextVAlignment_enum_init(mrb);
    mrb_define_class_method(mrb, renum_TextVAlignment, "TOP", ruby_cocos2dx_global_constant_get, ARGS_NONE());
    mrb_define_class_method(mrb, renum_TextVAlignment, "CENTER", ruby_cocos2dx_global_constant_get, ARGS_NONE());
    mrb_define_class_method(mrb, renum_TextVAlignment, "BOTTOM", ruby_cocos2dx_global_constant_get, ARGS_NONE());

    struct RClass* renum_ResolutionPolicy = mrb_define_module(mrb, "ResolutionPolicy");
    ruby_cocos2dx_global_ResolutionPolicy_enum_init(mrb);
    mrb_define_class_method(mrb, renum_ResolutionPolicy, "EXACT_FIT", ruby_cocos2dx_global_constant_get, ARGS_NONE());
    mrb_define_class_method(mrb, renum_ResolutionPolicy, "NO_BORDER", ruby_cocos2dx_global_constant_get, ARGS_NONE());
    mrb_define_class_method(mrb, renum_ResolutionPolicy, "SHOW_ALL", ruby_cocos2dx_global_constant_get, ARGS_NONE());
    mrb_define_class_method(mrb, renum_ResolutionPolicy, "FIXED_HEIGHT", ruby_cocos2dx_global_constant_get, ARGS_NONE());
    mrb_define_class_method(mrb, renum_ResolutionPolicy, "FIXED_WIDTH", ruby_cocos2dx_global_constant_get, ARGS_NONE());
    mrb_define_class_method(mrb, renum_ResolutionPolicy, "UNKNOWN", ruby_cocos2dx_global_constant_get, ARGS_NONE());

    struct RClass* renum_LightType = mrb_define_module(mrb, "LightType");
    ruby_cocos2dx_global_LightType_enum_init(mrb);
    mrb_define_class_method(mrb, renum_LightType, "DIRECTIONAL", ruby_cocos2dx_global_constant_get, ARGS_NONE());
    mrb_define_class_method(mrb, renum_LightType, "POINT", ruby_cocos2dx_global_constant_get, ARGS_NONE());
    mrb_define_class_method(mrb, renum_LightType, "SPOT", ruby_cocos2dx_global_constant_get, ARGS_NONE());
    mrb_define_class_method(mrb, renum_LightType, "AMBIENT", ruby_cocos2dx_global_constant_get, ARGS_NONE());

    struct RClass* renum_LabelEffect = mrb_define_module(mrb, "LabelEffect");
    ruby_cocos2dx_global_LabelEffect_enum_init(mrb);
    mrb_define_class_method(mrb, renum_LabelEffect, "NORMAL", ruby_cocos2dx_global_constant_get, ARGS_NONE());
    mrb_define_class_method(mrb, renum_LabelEffect, "OUTLINE", ruby_cocos2dx_global_constant_get, ARGS_NONE());
    mrb_define_class_method(mrb, renum_LabelEffect, "SHADOW", ruby_cocos2dx_global_constant_get, ARGS_NONE());
    mrb_define_class_method(mrb, renum_LabelEffect, "GLOW", ruby_cocos2dx_global_constant_get, ARGS_NONE());

    struct RClass* renum_CameraFlag = mrb_define_module(mrb, "CameraFlag");
    ruby_cocos2dx_global_CameraFlag_enum_init(mrb);
    mrb_define_class_method(mrb, renum_CameraFlag, "DEFAULT", ruby_cocos2dx_global_constant_get, ARGS_NONE());
    mrb_define_class_method(mrb, renum_CameraFlag, "USER1", ruby_cocos2dx_global_constant_get, ARGS_NONE());
    mrb_define_class_method(mrb, renum_CameraFlag, "USER2", ruby_cocos2dx_global_constant_get, ARGS_NONE());
    mrb_define_class_method(mrb, renum_CameraFlag, "USER3", ruby_cocos2dx_global_constant_get, ARGS_NONE());
    mrb_define_class_method(mrb, renum_CameraFlag, "USER4", ruby_cocos2dx_global_constant_get, ARGS_NONE());
    mrb_define_class_method(mrb, renum_CameraFlag, "USER5", ruby_cocos2dx_global_constant_get, ARGS_NONE());
    mrb_define_class_method(mrb, renum_CameraFlag, "USER6", ruby_cocos2dx_global_constant_get, ARGS_NONE());
    mrb_define_class_method(mrb, renum_CameraFlag, "USER7", ruby_cocos2dx_global_constant_get, ARGS_NONE());
    mrb_define_class_method(mrb, renum_CameraFlag, "USER8", ruby_cocos2dx_global_constant_get, ARGS_NONE());

    struct RClass* renum_LightFlag = mrb_define_module(mrb, "LightFlag");
    ruby_cocos2dx_global_LightFlag_enum_init(mrb);
    mrb_define_class_method(mrb, renum_LightFlag, "LIGHT0", ruby_cocos2dx_global_constant_get, ARGS_NONE());
    mrb_define_class_method(mrb, renum_LightFlag, "LIGHT1", ruby_cocos2dx_global_constant_get, ARGS_NONE());
    mrb_define_class_method(mrb, renum_LightFlag, "LIGHT2", ruby_cocos2dx_global_constant_get, ARGS_NONE());
    mrb_define_class_method(mrb, renum_LightFlag, "LIGHT3", ruby_cocos2dx_global_constant_get, ARGS_NONE());
    mrb_define_class_method(mrb, renum_LightFlag, "LIGHT4", ruby_cocos2dx_global_constant_get, ARGS_NONE());
    mrb_define_class_method(mrb, renum_LightFlag, "LIGHT5", ruby_cocos2dx_global_constant_get, ARGS_NONE());
    mrb_define_class_method(mrb, renum_LightFlag, "LIGHT6", ruby_cocos2dx_global_constant_get, ARGS_NONE());
    mrb_define_class_method(mrb, renum_LightFlag, "LIGHT7", ruby_cocos2dx_global_constant_get, ARGS_NONE());
    mrb_define_class_method(mrb, renum_LightFlag, "LIGHT8", ruby_cocos2dx_global_constant_get, ARGS_NONE());
    mrb_define_class_method(mrb, renum_LightFlag, "LIGHT9", ruby_cocos2dx_global_constant_get, ARGS_NONE());
    mrb_define_class_method(mrb, renum_LightFlag, "LIGHT10", ruby_cocos2dx_global_constant_get, ARGS_NONE());
    mrb_define_class_method(mrb, renum_LightFlag, "LIGHT11", ruby_cocos2dx_global_constant_get, ARGS_NONE());
    mrb_define_class_method(mrb, renum_LightFlag, "LIGHT12", ruby_cocos2dx_global_constant_get, ARGS_NONE());
    mrb_define_class_method(mrb, renum_LightFlag, "LIGHT13", ruby_cocos2dx_global_constant_get, ARGS_NONE());
    mrb_define_class_method(mrb, renum_LightFlag, "LIGHT14", ruby_cocos2dx_global_constant_get, ARGS_NONE());
    mrb_define_class_method(mrb, renum_LightFlag, "LIGHT15", ruby_cocos2dx_global_constant_get, ARGS_NONE());

    struct RClass* renum_MATRIX_STACK_TYPE = mrb_define_module(mrb, "MATRIX_STACK_TYPE");
    ruby_cocos2dx_global_MATRIX_STACK_TYPE_enum_init(mrb);
    mrb_define_class_method(mrb, renum_MATRIX_STACK_TYPE, "MATRIX_STACK_MODELVIEW", ruby_cocos2dx_global_constant_get, ARGS_NONE());
    mrb_define_class_method(mrb, renum_MATRIX_STACK_TYPE, "MATRIX_STACK_PROJECTION", ruby_cocos2dx_global_constant_get, ARGS_NONE());
    mrb_define_class_method(mrb, renum_MATRIX_STACK_TYPE, "MATRIX_STACK_TEXTURE", ruby_cocos2dx_global_constant_get, ARGS_NONE());

    struct RClass* renum_GlyphCollection = mrb_define_module(mrb, "GlyphCollection");
    ruby_cocos2dx_global_GlyphCollection_enum_init(mrb);
    mrb_define_class_method(mrb, renum_GlyphCollection, "DYNAMIC", ruby_cocos2dx_global_constant_get, ARGS_NONE());
    mrb_define_class_method(mrb, renum_GlyphCollection, "NEHE", ruby_cocos2dx_global_constant_get, ARGS_NONE());
    mrb_define_class_method(mrb, renum_GlyphCollection, "ASCII", ruby_cocos2dx_global_constant_get, ARGS_NONE());
    mrb_define_class_method(mrb, renum_GlyphCollection, "CUSTOM", ruby_cocos2dx_global_constant_get, ARGS_NONE());

}

void register_all_cocos2dx(mrb_state* mrb)
{
	struct RClass* rmodule = mrb_define_module(mrb, "CC");

	ruby_register_cocos2dx_Ref(mrb, rmodule);
	ruby_register_cocos2dx_Console(mrb, rmodule);
	ruby_register_cocos2dx_Node(mrb, rmodule);
	ruby_register_cocos2dx_Scene(mrb, rmodule);
	ruby_register_cocos2dx_TransitionScene(mrb, rmodule);
	ruby_register_cocos2dx_TransitionEaseScene(mrb, rmodule);
	ruby_register_cocos2dx_TransitionMoveInL(mrb, rmodule);
	ruby_register_cocos2dx_TransitionMoveInB(mrb, rmodule);
	ruby_register_cocos2dx_AtlasNode(mrb, rmodule);
	ruby_register_cocos2dx_TileMapAtlas(mrb, rmodule);
	ruby_register_cocos2dx_TransitionMoveInT(mrb, rmodule);
	ruby_register_cocos2dx_TMXTilesetInfo(mrb, rmodule);
	ruby_register_cocos2dx_TransitionMoveInR(mrb, rmodule);
	ruby_register_cocos2dx_Color4F(mrb, rmodule);
	ruby_register_cocos2dx_Action(mrb, rmodule);
	ruby_register_cocos2dx_FiniteTimeAction(mrb, rmodule);
	ruby_register_cocos2dx_ActionInstant(mrb, rmodule);
	ruby_register_cocos2dx_Hide(mrb, rmodule);
	ruby_register_cocos2dx_ParticleSystem(mrb, rmodule);
	ruby_register_cocos2dx_ParticleSystemQuad(mrb, rmodule);
	ruby_register_cocos2dx_ParticleSpiral(mrb, rmodule);
	ruby_register_cocos2dx_Color4B(mrb, rmodule);
	ruby_register_cocos2dx_AnimationCache(mrb, rmodule);
	ruby_register_cocos2dx_ActionInterval(mrb, rmodule);
	ruby_register_cocos2dx_ActionCamera(mrb, rmodule);
	ruby_register_cocos2dx_ProgressFromTo(mrb, rmodule);
	ruby_register_cocos2dx_MoveBy(mrb, rmodule);
	ruby_register_cocos2dx_MoveTo(mrb, rmodule);
	ruby_register_cocos2dx_JumpBy(mrb, rmodule);
	ruby_register_cocos2dx_EventListener(mrb, rmodule);
	ruby_register_cocos2dx_EventListenerKeyboard(mrb, rmodule);
	ruby_register_cocos2dx_EventListenerMouse(mrb, rmodule);
	ruby_register_cocos2dx_TransitionRotoZoom(mrb, rmodule);
	ruby_register_cocos2dx_Director(mrb, rmodule);
	ruby_register_cocos2dx_Scheduler(mrb, rmodule);
	ruby_register_cocos2dx_ActionEase(mrb, rmodule);
	ruby_register_cocos2dx_EaseElastic(mrb, rmodule);
	ruby_register_cocos2dx_EaseElasticOut(mrb, rmodule);
	ruby_register_cocos2dx_EaseQuadraticActionInOut(mrb, rmodule);
	ruby_register_cocos2dx_EaseBackOut(mrb, rmodule);
	ruby_register_cocos2dx_Texture2D(mrb, rmodule);
	ruby_register_cocos2dx_TransitionSceneOriented(mrb, rmodule);
	ruby_register_cocos2dx_TransitionFlipX(mrb, rmodule);
	ruby_register_cocos2dx_Rect(mrb, rmodule);
	ruby_register_cocos2dx_GridAction(mrb, rmodule);
	ruby_register_cocos2dx_TiledGrid3DAction(mrb, rmodule);
	ruby_register_cocos2dx_FadeOutTRTiles(mrb, rmodule);
	ruby_register_cocos2dx_FadeOutUpTiles(mrb, rmodule);
	ruby_register_cocos2dx_FadeOutDownTiles(mrb, rmodule);
	ruby_register_cocos2dx_StopGrid(mrb, rmodule);
	ruby_register_cocos2dx_ParticleBatchNode(mrb, rmodule);
	ruby_register_cocos2dx_SkewTo(mrb, rmodule);
	ruby_register_cocos2dx_SkewBy(mrb, rmodule);
	ruby_register_cocos2dx_EaseQuadraticActionOut(mrb, rmodule);
	ruby_register_cocos2dx_TransitionProgress(mrb, rmodule);
	ruby_register_cocos2dx_TransitionProgressVertical(mrb, rmodule);
	ruby_register_cocos2dx_Layer(mrb, rmodule);
	ruby_register_cocos2dx_TMXTiledMap(mrb, rmodule);
	ruby_register_cocos2dx_Grid3DAction(mrb, rmodule);
	ruby_register_cocos2dx_BaseLight(mrb, rmodule);
	ruby_register_cocos2dx_SpotLight(mrb, rmodule);
	ruby_register_cocos2dx_FadeTo(mrb, rmodule);
	ruby_register_cocos2dx_FadeIn(mrb, rmodule);
	ruby_register_cocos2dx_DirectionLight(mrb, rmodule);
	ruby_register_cocos2dx_GLProgramState(mrb, rmodule);
	ruby_register_cocos2dx_EventListenerCustom(mrb, rmodule);
	ruby_register_cocos2dx_FlipX3D(mrb, rmodule);
	ruby_register_cocos2dx_FlipY3D(mrb, rmodule);
	ruby_register_cocos2dx_EaseSineInOut(mrb, rmodule);
	ruby_register_cocos2dx_TransitionFlipAngular(mrb, rmodule);
	ruby_register_cocos2dx_EaseElasticInOut(mrb, rmodule);
	ruby_register_cocos2dx_EaseBounce(mrb, rmodule);
	ruby_register_cocos2dx_Show(mrb, rmodule);
	ruby_register_cocos2dx_FadeOut(mrb, rmodule);
	ruby_register_cocos2dx_CallFunc(mrb, rmodule);
	ruby_register_cocos2dx_Event(mrb, rmodule);
	ruby_register_cocos2dx_EventMouse(mrb, rmodule);
	ruby_register_cocos2dx_GLView(mrb, rmodule);
	ruby_register_cocos2dx_EaseBezierAction(mrb, rmodule);
	ruby_register_cocos2dx_ParticleFireworks(mrb, rmodule);
	ruby_register_cocos2dx_MenuItem(mrb, rmodule);
	ruby_register_cocos2dx_MenuItemSprite(mrb, rmodule);
	ruby_register_cocos2dx_MenuItemImage(mrb, rmodule);
	ruby_register_cocos2dx_TransitionJumpZoom(mrb, rmodule);
	ruby_register_cocos2dx_ParticleFire(mrb, rmodule);
	ruby_register_cocos2dx_TransitionZoomFlipAngular(mrb, rmodule);
	ruby_register_cocos2dx_EaseRateAction(mrb, rmodule);
	ruby_register_cocos2dx_EaseIn(mrb, rmodule);
	ruby_register_cocos2dx_EaseExponentialInOut(mrb, rmodule);
	ruby_register_cocos2dx_EaseBackInOut(mrb, rmodule);
	ruby_register_cocos2dx_Waves3D(mrb, rmodule);
	ruby_register_cocos2dx_EaseExponentialOut(mrb, rmodule);
	ruby_register_cocos2dx_SpriteBatchNode(mrb, rmodule);
	ruby_register_cocos2dx_Label(mrb, rmodule);
	ruby_register_cocos2dx_Application(mrb, rmodule);
	ruby_register_cocos2dx_DelayTime(mrb, rmodule);
	ruby_register_cocos2dx_LabelAtlas(mrb, rmodule);
	ruby_register_cocos2dx_AsyncTaskPool(mrb, rmodule);
	ruby_register_cocos2dx_ParticleSnow(mrb, rmodule);
	ruby_register_cocos2dx_Sprite3DData(mrb, rmodule);
	ruby_register_cocos2dx_EaseElasticIn(mrb, rmodule);
	ruby_register_cocos2dx_EaseCircleActionInOut(mrb, rmodule);
	ruby_register_cocos2dx_Animation3DData(mrb, rmodule);
	ruby_register_cocos2dx_EaseQuarticActionOut(mrb, rmodule);
	ruby_register_cocos2dx_EventAcceleration(mrb, rmodule);
	ruby_register_cocos2dx_EaseCubicActionIn(mrb, rmodule);
	ruby_register_cocos2dx_TextureCache(mrb, rmodule);
	ruby_register_cocos2dx_ActionTween(mrb, rmodule);
	ruby_register_cocos2dx_TransitionFadeTR(mrb, rmodule);
	ruby_register_cocos2dx_TransitionFadeDown(mrb, rmodule);
	ruby_register_cocos2dx_ParticleSun(mrb, rmodule);
	ruby_register_cocos2dx_TransitionProgressHorizontal(mrb, rmodule);
	ruby_register_cocos2dx_TMXObjectGroup(mrb, rmodule);
	ruby_register_cocos2dx_TMXLayer(mrb, rmodule);
	ruby_register_cocos2dx_FlipX(mrb, rmodule);
	ruby_register_cocos2dx_FlipY(mrb, rmodule);
	ruby_register_cocos2dx_EventKeyboard(mrb, rmodule);
	ruby_register_cocos2dx_TransitionSplitCols(mrb, rmodule);
	ruby_register_cocos2dx_Timer(mrb, rmodule);
	ruby_register_cocos2dx_ProgressTimer(mrb, rmodule);
	ruby_register_cocos2dx_RepeatForever(mrb, rmodule);
	ruby_register_cocos2dx_Place(mrb, rmodule);
	ruby_register_cocos2dx_EventListenerAcceleration(mrb, rmodule);
	ruby_register_cocos2dx_GridBase(mrb, rmodule);
	ruby_register_cocos2dx_TiledGrid3D(mrb, rmodule);
	ruby_register_cocos2dx_EaseBounceOut(mrb, rmodule);
	ruby_register_cocos2dx_Color3B(mrb, rmodule);
	ruby_register_cocos2dx_TintBy(mrb, rmodule);
	ruby_register_cocos2dx_TransitionShrinkGrow(mrb, rmodule);
	ruby_register_cocos2dx_ClippingNode(mrb, rmodule);
	ruby_register_cocos2dx_ParticleFlower(mrb, rmodule);
	ruby_register_cocos2dx_EaseCircleActionIn(mrb, rmodule);
	ruby_register_cocos2dx_ParticleSmoke(mrb, rmodule);
	ruby_register_cocos2dx_Image(mrb, rmodule);
	ruby_register_cocos2dx_LayerMultiplex(mrb, rmodule);
	ruby_register_cocos2dx_Blink(mrb, rmodule);
	ruby_register_cocos2dx_JumpTo(mrb, rmodule);
	ruby_register_cocos2dx_Vec4(mrb, rmodule);
	ruby_register_cocos2dx_ParticleExplosion(mrb, rmodule);
	ruby_register_cocos2dx_Vec2(mrb, rmodule);
	ruby_register_cocos2dx_Vec3(mrb, rmodule);
	ruby_register_cocos2dx_Touch(mrb, rmodule);
	ruby_register_cocos2dx_NodeData(mrb, rmodule);
	ruby_register_cocos2dx_AnimationFrame(mrb, rmodule);
	ruby_register_cocos2dx_NodeGrid(mrb, rmodule);
	ruby_register_cocos2dx_TMXLayerInfo(mrb, rmodule);
	ruby_register_cocos2dx_EaseSineIn(mrb, rmodule);
	ruby_register_cocos2dx_EaseBounceIn(mrb, rmodule);
	ruby_register_cocos2dx_Camera(mrb, rmodule);
	ruby_register_cocos2dx_GLProgram(mrb, rmodule);
	ruby_register_cocos2dx_ParticleGalaxy(mrb, rmodule);
	ruby_register_cocos2dx_Twirl(mrb, rmodule);
	ruby_register_cocos2dx_MenuItemLabel(mrb, rmodule);
	ruby_register_cocos2dx_EaseQuinticActionIn(mrb, rmodule);
	ruby_register_cocos2dx_LayerColor(mrb, rmodule);
	ruby_register_cocos2dx_FadeOutBLTiles(mrb, rmodule);
	ruby_register_cocos2dx_LayerGradient(mrb, rmodule);
	ruby_register_cocos2dx_EventListenerTouchAllAtOnce(mrb, rmodule);
	ruby_register_cocos2dx_GLViewImpl(mrb, rmodule);
	ruby_register_cocos2dx_ToggleVisibility(mrb, rmodule);
	ruby_register_cocos2dx_Repeat(mrb, rmodule);
	ruby_register_cocos2dx_CardinalSplineTo(mrb, rmodule);
	ruby_register_cocos2dx_CardinalSplineBy(mrb, rmodule);
	ruby_register_cocos2dx_TransitionFlipY(mrb, rmodule);
	ruby_register_cocos2dx_TurnOffTiles(mrb, rmodule);
	ruby_register_cocos2dx_TintTo(mrb, rmodule);
	ruby_register_cocos2dx_CatmullRomTo(mrb, rmodule);
	ruby_register_cocos2dx_TransitionFadeBL(mrb, rmodule);
	ruby_register_cocos2dx_TargetedAction(mrb, rmodule);
	ruby_register_cocos2dx_DrawNode(mrb, rmodule);
	ruby_register_cocos2dx_TransitionTurnOffTiles(mrb, rmodule);
	ruby_register_cocos2dx_RotateTo(mrb, rmodule);
	ruby_register_cocos2dx_TransitionSplitRows(mrb, rmodule);
	ruby_register_cocos2dx_Device(mrb, rmodule);
	ruby_register_cocos2dx_TransitionProgressRadialCCW(mrb, rmodule);
	ruby_register_cocos2dx_EventListenerFocus(mrb, rmodule);
	ruby_register_cocos2dx_TransitionPageTurn(mrb, rmodule);
	ruby_register_cocos2dx_BezierBy(mrb, rmodule);
	ruby_register_cocos2dx_BezierTo(mrb, rmodule);
	ruby_register_cocos2dx_Menu(mrb, rmodule);
	ruby_register_cocos2dx_SpriteFrame(mrb, rmodule);
	ruby_register_cocos2dx_ActionManager(mrb, rmodule);
	ruby_register_cocos2dx_UserDefault(mrb, rmodule);
	ruby_register_cocos2dx_TransitionZoomFlipX(mrb, rmodule);
	ruby_register_cocos2dx_EventFocus(mrb, rmodule);
	ruby_register_cocos2dx_EaseQuinticActionInOut(mrb, rmodule);
	ruby_register_cocos2dx_SpriteFrameCache(mrb, rmodule);
	ruby_register_cocos2dx_PointLight(mrb, rmodule);
	ruby_register_cocos2dx_TransitionCrossFade(mrb, rmodule);
	ruby_register_cocos2dx_Ripple3D(mrb, rmodule);
	ruby_register_cocos2dx_Lens3D(mrb, rmodule);
	ruby_register_cocos2dx_ScaleTo(mrb, rmodule);
	ruby_register_cocos2dx_AnimationFrameData(mrb, rmodule);
	ruby_register_cocos2dx_Spawn(mrb, rmodule);
	ruby_register_cocos2dx_EaseQuarticActionInOut(mrb, rmodule);
	ruby_register_cocos2dx_ShakyTiles3D(mrb, rmodule);
	ruby_register_cocos2dx_PageTurn3D(mrb, rmodule);
	ruby_register_cocos2dx_TransitionSlideInL(mrb, rmodule);
	ruby_register_cocos2dx_TransitionSlideInT(mrb, rmodule);
	ruby_register_cocos2dx_Grid3D(mrb, rmodule);
	ruby_register_cocos2dx_EaseCircleActionOut(mrb, rmodule);
	ruby_register_cocos2dx_TransitionProgressInOut(mrb, rmodule);
	ruby_register_cocos2dx_EaseCubicActionInOut(mrb, rmodule);
	ruby_register_cocos2dx_EaseBackIn(mrb, rmodule);
	ruby_register_cocos2dx_SplitRows(mrb, rmodule);
	ruby_register_cocos2dx_RenderTexture(mrb, rmodule);
	ruby_register_cocos2dx_Follow(mrb, rmodule);
	ruby_register_cocos2dx_Animate(mrb, rmodule);
	ruby_register_cocos2dx_ShuffleTiles(mrb, rmodule);
	ruby_register_cocos2dx_Size(mrb, rmodule);
	ruby_register_cocos2dx_ParticleMeteor(mrb, rmodule);
	ruby_register_cocos2dx_EaseQuarticActionIn(mrb, rmodule);
	ruby_register_cocos2dx_EaseInOut(mrb, rmodule);
	ruby_register_cocos2dx_TransitionZoomFlipY(mrb, rmodule);
	ruby_register_cocos2dx_ScaleBy(mrb, rmodule);
	ruby_register_cocos2dx_EventTouch(mrb, rmodule);
	ruby_register_cocos2dx_Animation(mrb, rmodule);
	ruby_register_cocos2dx_TMXMapInfo(mrb, rmodule);
	ruby_register_cocos2dx_EaseExponentialIn(mrb, rmodule);
	ruby_register_cocos2dx_ReuseGrid(mrb, rmodule);
	ruby_register_cocos2dx_EaseQuinticActionOut(mrb, rmodule);
	ruby_register_cocos2dx_EventDispatcher(mrb, rmodule);
	ruby_register_cocos2dx_MenuItemAtlasFont(mrb, rmodule);
	ruby_register_cocos2dx_Liquid(mrb, rmodule);
	ruby_register_cocos2dx_OrbitCamera(mrb, rmodule);
	ruby_register_cocos2dx_ParallaxNode(mrb, rmodule);
	ruby_register_cocos2dx_ClippingRectangleNode(mrb, rmodule);
	ruby_register_cocos2dx_EventCustom(mrb, rmodule);
	ruby_register_cocos2dx_TransitionFade(mrb, rmodule);
	ruby_register_cocos2dx_Component(mrb, rmodule);
	ruby_register_cocos2dx_EaseCubicActionOut(mrb, rmodule);
	ruby_register_cocos2dx_EventListenerTouchOneByOne(mrb, rmodule);
	ruby_register_cocos2dx_ParticleRain(mrb, rmodule);
	ruby_register_cocos2dx_Waves(mrb, rmodule);
	ruby_register_cocos2dx_EaseOut(mrb, rmodule);
	ruby_register_cocos2dx_MenuItemFont(mrb, rmodule);
	ruby_register_cocos2dx_TransitionFadeUp(mrb, rmodule);
	ruby_register_cocos2dx_EaseSineOut(mrb, rmodule);
	ruby_register_cocos2dx_JumpTiles3D(mrb, rmodule);
	ruby_register_cocos2dx_MenuItemToggle(mrb, rmodule);
	ruby_register_cocos2dx_RemoveSelf(mrb, rmodule);
	ruby_register_cocos2dx_SplitCols(mrb, rmodule);
	ruby_register_cocos2dx_ProtectedNode(mrb, rmodule);
	ruby_register_cocos2dx_MotionStreak(mrb, rmodule);
	ruby_register_cocos2dx_RotateBy(mrb, rmodule);
	ruby_register_cocos2dx_FileUtils(mrb, rmodule);
	ruby_register_cocos2dx_Sprite(mrb, rmodule);
	ruby_register_cocos2dx_ProgressTo(mrb, rmodule);
	ruby_register_cocos2dx_TransitionProgressOutIn(mrb, rmodule);
	ruby_register_cocos2dx_CatmullRomBy(mrb, rmodule);
	ruby_register_cocos2dx_Sequence(mrb, rmodule);
	ruby_register_cocos2dx_Shaky3D(mrb, rmodule);
	ruby_register_cocos2dx_TransitionProgressRadialCW(mrb, rmodule);
	ruby_register_cocos2dx_EaseBounceInOut(mrb, rmodule);
	ruby_register_cocos2dx_TransitionSlideInR(mrb, rmodule);
	ruby_register_cocos2dx_NodeDatas(mrb, rmodule);
	ruby_register_cocos2dx_AmbientLight(mrb, rmodule);
	ruby_register_cocos2dx_GLProgramCache(mrb, rmodule);
	ruby_register_cocos2dx_EaseQuadraticActionIn(mrb, rmodule);
	ruby_register_cocos2dx_WavesTiles3D(mrb, rmodule);
	ruby_register_cocos2dx_PointArray(mrb, rmodule);
	ruby_register_cocos2dx_TransitionSlideInB(mrb, rmodule);
	ruby_register_cocos2dx_Speed(mrb, rmodule);
	ruby_register_cocos2dx_ShatteredTiles3D(mrb, rmodule);

    register_all_cocos2dx_enums(mrb);
}

